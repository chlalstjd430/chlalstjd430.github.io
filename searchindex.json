{"categories":[{"title":"2020 계획","uri":"http://blog.cmstown.com/categories/2020-%EA%B3%84%ED%9A%8D/"},{"title":"2021 계획","uri":"http://blog.cmstown.com/categories/2021-%EA%B3%84%ED%9A%8D/"},{"title":"AWS","uri":"http://blog.cmstown.com/categories/aws/"},{"title":"backend","uri":"http://blog.cmstown.com/categories/backend/"},{"title":"clean code","uri":"http://blog.cmstown.com/categories/clean-code/"},{"title":"database","uri":"http://blog.cmstown.com/categories/database/"},{"title":"design pattern","uri":"http://blog.cmstown.com/categories/design-pattern/"},{"title":"Docker","uri":"http://blog.cmstown.com/categories/docker/"},{"title":"IT 정보","uri":"http://blog.cmstown.com/categories/it-%EC%A0%95%EB%B3%B4/"},{"title":"JAVA","uri":"http://blog.cmstown.com/categories/java/"},{"title":"kafka","uri":"http://blog.cmstown.com/categories/kafka/"},{"title":"Kubernetes","uri":"http://blog.cmstown.com/categories/kubernetes/"},{"title":"python","uri":"http://blog.cmstown.com/categories/python/"},{"title":"spring","uri":"http://blog.cmstown.com/categories/spring/"},{"title":"리액티브 프로그래밍","uri":"http://blog.cmstown.com/categories/%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"},{"title":"백준 문제풀이","uri":"http://blog.cmstown.com/categories/%EB%B0%B1%EC%A4%80-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/"},{"title":"알고리즘","uri":"http://blog.cmstown.com/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"title":"프로그래머스 문제풀이","uri":"http://blog.cmstown.com/categories/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/"}],"posts":[{"content":"2021 계획 올해 계획은 심플하다. 그 이유는 올해의 가장 큰 목표가 취업이기 때문이다. 취업 준비를 하는 과정에서는 특별하게 다양한 도전을 하는 것보다, 인턴,알고리즘의 위주의 한 해가 되지않을까 생각한다.\n  서비스 운영\n여러번 프로젝트를 런칭해보았지만, 실제 서비스를 길게 운영해본 경험이 없다. 단순 개발만하고 실제로 트래픽 처리에 대한 경험은 전혀 없다. 그렇기에 이번년도에는 기존에 참여하고있던 그라운드(iOS, Android) 서비스에 보다 기여하여 실 운영이 원할하게 될 수 있도록하고 이어서 졸업작품으로 교내에 지속적으로 서비스 할 수 있는 플랫폼을 만들 계획이다.\n  인턴\n지난 네이버 웹툰에서 정말 소중한 인턴 경험을 쌓았다. 이러한 경험은 학교에서 절대 경험하지못할 실무적인 경험이고 이 경험들이 나를 보다 빠르고 견고하게 성장시켜준다. 그렇기에 이번에도 1학기에 학교 대신에 인턴을 진행하며 실무 능력을 쌓아볼까한다.\n  취업\n올해 목표중 가장 중요한 취업이다. 최고의 시나리오는 2학기 조기 취업하여, 취업계 내면서 회사를 다니는게 목표이다. 목표하는 기업들 중 한 곳에 반드시 취업하여 최고의 한 해를 마무리하고싶다.\n  졸업작품\n우리과는 졸업시 졸업작품을 진행하여야하는데, 무엇을 할까 고민하다 \u0026ldquo;졸업 작품 관리 플랫폼\u0026quot;이라는 주제로 웹 개발을 하기로 계획했다. 해당 프로젝트는 우리 교내인원을 대상으로 지속적으로 운영해볼 계획이다. 과연 유의미한 트래픽이 생길지는 의문이지만, 이번년도 계기로 1년간 먼저 운영해볼 계획이다.\n추가적으로 해당 프로젝트에서는 기존에 잘 시도하지않았던, 프론트 영역도 도전하며 프론트/서버 개발에 참여하며 전체적으로 프로젝트를 리딩할 예정이다. 또한 서버에서는 평소 사용해보고싶었던 기술들을 적용하며 보다 실무적인 관점으로 프로젝트를 개발할 계획이다.\n  알고리즘\n알고리즘은 방학동안 우선적으로 꾸준히 해볼 계획이다. 1차적으로 종만북 책을 섭렵하고, 프로그래머스와 릿코드를 통해 꾸준히 문제를 풀어볼 계획이다. 꾸준하게 알고리즘 공부를 하여 이번년도에 지원하는 기업의 코테는 거뜬히 합격해내고싶다.\n  블로그 포스팅\n프로젝트 및 개인 공부를 진행하면서 겪은 트러블슈팅을 블로그에 기재해볼 계획이다. 또한 새로운 개념에 대해 공부할 때, 보다 깊게 공부한 흔적을 남겨서 누군가에게 유익한 정보도 남기고싶다.\n  ","id":0,"section":"posts","summary":"2021 계획 올해 계획은 심플하다. 그 이유는 올해의 가장 큰 목표가 취업이기 때문이다. 취업 준비를 하는 과정에서는 특별하게 다양한 도전을 하는 것보다, 인턴,알고리즘","tags":null,"title":"2021 계획","uri":"http://blog.cmstown.com/2021/01/2021_%EA%B3%84%ED%9A%8D/","year":"2021"},{"content":"2020 회고록 드디어 20201년이 다가왔다. 작년 한 해는 개인적으로 코로나뿐만 아니라 정말 다사다난한 한 해였다. 그러한 다사다난한 상황 속에서 개인적으로 개발자로서 정말 큰 성장을 이룬 것 같다. 그럼 어떠한 한 해를 보냈는지 살펴보자.\n\n첫 2020 계획 블로그를 개설하며 2020 계획을 글로 작성해보았었다. 해당 내용에서 목표했던 내용을 요약하면 다음과 같다.\n  IT 동아리 활동하기\n  프로젝트 런칭하기\n  S/W 마에스트로 활동\n  학점 4.0 넘기기\n  인턴 경험하기\n  꾸준한 알고리즘 공부\n  꾸준히 블로그 포스팅\n  공모전/해커톤 참여\n  장학금 받기\n  개발 공부\n  위의 10가지에 대해 어떻게 이루었는지 한번 살펴보자.\n1. IT 동아리 활동하기, 프로젝트 런칭하기 2019년에 교내 IT동아리인 유어슈에서 이미 활동하고있었다. 그러나 교내 뿐만 아니라 교외로 넘어가 현업 개발자들과 협업하며 개발을 하고싶다는 생각을 하였고, IT 동아리에 들어가는것을 목표로 하였다.\n그 결과 YAPP(얍),NEXTERS(넥스터즈) 라는 두 곳의 동아리에서 활동하게되었고 개인적으로 소중한 인연들은 만나게되어 정말 좋은 경험을 하게되었다고 생각한다.\n얍   개인적으로 얍에서 진행했던 프로젝트는 상당히 미흡한 부분이 많았지만, 외부 사람들과 첫 협업을 했다는 경험에 큰 의의를 두고있다.\n  얍에서 아는 지인의 부탁으로 얍의 경우 면접관으로 들어갔었는데, 이 경험이 상당히 나에게 있어서 소중한 경험이되었다.\n  넥스터즈  넥스터즈에서는 상당히 캐미가 잘 만나는 팀을 만나 짧은 시간 내에 빠르게 런칭을 해보았다. 다만 기술적으로 새로운 시도를 해보지못하여 개발적으로는 상당히 아쉬움이 남았었다.  2. 프로젝트 런칭 올 해 4-5개 정도의 프로젝트를 진행했었는데, 그 과정에서 2개 정도의 프로젝트를 런칭해보았다. 첫 런칭은 얍에서 진행했는데, 앞에서 언급한대로 전체적으로 너무 미흡한 부분이 많았다. 사실 런칭이라고하기 부끄러울 정도로 전체적으로 참했다\u0026hellip;\n이후에 넥스터즈에서 \u0026ldquo;아재트(AZ)\u0026ldquo;라는 어플리케이션을 런칭하였는데, 개발 과정에서 만드는 재미는 있었지만 실질적으로 팀원들 모두 지속하여 운영할 의사가 없어 더 이상은 디벨롭하지않았다.(다만 이 팀원들 중 일부와 새로운 사이드 프로젝트를 하기로\u0026hellip;)\n2020년에는 그저 프로젝트의 런칭이 목표였다면, 2021년에는 실질적으로 운영을 하고싶다는 생각이들었다. 실제로 \u0026ldquo;런칭\u0026quot;과 \u0026ldquo;운영\u0026quot;는 차이가 크기에, 여러가지 상황에 유연하게 대응하며 운영하는 것이 목표다.\n3. S/W 마에스트로 활동 개인적으로 개발을 시작하면서 S/W마에스트로 활동이 정말 간절했었다. 친한 동생이 소마에 들어가 크게 성장하는 모습을 바라보았는데, 나도 풍족한 지원(?) 속에서 이 친구와 같이 크게 성장해보고싶었기에 2020년에 가장 큰 목표중 하나였다. 결론부터 말하자면 불합격되었는데, 1차,2차 코딩 테스트 합격 후 최종 면접에서 떨어지게되었다. 면접은 다대다(그때 당시 5대5였던걸로..)로 이루어졌는데, 해당 면접 그룹에서 나름대로 잘 보았다고 생각하였고 당연히 합격을 할 것 같다 생각했다. 그러나 결과는 \u0026ldquo;불합격\u0026rdquo; 통보를 받았고, 이에 대해 크게 실망하고 많인 힘들었던 것 같다.\n불합격에 대한 원인 분석을 해보았는데, 음..아직도 잘 모르겠다ㅜㅜ. 주어진 질문에 잘 대답하였고, 크게 대응하지 못했던 상황은 없었는데 아쉬움이 가득했다.\n4. 학점 4.0 넘기기 결론적으로 말하면 부분적으로는 성공이다. 1학기 당시는 전체/전공 모두 평균 4.1로 상당히 준수한 성적을 받았다. 다만 2학기에는 전체/전공 학점은 3.53/4.25였는데, 전체 평점에대해 변명을하자면 2학기에 네이버에서 인턴을 하고있었고 학점보다는 회사의 업무에 충실하는게 목표였다. 그리고 개인적으로 성적에 대한 관점이 바뀌었는데, 교양보다는 전공에 더 충실하면 크게 문제없을 것 같다고 생각하였다. 그렇기에 2학기에는 전공은 a이상의 학점을 받고, 교양은 B+~C+의 성적을 받아 전체적으로 3.53이라는 학점을 받았다. 그렇기에 학점은 대채적으로 만족하는 점수를 받으며 학기를 마무리하였다.\n5. 인턴 경험하기 소프트웨어 마에스트로에서 탈락하며, 보다 빠르게 인턴 준비를하게되었다. 여름방학부터 인턴을 준비하여 결과적으로 3개의 회사에서 합격을 받게되었다. 인생사 새옹지마\u0026hellip;그 중에서 정말정말 가고싶었던 네이버 웹툰을 최종적으로 선택하였고, 9월부터 12월까지 약 4개월간 근무를하게되었다.\n네이버 웹툰에서 평소 고민하지못했던 고민들을 하고 새로운 기술들을 학습하며 정말 빠르게 성장한 것 같다. 2020년 한 해중 가장 기억에 남는 개발 활동이었다. 전반적인 인턴 생활에 대한 이야기는 추후 정리하여 글을 작성할 계획이다.\n인턴 생활중 마지막에 책임리더님이 하신 말이 기억남는다, \u0026ldquo;이용자가 되지말고 사용자가 되자\u0026rdquo;. 즉, 최근 많은 기술들이 새롭게 등장함에 따라 최신 기술이라고 이것저것 적용해보고 공부하는데, 여기서 단순 기술을 이용하는 수준에 멈추지말고, 동작 원리, 내부 구조 등에도 관심을 가지며 개발자의 관점으로 딥다이빙하라는 말이다. 이 말이 개인적으로 정말 크게 와 닿았다.\n앞으로 이 경험을 살려 보다 기술들을 깊게 파고드는 노력을 할 것이다.\n6. 꾸준한 알고리즘 공부 알고리즘의 경우 2020년 초반에는 스터디도하며 꾸준하게 열심히 공부했던 기억이있다. 다만, 1학기가 시작될 무렵쯤부터는 개인적으로 진행중인 프로젝트나 학업에 밀려 비교적 꾸준하게 진행하지 못해 아쉽다. 21년은 본격적인 취준의 해인만큼, 보다 알고리즘 공부에 신경쓸 계획이다.\n7. 꾸준한 블로그 포스팅 2020년에 약 80개의 게시글을 포스팅하였다. 평균적으로 보면 한달에 약 6개, 1주일에 1.5개의 게시글을 작성한건데 이 정도면 나름대로 꾸준하게 게시글을 작성한 것 같아 만족스럽다.\n21년에는 앞으로 더 많은 포스팅과 함께 개발자로서 공부한 내용을 보다 딥다이빙하게 정리하여 블로그에 기재해, 도움될 수 있는 글을 작성하고싶다. 뿐만 아니라 구글 애널리틱스 분석 결과 IT 동아리 정보, 코디미 상담 후기와 같은 글이 인기각 많았는데, 이러한 도움이 될 수 있는 정보글들도 작성하며 선한 영향력을 주는 게시글도 작성할 예정이다.\n8. 공모전/해커톤 참여 2020년에 \u0026ldquo;국방 공공데이터\u001c 활용 공모전\u0026quot;과 \u0026ldquo;엔젤핵 해커톤\u0026quot;에 참여하였는데. 공모전의 경우 완성된 작품의 기능들이 예상보다 퀄리티가 낮아 떨어졌고, 엔젤핵 해커톤의 경우 빠르게 만들었지만 다른 좋은 작품을 만든 참가들이 있어 아쉽게 수상하지 못하였다. 그럼에도 불구하고 처음으로 개발 관련된 공모전과 해커톤테 참여해보면 참 열심히 살았다고 느끼는 한해 인것 같다.\n9. 장학금 받기 \u0026ldquo;대학생이되면 장학금을 받겠노라.\u0026ldquo;라는 포부를 2020년에 가지게되었는데, 그 포부를 지킬 수 있어 정말 다행이다. 계획했던 성적 장학금은 아니지만, 더 많은 금액인 500만원을 NHN IT미래인재릴레이라는 장학금을 수여받게되었다. 코딩 테스트로 선발하여 장학금을 주는데 운이 좋게 겪어본 유형의 문제를 만나 쉽게 장학금을 받을 수 있었던 것 같다.\n10. 개발 공부 구체적인 개발 공부 계획 내용이있지만, 포괄적으로 \u0026ldquo;개발 공부\u0026quot;라는 항목으로 다 이야기하겠다. 올 한 해에 새로운 기술들도 적용해보고 책도 읽어가며 공부하였는데, 계획했던 모든 기술들을 공부한건아니지만 대체적으로 관심있게 본 기술들에 대해 빠르게 학습한 것 같다. 다만 앞으로 공부할 때 단순 이용을 위한 공부보다, 정말 개발하기 위한 공부를 하며 보다 딥다이빙해야하는 자세를 배워야할 것 같다.\n\n마무리 뒤 돌아보니 참 열심히 공부하며 한 해를 보낸 것 같다. 대외활동,공모전,해커톤,인턴,학교,장학금 수여 이 모든 활동들을 쉬지않고 꾸준하게 열심히하였기에 빠르게 성장할 수 있지않았나싶다. 또한 개발자로서 방향성을 잡는데 큰 도움이되는 한 해였던 것 같다.\n그리고 인생사 새옹지마, 소마 탈락에 좌절했지만 결국 네이버웹툰으로 인턴 생활을 하며 포기하지않고 꾸준히하며 결과를 얻을 수 있다는 자신감을 얻게 되었다. 앞으로 이와 같은 꾸준한 노력으로 20201년에도 원하는 바를 이루고싶다!\n p.s 곧 2021 계획에 대한 포스팅도 할 예정이다. 이번 한 해도 알차게 계획 세워서 22년에 보람차게 회고하고싶다!  ","id":1,"section":"posts","summary":"2020 회고록 드디어 20201년이 다가왔다. 작년 한 해는 개인적으로 코로나뿐만 아니라 정말 다사다난한 한 해였다. 그러한 다사다난한 상황 속에서 개인적으로 개발자","tags":null,"title":"2021 회고록 - 3학년 학부생에서 네이버 인턴 경험까지","uri":"http://blog.cmstown.com/2021/01/2020_%ED%9A%8C%EA%B3%A0%EB%A1%9D/","year":"2021"},{"content":"@Order 최근 레디스 분산락으로 구현한 AOP와 @Transactional을 동시에 사용할 일이 생겼는데, 이 둘의 AOP 실행 순서에 있어서 구현한 AOP가 우선적으로 처리되어야했다.\n이에 @Order값을 확인하고 조정할 필요가있었다. @Order는 숫자가 작을 수록 우선순위가 높다. 사용방법 또한 간단한데, @Order(정수) 로 사용하면된다. 예제는 아래와 같다.\n@Aspect @Order(0) public class TestAspect { public void printOrder(JoinPoint jp){ System.out.println(\u0026quot;order 0\u0026quot;); } }  위의 코드와 같이 어노테이션을 추가하면된다.\n@Transactional의 order값은? 그럼 내가 겪었던 문제를 해결하기 위해 @Transactional의 order값을 확인해보았다. 확인 결과, Ordered.LOWEST_PRECEDENCE로 정수로 환산하면 Integer의 MAX 값과 같았다. 즉, @Transactional의 Order값은 가장 나중에 처리되도록 설정되어있었다. 이로써 내가 구현하고자하는 바가 보장이되었음을 확인할 수 있었다.\n","id":2,"section":"posts","summary":"@Order 최근 레디스 분산락으로 구현한 AOP와 @Transactional을 동시에 사용할 일이 생겼는데, 이 둘의 AOP 실행 순서에 있어서 구현한 AOP가 우선적으로","tags":null,"title":"[Spring(스프링)] @Order","uri":"http://blog.cmstown.com/2020/12/transactional_order/","year":"2020"},{"content":"최근 캐시와 관련된 개발을 하게 되었는데, 접해보지 못했던 부분이라 기본적인 베이스를 학습하고자 글을 정리해본다.\n\n캐시(Cache) 캐시란 지역성을 데이터를 미리 복사해 임시 저장을하여 더 빠른 속도로 데이터에 접근하는 장소이다.\n  위의 모든 계층구조에는 캐시가 존재하고 계층 구조가 위로 올라갈수록 속도는 빠르고 용량이 작다. 그러므로 속도와 용량을 모두 확보하기에는 너무 많은 비용이들어 데이터 저장 공간은 속도와 용량에 따라 특성에 맞게 사용하여야한다.\n캐시의 작동 방식   원본 데이터와는 별개로 자주 쓰이는 데이터들을 복사해둘 캐시 공간을 마련한다.\n 캐시 공간은 상수 시간 등 낮은 시간 복잡도로 접근 가능한 곳을 사용    데이터 요청시 원본 데이터를 찾기 전에 캐시의 내부부터 탐색\n  캐시에 원하는 데이터가 없거나 (Cache miss) 너무 오래되었을 경우 (Expiration) 원본 데이터를 탐색하여 데이터를 가져온다.\n 원본 데이터에서 데이터를 가져올 때 캐시에도 해당 데이터를 복사하거나 혹은 갱신한다.    캐시에 원하는 데이터가 있으면 데이터 탐색을 진행하지않고, 캐시로부터 해당 데이터를 제공한다. (Cache hit)\n    캐시 공간은 비교적 작으므로 안 쓰는 데이터부터 삭제하여 공간을 확보한다. (Eviction)\n  Local Cache VS Global Cache Local Cache\n  서버마다 캐시를 따로 저장한다.\n  다른 서버의 캐시를 참조하기 어렵다.\n  서버 내에서 작동하기 때문에 속도가 빠르다.\n  로컬 서버 장비의 Resource를 이용한다. (Memory, Disk)\n  Global Caache\n  여러 서버에서 Cache Server에 접근하여 사용하는 캐시\n  데이터를 분산하여 저장할 수 있다.\n  Replication : 데이터 복제\n  Sharding : 데이터 분산 저장\n    Local Cache에 비해 상대적으로 느리다\n 네트워크 트래픽 때문에    별도의 Cache Server를 이용하기 때문에 서버간 데이터 공유 원할\n  EHcache   EHcahce는 오픈 소스 기반의 Local Cache이다.\n  Java의 대표적인 캐시 엔진중 하나\n  속도가 빠른 경량 Cache이다.\n  Disk, Memory에 저장이 가능한 형태\n  서버간 분산 캐시를 지원한다(동기/비동기 복제)\n 대규 서비스에서 캐시 서버 여럿을 클러스터로 묶을 수 있는 기능 제공    Java 메소드에 캐싱을 적용함으로써 캐시에 보관된 정보로 메소드의 실행 횟수를 줄일 수 있다.\n  ehcache는 데몬을 가지지 않고 Spring 내부적으로 동작하여 캐싱 처리를 한다.\n 서버 애플리케이션과 라이프사이클이 같다    Redis   다양한 데이터 구조를 지원하며 multilingual에서 유리하다.\n  In-Memory Databases\n  기본적으로 single thread\n 데이터 손실 없이 클러스터링을 통해 수평 확장 가능.    redis 메모리가 날라가도 스냅샷을 제공하여 복구가 가능하다.\n  다양한 API를 제공한다.\n Eviction 정책을 6가지 제공한다.    관리하는 데이터를 복제할 수 있다.\n  Memcache   HTML과 같이 상대적으로 작고 정적인 데이터를 캐싱할 때 좋다.\n  메모리 관리가 redis만큼 정교하지는 않지만, 메타 데이터에 대한 메모리 리소스를 비교적 적게 소비하여 간단한 사용에 적합하다.\n  멀티 스레이드이다.\n 쉽게 확장할 수 있지만 해싱 사용 여부에 따라 캐시된 데이터의 일부 또는 전부를 잃는다.    ket bane울 250bytes로 제한하고 일반 문자열로만 작동한다.\n  \n대략적으로 3개에 대해 정리가 되는 것 같은데, 아직 명확하게 어떤 상황에서 무엇이 적합한지 잘 모르겠다..더 딥다이빙해봐야겠다..\n\n참고\n  우아한 tech youtube\n  https://deveric.tistory.com/71\n  https://postitforhooney.tistory.com/entry/DBRedisRedis%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EA%B3%B5%EB%B6%80%ED%95%98%EA%B8%B0-Redis-vs-Ehcache-vs-Memcached-%EB%B9%84%EA%B5%90%ED%95%98%EB%A9%B0-%ED%8C%8C%EC%95%85%ED%95%98%EA%B8%B0\n  ","id":3,"section":"posts","summary":"최근 캐시와 관련된 개발을 하게 되었는데, 접해보지 못했던 부분이라 기본적인 베이스를 학습하고자 글을 정리해본다. 캐시(Cache) 캐시란 지역성을 데이터를","tags":null,"title":"[캐시(Cache)] redis VS ehcache VS memcached","uri":"http://blog.cmstown.com/2020/12/redis-vs-ehcache-vs-memcached/","year":"2020"},{"content":"InnoDB Lock과 Isolation 앞서 게시글을 통해 Transaction과 Isolation에 대해 공부한 내용을 정리해보았다. 그런데 개발도중 이 isolation level을 이해하며 적용하는데, 문득 어떻게 각 isolation level 어떻게 isolation 문제점을 보장해주는 궁금해졌다. 즉 isolation에 따라 어떻게 트랜잭션이 데이터를 보호해주는지 정확히 파악할 필요가 있었다. 이에 좋은 블로그의 글을 보게되었고, 여기에 내 종합적인 의견들을 반영해서 정리해보고자한다.\n설명에 앞서 트랜잭셔이나 독립성에 대해 잘 모른다면, 이 글을 읽고 시작하면 좋을 것 같다.\n\nInnoDB LOCK InnoDB는 transaction의 ACID 원칙과 동시성을 최대한 보장하기 위해 다양한 종류의 lock을 사용한다. lock은 한 트랜잭션이 commit/rollback 되기전까지 진행된다. lock의 종류는 아래와 같다.\n  Shared and Exclusive Locks\n  Intention Locks\n  Record Locks\n  Gap Locks\n  Next-Key Locks\n  Insert Intention Locks\n  AUTO-INC Locks\n  이중에서 isolation과 관련된 Shared and Exclusive Locks, Record Locks, Gap Locks 에 대해 집중적으로 살펴보자. 이 외 다른 부분은 공식 문서(MySQL 5.6 기준)을 읽어보자.\nShared and Exclusive Locks InnoDB에서는 row-level locking으로 shared locks(S lock)과 exclusive locks(X lock)를 제공한다.\nShared Lock(S Lock)   S lock은 read에 대한 lock이다.\n  SELECT 쿼리는 lock을 사용하지 않고 DB를 읽어들인다. 하지만 \u0026lsquo;SELECT \u0026hellip; FOR SHARE\u0026rsquo;나 일부 SELECT 쿼리 는 read 작업을 수행할 때 InnoDB가 각 row에 S lock을 건다.\n  Exclusive lock(X lock)   X lock은 write에 대한 lock이다.\n  \u0026lsquo;SELECT \u0026hellip; FOR UPDATE\u0026rsquo;나 \u0026lsquo;UPDATE\u0026rsquo;,\u0026lsquo;DELETE\u0026rsquo; 등의 쿼리를 사용할 때 row에 걸리는 lock이다.\n  S lock과 X lock의 사용되는 규칙은 아래와 같다.\n  여러 transaction은 동시에 하나의 row에 S lock을 걸 수 있다.\n S lock이 걸려있는 row를 다른곳에서도 동시에 읽을 수 있다.    S lock이 걸려있는 row에 다른 transaction의 X lock을 걸 수 없다.\n S lock이 걸려있는 row를 다른 transaction이 수정/삭제 할 수 없다.    X lock이 걸려있는 row에는 다른 transaction이 S lock과 X lock을 걸 수 없다.\n x lock이 걸린 row는 읽기,수정,삭제 모두 불가능하다.    Record Locks record lock은 row 자체가 아닌 DB의 index record에 걸리는 lock이다. record lock에도 S lock과 X lock이 존재한다.\n예시 먼저 다음과 같이 두개의 트랜잭션이 존재한다 가정하자.\n## Transaction A SELECT user FROM t WHERE user_id = 1 FOR UPDATE; ## - (1)  ## Transaction B DELETE FROM user WHERE user_id = 1;  이후 두 트랜잭션이 다음과 같이 수행된다고 가정하자.\n## Transaction A Start A(1) 수행 ## Transaction B Start B(1) 수행 ## Transaction A commit ## Transaction B commit  이 상황에서 A(1)이 수행될 때, user_id=1 값에는 X lock이 걸린다. transaction a가 아직 커밋 전에 B(1) 수행한다면 index가 user_id=1에 접근할 수 없다.\nGap Locks Gap Lock은 DB index record의 gap에 걸리는 lock이다. 즉 index에 범위가 \u0026lsquo;user_id \u0026lt;= 10\u0026rsquo;로 주어질 때, user_id=1,2\u0026hellip;10의 index에 대해 lock을 거는 개념이다. Record Lock에서 범위가 추가되는 개념이다.\n예시 현재 user테이블에 user_id는 1만 있다고 가정해보자.\n## Transaction A SELECT user FROM t WHERE user_id BETWEEN 1 AND 10 FOR UPDATE; ## - (1)  ## Transaction B DELETE FROM user WHERE user_id = 3;  이후 두 트랜잭션이 다음과 같이 수행된다고 가정하자.\n## Transaction A Start A(1) 수행 ## Transaction B Start B(1) 수행 ## Transaction A commit ## Transaction B commit  A(1) 수행 결과 user_id=1,2\u0026hellip;10까지의 인덱스에 lock을 거므로, B(1) 수행시 접근이 불가능하다.\n\nIsolation과 Lock 그렇다면 이 lock과 isolation의 관계는 어떻게 될까? isolation에 대한 설명은 이 글에서 먼저 설명했기에 추가적인 설명은 하지않겠다. 그렇다면 isolation level에 따라 어떻게 lock을 주는지 살펴보자.\nRead Uncommitted  Read Uncommited는 S-lock을 사용하지 않는다. 즉, X-Lock이 걸린 데이터를 읽을 수 있다는 것을 뜻한다.  Read Committed   Read Committed에서는 S-lock을 사용한다. 그렇기에 X-Lock이 걸린 데이터를 읽으려 할 때 S-lock을 걸려고 시도한다. 즉, X-Lock이 걸린 데이터를 읽을 수 없다는 것을 뜻한다.\n  lock을 사용하는 SELECT, UPDATE, DELETE 쿼리에 대해 record lock만 사용하고 gap lock은 사용하지 않는다.\n  Repeatable Read  Repeatable Read에서는 lock을 사용하는 SELECT, UPDATE, DELETE 쿼리에 대해 gap lock과 next-key lock까지 사용된다.  Serializalbe  SELECT 쿼리가 전부 SELECT \u0026hellip; FOR SHARE로 변경된다. 즉, SELECT 쿼리 진행시 범위에 해당하는 index row에 S lock 걸린다.  대략적으로 lock과 isolation의 관계에 대해 살펴보았다. isolation이 높을 수록 lock도 많이 걸고 복잡해보일 수 있고 반대로 isolationn이 낮을 경우 많은 isolation 문제점이 발생할 것 같다. 동시성과 isolation 문제점을 모두 동시에 다 해결할 수는 없다. 그렇기에 우리가 사용하는 수준에서 적절한 isolation level을 취해 사용하는 것이 굉장히 중요한 것 같다.\n\n출저   https://suhwan.dev/2019/06/09/transaction-isolation-level-and-lock/\n  https://dev.mysql.com/doc/refman/5.6/en/innodb-locking.html\n  https://kuaaan.tistory.com/98\n  ","id":4,"section":"posts","summary":"InnoDB Lock과 Isolation 앞서 게시글을 통해 Transaction과 Isolation에 대해 공부한 내용을 정리해보았다. 그런데 개발도중 이 isolation level을 이해하","tags":null,"title":"InnoDB Lock과 Isolation","uri":"http://blog.cmstown.com/2020/11/db_lock_in_treansaction/","year":"2020"},{"content":"카프카 개념 정리 카프카란? 기존에 end-to-end 연결 방식의 아키텍처로 인하여 데이터 연동의 복잡성이 증가되었다. 이에 링크드인에서 데이터가 갑자기 많아지더라도 확장이 용이하고, 데이터를 전송 실시간 처리에 대한 필요성을 느꼈고 아래와 같은 특징을 가진 카프카를 개발하였다.\n  프로듀서/컨슈머 분리\n  메시지 데이터를 여러 컨슈머에게 허용\n  높은 처리량을 위한 메시지 최적화\n  스케일 아웃 가능\n  관련 생태계 제공\n  \n브로커(broker)   실행된 카프카 애플리케이션 서버 중 1대\n 2대 이상일 수 있지만, 실제 운영 환경에서 그런 경우는 굉장히 드뭄    3대 이상의 브로커로 클러스터구성\n  주키퍼와 연동\n 주키퍼의 역할 : 메타데이터(브로커id, 컨트롤러id 등) 저장    n개 브로커 중 1대는 컨트롤러(Controller) 기능 수행\n  컨트롤러\n  각 브로커에게 담당 파티션 할당 수행.\n  브로커 정상 동작 모니터링 관리.\n  컨트롤러가 누군지는 주키퍼에 저장.\n      \n토픽 \u0026amp; 파티션(Topic \u0026amp; Partition)   메시지 분류 단위\n  n개의 파티션 할당 가능\n  파티션 수를 늘리면 처리량도 증가\n  파티션 증가는 쉬우나 축소는 어려우니 처음 설계할 때 잘 고려할 것\n    각 파티션마다 고유한 오프셋(offset)을 까짐\n 숫자가 클 수록 최신    메시지 처리순서는 파티션별로 유지 관리됨\n  \n프로듀서 \u0026amp; 컨슈머(Producer \u0026amp; Consumer) 브로커가 컨슈머로 보내는 것이 아니다.\n  프로듀서는 레코드를 생성하여 브로커로 전송\n  전송된 레코드는 파티션에 신규 오프셋과 함께 기록됨\n  컨슈머는 쁘로커로 부터 레코드를 요청하여 가젹감(polling)\n  \n카프카 로그와 세그먼트   레코드는 파일 시스템 단위로 저장된다.\n  메시지가 저장될떄는 세그먼트 파일이 열려있음.\n  섹그먼트는 시간 또는 크기 기준으로 닫힘\n  세그먼트가 닫힌 이후일정 시간(또는 용량)에 따라 삭제 또는 압축\n 카프카의 데이터는 보통 일정 기간/용량을 옵션을 준다    \n컨슈머와 파티션   파티션 개수 \u0026gt;= 컨슈머 개수 로 만들어야한다.\n 반대의 경우에는 컨슈머가 파티션을 할당받지 못하고 대기하게 된다.    파티션 3개, 컨슈머 3개 동작 중 컨슈머 1개가 장애가난 경우\n  리밸런스 가 발생하여 파티션 컨슈머 할당 재조정\n  리밸런스가 일어나는 중에는 할당하는 과정이 중단된다.\n    2개 이상의 컨슈머 그룹이 있을 경우\n  각 그룹별로 독립적으로 파티션을 읽음.\n  실제로 elasticsearch/hadoop 컨슈머 그룹을 나누어 저장하는 경우도 있음.\n    \n리더 파티션, 팔로워 파티션   리더 파티션 : Kafka 클라이언트와 데이터를 주고 받는 역할\n  팔로워 파티션\n  리더 파티션으로 부터 레코드를 지속 복제(복제하는데 시간이 걸림).\n  리퍼 파티션의 동작이 불가능할 경우 나머지 팔로워 중 1개가 리더로 선출됨\n    ISR(In-Sync Replica) : 파티션의 리더, 팔로워의 레코드가 모두 복제되어 sync가 맞는 살태\n ISR이 아닌 상태에서 장애가 나면 : unclean.leader.election.enable    \nkafka 핵심요소 중간정리   Broker : 카프카 애플리케이션 서버 단위\n  Topic : 데이터 분리 단위. 다수 파티션 보유\n  Partition : 레코드를 담고 있음. 컨슈머 요청시 레코드 전달\n  Offset : 각 레코드당 파티션에 할당된 고유 번호\n  Consumer : 레코드를 polling하는 애플리케이션\n  Consumer group : 다수 컨슈머 묶음\n  Consumer offset : 특정 컨슈머가 가져간 레코드의 번호\n    Producer : 레코드를 브로커로 전송하는 애플리케이션\n  Replication : 파티션 복제 기능\n ISR : 리더 + 팔로워 파티션의 sync가 된 묶음    Rack-awareness: Server rack 이슈에 대응\n  \n카프카 클라이언트(Kafka Client)   kafka와 데이터를 주고받끼 위해 사용하는 java library\n  producer, consumer, admin, stream 등 kafka 관련 api 제공\n  \n카프카 스트림즈(Kafka Streams)   데이터를 변환하기 위한 목적으로 사용하는 API\n  스트림 프로세싱을 지원하기 위한 다양한 기능을 제공\n  stateful 또는 stateless와 같이 상태기반 스틀미 처리 가능\n  stream api와 DSL을 동시 지원\n  kafka security 완벽 지원\n  스트림 처리를 위한 별도 클러스터 불필요\n    \n카프카 커넥트(Kafka Conenct)   많은 경우 Kafka client를 Kafka로 데이터를 넣는 코드를 작성할떄도 있지만, Kafka connect를 통해 data를 import/export 할 수 있음\n  코드 없이 configuration으로 데이터를 이동시키는 것이 목적\n  \n카프카 미러 메이커(Kafka Mirror maker)   특정 카프카 클러스터에서 다른 카프카 클러스터로 Topic 및 Record를 복제하는 Standalone tool\n  클러스터간 토픽에 대한 모든 것을 복제하는 것이 목적\n  \n참고   아파치 카프카 입문 강의\n  kafka documentation\n  ","id":5,"section":"posts","summary":"카프카 개념 정리 카프카란? 기존에 end-to-end 연결 방식의 아키텍처로 인하여 데이터 연동의 복잡성이 증가되었다. 이에 링크드인에서 데이터가 갑자기 많아지더라도 확장이 용","tags":null,"title":"카프카 개념","uri":"http://blog.cmstown.com/2020/11/kafka_sumary/","year":"2020"},{"content":"알고 쓰는 @Transactional 스프링으로 프로젝트를 진행하다보면 @Transactional 어노테이션을 많이들 활용한다. 그런데 동아리나 다른 스프링 개발자들 중 해당 어노테이션의 default값이 어떤것을 의미하는지도 모르고 사용하는 분들이 종종 있다. 부끄럽지만 나 역시도 옛날에 그랬다. 당연히 서비스의 메소드들에 써야하는 것인 줄 알았고, 정확히 의미하는 것이 무엇인지도 몰랐다. 이에 보다 확실하게 @Transactional에 대해 알고 쓸 수 있도록 글을 작성해본다.\n@Transactional이란? 스프링에서 @Transactional 어노테이션을 이용하면 트랜잭션의 범위 및 규칙을 정의할 수 있다. 트랜잭션에 대해 잘 모른다몬 이 글을 참고해보자.\n기본적으로 @Transactional에서 사용하는 옵션은 아래와 같다.\n\npropagation(전파옵션) @Transactional(propagation = Propagation.REQUIRED)  전파옵션이란 트랜잭션 동작 도중 다른 트래잭션을 호출하는 상황에 선택할 수 있는 옵션이다.\nREQUIRED(defuat)  디폴트 속성으로 붐모 트랜잭션 내에서 실행하며 부모 트랜잭션이 없을 겨웅 새로운 트랜잭션을 생성한다.  SUPPORTS  이미 시작된 트랜잭션(부모 트랜잭션)이 있으면 참여하고 그렇지 않으면 트랜잭션 없이 진행하게 만든다.  REQUIRES_NEW   부모 트랜잭션 유무에 상과없이 새 트랜잭션을 시작\n  부모 트랜잭션이 존재할 경우 부모 트랜잭션을 잠시 보류\n  MANDATORY   REQUIRED와 비슷하게 이미 시작된 트랜잭션이 있으면 참여하낟.\n  반면에 트랜잭션이 시작된 것이 없으면 새로 시작하는 대신 예외를 발생시킨다.\n  혼자서는 독립적으로 트랜잭션을 진행하면 안되는 경우에만 사용\n  NOT_SUPPORTED   트랜잭션을 사용하지 않게 한다.\n  이미 진행 중인 트랜잭션(부모 트랜잭션)이 있으면 보류시킨다.\n  NEVER  부모 트랜잭션이 존재할 경우 exception 발생  NESTED   이미 진해중인 트랜잭션이 있으면 중첩 트랜잭션을 시작한다.\n  중첩 트랜잭션은 트랜젹션 안에 트랜잭션을 만드는 것.\n  진행인 작업이 실패하더라도 DB에 로그를 남겨야하는 경우에 사용된다.\n  \nisolation(격리수준) @Transactional(isolation = Isolation.DEFAULT)  isolation에 대한 내용은 이 글을 읽어보면 도움이된다.\nDEFAULT   기본 격리 수준으로 DB의 isolation level을 따른다.\n  mysql의 경우 REPEATABLE_READ이다.\n  READ_UNCOMMITED READ_COMMITED REPEATABE_READ SERIALIZABLE \nreadOnly @Transactional(readOnly = false)  true일 경우 ]\n  readOnly는 트랜잭션을 읽기 전용으로 설정할 수 있다\n  특정 트랜잭션 안에서 쓰기 작업이 일어나는 것을 의도적으로 방지하기 위해 사용할 수도 있다.\n  일반적으로 읽기 전용 트랜잭션이 시작된 이후 insert, update, delete 같은 작업이 진행되면 예외가 발생한다.\n  \n트랜잭션 롤백(rollbackFor, follbackForClassName) @Transactional(rollbackFor = IllegalArgumentException.class, noRollbackFor = NullPointerException.class)    기존본적으로 런타임 예외가 발생하면 롤백된다.\n  checked exception의 경우 발생해도 커밋한다.\n 체크 예외는 예외적인 상황에서 사용되기보다는 리턴 값을 대신해서 비즈니스적인 의미를 담은 결과를 돌려주는 용도로 많이 사용되기 때문이다.    rollbackFor  특정 예외가 발생시 강제로 Rollback  noRollbackFor  특정 예외 발생시 Rollback되지 않음.  \ntimeout @Transactional(timeout = -1)    지정한 시간 내에 해당 메소드 수행이 완료되지 않는 경우 rollback 수행\n  default는 -1로 no timeout을 뜻한다.\n  \n앞으로 @Transactional 을 활용하는데 있어서 위에부분만 잘 숙지하면 목적과 의도에 맞게 원하는 트랜잭션을 구현할 수 있을 것이다.\n\n참고  https://goddaehee.tistory.com/167  ","id":6,"section":"posts","summary":"알고 쓰는 @Transactional 스프링으로 프로젝트를 진행하다보면 @Transactional 어노테이션을 많이들 활용한다. 그런데 동아리나 다른 스프링 개발자들 중 해당 어노테이션의 default값이","tags":null,"title":"[Spring(스프링)] 알고 쓰는 @Transactional","uri":"http://blog.cmstown.com/2020/11/transactional/","year":"2020"},{"content":"트랜잭션(Transaction) 트랜잭션은 정말 중요하다, 우리가 사이드로 프로젝트를 진행하나 실무에서 적용하나 트랜잭션은 반드시 활용될 것이다. 심지어 면접에서도 이에 대해 물어보는 경우가 많다. 오늘 다시 한번 이 트랜잭션에 대해 정리하는 시간을 가져보자.\n\n트랜잭션이란? 트랜잭션은 데이터베이스의 상태를 변화시키기 위해서 수행하나는 작업의 단위이다.\n\n트랜잭션의 특징(ACID) 흔히들 트랜잭션의 특징으로 ACID를 말한다. 이 ACID가 무엇인지 알아보자.\n원자성(Atomicity) 트랜잭션이 데이터베이스에 모두 반영되던가, 아니면 전혀 반영되지 않아야 한다는 특징\n일관성(Consistency) 어떤 하나의 트랜잭션이라도 다른 트랜잭션의 연산에 끼어들 수 없다는 특징\n독립성(Isolation) 어떤 하나의 트랜잭션이라도 다른 트랜잭션의 연산에 끼어들 수 없다는 것\n지속성(Durability) 트랜잭션이 성공적으로 완료되었을 경우 결과는 영구적으로 반영되어야한다는 것\n트랜잭션의 특징(은행원 예시) 특징들만 읽었을 때, 선뜻 완벽히 이해하지 못할 수도 있다. 그렇기에 고전적인 은행원 예시를 활용해보겠다.\n원자성(Atomicity) 은행에서 작업이 부분적으로 성공하는 일이 없아야 한다. 즉, 송금은 성공했지만 받는 사람의 계좌에 돈이 안들어오는 경우는 없어야한다.\n일관성(Consistency) DB의 여러 제약 조건에 맞는 상태를 보장해야한다. 즉, 송금하는 사람의 계좌 잔고가 0보다 작을 수 없다.\n독립성(Isolation) 송긍하는 사람의 계좌에서 돈은 빠져나갔는데, 아직 받는 사람의 계좌에 돈이 들어가지 않는 상황을 볼 수 없다.\n지속성(Durability) 은행에서 장애가 나도 성 성공한 거래 내역은 그대로 보장해야한다.\n\n독립성(Isolation) 문제점 이러한 트랜잭션의 특징들을 이용하여 사용시에 독립성(Isolation) 관련 문제점에 유의하여 사용해야한다. 독립성 관련 문제는 무엇이 있는지 알아보자.\nDirt Read 하나의 트랜잭션(T1)이 데이터에 접근하여 값을 \u0026lsquo;A\u0026rsquo;에서 \u0026lsquo;B\u0026rsquo;로 변경했고 아직 커밋을 하지 않았을 때, 다른 트랜젹선(T2)이 해당 데이터를 Read할 경우 변경된 \u0026lsquo;B\u0026rsquo; 데이터를 읽는다. 그러나 이때 T1 이 최종 커밋을 하지 않고 종료된다면 문제가 생기게 된다.\nNon-Repeatable Read 트랜잭션 내에서 같은 쿼리를 두 번 수행했는데, 그 사이에 다른 트랜잭션이 값을 수정 또는 삭제하는 바람에 두 쿼리 결과가 다르게 나타나는 현상을 말한다\nPhantom Read 한 트랜잭션 안에서 일정범위의 레코드를 두번 이상 읽을 때, 첫 번재 쿼리에서 없던 유령 레코드가 두번째 쿼리에서 나타나는 현상을 말한다.\n\n트랜잭션 격리 수준 독립성과 관련된 문제점 때문에, ANSI 표준에서 트랜잭션의 격리성과 동시 처리 성능 사이의 Trade-off를 두고 4단계 격리수준을 나누었다. 내려갈수록 격리 수준이 높아져서 언급된 이슈는 적게 발생하지만 동시 처리 성능은 떨어진다.\n참고로, 트랜잭션이 발생하면 락(Lock)이 걸리는 R 은 공유락 , CUD는 배타적 락이 걸린다.\nRead Uncommitted(레벨 0) 하나의 트랜잭션에서 커밋하지 않은 데이터에 다른 트랜잭션이 접근 가능하다. 즉, 커밋하지 않은 데이터를 읽을 수 있다.\n장점\n 동시 처리 성능은 가장 높다  단점\n Dirty Read, Non-Repeatable Read, Phantom Read 문제 발생여부가 있다.  Read Committed(레벨 1) 커밋이 완료된 데이터만 읽을 수 있다.\n데이터베이스들은 보통 Read Committed 를 default로 삼는다.\n장점\n Dirty Read가 발생한 여지는 없다.  단점\n Non-Repeatable Read, Phantom Read 발생 여부  Repeatable Read(레벨 2) 트랜잭션 내에서 한번 조회한 데이터를 반복해서 조회해도 같은 데이터가 조회된다.\n장점\n Dirty Read , Non-Repeatable Read는 발생하지 않는다.  단점\n Phantom Read 발생  Serializable(레벨 3) 가장 엄격한 격리 수준\n장점\n 모든 문제점을 예방할 수 있다. 두 트랜잭션이 간섭을 안 받는것처럼 실행된다.  단점\n 동시 처리 성능은 가장 낮다  ","id":7,"section":"posts","summary":"트랜잭션(Transaction) 트랜잭션은 정말 중요하다, 우리가 사이드로 프로젝트를 진행하나 실무에서 적용하나 트랜잭션은 반드시 활용될 것이다. 심지","tags":null,"title":"트랜잭션(Transcation) ","uri":"http://blog.cmstown.com/2020/11/transcation/","year":"2020"},{"content":"🕸 쿠버네티스 입문 - 인그레스 🕸 이전에 배운 NodePort로 외부 서비스를 공개하는 것은 L4 레벨까지만 다룰 수 있기 떄문에 HTTP/HTTPS처럼 경로를 기반으로 서비스를 전환하는 L7 레벨의 제어는 불가능하다.\n이를 해결하기 위한 리소스가 인그레스 다. 그러나 로컬 쿠버네티스 환경에서는 인그레스를 사용해 서비스를 노출시킬 수 없다. 클러스터외부에서 온 HTTP 요청을 서비스로 라우팅하기 위한 niginx_ingress_controller을 다음과 같이 배포한다.\n$ kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v0.35.0/deploy/static/provider/cloud/deploy.yaml ... job.batch/ingress-nginx-admission-create created job.batch/ingress-nginx-admission-patch created  그러면 잠시 후 ingress-nginx에 다음과 같은 서비스와 파드가 생성된다. 이제 인그레스 리소스를 사용할 수 있다.\n$ kubectl -n ingress-nginx get service,pod NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/ingress-nginx-controller LoadBalancer 10.98.76.240 localhost 80:32634/TCP,443:31331/TCP 4m29s service/ingress-nginx-controller-admission ClusterIP 10.111.83.116 \u0026lt;none\u0026gt; 443/TCP 4m29s NAME READY STATUS RESTARTS AGE pod/ingress-nginx-admission-create-lxkrf 0/1 Completed 0 4m29s pod/ingress-nginx-admission-patch-4qqq4 0/1 Completed 2 4m29s pod/ingress-nginx-controller-5947756d78-tsm56 1/1 Running 0 4m29s  \n인그레스를 통해 접근하기 실제로 인그레스를 통해 서비스에 접근해 보겠다. simple-service.yaml 파일을 다음과 같이 수정하고 반영해보자. spec.type 값은 지정하지 않으면 ClusterIP 서비스가 생성된다.\napiVersion: v1 kind: Service metadata: name: echo spec: selector: app: echo ports: - name: http port: 80  $ kubectl apply -f simple-service.yaml service/echo created  simple-ingress.yaml 파일에 간단한 인그레스를 정의하고 반영한다.\napiVersion: extensions/v1beta1 kind: Ingress metadata: name: echo spec: rules: - host: ch05.cms.local http: paths: - path: / backend: serviceName: echo servicePort: 80  $ kubectl apply -f simple-ingress.yaml ingress.extensions/echo created $ kubectl get ingress NAME HOSTS ADDRESS PORTS AGE echo ch05.cms.local 80 20s  인그레스는 L7 라우팅이 가능하므로 가상 호스팅 기능처럼 저장된 호스트 혹은 경로와 일치하는 서비스로 요청을 전달할 수 있다.\n로컬에서 다음과 같은 HTTP 요청을 보내면 백엔드에 있는 echo 서비스에서 다음과 같은 응답을 보내온다. /etc/hosts에 인그레스에서 정의한 호스트를 127.0.0.1로 정의해 같은 결과를 얻을 수 있다.\n$ curl http://localhost -H 'Host: ch05.cms.local'  이 외에도 인그레스 층에서 HTTP 요청에 다양한 제어를 할 수 있다. 예를 들면, simple-ingress.yaml 파일을 다음과 같이 수정한다.\napiVersion: extensions/v1beta1 kind: Ingress metadata: name: echo annotations: nginx.ingress.kubernetes.io/server-shippet: | set $agentflag 0; if ( $http_user_agent ~* \u0026quot;(Mobile)\u0026quot; ) { set $agentflag 1; } if ( $agentflag = 1) { return 301 http://cms.kr/; } spec: rules: - host: ch05.cms.local http: paths: - path: / backend: serviceName: echo servicePort: 80  로컬 쿠버네티스 환경에서는 nginx-ingress-controller를 사용한다. metadata.annotations 파일에 nginx-ingress-controller 자체의 제어 설정을 할 수 있다. nginx.ingress.kubernetes.io/server-snippet을 설정하면 Nginx 설정 파일 문법에 따라 요청 필터링 등을 사이에 추가할 수 있다.\n위 예제 같은 경우 User-Agent 값에 Mobile이 포함된 경우 요청을 다른 URL로 리다이렉트하는 것이다. 이런 요청 제어를 인그레스에서 처리할 수 있기 떄문에 백엔드나 웹 서버, 애플리케이션 서버에서 이를 신경 쓸 필요가 없다.\n퍼블릭 클라우드 환경에서 인그레스는 해당 플랫폼의 L7 로드 밸런서를 이용할 수 있다. GCP에서는 Cloud Load Balancing을 기본으로 사용하며 AWS에서는 Application Load Balancer를 사용할 수 있다.\n다음 장에서는 이러한 퍼블릭 클라우드를 사용해 쿠버네티스를 이용한 좀 더 실전적인 예제를 가지고 다루도록 하겠다.\n\n참고\n도커/쿠버네티스를 활용한 컨테이너 개발 실전 입문\n","id":8,"section":"posts","summary":"🕸 쿠버네티스 입문 - 인그레스 🕸 이전에 배운 NodePort로 외부 서비스를 공개하는 것은 L4 레벨까지만 다룰 수 있기 떄문에 HTTP/HTTPS처럼 경로를 기","tags":["Devops"],"title":"[Kubernets/쿠버네티스] 03. 쿠버네티스 입문 - 인그레스(ingress)","uri":"http://blog.cmstown.com/2020/09/k8s_03/","year":"2020"},{"content":"🕸 쿠버네티스 입문 - 파드(Pod),래플리카세트(ReplicaSet),디플로이먼트(Deployment),서비스(Service) 🕸 파드 파드(pod)는 컨테이너가 모인 집합체의 단위로, 적어도 하나 이상의 컨테이너로 이루어진다. 쿠버네티스를 도커와 함께 사용한다면 파드는 컨테이너 하나 혹은 컨테이너의 집합체가 된다. 쿠버네티스에서는 결합이 강한 컨테이너를 파드로 묶어 일괄 배포한다.\n파드는 다음 그림에서 보듯이 노드에 배치해야 한다. 같은 파드를 여러 노드에 배치할 수도 있고 한 노드에 여러 개 배치할 수도 있다. 그러나 파드 하나가 여러 노드에 걸쳐 배치될 수는 없다.\n파드 생성 및 배포하기 그럼 이제 파드를 생성해 배포해 보자. nginx-proxy와 애플리케이션, 2개의 컨테이너를 포함하는 파드를 로컬 쿠버네티스 환경에 배포해 보자.\n파드 생성은 kubectl만 사용해도 가능하지만, 버전 관리 관점에서도 yaml 파일로 정의하는 것이 좋다. 쿠버네티스의 여러 가지 리소스를 정의하는 파일을 매니페스트 파일 이라고 한다. niginx와 echo라는 애플리케이션 두 컨테이너로 구성되는 파드를 정의한 매니페스트 파일을 simple-pod.yaml이라는 이름으로 다음과 같이 작성한다.\napiVersion: v1 kind: Pod metadata: name: simple-echo spec: containers: - name: nginx image: gihyodocker/nginx:latest env: - name: BACKEND_HOST value: localhost:8080 ports: - containerPort: 80 - name: echo image: gihyodocker/echo:latest ports: - containerPort: 8080  이 설정 파일의 내용을 설명하겠다.\nkind는 이 파일에서 정의하는 쿠버네티스 리소스의 유형을 지정하는 속성이다. kind 속성의 값에 따라 spec 아래의 스키마가 변화한다.\nmetadata는 이름 그대로 리소스에 부여되는 메타데이터다. medatadata.name 속성의 값이 이 리소스의 이름이 된다.\nspec은 리소스를 정의하기 위한 속성으로, 파드의 경우 파드를 구성하는 컨테이너를 containers 아래에 정의한다.\nname은 컨테이너 이름, image는 도커 허브에 저장된 이미지 태그값을 지정한다.\nports 속성은 컨테이너가 노출시킬(EXPOSE) 포트를 지정한다.\nenv 속성에 환경 변수를 열거할 수 있다. nginx는 요청의 프록싱 대상이 될 BACKEND_HOST 값이 필요하기 때문에 이 값이 설정돼 있다.\n이 파드를 로컬 쿠버네티스 클러스터에 배포해 보겠다. 매니페스트 파일의 내용을 그대로 반여하려면 다음과 같이 kubectl에서 -f 옵션으로 매니페스트 파일에 대한 경로를 지정하고 apply 명령을 사용한다.\n$ kubectl apply -f simple-pod.yaml pod/simple-echo created  이제 파드가 동작하기는 하지만, 아직은 접근할 수 없다. 파드에 접근하는 방법은 잠시 후에 다루도록 하겠다.\n파드 다루기 매니페스트 파일로 파드를 생성했다. 이번에는 파드를 조작하는 기본 방법을 알아본다.\n파드의 상태는 다음과 같이 목록에서 확인할 수 있다. STATUS가 Running이면 파드 안의 모든 컨테이너가 실행 중이라는 의미다. READY 칼럼값의 분모는 파드에 정의된 컨테이너 수이고 분자는 실행 실행 상태의 컨테이너 수이다.\n$ kubectl get pod NAME READY STATUS RESTARTS AGE simple-echo 2/2 Running 0 35m  kubectl을 사용해 컨테이너 안에 접근 할 수도 있다. 파드 안의 컨테이너가 여러 개인 경우에는 -c 옵션에 컨테이너 명을 지정한다.\n$ kubectl exec -it simple-echo -c nginx /bin/bash root@simple-echo:/#  kubectl log 명령 으로 파드 안에 있는 컨테이너의 표준 출력을 화면에 출력할 수 있다. 마찬가지로 -c 옵션으로 컨테이너명을 지정한다.\n$ kubectl logs -f simple-echo -c echo 2020/09/09 14:00:56 start server  파드를 삭제하려면 kubectl delete pod 명령을 사용한다. kubectl delete 명령은 파드 외에 리소스에도 유효하다. 또한 매니페스트 파일로 파드를 삭제할 수 있는데, 이 경우에는 매니페스트에 작성된 리소스 전체가 삭제된다.\n$ kubectl delete pod simple-echo  $ kubectl delte -f simple-pod.yaml  \n레플리카세트 파드를 정의한 매니페스트 파일로는 파드를 하나밖에 생성할 수 없다. 그러나 어느 정도 규모가 되는 애플리케이션을 구축하려면 같은 파드를 여러 개 실행해 가용성을 확보해야 하는 경우가 생긴다.\n이런 경우에 사용되는 것이 래플리카세트(ReplicaSet) 다. 래플리카 세트는 똑같은 정의를 갖는 파드를 여러 개 생성하고 관리하기 위한 리소스다. 파드의 정의 자체도 레플리카 세트를 정의한 yaml 파일에 작성하므로 파드의 설정 파일을 따로 둘 필요 없이 파일 하나로 정의를 완결지을 수 있다. 그러면 simple-replicaset.yaml을 작성해보자.\napiVersion: apps/v1 kind: ReplicaSet metadata: name: echo labels: app: echo spec: replicas: 3 selector: matchLabels: app: echo template: metadata: labels: app: echo spec: containers: - name: nginx image: gihyodocker/nginx:latest env: - name: BACKEND_HOST value: localhost:8080 ports: - containerPort: 80 - name: echo image: gihyodocker/echo:latest ports: - containerPort: 8080  replicas는 레플리카세트에서 만들 파드의 복제본 수다. 그리고 template 속성의 내용은 파드 정의와 같다. 이 레플리카세트를 배포하면 파드가 3개 만들어진 것을 확인할 수 있다. 같은 파드가 여럿 복제된 것이므로 파드명에 echo-xxx처럼 무작위로 생성된 접미사가 붙는다.\n$ kubectl apply -f simple-replicaset.yaml replicaset.apps/echo created  $ kubectl get pod NAME READY STATUS RESTARTS AGE echo-2sf2h 2/2 Running 0 45s echo-q76w2 2/2 Running 0 45s echo-tlknw 2/2 Running 0 45s  레플리카세트를 조작(yaml 파일을 수정) 파드의 수를 줄이면 줄인 개수만큼 파드가 삭제된다. 삭제된 파드는 복원할 수 없기 때문에 웹 애플리케이션 같은 stateless 파드를 사용하기에 유리하다.\n생성한 레플리카세트를 매니페스트 파일을 이용해 다음과 같이 삭제가 가능하다.\n$ kubectl delete -f simple-replicaset.yaml replicaset.apps \u0026quot;echo\u0026quot; deleted $ kubectl get pod NAME READY STATUS RESTARTS AGE echo-2sf2h 2/2 Terminating 0 5m18s echo-q76w2 2/2 Terminating 0 5m18s echo-tlknw 2/2 Terminating 0 5m18s  \n디플로이먼트 레플리카세트보다 상위에 해당하는 리소스로 **디플로이먼트(deployment)**가 있다. 디플로이먼트는 애플리케이션 배포(deploy)의 기본 단위가 되는 리소스다. 또한 디플로이먼트는 레플리카세트를 관리하고 다루기 위한 리소스다.\n파드, 레플리카세트, 디플로이먼트의 관계를 정리하면 다음 그림과 같다.\n출처 : https://www.bluematador.com/blog/kubernetes-deployments-rolling-update-configuration\n디플로이먼트를 정의한 매니페스트 파일 simple-deployment.yaml을 다음과 같이 작성한다\napiVersion: apps/v1 kind: Deployment metadata: name: echo labels: app: echo spec: replicas: 3 selector: matchLabels: app: echo template: metadata: labels: app: echo spec: containers: - name: nginx image: gihyodocker/nginx:latest env: - name: BACKEND_HOST value: localhost:8080 ports: - containerPort: 80 - name: echo image: gihyodocker/echo:latest ports: - containerPort: 8080  디플로이먼트의 정의는 레플리카세트의 정의와 크게 다르지 않다. 차이가 있다면 디플로이먼트가 레플리카세트의 리비전 관리를 할 수 있다는 점 정도다.\n이 매니페스트 파일을 어떤 kubectl 명령을 실행했는지 기록을 남기는 옵션인 \u0026ndash;record를 붙여 kubectl로 클러스터에 반영한다.\n$ kubectl apply -f simple-deployment.yaml --record deployment.apps/echo created  kubectl 명령으로 상태를 확인해 보자. 디플로이먼트는 물론이고, 레플리카세트와 파드가 생성된 것을 확인할 수 있다.\n$ kubectl get pod,replicaset,deployment --selector app=echo NAME READY STATUS RESTARTS AGE pod/echo-59dfb6bdf7-7lg62 2/2 Running 0 2m1s pod/echo-59dfb6bdf7-wj8k6 2/2 Running 0 2m1s pod/echo-59dfb6bdf7-xvwkc 2/2 Running 0 2m1s NAME DESIRED CURRENT READY AGE replicaset.apps/echo-59dfb6bdf7 3 3 3 2m1s NAME READY UP-TO-DATE AVAILABLE AGE deployment.apps/echo 3/3 3 3 2m1s choeminseong-ui-MacBook-Pro:04.docekr_pod choeminseong$  디플로이먼트의 리비전은 다음과 같이 kubectl rollout history 명령으로 확인할 수 있다. 현재는 첫번째 반영이므로 REVISION=1이다.\n$ kubectl rollout history deployment echo deployment.apps/echo REVISION CHANGE-CAUSE 1 kubectl apply --filename=simple-deployment.yaml --record=true  레플리카세트의 생애주기 실제 운영에서 쿠버네티스는 디플로이먼트를 단위로 애플리케이션을 배포한다. 디플로이먼트가 관리하는 레플리카세트는 지정된 개수만큼 파드를 확보하거나 파드를 새로운 버전으로 교체하거나 이전 버전으로 롤백하는 등 중요한 역할을 한다. 그러므로 애플리케이션 배포를 바르게 운영하려면 디플로이먼트 안에서 레플리카세트가 어떻게 동작하는지 파악할 수 있어야 한다. 디플로이먼트를 수정하면 레플리카세트가 새로 생성되고 기존 레플리카세트와 교체된다.\n어떤 경우에 새 레플리카세트가 생성되는지 살펴보자.\n파드 개수만 수정하면 레플리카세트가 새로 생성되지 않음 우성 파드 개수만을 수정해 보겠다. 매니페스트 파일에서 replicas 값을 3에서 4로 수정해 반영하고 적용해보자.\n# 개수 반영 전 # $ kubectl get pod NAME READY STATUS RESTARTS AGE echo-59dfb6bdf7-7lg62 2/2 Running 0 17m echo-59dfb6bdf7-wj8k6 2/2 Running 0 17m echo-59dfb6bdf7-xvwkc 2/2 Running 0 17m  다음에서 보듯이 원래 있던 파드는 그대로 있고, 컨테이너가 하나 새로 생성된 것을 알 수 있다.\n# 개수 반영 후 # $ kubectl apply -f simple-deployment.yaml --record deployment.apps/echo configured $ kubectl get pod NAME READY STATUS RESTARTS AGE echo-59dfb6bdf7-7lg62 2/2 Running 0 17m echo-59dfb6bdf7-c47zf 2/2 Running 0 16s echo-59dfb6bdf7-wj8k6 2/2 Running 0 17m echo-59dfb6bdf7-xvwkc 2/2 Running 0 17m  레플리카세트가 새로 생성됐다면 리비전 번호가 2일 텐데, 그 내용은 출력되지 않는다. replicas 값만 변경해서는 레플리카세트의 교체가 일어나지 않는다는 것을 알 수 있다.\n$ kubectl rollout history deployment echo deployment.apps/echo REVISION CHANGE-CAUSE 1 kubectl apply --filename=simple-deployment.yaml --record=true  컨테이너 정의 수정 컨테이너 이미지가 수정된 경우를 확인해 보자, simple-deployment.yaml 파일의 echo 컨테이너 이미지를 다음과 같이 gihyodocker/echo:patced로 수정한다.\n- name: echo image: gihyodocker/echo:patched ports: - containerPort: 8080  $ kubectl apply -f simple-deployment.yaml --record deployment.apps/echo configured  그러면 다음과 같이 새로운 파드가 생성되고 기존 파드는 단계적으로 정지됨을 알 수 있다.\n$ kubectl get pod --selector app=echo NAME READY STATUS RESTARTS AGE echo-59dfb6bdf7-7lg62 2/2 Terminating 0 22m echo-59dfb6bdf7-wj8k6 0/2 Terminating 0 22m echo-6c77cf9d47-8gq2m 2/2 Running 0 38s echo-6c77cf9d47-fc82h 2/2 Running 0 34s echo-6c77cf9d47-nwnrp 2/2 Running 0 50s echo-6c77cf9d47-wlxgn 2/2 Running 0 49s  디플로이먼트의 리비전을 확인해 보면 REVISION=2가 생성됐다. kubectl apply를 실행했을 떄 디플로이먼트의 내용이 변경된 경우 새로운 리비전이 생성된다.\n$ kubectl rollout history deployment echo deployment.apps/echo REVISION CHANGE-CAUSE 1 kubectl apply --filename=simple-deployment.yaml --record=true 2 kubectl apply --filename=simple-deployment.yaml --record=true  롤백 실행하기 디플로이먼트는 리비전 번호가 기록되므로 특정 리비전의 내용을 확인할 수 있다.\n$ kubectl rollout history deployment echo --revision=1 deployment.apps/echo with revision #1 Pod Template: Labels:\tapp=echo pod-template-hash=59dfb6bdf7 Annotations:\tkubernetes.io/change-cause: kubectl apply --filename=simple-deployment.yaml --record=true Containers: nginx: Image:\tgihyodocker/nginx:latest Port:\t80/TCP Host Port:\t0/TCP Environment: BACKEND_HOST:\tlocalhost:8080 Mounts:\t\u0026lt;none\u0026gt; echo: Image:\tgihyodocker/echo:latest Port:\t8080/TCP Host Port:\t0/TCP Environment:\t\u0026lt;none\u0026gt; Mounts:\t\u0026lt;none\u0026gt; Volumes:\t\u0026lt;none\u0026gt;  undo를 실행하면 디플로이먼트가 바로 직전 리비전으로 롤백된다.\n$ kubectl rollout undo deployment echo deployment.apps/echo rolled back choeminseong-ui-MacBook-Pro:04.docekr_pod  디플로이먼트는 다음과 같이 매니페스트 파일을 이용해서 삭제한다. 디플로이먼트 및 관련된 레플리카세트와 파드가 함께 삭제된다.\n$ kubectl delete -f simple-deployment.yaml deployment.apps \u0026quot;echo\u0026quot; deleted  \n서비스 서비스는 쿠버네티스 클러스터 안에서 파드의 집합(주로 레플리카세트)에 대한 경로나 서비스 디스커버리(API 주소가 동적으로 바뀌는 경우에도 클라이언트가 접속 대상을 바꾸지 않고 하나의 이름으로 접근할 수 있도록 하는 기능)를 제공하는 리소스다. 서비스의 대상이 되는 파드는 서비스에서 정의하는 레이블 셀렉터로 정해진다.\n예를 들어, simple-replicaset-with-label.yaml이라는 이름으로 다음과 같은 매니페스트 파일을 작성해 레플리카세트를 2개 정의한다. 앞서 정의했던 echo 레플리카세트와 거의 같으나, release 속성값과 spring과 summer로 나뉜다.\napiVersion: apps/v1 kind: ReplicaSet metadata: name: echo-spring labels: app: echo release: spring spec: replicas: 1 selector: matchLabels: app: echo release: spring template: metadata: labels: app: echo release: spring spec: containers: - name: nginx image: gihyodocker/nginx:latest env: - name: BACKEND_HOST value: localhost:8080 ports: - containerPort: 80 - name: echo image: gihyodocker/echo:latest ports: - containerPort: 8080 --- apiVersion: apps/v1 kind: ReplicaSet metadata: name: echo-summer labels: app: echo release: summer spec: replicas: 2 selector: matchLabels: app: echo release: summer template: metadata: labels: app: echo release: summer spec: containers: - name: nginx image: gihyodocker/nginx:latest env: - name: BACKEND_HOST value: localhost:8080 ports: - containerPort: 80 - name: echo image: gihyodocker/echo:latest ports: - containerPort: 8080  $ kubectl apply -f simple-replicaset-with-label.yaml replicaset.apps/echo-spring created replicaset.apps/echo-summer created $ kubectl get pod -l app=echo -l release=spring NAME READY STATUS RESTARTS AGE echo-spring-5fp66 2/2 Running 0 75s $ kubectl get pod -l app=echo -l release=summer NAME READY STATUS RESTARTS AGE echo-summer-nff8t 2/2 Running 0 78s echo-summer-zkrkg 2/2 Running 0 78s  release=summer인 파드만 접근할 수 있는 서비스를 생성해 보자. 다음과 같이 simple-service.yaml 파일을 작성한다. spec.selector 속성값으로 서비스 대상으로 삼을 파드의 레이블값을 설정한다.\napiVersion: v1 kind: Service metadata: name: echo spec: selector: app: echo release: summer ports: - name: http port: 80  이 서비스와 레이블로 구분되는 각 파드의 관계를 다음 그림에 나타냈다. 파다의 레이블이 서비스에 정의된 셀렉터 값과 일치하면 해당 파드는 그 서비스의 대상이 되므로 서비스를 경유해 트래픽이 들어 온다.\nsimple-service.yaml을 반영해 서비스를 생성한다.\n$ kubectl apply -f simple-service.yaml service/echo created $ kubectl get svc echo NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE echo ClusterIP 10.97.4.73 \u0026lt;none\u0026gt; 80/TCP 19s  실제로도 release=summer인 파드에만 트래픽이 전달되는지 확인해 보자.\n서비스는 기본적으로 쿠버네티스 클러스터 안에서만 접근할 수 있다. 그러므로 쿠버네티스 클러스터 안에서 디버깅용 임시 컨테이너를 배포하고 curl 명령으로 HTTP 요청을 보내 확인해 볼 것이다. 디버그 컨테이너에 들어가서 http://echo/ 로 아무렇게나 HTTP 요청을 보낸다.\n$ kubectl run -i --rm --tty debug --image=gihyodocker/fundamental:0.1.0 --restart=Never -- bash -il If you don't see a command prompt, try pressing enter. debug:/# curl http://echo/ Hello Docker!!debug:/#  여기서 \u0026lsquo;http://echo/\u0026rsquo; 로 접근이 가능한 이유는 쿠버네티스 클러스터의 DNS는 서비스를 서비스명.네임스페이스명.svc.local로 연결해준다.\n예를 들어, 위의 echosms default 네임스페이스에 배치돼 있으므로 다음과 같다.\n http://echo.default.svc.local\n 여기서 svc.local 부분은 생략할 수 있고, 같은 네임스페이스라면 서비스명만으로 참조가 가능하다.\n레이블이 summer인 파드를 하나 골라 로그를 확인해 보면 \u0026ldquo;received request\u0026quot;가 출력된다. 반면 레이블이 spring인 파드는 로그가 출력되지 않는다.\n$ kubectl logs -f echo-summer-zkrkg -c echo 2020/09/11 07:37:41 start server 2020/09/11 14:01:07 received request  ClusterIP 서비스 서비스에도 여러 가지 종류가 있어서 그 종류를 yaml 파일에서 지정할 수 있다. 종류의 기본값은 ClusterIP 서비스 다.\nClusterIP 서비스를 사용하면 쿠버네티스 클러스터의 내부 IP 주소에 서비스를 공개할 수 있다. 이를 이용해 어떤 파드에서 다른 파드 그룹으로 접근할 떄 서비스를 거쳐 가도록 할 수 있으며, 서비스명으로 네임 레졸루션이 가능해진다. 다만, 외부로부터는 접근이 불가능하다.\nNodePort 서비스 NodePort 서비스는 클러스터 외부에서 접근할 수 있는 서비스다.\nNodePort 서비스는 ClusterIP를 만든다는 점은 ClusterIP 서비스와 같다. 각 노드에서 서비스 포트로 접속하기 위한 글로벌 포트를 개방한다는 점이 차이점이다.\napiVersion: v1 kind: Service metadata: name: echo spec: type: NodePort selector: app: echo ports: - name: http port: 80  $ kubectl apply -f simple-nodeport-service.yaml service/echo configured choeminseong-ui-MacBook-Pro:04.docekr_pod choe $ kubectl get svc echo NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE echo NodePort 10.97.4.73 \u0026lt;none\u0026gt; 80:30727/TCP 115m  NodePort 서비스를 생성했다면 위의 80:30727/TCP라고 나왔듯이 노드의 포트 31058를 통해 서비스에 접근할 수 있다. 이를 이용해 서비스를 구버네티스 클러스터 외부로 공개할 수 있다.\n$ curl http://localhost:30727 Hello Docker!!  LoadBalancer 서비스 LoadBalancer 서비스는 로컬 쿠버네티스 환경에서는 사용할 수 없는 서비스다. 이 서비스는 주로 각 클라우드 플랫폼에서 제공하는 로드 밸런서와 연동하기 위해 상용된다.\nExternalName 서비스 ExternalName 서비스는 셀렉터도 포트 정의도 없다. 쿠버네티스 클러스터에서 외부 호스트를 네임 레졸루션하기 위한 별명을 제공한다.\n예를 들어, 다음과 같은 서비스를 생성하면 cms.kr을 cms로 참조할 수 있다.\napiVersion: v1 kind: Service metadata: name: cms spec: type: ExternalName externalName: cms.kr  \n참고\n도커/쿠버네티스를 활용한 컨테이너 개발 실전 입문\n","id":9,"section":"posts","summary":"🕸 쿠버네티스 입문 - 파드(Pod),래플리카세트(ReplicaSet),디플로이먼트(Deployment),서비스(Service) 🕸 파드","tags":["Devops"],"title":"[Kubernets/쿠버네티스] 02. 쿠버네티스 입문 - 파드(Pod),래플리카세트(ReplicaSet),디플로이먼트(Deployment),서비스(Service)","uri":"http://blog.cmstown.com/2020/09/k8s_02/","year":"2020"},{"content":"🕸 쿠버네티스를 공부하기 전에\u0026hellip; 🕸 앞서 도커에 대해 공부를 해보았다. 도커가 발전함에 따라 컨테이너 오케스트레이션이 다양하게 등장했는데, 그 중 표준격인 쿠버네티스를 공부하고자한다. 많은 기업에서도 이미 사용되고있고, 서버 개발자라면\n\n🕸 쿠버네티스 입문 - 쿠버네티스란? 🕸 도커가 등장하고 다양한 오케스트레이션 도구가 등장했는데, 이에 사실상 표준격은 쿠버네티스 이다. 쿠버네티스는 컨테이너 운영을 자동화하기 위한 컨테이너 오케스레이션 도구로, 구글의주도로 개발됐다. 쿠버네티스의 가장 큰 특징은 다양한 부품을 조합해 유연한 애플리케이션을 구축할 수 있다는 점이다. 이에 대해서는 잠시후 설명하도록 하겠다.\n도커의 부상과 쿠버네티스의 탄생 도커가 발전함에 따라 여러 기업에서 도커를 더욱더 잘 활용하기 위한 메커니즘이나 도구등을 발표하기 시작했다. 그중에서도 최근 몇 년 동안 특히 존재감을 나타낸 것은 2014년 구글이 오픈 소스로 공개한 쿠버네티스다. 오픈 소스 소프트웨어이면서도 다양한 상황에 잘 대응하는 유연성을 갖고있다. 게다가 구글 외부로부터 많은 컨트리뷰션을 받아들일 수 있는 체제로 프로젝트가 운영된다는 점도 많은 개발자가 쿠버네티스를 애용하게 된 원인의 하나였다. 이에 2017년부터 도커와 쿠버네티스의 통합이 정식으로 발표됐다.\n\n로컬 PC에서 쿠버네티스 실행 🕸 먼저 다음의 항목들을 로컬 PC에 설치해주자.\n쿠버네티스 설치   window\n  macOS\n  linux\n  kubectl 설치 kubectl은 쿠버네티스를 다루기 위한 명령행 도구다. 로컬 환경이나 매니지드 환경 모두에서 상효라 수 있다.\n 공식 문서를 참고하여 다운로드하자.  대시보드 설치 대시보드는 쿠버네티스에 배포된 컨테이너 등에 대한 정보를 하눈에 보여주는 관리 도구다. Kubectl에 익숙해질 떄까지는 매우 중요한 도구가 될 것이다. 설치를 위해 다음 과정을 차례대로 진행해보자.\n kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0/aio/deploy/recommended.yaml\n 웹 브라우저로 대시보드를 볼 수 있도록 프록시 서버를 설정한다.\n kubectl proxy\n 이후 http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/ 에 접근하면 대시보드를 볼 수 있다.\n대시보드 접근시 접근 제한이된다면, 다음과 같은 화면이 나온다면 접속하려는 계정의 토큰 정보를 입력해서 들어갈 수 있습니다.\n$ kubectl get secrets NAME TYPE DATA AGE default-token-4tzsq kubernetes.io/service-account-token 3 4h28m $ kubectl describe secrets default-token-4tzsq Name: default-token-4tzsq Namespace: default Labels: \u0026lt;none\u0026gt; Annotations: kubernetes.io/service-account.name: default kubernetes.io/service-account.uid: 6b56df4c-5979-4152-abbb-4c767fd3c897 Type: kubernetes.io/service-account-token Data ==== ca.crt: 1025 bytes namespace: 7 bytes token: ~토큰  위에서 얻은 토큰값을 입력합니다.\n\n쿠버네티스의 주요 개념 쿠버네티스 로컬 환경을 갖췄으니 주요 개념을 간단히 짚고 넘어가 보자.\n쿠버네티스로 실행하는 애플리케이션은 애플리케이션을 구성하는 다양한 리소스(녿, 네임스페이스, 피드 등)가 함께 연동해 동작한다. 우리가 앞으로 다루는 쿠버네티스 리소스는 다음과 같다. 쿠버네티스 클러스터 안에서 이 리소스가 연동하고 협조하면서 컨테이너 시스템을 구성한다.\n   리소스 용도     노드 컨테이너가 배치되는 서버   네임스페이스 쿠버네티스 클러스터 안의 가상 클러스터   파드 컨테이너의 집합 중 가장 작은 단위로, 컨테이너의 실행 방법을 정의한다.   레플리카세트 같은 스팩을 갖는 파드를 여러 개 생성하고 관리하는 역할을 한다.   디플로이먼트 레플리카 세트의 리비전을 관리한다.   서비스 파드의 집합에 접근하기 위한 경로를 정의한다.   인그레스 서비스를 쿠버네티스 클러스터 외부로 노출시킨다.   컨피그맵 설정 정보를 정의하고 파드에 전달한다.   퍼피스턴트 볼륨 파드가 사용할 스토리지의 크기 및 종류를 정의   퍼피스턴트 볼륨 클레임 퍼시스턴트 볼륨을 동적으로 확보.   스토리지 클래스 퍼시스턴트 볼륨이 확보하는 스토리지의 종류를 정의   스테이트 풀세트 같은 스펙으로 모두 동일한 파드를 여러 개 생성하고 관리한다.   잡 상주실행을 목적으로 하지 않는 파드를 여러 개 생성하고 정상적인 종료를 보장한다.   크론잡 크론 문법으로 스케줄링되는 잡   시크릿 인증 정보 같은 기밀 데이터를 정의한다.   롤 네임스페이스 안에서 조작 가능한 쿠버네티스 리소스의 규칙을 정의한다.   롤바인딩 쿠버네티스 리소스 사용자와 롤을 연결 짓는다.   클러스터 롤 클러스터 전체적으로 조작 가능한 쿠버네티스 리소스의 규칙을 정의한다.   클러스터 롤 바인딩 쿠버네티스 리소스 사용자의 클러스터롤을 연결 짓는다.   서비스 계정     \n쿠버네티스 클러스터와 노드 쿠버네티스 클러스터는 쿠버네티스의 여러 리소스를 관리하기 위한 집합체를 말한다.\n쿠버네티스 리소스 중에서 가장 큰 개념은 노드(node) 이다. 노드는 쿠버네티스 클러스트의 관리 대상으로 등록된 도커 호스트로, 컨테이너가 배치되는 대상이다.\n쿠버네티스 클러스트는 전체를 관리하는 서버인 마스터가 적어도 하나 이상 있어야 한다. 쿠버네티스 클러스터는 다음과 같이 마스터와 노드의 그룹으로 구성된다.\n쿠버네티스는 노드의 리소스 사용 현황 및 배치 전략을 근거로 컨테이너를 적절히 배치한다. 즉, 클러스터의 처리 능력은 노드에 의해 결정된다.\n로컬 환경에 설치한 쿠버네티스에는 클러스터를 생성할 때 만든 가상 머신이 노드로 등록돼 있다. kubectl get nodes 명령으로 현재 클러스터에 소속된 노드의 목록을 확인할 수 있다.\n$ kubectl get nodes NAME STATUS ROLES AGE VERSION docker-desktop Ready master 3h40m v1.16.6-beta.0 choeminseong-ui-MacBook-Pro:blog choeminseong$  클라우드에서 동작하는 쿠버네티스는 GCP라면 GCE, AWS라면 EC2 인스턴스가 노드가 된다.\n\n네임스페이스 쿠버네티스는 클러스터 안에 가상 클러스터를 또 다시 만들 수 있다. 이 클러스터 안의 가상 클러스터를 네임스페이스(namespace) 라고 한다. 클러스터를 처음 구축하면 default, docker, kube-public, kube-system의 네임스페이스 4개가 이미 만들어져 있다. 다음과 같은 명령어로 현재 클러스터 안에 존재하는 네임스페이스의 목록을 확인할 수 있다.\n$ kubectl get namespaces NAME STATUS AGE default Active 4h39m docker Active 4h37m kube-node-lease Active 4h39m kube-public Active 4h39m kube-system Active 4h39m kubernetes-dashboard Active 3h57m  네임스페이스는 개발팀이 일정 규모 이상일 때 유용하다. 예를 들어, 개발자마다 자신만의 네임스페이스를 두면 메인 네임스페이스가 어질러지는 것을 방지할 수 있다. 네임스페이스마다 권한을 설정할 수 있으므로 더욱 견고하고 세세하게 권한을 제어할 수 있다.\n\n\n참고\n도커/쿠버네티스를 활용한 컨테이너 개발 실전 입문\n","id":10,"section":"posts","summary":"🕸 쿠버네티스를 공부하기 전에\u0026hellip; 🕸 앞서 도커에 대해 공부를 해보았다. 도커가 발전함에 따라 컨테이너 오케스트레이션이 다양하게 등장했는데, 그 중","tags":["Devops"],"title":"[Kubernets/쿠버네티스] 01. 쿠버네티스 입문 - 쿠버네티스란?","uri":"http://blog.cmstown.com/2020/09/k8s_01/","year":"2020"},{"content":"더 자세한 내용은 부디 책을 참고하길 부탁드립니다.\n목차   [Docker/도커] 01. 도커의 기초 - 도커란 무엇인가?\n  [Docker/도커] 02. 도커의 기초 - 도커를 사용하는 의의 / 도커 설치하기\n  [Docker/도커] 03.도커 컨테이너 배포 - 컨테이너로 애플리케이션 실행하기\n  [Docker/도커] 04.도커 컨테이너 배포 - 도커 이미지 다루기\n  [Docker/도커] 05.도커 컨테이너 배포 - 도커 컨테이너 다루기\n  [Docker/도커] 06.도커 컨테이너 배포 - 운영과 관리를 위한 명령\n  [Docker/도커] 07.도커 컨테이너 배포 - 도커 컴포즈로 여러 컨테이너 실행하기\n  👉 [Docker/도커] 08.컨테이너 실전 구축 및 배포 👈\n  \n🐳 08.컨테이너 실전 구축 및 배포 🐳 실제 운영 환경에서는 같은 컨테이너를 복제해 여러 호스트에 배포하는 경우가 흔하다. 그렇기에 실제 운영에서는 애플리케이션을 컨테이너 안에 어떻게 배치하는지가 매우 중요하다.\n애플리케이션과 시스템 내 단일 컨테이너의 적정 비중 도커 초기에는 컨테이너 1개 = 프로세스 1개를 반드시 지켜야 한다고 생각하는 사용자가 있어 자주 토론 거리가 됐다. 그렇다면 도커의 입장은 어떨까? 실제 도커의 공식 문서 \u0026lsquo;Best Practices for writing Dockerfile\u0026rsquo;에 이에 대한 공식적인 입장이 담겨있다.\n Each container should have only one concern.\n컨테이너는 하나의 관심사에만 집중해야 한다.\n 그렇다면 여기서 말하는 하나의 관심사란 무엇인가? 이는 컨테이너 하나가 한 가지 역할이나 문제 영역(도메인)에만 집중해야 한다는 의미이다.\n결론적으로 \u0026lsquo;컨테이너 1개 = 프로세스 1개\u0026rsquo; 원칙만을 고수하는 것은 바람직하지 않다. 상황에 따라 유연하게 대처할 수 있어야 하고, 궁극적으로 하나의 관심사(역할)에만 집줄할 수 있도록 컨테이너를 분리하면 된다.\n\n컨테이너의 이식성 도커를 처음 소개하는 글에서 말했다시피 도커는 이식성이 좋다. 그러나 이식성이 완벽하지 않다.\n커널 및 아키텍처의 차이 도커에서 사용되는 컨테이너형 가상화 기술은 호스트 운영 체제와 커널 리소스를 공유한다. 이는 사실상 도커 컨테이너를 실행하려면 호스트가 특정 CPU 아키텍처 혹은 운영 체제를 사용해야 한다는 의미다.\n라이브러리와 동적 링크 문제 라이브러리 사용시 동적 링크를 사용하면 문제가 생기는 경우도 있다. 도커를 사용할 떄 이식성이란 말이 자주 등장하는데, 이러한 성격이 절대적인 것이 아님을 이해해야 한다.\n\n도커 친화적인 애플리케이션 애플리케이션 중 도커를 적용하기에 유리한 특징을 가진 것들이 있다. 이런 특징을 여러 갖춘 도커 친화적인 애플리케이션은 컨테이너의 장점을 최대한 누릴 수 있다.\n도커 컨테이너 형태로 실행되는 애플리케이션의 동작을 제어하는 방법으로는 다음과 같은 것을 꼽을 수 있다.\n  실행 시 인자\n  설정 파일\n  애플리케이션 동작을 환경 변수로 제어\n  설정 파일에 환경 변수를 포함\n  책에서는 환경 변수로 제어하는 방법을 추천한다.\n애플리케이션 동작을 환경 변수로 제어 앞에서 본 젠킨스 예제에서도 슬레이브 쪽에 JENKINS_SLAVE_SSH_PUBKEY라는 환경 변수에 값을 설정하는 방식으로 마스터 인스턴스의 공개키를 전달했다. 이떄도 이 방법의 편리성을 알 수 있었다.\n해당 방법의 장점은 매번 이미지를 다시 빌드하지 않아도 된다는 점이다. 설정값이 조금 바뀌었다고 도커 이미지를 다시 빌드할 때 낭비되는 시간은 물론이고 환경 변수 값을 바꾼 후 컨테이너를 다시 시작하면 그만임므로 시행착오에 드는 시간도 압도적으로 줄어든다.\n환경 변수는 컴포즈를 사용하는 경우 docker-compose.yml 파일의 env 속성에 기술해 관리한다. 쿠버네티스나 아마존 ECS에도 비슷한 기능을 제공한다.\n\n퍼시스턴스 데이터를 다루는 방법 컨테이너를 사용해서 상태를 갖는 애플리케이션을 운영하려면 샘로운 버전의 컨테이너가 배포돼도 이전 버전의 컨테이너에서 사용하던 파일 및 디렉터리를 그대로 이어받아 사용할 수 있어야 한다. 이런 경우에 사용도니는 것이 볼륨(data volume) 이다.\n데이터 볼륨 데이터 볼륨은 도커 컨테이너 안의 디렉터리를 디스크에 퍼시스턴스 데이터로 남기기 위한 메커니즘으로, 호스트와 컨테이너 사이의 디렉터리 공유 및 재사용 기능을 제공한다. 이미지를 수정하고 새로 컨테이너를 생성해도 데이터 볼륨은 계속 사용할 수 있다. 또, 데이터 볼륨은 컨테이너를 파기해도 디스크에 그대로 남으므로 컨테이너로 상태를 갖는 애플리케이션을 실행하는 데 적합하다.\n데이터 볼륨을 생성하려면 다음과 같이 docker container run 명령에 -v 옵션을 사용하면 된다.\n docker container run [options] -v 호스트_디렉터리:컨테이너_디렉터리 리포지토리명[:태그] [명령] [명령인자]\n 데이터 볼륨의 용도 중 하나로, 컨테이너에서 생성된 파일을 호스트에서 참조하는 경우를 들 수 있다. 예를 들어, 이미지 처리 도구인 ImageMagick를 제공하는 gibyodocker/imaagemagick:latest 이미지를 사용해 컨테이너 안에서 이미지 파일을 생성해 보자.\n$ docker container run -v \u0026quot;$(PWD):/workspace\u0026quot; gihyodocker/imagemagick:latest convert -size 100x100 xc:#000000 /workspace/gihyo.jpg $ ls -al total 8 drwxr-xr-x 3 choeminseong staff 96 9 8 01:25 . drwxr-xr-x 6 choeminseong staff 192 9 8 01:18 .. -rw-r--r--@ 1 choeminseong staff 203 9 8 01:25 gihyo.jpg  위 명령의 convert 이후 부분이 컨테이너에 전달될 애플리케이션 실행 인자인데, 그 내용은 ImageMagick에 100x100 크기의 흑백 이미지를 당믄 /workspace/gihyo.jpg라는 파일을 생성하라는 명령이다. -v 옵션을 사용해 데이터 볼륨이 설정돼 있으므로 컨테이너 안의 /workspace 디렉터리는 환경 변수 $PWD가 나타내느 디렉토리(현재 작업 디렉터리)에 마운트된다. 실제로 디렉토리를 보면 파일이 공유되있는 것을 확인할 수 있다.\n이 방법을 사용하면 컨테이너 안의 설정 파일을 쉽게 수정할 수 있다. 다만, 호스트 안의 특정 경로에 의존성이 생기기 떄문에 이식성 면에서는 아직 개선의 여지가 있는 기법임을 알아둬야 한다.\n데이터 볼륨 컨테이너 컨테이너 데이터 퍼시스턴스 기법으로 추천되는 것이 데이터 볼륨 컨테이너다.\n앞에서 설명한 데이터 볼륨은 컨테이너와 호스트 사이의 디렉터리를 공유하는 것이었으나, 데이터 볼륨 컨테이너는 컨테이너 간에 디렉터리를 공유한다.\n데이터 볼륨 컨테이너는 이름 그대로 데이터를 저장하는 것만이 목적인 컨테이너 다. 이전 장에서 도커 컨테이너를 파기하지 않는 한 컨테이너의 내용은 디스크에 그대로 유지된다고 설명했다. 데이터 볼륨 컨테이너는 이러한 특성을 활용한 것으로 디스크에 저장된 컨테이너가 갖는 퍼시스턴스 데이터를 볼륨으로 만들어 다른 컨테이너에 공유하는 컨테이너가 데이터 볼륨 컨테이너다.\n호스트-컨테이너 데이터 볼륨은 호스트 쪽 특정 디렉터리에 읜존성을 갖는다. 데이터 볼륨 컨테이너의 볼륨은 도커에서 관리하는 영역인 호스트 머신의 /var/lib/docker/volumes/ 아래에 위치한다. 즉, 데이터 볼륨 컨테이너 방식은 도커가 관리하는 디렉터리 영역에만 영향을 미친다.\n데이터 보륨에 MySQL 데이터 저장하기 MySQL을 예로 데이터 볼류 컨테이너를 사용해 보자. 데이터 볼류 컨테이너 역할을 할 이미지를 다음과 같은 Dockerfile로 생성한다.\nFROM busybox VOLUME /var/lib/mysql CMD [\u0026quot;bin/true\u0026quot;]  busybox는 최소한의 운영 체제 기능만 제공하는 경량 운영 체제로, 도커 이미지의 기반 이미지로 많이 사용된다. 데이터 볼륨 컨테이너는 데이터를 저장하는 것만을 목적으로 하는 컨테이너이므로 되도록 이렇게 작은 이미지를 사용하는 것이 효과적이다.\n#docker image build -t 이미지명[:태그명] Dockerfile의_경로# $ docker image build -t example/mysql-data:latest . Sending build context to Docker daemon 3.072kB Step 1/3 : FROM busybox latest: Pulling from library/busybox 9c075fe2c773: Pull complete Digest: sha256:c3dbcbbf6261c620d133312aee9e858b45e1b686efbcead7b34d9aae58a37378 Status: Downloaded newer image for busybox:latest ---\u0026gt; edabd795951a Step 2/3 : VOLUME /var/lib/mysql ---\u0026gt; Running in 53ab91aea6e9 Removing intermediate container 53ab91aea6e9 ---\u0026gt; 5b91966e4a46 Step 3/3 : CMD [\u0026quot;bin/true\u0026quot;] ---\u0026gt; Running in 76d4d7d82a80 Removing intermediate container 76d4d7d82a80 ---\u0026gt; f53d1d16a4d4 Successfully built f53d1d16a4d4 Successfully tagged example/mysql-data:latest  이 이미지의 컨테이너를 mysql-data라는 이름으로 데이터 볼륨 컨테이너로 실행한다. 이 컨테이너는 CMD 인스트럭션에서 셀을 실행하는 것이 전부기 떄문에 실행이 끝나면 컨테이너가 바로 종료된다.\n$ docker container run -d --name mysql-data example/mysql-data:latest 552b6376be6dd3c04471ff201942c9327b3bb440aabeb5237c484d0eb96859d4  이어서 MySQL을 동작시킬 컨테이너를 실행한다. 환경 벼수로 데이터베이스 이름, 사용자명, 패스워드를 설정한다. \u0026ndash;volumes-from 옵션을 사용해 데이터 볼륨 컨테이너 mysql-data를 MySQL 컨테이너에 마운트한다. 이제 MySQL 컨테이너의 /var/lib/mysql에는 데이터가 저장되지 않는다.\n$ docker container run -d --rm --name mysql -e \u0026quot;MYSQL_ALLOW_EMPTY_PASSWORD=yes\u0026quot; -e \u0026quot;MYSQL_DATABASE=volume_test\u0026quot; -e \u0026quot;MYSQL_USER=example\u0026quot; -e \u0026quot;MYSQL_PASSWORD=example\u0026quot; --volumes-from mysql-data mysql:5.7  실행 중인 mysql 컨테이너에 root 계정으로 로그인하고 다음과 같은 CREATE, INSERT 쿼리를 보낸다.\n$ docker container exec -it mysql mysql -u root -p volume_test Enter password:  mysql\u0026gt; CREATE TABLE user( -\u0026gt; id int PRIMARY KEY AUTO_INCREMENT, -\u0026gt; name VARCHAR(255) -\u0026gt; ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE utf8mb4_unicode_ci; Query OK, 0 rows affected (0.01 sec)  mysql\u0026gt; INSERT INTO user (name) VALUES ('minseong'), ('docker'), ('Solomon Hykes'); Query OK, 3 rows affected (0.00 sec) Records: 3 Duplicates: 0 Warnings: 0  이제 데이터가 저장됐다. 테스트를 위해 컨테이너를 정지하면 mysql 컨테이너는 \u0026ndash;rm 옵션을 붙여 실행했으니 정지와 함꼐 컨테이너가 삭제된다. 다시 새로운 컨테이너를 실행하고 조금 전 저장한 데이터가 남아 있는지 확인하자.\n$ docker container stop mysql mysql $ docker container run -d --rm --name mysql -e \u0026quot;MYSQL_ALLOW_EMPTY_PASSWORD=yes\u0026quot; -e \u0026quot;MYSQL_DATABASE=volume_test\u0026quot; -e \u0026quot;MYSQL_USER=example\u0026quot; -e \u0026quot;MYSQL_PASSWORD=example\u0026quot; --volumes-from mysql-data mysql:5.7 f579e9c6c29cdf805c9f60956aeeec00516fd466e6d534c98e76b35e089aff1a  $ docker container exec -it mysql mysql -u root -p volume_test Enter password: mysql\u0026gt; select * from user; +----+---------------+ | id | name | +----+---------------+ | 1 | minseong | | 2 | docker | | 3 | Solomon Hykes | +----+---------------+ 3 rows in set (0.00 sec)  보는 바와 같이 저장한 데이터가 잘 남아 있다. 이렇게 애플리케이션 컨테이너와 데이터 볼륨 컨테이너를 분리하면 쉽게 데이터와 컨테이너를 교체할 수 있다.\n참고\n도커/쿠버네티스를 활용한 컨테이너 개발 실전 입문\n","id":11,"section":"posts","summary":"더 자세한 내용은 부디 책을 참고하길 부탁드립니다. 목차 [Docker/도커] 01. 도커의 기초 - 도커란 무엇인가? [Docker/도커] 02. 도커의 기초 - 도커","tags":["Devops"],"title":"[Docker/도커] 08.컨테이너 실전 구축 및 배포","uri":"http://blog.cmstown.com/2020/09/docker_08/","year":"2020"},{"content":"더 자세한 내용은 부디 책을 참고하길 부탁드립니다.\n목차   [Docker/도커] 01. 도커의 기초 - 도커란 무엇인가?\n  [Docker/도커] 02. 도커의 기초 - 도커를 사용하는 의의 / 도커 설치하기\n  [Docker/도커] 03.도커 컨테이너 배포 - 컨테이너로 애플리케이션 실행하기\n  [Docker/도커] 04.도커 컨테이너 배포 - 도커 이미지 다루기\n  [Docker/도커] 05.도커 컨테이너 배포 - 도커 컨테이너 다루기\n  [Docker/도커] 06.도커 컨테이너 배포 - 운영과 관리를 위한 명령\n  👉 [Docker/도커] 07.도커 컨테이너 배포 - 도커 컴포즈로 여러 컨테이너 실행하기 👈\n  [Docker/도커] 08.컨테이너 실전 구축 및 배포\n  \n🐳 07.도커 컨테이너 배포 - 도커 컴포즈로 여러 컨테이너 실행하기 🐳 도커를 실제 운영 환경에 적용할 때 단일 컨테이너만 이용하는 경우는 드물다. 이에 여러 컨테이너를 동작을 제어하기 위한 설정 파일이나 환경 변수를 어떻게 전달하지, 컨테이너의 의존관계를 고려할 때 포트 포워딩을 어떻게 설정해야 하는지 드으이 요소를 적절히 관리해야 한다.\n이떄 필요한 것이 **도커 컴포즈(Docekr Compose)다.\ndocker-compose 명령으로 컨테이너 실행하기 Compose는 yaml 포맷으로 기술된 설정 파일로 여러 컨테이너의 실행을 한 번에 관리할 수 있게 해준다.\n우선 어떤 기능들이 있는지 살펴보자. 윈도우/macOS용 도커를 로컬에 설치한 경우 바로 사용할 수 있고, 리눅스 환경은 별도 설치가 필요하다.\n먼저 컨테이너 하나를 실행해 보겠다. 그리고 같은 작업을 docker-composer를 사용해 다시 수행할 것이다.\n$ docker container run -d -p 9000:8080 example/echo:latest 9eec9e85ef46b267e40518f108910e60528fcce9c7d643b8403681160d28217c  임의의 디렉터리에서 docker-compose.yml이라는 파일명으로 다음과 같은 내용을 작성한다.\nversion: \u0026quot;3\u0026quot; services: echo: image: example/echo:latest ports: - 9000:8080  여기서 version: \u0026ldquo;3\u0026rdquo; 부분은 이 docker-compose.yml 파일의 내용을 해석하는 데 필요한 문법을 선언한 것이다. 여기서 만든 example/echo:latest 이미지를 도커 컴포즈에서 사용해 보겠다.\nservices 요소 아래의 echo는 컨테이너 이름으로, 그 아래에 다시 어떤 이미지를 실행할지가 정의된다. image 요소는 도커 이미지, ports는 포트 포워딩 설정을 지정한다.\n이 파일을 이용해 도커 컨테이너를 실행해 보겠다. 해당 파일이 위치한 디렉터리에서 이 정의에 따라 여러 컨테이너를 한꺼번에 시작하려면 docker-compose up 명령을 사용하면 된다.\n$ docker-compose up -d Starting 02docker_compose_echo_1 ... done choeminseong-ui-MacBook-Pro:02.docker_compo $ docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7807cf538fbf example/echo:latest \u0026quot;go run /echo/main.go\u0026quot; 2 minutes ago Up About a minute 0.0.0.0:9000-\u0026gt;8080/tcp 02docker_compose_echo_1  컨테이너가 정상적으로 동작되고 있는 것을 확인했다. 그렇다면 컨테이너를 정지해보자. docker-compose down 명령을 사용하면 docker-compose.yml 파일에 정의된 모든 컨테이너가 정지 혹은 삭제된다.\n$ docker-compose down Stopping 02docker_compose_echo_1 ... done Removing 02docker_compose_echo_1 ... done Removing network 02docker_compose_default  일일이 컨테이너 ID를 확인후 지울 필요가 없어 훨씬 간단하다. 이번에는 지난번 작성한 main.go와 Dockerfile이 있는 디렉토리에 docker-compose.yml을 작성후 실행해보자.\ndocker-compose.yml\nversion: \u0026quot;3\u0026quot; services: echo: build: . ports: - 9000:8080  $ docker-compose up -d --build Creating network \u0026quot;01test_go_default\u0026quot; with the default driver Building echo Step 1/4 : FROM golang:1.9 ---\u0026gt; ef89ef5c42a9 Step 2/4 : RUN mkdir /echo ---\u0026gt; Using cache ---\u0026gt; 24e37983e029 Step 3/4 : COPY main.go /echo ---\u0026gt; 290af47dafb2 Step 4/4 : CMD [\u0026quot;go\u0026quot;, \u0026quot;run\u0026quot;, \u0026quot;/echo/main.go\u0026quot;] ---\u0026gt; Running in 14c5efebddb9 Removing intermediate container 14c5efebddb9 ---\u0026gt; 127a4a067c54 Successfully built 127a4a067c54 Successfully tagged 01test_go_echo:latest Creating 01test_go_echo_1 ... done  이로써 docker-compose.yml 파일을 작성하면 기존 docker 명령을 사용해 컨테이너를 실행할 떄 매번 부여하던 옵션을 설정 파일로 관리할 수 있다. 그러나 컴포즈를 사용한 구성 관리 기능의 진가는 여러 컨테이너를 실행할 떄 발휘한다.\n젠킨스 컨테이너 실행하기 컴포즈를 사용해 여러 컨테이너를 실행하기 위해 필요한 기본 요소를 파악하기 위해 젠킨스를 예제 삼아 실행해 보자. 다음과 같이 docekr-compose.yml 파일을 작성한다.\nversion: \u0026quot;3\u0026quot; services: master: container_name: master image: jenkins/jenkins:2.235.5-lts ports: - 8080:8080 volumes: - ./jenkins_home:/var/jenkins_home  젠킨스 이미지는 도커 허브에 올라와 있는 것을 이용한다. volumes라는 설정 항목은 호스트와 컨테이너 사이에 파일을 복사하는 것이 아니라 파일을 공유할 수 있는 매커니즘이다. Dockerfile의 COPY 인스트럭션이나 container cp 명령은 로스트와 컨테이너 사이에 파일을 복사하는 기능이었지만, volumes는 공유라는 점에서 차이가 있다. 즉, 현재 volumes를 이용하여 현재 작업 디렉토리 바로 아래에 jenkins_home 디렉터리를 젠킨스 컨테이너의 /var/jenkins_home에 마운트한다.\n이제 컴포즈를 실행하는데, 이 때 -d 옵션을 사용하지 않고 포어그라운드로 실행하면 패스워드가 생성되는데 이 패스워드를 잘 복사해 놓는다.\n$ docker-compose up Creating network \u0026quot;02docker_compose_default\u0026quot; with the default driver Pulling master (jenkins/jenkins:2.235.5-lts)... 2.142-slim: Pulling from jenkinsci/jenkins ... master | Sep 06, 2020 6:27:21 PM jenkins.install.SetupWizard init master | INFO: master | master | ************************************************************* master | ************************************************************* master | ************************************************************* master | master | Jenkins initial setup is required. An admin user has been created and a password generated. master | Please use the following password to proceed to installation: master | master | **비밀번호** master | master | This may also be found at: /var/jenkins_home/secrets/initialAdminPassword master | master | ************************************************************* master | ************************************************************* master | ************************************************************* master | master | Sep 06, 2020 6:27:29 PM hudson.model.UpdateSite updateData master | INFO: Obtained the latest update center data file for UpdateSource default ... master | INFO: Finished Download metadata. 13,358 ms  여기서 젠킨스를 호스트 쪽 포트 8080과 포트 포워딩으로 연결하였으니 http://localhost:8080/ 에 접속 해보자.\n이후 아까 복사해둔 비밀번호를 입력하면 다음과 같은 화면이 나온다.\n여기서 세세한 설정은 건드릴 필요 없으니, \u0026lsquo;Install suggested plugins\u0026rsquo;를 클릭한다. 그러면 다음과 같이 설치 과정이 나올 것이다.\n이후 플러그인 설치 후 로그인 하면 젠킨스 홈 화면이 나온다.\n마스터 젠킨스 용 SSH 키 생성 이제 젠킨스 컨테이너를 하나 실행했다. 다응믄 좀 더 실용적인 예제로, 여기에 슬레이브 젠킨스 컨테이너를 추가해보겠다. 실제 젠킨스 운영할 때 단일 서버로 운영하기보다는 관리 기능이나 작업 실행 등은 맘스터 인스터스가 맡고, 작업을 실제로 진행하는 것은 슬레이브 인스턴스가 담당한다. 이러한 구성을 컴포즈로 만들어 보겠다.\n먼저 마스터가 슬레이브에 접속할 수 있도록 마스터 컨테이너에서 SSH 키를 생성한다.\n$ docker container exec -it master ssh-keygen -t rsa -C \u0026quot;\u0026quot; Generating public/private rsa key pair. Enter file in which to save the key (/var/jenkins_home/.ssh/id_rsa): Created directory '/var/jenkins_home/.ssh'. Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /var/jenkins_home/.ssh/id_rsa. Your public key has been saved in /var/jenkins_home/.ssh/id_rsa.pub.  지금ㅁ 만든 /var/jenkins_home/.ssh/id_rsa.pub 파일은 마스터 젠킨스가 슬레이브 젠킨스에 접속할 때 사용할 키다. 이 키를 슬레이브를 추가할 때 설정할 것이다.\n슬레이브 젠킨스 컨테이너 생성 슬레이브 인스턴스 역할을 할 젠킨스 컨테이너를 추가한다. 마스터 컨테이너는 master, 슬레이브 컨테이너느 slave01로 각각 이름을 붙인다.\nversion: \u0026quot;3\u0026quot; services: master: container_name: master image: jenkins/jenkins:2.235.5-lts ports: - 8080:8080 volumes: - ./jenkins_home:/var/jenkins_home links: - slave01 slave01: container_name: slave01 image: jenkins/ssh-slave environment: - JENKINS_SLAVE_SSH_PUBKEY={호스트 파일 시스템의 ./jenkins_home/.ssh/id_rsa.pub 의 내용을 붙여넣는다}  SSH 접속 허용 설정 새로 추가하는 슬레이브 컨테이너를 만들 떄는 SSH로 접속하는 슬레이브 용도로 구성된 도커 이미지를 사용한다. 슬레이브 컨테이너 안에서 키를 받아오거나 설정해서는 안되며, 외부 환경 변수로 받아 오게 해야 한다.\nSSH 접속 대상 설정 이제 마스터 컨테이너가 어떻게 슬레이브 컨테이너를 찾아 추가할 것인가 하는 문제가 남아 있다. IP 주소를 찾아 설정하는 방법도 있지만, 컴포즈를 사용하면 좀 더 깔끔하게 문제를 해결할 수 있다. linkks: - slave01 이 바로 그 방법이다. 이것으로 master에서 slave01이라는 이름으로 슬레이브 컨테이너를 찾아갈 수 있다.\n컨테이너 간의 관계 정리 및 준비 완료 지금까지 작업한 디렉토리 상태를 tree 명령으로 확인해 보자. tree가 설치되지 않았다면 해당 블로그를 참고하자.\n$ tree -a -L 2 . ├── docker-compose.yml └── jenkins_home ├── .bash_history ├── .cache ├── .groovy ├── .java ├── .lastStarted ├── .owner ├── .ssh ├── com.cloudbees.hudson.plugins.folder.config.AbstractFolderConfiguration.xml ├── config.xml ├── copy_reference_file.log ├── hudson.model.UpdateCenter.xml ├── hudson.plugins.git.GitTool.xml ├── identity.key.enc ├── init.groovy.d ├── jenkins.CLI.xml ├── jenkins.install.InstallUtil.installingPlugins ├── jenkins.install.InstallUtil.lastExecVersion ├── jenkins.install.UpgradeWizard.state ├── jenkins.telemetry.Correlator.xml ├── jobs ├── logs ├── nodeMonitors.xml ├── nodes ├── plugins ├── queue.xml.bak ├── secret.key ├── secret.key.not-so-secret ├── secrets ├── updates ├── userContent ├── users ├── war └── workflow-libs  이제 docker-compose.yml 이 작성되었으니 해당 디렉토리에서 다시 컴포즈를 실행해보자. 이후 docker-compose ps 명령으로 확인해보면 master와 slave01이라는 이름이 붙은 컨테이너가 실행됐음을 알 수 있다.\n$ docker-compose up -d Pulling slave01 (jenkins/ssh-slave:)... latest: Pulling from jenkins/ssh-slave f15005b0235f: Pull complete ... Status: Downloaded newer image for jenkins/ssh-slave:latest Creating slave01 ... done Recreating master ... done $ docker-compose ps Name Command State Ports ------------------------------------------------------------------------------------ master /sbin/tini -- /usr/local/b ... Up 50000/tcp, 0.0.0.0:8080-\u0026gt;8080/tcp slave01 setup-sshd Up 22/tcp  마지막 설정 두 컨테이너를 실행했다고 해서 마스터 젠킨스가 슬레이브 젠킨스를 인식하지는 못한다. 이에 실제로 젠킨스 페이지에서 설정을 해주어야한다.\n먼저 다시한번 \u0026lsquo;http://localhost:8080/\u0026rsquo; 에 접속하고, 왼쪽 메뉴에 \u0026lsquo;Jenkins 관리\u0026rsquo; 클릭 후 \u0026lsquo;노드 관리\u0026rsquo;에 들어간다. 그리고 왼쪽 메뉴탭의 \u0026lsquo;신규 노드\u0026rsquo;를 클릭해주고 다음과 같은 절차를 따른다.\n노드명은 \u0026lsquo;slave01\u0026rsquo;로 정하고, Premanet Agent에 체크해주자\n그러면 다음과 같은 화면이 나오는데, \u0026lsquo;Remote root directory\u0026rsquo;는 본인이 원하는 디렉토리를 아무거나 설정해도 된다. 그리고 '\tLaunch method\u0026rsquo;를 \u0026lsquo;Launch agents via SSH\u0026rsquo; 로 설정해준다. 여기서 \u0026lsquo;Host\u0026rsquo; 값은 slave01로 입력하면, 굳이 slave01의 IP 주소를 찾아 입력할 필요 없이 master 컨테이너에서 slave01이라는 이름으로 컨테이너를 찾아올 수 있다. \u0026lsquo;Credentials\u0026rsquo;은 Add를 눌러 풀다운 메뉴에서 Jenkins를 선택해 설정을 추가한다.\n그러면 \u0026lsquo;kind\u0026rsquo;를 SSH Username with private key로 바꾸고, \u0026lsquo;Username\u0026rsquo;은 Jenkins, Private Key는 미스터 젠키스의 /.ssh/id_rsa를 선택한다. 그리고 \u0026lsquo;Add\u0026rsquo;를 누른 뒤 \u0026lsquo;Credentials\u0026rsquo;에 Jenkins를 추가해주고, \u0026lsquo;Host Key Verification Startegy\u0026rsquo;도 다음과 같이 바꿔주자.\n id_rsa 의 키가 pass phrase가 제거되어있지 않으면 이 블로그를 참고하자.  그리고 최종적으로 \u0026lsquo;Save\u0026rsquo;하면 다음과 같은 화면이 나온다.\n 참고로 java 경로를 못찾는 오류가 생길 경우 이 글을 참고하자  이렇게 컴포즈를 이용해 마스터/슬레이브로 구성된 젠킨스를 구축했다. 물론 해당 작업에서는 약간의 수작업도 진행하였다. 그렇담면 다음 글에서 설정만으로 도커 구성 관리를 완성할 수 있도록 애플리케이션과 컨테이너를 만들려면 어떻게 해야 하는지 그 기본적인 내용을 알아보겠다.\n참고\n도커/쿠버네티스를 활용한 컨테이너 개발 실전 입문\n","id":12,"section":"posts","summary":"더 자세한 내용은 부디 책을 참고하길 부탁드립니다. 목차 [Docker/도커] 01. 도커의 기초 - 도커란 무엇인가? [Docker/도커] 02. 도커의 기초 - 도커","tags":["Devops"],"title":"[Docker/도커] 07.도커 컨테이너 배포 - 도커 컴포즈로 여러 컨테이너 실행하기","uri":"http://blog.cmstown.com/2020/09/docker_07/","year":"2020"},{"content":"더 자세한 내용은 부디 책을 참고하길 부탁드립니다.\n목차   [Docker/도커] 01. 도커의 기초 - 도커란 무엇인가?\n  [Docker/도커] 02. 도커의 기초 - 도커를 사용하는 의의 / 도커 설치하기\n  [Docker/도커] 03.도커 컨테이너 배포 - 컨테이너로 애플리케이션 실행하기\n  [Docker/도커] 04.도커 컨테이너 배포 - 도커 이미지 다루기\n  [Docker/도커] 05.도커 컨테이너 배포 - 도커 컨테이너 다루기\n  👉 [Docker/도커] 06.도커 컨테이너 배포 - 운영과 관리를 위한 명령 👈\n  [Docker/도커] 07.도커 컨테이너 배포 - 도커 컴포즈로 여러 컨테이너 실행하기\n  [Docker/도커] 08.컨테이너 실전 구축 및 배포\n  \n🐳 06.도커 컨테이너 배포 - 운영과 관리를 위한 명령 🐳 이미지와 컨테이너를 관리하는 명령어들을 앞 글에서 배웠다, 이번에는 도커를 운영하고 관리하기 위한 명령을 알아보자.\nprune - 컨테이너 및 이미지 파기 docker container prune docker container prune 명령은 정지 상태인 모든 컨테이너를 삭제하는 명령이다.\n docker container prune [options]\n $ docker container prune WARNING! This will remove all stopped containers. Are you sure you want to continue? [y/N] y Deleted Containers: cf4675024fa353b0ee411d3eae5f1737ebc3f4d93b766a8a7e2d761e4df39757 2490f2b623a3d80e11cfb4682da14c9f5d79a8cb00c368146c69e1fe80245ee8 192f07f065fe7d97fcd42045461d6f3ba5de57532831dc0b5d952d69c0223ace 26ad2eeed018a9c1aeae0e4f984ee245c7e32b3395035a92d29cd52d46c46229 2273136cd7a0e82771d829d8d0ff3449a575837a79c3340bc03b4f6595e13e10 c37f1e8937ca50be8145d7dc6895acd7f42978c2a36995beaa9e37393c384a36 Total reclaimed space: 21MB  docker image prune docker image prune 명령은 태그가 붙지 않은 모든 이미지를 삭제한다.\n docker image prune [options]\n $ docker image prune WARNING! This will remove all dangling images. Are you sure you want to continue? [y/N] y Total reclaimed space: 0B  현재 삭제된 이미지가 없는데, 이유는 실행 상태인 컨테이너 이미지 등 이유가 있어 도커가 남겨 놓은 것이다.\ndocker system prune 사용하지 않는 도커 이미지 및 컨테이너, 볼륨, 네트워크 등 모든 도커 리소스를 일괄적으로 삭제하고 싶다면 docker system prune 명령을 사용한다.\n#현재 앞에서의 테스트로 image와 container를 이미 지워서 지울 영역이 없다.# $ docker system prune WARNING! This will remove: - all stopped containers - all networks not used by at least one container - all dangling images - all dangling build cache Are you sure you want to continue? [y/N] y Total reclaimed space: 0B  docker container stats - 사용 현황 확인하기 시스템 리소스 사용 현황을 컨테이너 단위로 확인하려면 docker container stats 명령을 사용한다.\n docker container stats [options] [대상_컨테이너ID \u0026hellip;]\n $ docker container stats CONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS 22e874692682 echo 0.00% 8.84MiB / 1.944GiB 0.44% 1.29kB / 0B 0B / 0B 20 32617814466b naughty_kalam 0.00% 8.988MiB / 1.944GiB 0.45% 1.92kB / 0B 0B / 0B 21 4a671813692e inspiring_poitras 0.00% 8.984MiB / 1.944GiB 0.45% 2.73kB / 487B 0B / 0B 20  $ docker container stats 22e87 CONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS 22e874692682 echo 0.00% 8.84MiB / 1.944GiB 0.44% 1.29kB / 0B 0B / 0B 20  참고\n도커/쿠버네티스를 활용한 컨테이너 개발 실전 입문\n","id":13,"section":"posts","summary":"더 자세한 내용은 부디 책을 참고하길 부탁드립니다. 목차 [Docker/도커] 01. 도커의 기초 - 도커란 무엇인가? [Docker/도커] 02. 도커의 기초 - 도커","tags":["Devops"],"title":"[Docker/도커] 06.도커 컨테이너 배포 - 운영과 관리를 위한 명령","uri":"http://blog.cmstown.com/2020/09/docker_06/","year":"2020"},{"content":"더 자세한 내용은 부디 책을 참고하길 부탁드립니다.\n목차   [Docker/도커] 01. 도커의 기초 - 도커란 무엇인가?\n  [Docker/도커] 02. 도커의 기초 - 도커를 사용하는 의의 / 도커 설치하기\n  [Docker/도커] 03.도커 컨테이너 배포 - 컨테이너로 애플리케이션 실행하기\n  [Docker/도커] 04.도커 컨테이너 배포 - 도커 이미지 다루기\n  👉 [Docker/도커] 05.도커 컨테이너 배포 - 도커 컨테이너 다루기 👈\n  [Docker/도커] 06.도커 컨테이너 배포 - 운영과 관리를 위한 명령\n  [Docker/도커] 07.도커 컨테이너 배포 - 도커 컴포즈로 여러 컨테이너 실행하기\n  [Docker/도커] 08.컨테이너 실전 구축 및 배포\n  \n🐳 05.도커 컨테이너 배포 - 도커 컨테이너 다루기 🐳 이번 글에서는 도커 컨테이너를 다루는 방법을 알아보자. 겉에서 본 도커 컨테이너는 가상 환경이다. 파일 시스템과 애플리케이션이 함께 담겨 있는 박스라고 보면 된다. 보다 쉽게 이해하기 위해 도커 명령을 실제 실행해보며 컨테이너에 대해 알아보자.\n도커 컨테이너의 생애주기 도커는 크게 실행 중, 정지, 파기의 3가지 상태를 갖는다. 각 컨테이너는 같은 이미지로 생성했다고 하더라도 별개의 상태를 갖는다.\n실행 중 상태 docker container run 명령 실행 이후 Dockerfile에 포함된 내용이 실행되면 이 애플리케이션이 실행 중인 상태가 컨테이너의 실행 중 상태가 된다.\nHTTP 요청을 받는 서버 애플리케이션임면 오류로 인해 종료되지 않는 한 실행 중 상태가 지속된다. 이에 비해 ㅁ명령이 바로 실행되고 끝나는 명령행 도구 등의 컨테이너는 실행 상태가 길지 않다.\n실행이 끝나면 정지 상태가 된다.\n정지 상태 실행 중 상태에 있는 컨테이너를 사용자가 명시적으로 정지하거나 컨테이너에서 실행된 애플리케이션이 종료 된 경우 자동으로 정지 상태가 된다.\n정지시킨 컨테이너는 다시 실행할 수 있다.(docker container ls -a 명령으로 정지된 컨테이너 확인 가능)\n파기 상태 정지 상태의 컨테이너는 명시적으로 파기하지 않는 이상 디스크에 그대로 남아 있다. 그러기에 명시적으로 파기를 해야 파기 상태가 된다.\ndocker container run - 컨테이너 생성 및 실행 docker container run 명령은 도커 이미지로부터 컨테이너를 생성하고 실행하는 명령이다.\n docker container run [options] 이미지명[:태그] [명령] [명령인자\u0026hellip;]\n  docker container run [options] 이미지ID [명령] [명령인자\u0026hellip;]\n 그 동안 앞에서 사용했던 예제를 다시 사용하면 다음과 같다.\n$ docker container run -d -p 9001:8080 chlalstjd430/echo:latest 0f6830630de986faa6955f808bff6e7e408179c7a157209d1f5902a4aaff5669  docker contatainer run 옵션 -d 백그라운드 실행을 위한 명령\n-p 포트 포워딩을 위해 사용한다.\n-e 컨테이너 내에서 사용할 환경변수 설정\n-it -i 와 -t 명령을 합친 것으로 실행된 bash shell에 입/출력 가능\n\u0026ndash;name 컨테이너에 대한 이름을 설정. 따로 정의하지 않으면 자동으로 유명 과학자나 해커들의 이름을 조합하여 생성된다.\n–rm 프로세스 종료시 컨테이너 자동 제거\n-v 호스트와 컨테이너 간에 디렉터리나 파일을 공유하기 위해 사용하는 옵션\ndocker container ls - 도커 컨테이너 목록 보기 docker container ls 명령은 컨테이너 목록을 보여주는 명령이다.\n docker container ls [options]\n $ docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 0f6830630de9 chlalstjd430/echo:latest \u0026quot;go run /echo/main.go\u0026quot; 36 minutes ago Up 36 minutes 0.0.0.0:9001-\u0026gt;8080/tcp nice_noether 32617814466b example/echo:latest \u0026quot;go run /echo/main.go\u0026quot; 8 hours ago Up 8 hours 0.0.0.0:32768-\u0026gt;8080/tcp naughty_kalam 4a671813692e example/echo:latest \u0026quot;go run /echo/main.go\u0026quot; 8 hours ago Up 8 hours 0.0.0.0:9000-\u0026gt;8080/tcp inspiring_poitras  docker container ls 명령 수행시 위와 같이 나오는데, 각 항목의 의미는 다음과 같다.\n   항목 내용     CONTAINER_ID 컨테이너를 식별하기 위한 유일한 식별자   IMAGE 컨테이너를 만드는 데 사용된 도커 이미지   COMMAND 컨테이너에서 실행되는 애플리케이션 프로세스   CREATED 컨테이너 생성 후 경과된 시간   STATUS Up(실행 중), Exited(종료) 등 컨테이너의 실행 상태   PORTS 호스트 포트와 컨테이너 포트의 연결 관계(포트 포워딩)   NAMES 컨테이너의 이름    컨테이너 ID만 추출하기 $ docker container ls -q 0f6830630de9 32617814466b 4a671813692e  컨테이너 목록 필터링하기  docker container ls \u0026ndash;filter \u0026ldquo;필터명=값\u0026rdquo;\n 이미지로 릴터링\n$ docker container ls --filter \u0026quot;ancestor=chlalstjd430/echo\u0026quot; CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 0f6830630de9 chlalstjd430/echo:latest \u0026quot;go run /echo/main.go\u0026quot; 44 minutes ago Up 44 minutes 0.0.0.0:9001-\u0026gt;8080/tcp nice_noether 32617814466b example/echo:latest \u0026quot;go run /echo/main.go\u0026quot; 8 hours ago Up 8 hours 0.0.0.0:32768-\u0026gt;8080/tcp naughty_kalam 4a671813692e example/echo:latest \u0026quot;go run /echo/main.go\u0026quot; 9 hours ago Up 9 hours 0.0.0.0:9000-\u0026gt;8080/tcp inspiring_poitras  이름으로 필터링\n$ docker container ls --filter \u0026quot;name=nice\u0026quot; CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 0f6830630de9 chlalstjd430/echo:latest \u0026quot;go run /echo/main.go\u0026quot; 45 minutes ago Up 45 minutes 0.0.0.0:9001-\u0026gt;8080/tcp nice_noether  종료된 컨테이너 보기 -a 옵션을 사용하면 이미 종료된 컨테이너를 포함한 컨테이너 목록을 볼 수 있다.\n$ docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 0f6830630de9 chlalstjd430/echo:latest \u0026quot;go run /echo/main.go\u0026quot; 46 minutes ago Up 46 minutes 0.0.0.0:9001-\u0026gt;8080/tcp nice_noether cf4675024fa3 chlalstjd430/echo:latest \u0026quot;go run /echo/main.go\u0026quot; 46 minutes ago Created compassionate_davinci 32617814466b example/echo:latest \u0026quot;go run /echo/main.go\u0026quot; 8 hours ago Up 8 hours 0.0.0.0:32768-\u0026gt;8080/tcp naughty_kalam 4a671813692e example/echo:latest \u0026quot;go run /echo/main.go\u0026quot; 9 hours ago Up 9 hours 0.0.0.0:9000-\u0026gt;8080/tcp inspiring_poitras 2490f2b623a3 example/echo \u0026quot;go run /echo/main.go\u0026quot; 9 hours ago Exited (2) 9 hours ago romantic_boyd 192f07f065fe example/echo \u0026quot;go run /echo/main.go\u0026quot; 11 hours ago Exited (2) 9 hours ago lucid_mendeleev  docker container stop - 컨테이너 정지하기  docker container stop 컨테이너ID_또는_컨테이너명\n $ docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 0f6830630de9 chlalstjd430/echo:latest \u0026quot;go run /echo/main.go\u0026quot; 46 minutes ago Up 46 minutes 0.0.0.0:9001-\u0026gt;8080/tcp nice_noether  $ docker container stop 0f68 0f68  choeminseong-ui-MacBook-Pro:~ choeminseong$ docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 0f6830630de9 chlalstjd430/echo:latest \u0026quot;go run /echo/main.go\u0026quot; 48 minutes ago Exited (2) 17 seconds ago nice_noether  컨테이너ID로 종료할 떄 컨테이너ID 전체값을 입력하지 않고 앞부분의 일부만 입력해도 해당 컨테이너ID와 일치하는 것을 찾아 종료해준다.\ndocker container restart - 컨테이너 재시작하기  docker container restart 컨테이너ID_또는_컨테이너명\n docker container rm - 컨테이너 파기하기  docker container rm 컨테이너ID_또는_컨테인어명\n $ docker container rm nice_noether nice_noether  -f 현재 실행중인 컨테이너 삭제시 사용하는 옵션\n docker container rm -f 컨테이너ID_또는_컨테이너명\n docker container logs - 표준 출력 연결하기 docker container logs 명령을 사용하면 현재 실행 중인 특정 도커 컨테이너의 표준 출력 내용을 확인할 수 있다.\n docker container logs [options] 컨테이너ID_또는_컨테이너명\n $ docker container logs 3261 2020/09/05 07:04:55 start server  -f -f 옵션을 사용하면 새로 출력되는 표준 출력 내용을 계속 보여준다.\ndocker container exec - 실행 중인 컨테이너에서 명령 실행하기 docker container exec 명령을 사용하면 실행 중인 컨테이너에서 원하는 명령을 실행할 수 있다.\n docker container exec [options] 컨테이너ID_또는_컨테이너명 컨테이너에서_실행할_명령\n $ docker container run -t -d --name echo --rm example/echo:latest 22e874692682876b000b974029a695bc628dc7efbb3ed8f8e72b36588bc98c8d $ docker container exec echo pwd /go  docker container cp - 파일 복사하기 docker container cp 명령은 컨테이너끼리 혹은 컨테이너와 호스트 간에 파일을 복사하기 위한 명령이다. Dockerfile에 포함된 COPY 인스트럭션은 이미지를 빌드할 떄 호스트에서 복사해 올 파일을 정의하기 위한 것이고, docker container cp 명령은 실행 중인 컨테이너와 파일을 주고받기 위한 것이다.\n docker container cp [options] 컨테이너ID_또는_컨테이너명:원본파일 대상파일\n  docker container cp [options 호스트_원본_파일 컨테이너ID_또는_컨테이너명:대상파일]\n $ docker container cp echo:/echo/main.go  참고\n도커/쿠버네티스를 활용한 컨테이너 개발 실전 입문\n","id":14,"section":"posts","summary":"더 자세한 내용은 부디 책을 참고하길 부탁드립니다. 목차 [Docker/도커] 01. 도커의 기초 - 도커란 무엇인가? [Docker/도커] 02. 도커의 기초 - 도커","tags":["Devops"],"title":"[Docker/도커] 05.도커 컨테이너 배포 - 도커 컨테이너 다루기","uri":"http://blog.cmstown.com/2020/09/docker_05/","year":"2020"},{"content":"더 자세한 내용은 부디 책을 참고하길 부탁드립니다.\n목차   [Docker/도커] 01. 도커의 기초 - 도커란 무엇인가?\n  [Docker/도커] 02. 도커의 기초 - 도커를 사용하는 의의 / 도커 설치하기\n  [Docker/도커] 03.도커 컨테이너 배포 - 컨테이너로 애플리케이션 실행하기\n  👉 [Docker/도커] 04.도커 컨테이너 배포 - 도커 이미지 다루기 👈\n  [Docker/도커] 05.도커 컨테이너 배포 - 도커 컨테이너 다루기\n  [Docker/도커] 06.도커 컨테이너 배포 - 운영과 관리를 위한 명령\n  [Docker/도커] 07.도커 컨테이너 배포 - 도커 컴포즈로 여러 컨테이너 실행하기\n  [Docker/도커] 08.컨테이너 실전 구축 및 배포\n  \n🐳 04.도커 컨테이너 배포 - 도커 이미지 다루기 🐳 도커 사용법은 크게 이미지를 대상으로 하는 것과 컨테이너를 대상으로 하는 것읕로 나눈다. 이번 글에서는 이미지를 다루는 법에 대해 먼저 알아보자.\n\n도커 이미지 먼저 도커가 무엇인지 알아보자.\n도커 이미지는 쉽게 말하면 도커 컨테이너를 만들기 위한 템플릿이다.\n도커 이미지는 운영 체제로 구성된 파일 시스템은 물론, 라이브러리, 샐행 환경 등을 포함하는 아카이브다. 이번 글에서는 이미지를 빌드하는 명령어부터 시작해 이미지를 다루는 기본 명령을 살펴볼 것이다. 그리고 마지막으로 도커 허브에 이미지를 등록하는 과정까지 수행하여 다른 사람이 이용할 수 있게 하는 단계를 목표로 한다.\n추가적으로 설명에서 부족한 명령들은 \u0026ldquo;$ docker help\u0026rdquo; 키워드를 이용하여 자세히 살펴 보기를 바란다.\ndocker help 예시\n$ docker help Usage:\tdocker [OPTIONS] COMMAND A self-sufficient runtime for containers Options: --config string Location of client config files (default \u0026quot;/Users/choeminseong/.docker\u0026quot;) -c, --context string Name of the context to use to connect to the daemon (overrides DOCKER_HOST env var and default context set with \u0026quot;docker context use\u0026quot;) -D, --debug Enable debug mode -H, --host list Daemon socket(s) to connect to -l, --log-level string Set the logging level (\u0026quot;debug\u0026quot;|\u0026quot;info\u0026quot;|\u0026quot;warn\u0026quot;|\u0026quot;error\u0026quot;|\u0026quot;fatal\u0026quot;) (default \u0026quot;info\u0026quot;) --tls Use TLS; implied by --tlsverify --tlscacert string Trust certs signed only by this CA (default \u0026quot;/Users/choeminseong/.docker/ca.pem\u0026quot;) --tlscert string Path to TLS certificate file (default \u0026quot;/Users/choeminseong/.docker/cert.pem\u0026quot;) --tlskey string Path to TLS key file (default \u0026quot;/Users/choeminseong/.docker/key.pem\u0026quot;) --tlsverify Use TLS and verify the remote -v, --version Print version information and quit Management Commands: builder Manage builds config Manage Docker configs container Manage containers context Manage contexts image Manage images network Manage networks node Manage Swarm nodes plugin Manage plugins secret Manage Docker secrets service Manage services stack Manage Docker stacks swarm Manage Swarm system Manage Docker trust Manage trust on Docker images volume Manage volumes Commands: attach Attach local standard input, output, and error streams to a running container build Build an image from a Dockerfile commit Create a new image from a container's changes cp Copy files/folders between a container and the local filesystem create Create a new container diff Inspect changes to files or directories on a container's filesystem events Get real time events from the server exec Run a command in a running container export Export a container's filesystem as a tar archive history Show the history of an image images List images import Import the contents from a tarball to create a filesystem image info Display system-wide information inspect Return low-level information on Docker objects kill Kill one or more running containers load Load an image from a tar archive or STDIN login Log in to a Docker registry logout Log out from a Docker registry logs Fetch the logs of a container pause Pause all processes within one or more containers port List port mappings or a specific mapping for the container ps List containers pull Pull an image or a repository from a registry push Push an image or a repository to a registry rename Rename a container restart Restart one or more containers rm Remove one or more containers rmi Remove one or more images run Run a command in a new container save Save one or more images to a tar archive (streamed to STDOUT by default) search Search the Docker Hub for images start Start one or more stopped containers stats Display a live stream of container(s) resource usage statistics stop Stop one or more running containers tag Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE top Display the running processes of a container unpause Unpause all processes within one or more containers update Update configuration of one or more containers version Show the Docker version information wait Block until one or more containers stop, then print their exit codes Run 'docker COMMAND --help' for more information on a command.  $ docker image --help Usage:\tdocker image COMMAND Manage images Commands: build Build an image from a Dockerfile history Show the history of an image import Import the contents from a tarball to create a filesystem image inspect Display detailed information on one or more images load Load an image from a tar archive or STDIN ls List images prune Remove unused images pull Pull an image or a repository from a registry push Push an image or a repository to a registry rm Remove one or more images save Save one or more images to a tar archive (streamed to STDOUT by default) tag Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE Run 'docker image COMMAND --help' for more information on a command.  $ docker image build --help Usage:\tdocker image build [OPTIONS] PATH | URL | - Build an image from a Dockerfile Options: --add-host list Add a custom host-to-IP mapping (host:ip) --build-arg list Set build-time variables --cache-from strings Images to consider as cache sources --cgroup-parent string Optional parent cgroup for the container --compress Compress the build context using gzip --cpu-period int Limit the CPU CFS (Completely Fair Scheduler) period --cpu-quota int Limit the CPU CFS (Completely Fair Scheduler) quota -c, --cpu-shares int CPU shares (relative weight) --cpuset-cpus string CPUs in which to allow execution (0-3, 0,1) --cpuset-mems string MEMs in which to allow execution (0-3, 0,1) --disable-content-trust Skip image verification (default true) -f, --file string Name of the Dockerfile (Default is 'PATH/Dockerfile') --force-rm Always remove intermediate containers --iidfile string Write the image ID to the file --isolation string Container isolation technology --label list Set metadata for an image -m, --memory bytes Memory limit --memory-swap bytes Swap limit equal to memory plus swap: '-1' to enable unlimited swap --network string Set the networking mode for the RUN instructions during build (default \u0026quot;default\u0026quot;) --no-cache Do not use cache when building the image -o, --output stringArray Output destination (format: type=local,dest=path) --platform string Set platform if server is multi-platform capable --progress string Set type of progress output (auto, plain, tty). Use plain to show container output (default \u0026quot;auto\u0026quot;) --pull Always attempt to pull a newer version of the image -q, --quiet Suppress the build output and print image ID on success --rm Remove intermediate containers after a successful build (default true) --secret stringArray Secret file to expose to the build (only if BuildKit enabled): id=mysecret,src=/local/secret --security-opt strings Security options --shm-size bytes Size of /dev/shm --squash Squash newly built layers into a single new layer --ssh stringArray SSH agent socket or keys to expose to the build (only if BuildKit enabled) (format: default|\u0026lt;id\u0026gt;[=\u0026lt;socket\u0026gt;|\u0026lt;key\u0026gt;[,\u0026lt;key\u0026gt;]]) --stream Stream attaches to server to negotiate build context -t, --tag list Name and optionally a tag in the 'name:tag' format --target string Set the target build stage to build. --ulimit ulimit Ulimit options (default [])  \ndocker image build - 이미지 빌드 docker image build는 Dockerfile에 기술된 구성을 따라 도커 이미지를 생성하는 명령어이다.\ndocker image build -t 이미지명[:태그명] Dockerfile의_경로  Dockerfile의_경로 Dockerfile의 경로는 말 그대로 Dockerfile의 경로를 적어주면 된다. 만약 현재 작업 디렉토리에 있다면 그대로\ndocker image build -t examplet/echo:latest  위와 같은 식으로 경로를 생략하고 명령어를 작성하면 된다.\n-t 옵션 -t 옵션은 이미지명과 태그명을 붙이는 것으로, 실제 사용에서 거의 필수적으로 쓰인다.\n-f 옵션 docker image build 명령은 기본으로 Dockerfile이라는 이름으로 된 Dokcerfile을 찾는다. 그 외 파일명으로 찾고자하는 경우 다음과 같이 -f 옵션을 사용해야 한다.\n$ docker image build -f Dockerfile-test -t example/echo:latest  \u0026ndash;pull 옵션 docker image build 영역으로 이미지를 빌드하려면 Dockerfile의 FROM 인스트럭션에 지정한 이미지를 레지스트리에서 내려받은 후, 이를 베이스 이미지로 해서 새로운 이미지를 빌드한다.\n이렇게 레지스트리에서 받아온 도커 이미지는 일부로 삭제하지 않는 한 호스트 운영 체제에 저장된다. 그러므로 이미지를 빌드할 떄 매번 베이스 이미지를 받아오지 않는다. 그러나 \u0026ndash;pull 옵션을 사용하면 매번 베이스 이미지를 새로 받아온다.\n$ docker image build --pull=true -t example/echo:latest  docker search - 이미지 검색 도커 허브는 도커 이미지 레지스트리로, 마치 깃허브처럼 사용자나 조직 이름으로 리포지토리를 만들 수 있다. 그리고 이 리포지토리를 사용해 도커 이미지를 관리한다. 또한 도커 허브에는 모든 이미지의 기반이 되는 운영 체제, 언어 런타임, 미들웨어 등이 관리되는 수많은 리포지토리가 있어 쉽게 만들어져있는 이미지를 사용할 수 있다.\n이런 도커 허브를 활용 할 떄 docker search 명령을 사용하면 도커 허브에 등록된 리포지토리를 검색할 수 있다.\ndocker search [options] 검색_키워드  \u0026ndash;limit 옵션으로 최대 검색 건수를 5개 제한하여, \u0026ldquo;mysql\u0026quot;을 검색해보면 다음과 같다.\n$ docker search --limit 5 mysql NAME DESCRIPTION STARS OFFICIAL AUTOMATED mysql MySQL is a widely used, open-source relation… 9928 [OK] mysql/mysql-server Optimized MySQL Server Docker images. Create… 723 [OK] mysql/mysql-cluster Experimental MySQL Cluster Docker images. Cr… 75 bitnami/mysql Bitnami MySQL Docker Image 44 [OK] circleci/mysql MySQL is a widely used, open-source relation… 19  검색 결과는 start 순서이고, 공식 리포지토리의 네임스페이스는 보는 바와 같이 생략이 가능하다.\ndocker search 명령으로 리포지토리는 검색할 수 있지만, 이 리포지토리가 관리하는 도커 이미지 태그까지는 검색이 불가능하다. 만약 리포지토리에 공개된 이미지의 태그를 알고 싶다면 도커 허브의 해당 리포지토리 페이지에서 Tags를 보는 방법이나 다음과 같이 API를 사용해도 좋다(API 사용시 jq 사용시 별도 설치).\nchoeminseong-ui-MacBook-Pro:~ choeminseong$ curl -s 'https:/hub.docker.com/v2/repositories/library/mysql/tags/?page_size=10' | jq -r '.results[].name' latest 8.0.21 8.0 8 5.7.31 5.7 5.6.49 5.6 5 8.0.20  docker image pull - 이미지 내려받기 도커 레지스트리에서 도커 이미지를 내려받으려면 docker image pull 명령을 사용한다.\ndocker image pull [options] 리포지토리명[:태그명]  $ docker image pull jenkins:latest latest: Pulling from library/jenkins 55cbf04beb70: Already exists 1607093a898c: Already exists 9a8ea045c926: Already exists d4eee24d4dac: Already exists c58988e753d7: Pull complete 794a04897db9: Pull complete 70fcfa476f73: Pull complete 0539c80a02be: Pull complete 54fefc6dcf80: Pull complete 911bc90e47a8: Pull complete 38430d93efed: Pull complete 7e46ccda148a: Pull complete c0cbcb5ac747: Pull complete 35ade7a86a8e: Pull complete aa433a6a56b1: Pull complete 841c1dd38d62: Pull complete b865dcb08714: Pull complete 5a3779030005: Pull complete 12b47c68955c: Pull complete 1322ea3e7bfd: Pull complete Digest: sha256:eeb4850eb65f2d92500e421b430ed1ec58a7ac909e91f518926e02473904f668 Status: Downloaded newer image for jenkins:latest docker.io/library/jenkins:latest  docker image ls - 보유한 도커 이미지 목록 보기 docker image ls 명령은 현재 호스트 운영 체제에 저장된 도커 이미지의 목록을 보여준다.\n$ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE example/echo latest 4aa00bbd35bd 17 hours ago 750MB jenkins latest cd14cecfdb3a 2 years ago 696MB golang 1.9 ef89ef5c42a9 2 years ago 750MB gihyodocker/echo latest 3dbbae6eb30d 2 years ago 733MB애  docker image tag - 이미지에 태그 붙이기 docker image tag는 도커 이미지의 특정 버전에 태그를 붙일 때 사용한다.\ndocker image tag 기반이미지명[:태그] 새이미지명[:태그]  예를 들어 example/echo의 latest 이미지에 0.1.0 태그를 부여하려면 다음과 같이 부여하면 된다.\n$ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE example/echo latest 4aa00bbd35bd 17 hours ago 750MB $ docker image tag example/echo:latest example/echo:0.1.0 $ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE example/echo 0.1.0 4aa00bbd35bd 17 hours ago 750MB example/echo latest 4aa00bbd35bd 17 hours ago 750MB  docker image push - 이미지를 외부에 공개하기 docker iamge push 명령은 현재 저장된 도커 이미지를 도커 허브 등의 레지스트리에 등록하기 위해 사용한다.\ndocker image push [options] 리포지토리명[:태그]  먼저 push를 위해서 docker에 로그인(회원가입이 안되어있다면 회원가입부터 해주자)을 해줘야한다. 로그인이 완료됬다면, 기존에 example/echo:latest 이미지를 [자신의계정ID]/echo:latest로 tag를 이용해 변경해주고 push해보자.\n$ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE example/echo 0.1.0 4aa00bbd35bd 17 hours ago 750MB example/echo latest 4aa00bbd35bd 17 hours ago 750MB $ docker image tag example/echo:latest chlalstjd430/echo:latest choeminseong-ui-MacBook-Pro:~ choeminseong$ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE chlalstjd430/echo latest 4aa00bbd35bd 17 hours ago 750MB example/echo 0.1.0 4aa00bbd35bd 17 hours ago 750MB example/echo latest 4aa00bbd35bd 17 hours ago 750MB $ docker image push chlalstjd430/echo:latest The push refers to repository [docker.io/chlalstjd430/echo] a6d7b9e2aac4: Pushed 4174db7ef66f: Pushed 186d94bd2c62: Mounted from library/golang 24a9d20e5bee: Mounted from library/golang e7dc337030ba: Mounted from library/golang 920961b94eb3: Mounted from library/golang fa0c3f992cbd: Mounted from library/jenkins ce6466f43b11: Mounted from library/jenkins 719d45669b35: Mounted from library/jenkins 3b10514a95be: Mounted from library/jenkins latest: digest: sha256:27fd43220bf04164667592c276235640dd69175c1d54381f16415318c946d07a size: 2418  이후 docker hub에 접속해 로그인하면 다음과 같이 레파지토리가 생긴걸 알 수 있다.\n이로써 docker image를 다루는 기본 문법들을 살펴보았다. 더 자세한 문법을 직접 살펴보기를 권장드리며 이번 포스팅을 마치도록하겠다.\n참고\n도커/쿠버네티스를 활용한 컨테이너 개발 실전 입문\n","id":15,"section":"posts","summary":"더 자세한 내용은 부디 책을 참고하길 부탁드립니다. 목차 [Docker/도커] 01. 도커의 기초 - 도커란 무엇인가? [Docker/도커] 02. 도커의 기초 - 도커","tags":["Devops"],"title":"[Docker/도커] 04.도커 컨테이너 배포 - 도커 이미지 다루기","uri":"http://blog.cmstown.com/2020/09/docker_04/","year":"2020"},{"content":"더 자세한 내용은 부디 책을 참고하길 부탁드립니다.\n목차   [Docker/도커] 01. 도커의 기초 - 도커란 무엇인가?\n  [Docker/도커] 02. 도커의 기초 - 도커를 사용하는 의의 / 도커 설치하기\n  👉 [Docker/도커] 03.도커 컨테이너 배포 - 컨테이너로 애플리케이션 실행하기 👈\n  [Docker/도커] 04.도커 컨테이너 배포 - 도커 이미지 다루기\n  [Docker/도커] 05.도커 컨테이너 배포 - 도커 컨테이너 다루기\n  [Docker/도커] 06.도커 컨테이너 배포 - 운영과 관리를 위한 명령\n  [Docker/도커] 07.도커 컨테이너 배포 - 도커 컴포즈로 여러 컨테이너 실행하기\n  [Docker/도커] 08.컨테이너 실전 구축 및 배포\n  \n🐳 03.도커 컨테이너 배포 - 컨테이너로 애플리케이션 실행하기 🐳 도커의 기본 개념과 의의를 알아보았으니 도커의 기본 조작 방법을 배우고 애플리케이션을 배포하는 과정까지 알아보자.\n먼저 도커 이미지와 도커 컨테이너의 관계를 이해하자.\n  도커 이미지\n 도커 컨테이너를 구성하는 파일 시스템과 실행할 애플리케이션 설정을 하나로 합친 것으로 컨테이너를 생성하는 템플릿 역할을 한다.\n   도커 컨테이너\n 도커 이미지를 기반으로 생성되며, 파일 시스템과 애플리케이션이 구체화 돼 실행되는 상태이다.\n   도커 이미지 하나로 여러 개의 컨테이너를 생성할 수 있다.\n한번 실제로 도커 이미지로 도커 컨테이너를 만드는 과정을 살펴보자. 먼저 gihyodocker/echo:latest라는 도커 이미지를 받아온다. docker image pull 명령으로 받을 수 있고 터미널에 다음과 같이 작성한다.\n$ docker image pull gihyodocker/echo:latest latest: Pulling from gihyodocker/echo 723254a2c089: Pull complete abe15a44e12f: Pull complete 409a28e3cc3d: Pull complete 503166935590: Pull complete abe52c89597f: Pull complete ce145c5cf4da: Pull complete 96e333289084: Pull complete 39cd5f38ffb8: Pull complete 22860d04f4f1: Pull complete 7528760e0a03: Pull complete Digest: sha256:4520b6a66d2659dea2f8be5245eafd5434c954485c6c1ac882c56927fe4cec84 Status: Downloaded newer image for gihyodocker/echo:latest docker.io/gihyodocker/echo:latest  내려받은 이미지를 docker container run 명령으로 다음과 같이 실행한다. -t/-p 옵션에는 나중에 다루도록 할태니 일단 현재 명령어의 동작을 확인하자.\n$ docker container run -t -p 9000:8080 gihyodocker/echo:latest 2020/09/04 12:47:02 start server  지금 만든 컨테이너는 옵션을 통해 포트 포워딩이 적용돼 있다. 도커 실행 환경의 포트 9000을 거쳐 HTTP 요청을 전달받는다.\n이후 터미널에 \u0026ldquo;curl http://localhost:9000/\u0026rdquo; 을 입력하거나 해당 주소를 브라우저를 통해 접속해보면 \u0026ldquo;Hello World!\u0026ldquo;라는 문장을 볼 수 있다.\n\n간단한 애플리케이션과 도커 이미지 만들기 도커 컨테이너를 어떻게 만들고 실행하는지에 대한 감을 잡기 위해 Go 언어로 만든 간단한 웹 서버를 도커 컨테이너에서 실행해 보자.\nmain.go라는 파일에 다음 코드를 작성한다.\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;log\u0026quot; \u0026quot;net/http\u0026quot; ) func main() { http.HandleFunc(\u0026quot;/\u0026quot;, func(w http.ResponseWriter, r * http.Request) { log.Println(\u0026quot;received request\u0026quot;) fmt.Fprintf(w, \u0026quot;Hello Docker!!\u0026quot;) }) log.Println(\u0026quot;start server\u0026quot;) server := \u0026amp;http.Server {Addr: \u0026quot;:8080\u0026quot;} if err := server.ListenAndServe(); err != nil { log.Println(err) } }  위 코드는 간단한 서버 애플리케이션으로 다음과 같은 기능을 갖는다.\n  모든 HTTP 요청에 대해 \u0026ldquo;Hello Docker!\u0026ldquo;라는 응답을 보낸다.\n  포트 8080로 요청을 받는 서버 애플리케이션으로 동작한다.\n  클라이언트로부터 요청을 받으면 received request라는 메시지를 표준으로 출력한다.\n  이 Go 언어 코드를 도커 컨테이너에 배치한다. main.go 파일을 포함하는 새로운 도커 이미지를 만드는 것이다. 이를 위해 main.go파일과 같은 디렉터리에 Dockerfile을 다음과 같이 작성한다.\nFROM golan:1.9 RUN mkdir /echo COPY main.go /echo CMD [\u0026quot;go\u0026quot;, \u0026quot;run\u0026quot;, \u0026quot;/echo/main.go\u0026quot;]  여기서 사용된 FROM, RUN 같은 키워드를 인스트럭션(명령)이라고 한다.\n인스트럭션은 여러 가지 있으나, 기본적인 것부터 살펴보자.\nFROM FROM 인스트럭션은 도커 이미지의 바탕이 될 베이스 이미지를 지정한다. Dockerfile로 이미지를 빌드할 떄 먼저 FROM 인스트럭션에 지정된 이미지를 내려받는다.\nFROM에서 받아오는 도커 이미지는 도커 허브(Docker Hub)라는 레지스트리에 공개된 것이다. 도커는 FROM에서 지정한 이미지를 기본적으로 도커 허브 레지스트리에서 참조한다.\n1.9라고 된 부분은 태그라고 한다. 각 이미지의 버전등을 구별하는 식별자이다.\nRUN RUN 인스트럭션은 도커 이미지를 실행할 때 컨테이너 안에서 실행할 명령을 정의하는 인스트럭션이다. 인자로 도커 컨테이너 안에서 실행할 명령을 그대로 기술한다.\nCOPY COPY 인스트럭션은 도커가 동작 중인 호스트 머신의 파일이나 디렉토리를 도커 컨테이너 안으로 복사하는 인스트럭션이다.\n위 예제에서는 호스트에서 작성한 main.go 파일을 도커 컨테이너 안에서 실행할 수 있도록 컨테이너 안으로 복사하는 데 이 인스트럭션을 사용했다.\nCMD CMD 인스트럭션은 도커 컨테이너를 실행할 떄 컨테이너 안에서 실행할 프로세스를 지정한다. RUN은 애플리케이션 업데이트 및 배치에, CMD는 애플리케이션 자체를 실행하는 명령어라고 이해하면 된다.\n즉, 셀 스크립트로 치면 다음과 같다.\n$ go run /echo/main.go  위 명령을 CMD 인스트럭션에 기술하면 다음가 같이 명령을 공백으로 나눈 배열로 나타낸다.\nCMD [\u0026quot;go\u0026quot;, \u0026quot;run\u0026quot;, \u0026quot;/echo/main.go\u0026quot;]  \n도커 이미지 빌드하기 이제 위 파일을 작성했으면 docker image build 명령으로 도커 이미지를 빌드한다.\ndocker image build 명령은 도커 이미지를 빌드하기 위한 명령이다. docker image build 명령의 기본 문법은 다음과 같다.\n-t 옵션으로 이미지명을 지정한다. 태그명도 지정할수 있으며, 생략 시에는 latest 태그가 붙는다.\n-t 옵션으로 이미지명은 반드시 지정해야 한다고 생각하는 편이 좋다. 물론 작성하지 않아도 빌드 자체는 가능하다. 다만, 이미지명 없이는 해시값만으로 이미지를 구별해야 하므로 사용하기가 상당히 번거롭다.\ndocker image build -t 이미지명[:태그명] Dockerfile의_경로  그럼 다음과 같이 도커 이미지를 빌드 해보자.\ncd Dockerfile의_경로 docker image build -t example/echo:latest . Sending build context to Docker daemon 3.072kB Step 1/4 : FROM golang:1.9 1.9: Pulling from library/golang 55cbf04beb70: Pull complete 1607093a898c: Pull complete 9a8ea045c926: Pull complete d4eee24d4dac: Pull complete 9c35c9787a2f: Pull complete 8b376bbb244f: Pull complete 0d4eafcc732a: Pull complete 186b06a99029: Pull complete Digest: sha256:8b5968585131604a92af02f5690713efadf029cc8dad53f79280b87a80eb1354 Status: Downloaded newer image for golang:1.9 ---\u0026gt; ef89ef5c42a9 Step 2/4 : RUN mkdir /echo ---\u0026gt; Running in c4b677a54953 Removing intermediate container c4b677a54953 ---\u0026gt; d59e0db45149 Step 3/4 : COPY main.go /echo ---\u0026gt; a6bbddf2dfa0 Step 4/4 : CMD [\u0026quot;go\u0026quot;, \u0026quot;run\u0026quot;, \u0026quot;/echo/main.go\u0026quot;] ---\u0026gt; Running in 160bd2760fe8 Removing intermediate container 160bd2760fe8 ---\u0026gt; 2c23be37add6 Successfully built 2c23be37add6 Successfully tagged example/echo:latest  위와 같이 step에 따라 인스트럭션을 수행하고 성공한 것을 확인할 수 있다. 그리고 위에 이미지명에 \u0026lsquo;/\u0026lsquo;가 추가되었는데, 이는 이미지명의 충돌을 피하기 위해 추가된 네임스페이스이다. 가급적이면 네임스페이스를 활용하여 이미지명의 충돌을 예방하자.\ndocker image ls 명령어로 이미지의 **REPOSITORY , TAG, IMAGE ID, CREATED, SIZE 값 등을 확인할 수 있다.\n$ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE example/echo latest 2c23be37add6 2 minutes ago 750MB golang 1.9 ef89ef5c42a9 2 years ago 750MB gihyodocker/echo latest 3dbbae6eb30d 2 years ago 733MB  \n도커 컨테이너 실행 이미지를 생성했으니 docker container run 명령으로 컨테이너를 실행해 보겠다. 정상적으로 실행이 되면 \u0026lsquo;start sever\u0026rsquo;라는 로그가 다음과 같이 출력될 것이다.\nchoeminseong-ui-MacBook-Pro:01.test_go choeminseong$ docker container run example/echo 2020/09/04 17:49:01 start server  이후 컨테이너를 종료하고 싶다면 \u0026lsquo;Ctrl+C\u0026rsquo;를 입력하면된다.\n포트 포워딩 서버가 정상적으로 실행되었으니 로컬 환경에서 curl 명령어를 이용하여 get 요청을 8080포트에 보내보겠다.\nchoeminseong-ui-MacBook-Pro:~ choeminseong$ curl http://localhost:8080/ curl: (7) Failed to connect to localhost port 8080: Connection refused  그러면 위와 같이 Connection이 거절되었다는 문구가 나온다. 이것만 보면 애플리케이션이 리스닝하는 포트는 로컬 환경의 포트 8080이 아닌 것 같다. 이 지점에도 도커만의 특징이 있다.\n도커 컨테이너는 가상 환경이지만, 외부에서 봤을 때 독립된 하나의 머신처럼 다룰 수 있다는 특징이 있다. echo 애플리케이션은 8080 포트를 리스닝하고 있지만, 이 포트는 컨테이너 포트라고 해서 컨테이너에 한정된 포트다. 즉, curl은 컨테이너 안에서 실행해야 올바른 응답을 받을 수 있다는 것이다.\n이처럼 HTTP 요청을 받는 애플리케이션을 사용하려면 컨테이너 밖에서 온 요청을 컨테이너 안에 있는 애플리케이션에 전달해줘야 한다. 그 역할을 담당하는 것이 바로 도커의 포트 포워딩 이다.\n포트 포워딩을 사용하기 전에 앞서 실행한 컨테이너를 다음과 같이 정지시킨다.\nstop $(docker container ls --filter \u0026quot;ancestor=example/echo\u0026quot; -q)  docker container run 명령어에 -p 옵션을 붙이면 포트 포워딩을 지정할 수 있다. -p 옵션값은 호스트_포트:컨테이너_포트 형식으로 기술하면 된다. 그러면 호스트 포트 9000을 컨테이너 포트 8080에 연결하도록 포트 포워딩을 적용하고 curl 명령어를 실행해보자.\n$ docker container run -d -p 9000:8080 example/echo:latest 4a671813692ecc6bd7b4b3d0fb8f62e8bd4e8150ce8486611d578e58ff67ed22 $ curl http://localhost:9000/ Hello Docker!!  이제는 \u0026ldquo;Hello Docker!!\u0026ldquo;이라는 문장을 잘 받은걸 확인할 수 있다.\n이렇게 해서 도커 이미지 생성, 컨테이너 실행, 포트 포워딩까지 도커의 기본 사용법을 알아봤다.\n추가적으로 다음과 같이 호스트 포트를 생략할 수 있다.\n$ docker container run -d -p 8080 example/echo:latest  이럴 경우 \u0026ldquo;docker container ls\u0026rdquo; 명령어를 이용해 어떤 포트가 할당됐는지 알 수 있다.\n$ docker container run -d -p 8080 example/echo:latest 32617814466b39ee37d7a29ce8a0e615409825efa69f73d2c929dd68fbbb23e6 $ docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 32617814466b example/echo:latest \u0026quot;go run /echo/main.go\u0026quot; 6 seconds ago Up 6 seconds 0.0.0.0:32768-\u0026gt;8080/tcp naughty_kalam  참고\n도커/쿠버네티스를 활용한 컨테이너 개발 실전 입문\n초보를 위한 도커 안내서\n","id":16,"section":"posts","summary":"더 자세한 내용은 부디 책을 참고하길 부탁드립니다. 목차 [Docker/도커] 01. 도커의 기초 - 도커란 무엇인가? [Docker/도커] 02. 도커의 기초 - 도커","tags":["Devops"],"title":"[Docker/도커] 03.도커 컨테이너 배포 - 컨테이너로 애플리케이션 실행하기","uri":"http://blog.cmstown.com/2020/09/docker_03/","year":"2020"},{"content":"더 자세한 내용은 부디 책을 참고하길 부탁드립니다.\n목차   [Docker/도커] 01. 도커의 기초 - 도커란 무엇인가?\n  👉 [Docker/도커] 02. 도커의 기초 - 도커를 사용하는 의의 / 도커 설치하기 👈\n  [Docker/도커] 03.도커 컨테이너 배포 - 컨테이너로 애플리케이션 실행하기\n  [Docker/도커] 04.도커 컨테이너 배포 - 도커 이미지 다루기\n  [Docker/도커] 05.도커 컨테이너 배포 - 도커 컨테이너 다루기\n  [Docker/도커] 06.도커 컨테이너 배포 - 운영과 관리를 위한 명령\n  [Docker/도커] 07.도커 컨테이너 배포 - 도커 컴포즈로 여러 컨테이너 실행하기\n  [Docker/도커] 08.컨테이너 실전 구축 및 배포\n  \n🐳 02.도커의 기초 - 도커를 사용하는 의의 🐳 앞 장 에서 도카가 무엇인지 살펴보았다. 또한 사실 앞장만 봐도 왜 도커를 사용하는지 알 수 있을 것이다. 그럼에도 불구하고 이번장에서 도커를 왜 사용하는지 도커를 사용하는 의의와 도커를 설치하는 방법에 대해 알아보자.\n도커를 사용하는 의의는 크게 다음과 같다.\n  변화하지 않는 실행 환경으로 멱등성(Idempotency) 확보\n  코드를 통한 실행 환경 구축 및 애플리케이션 구성\n  실행 환경과 애플리케이션의 일체화로 이식성 향상\n  시스템을 구성하는 애플리케이션 및 미들웨어의 관리 용이성\n  그럼 위 내용의 장점들을 하나씬 순서대로 살펴보자.\n환경 차이로 인한 문제 방지 애플리케이션을 개발을 수행하면서 다음과 같은 문제를 경험한 적이 있을 것이다.\n 문제 1 : B 서버에서도 같은 애플리케이션을 배포하고 싶은데, A 서버와 다르게 동작하네ㅐ\u0026hellip;\n문제 2 : B 서버에 설치된 라이브러리 버전이 다르네..?\n문제 3 : 모든 서버에 같은 아카이브를 배포하고 싶은데\u0026hellip;\n 위 문제의 근본적인 원인은 인프라의 가변성(mutable infrastructure) 을 허용하고 있다는 것이다. 이 문제를 해결하기 위해 최근 제안된 것이 코드로 관리하는 인프라와 불면 인프라 개념이다. 도커는 도커 이미지(Dockerfile)로 서버 구성을 코드로 관리할 수 있따. 그러므로 기존 컨테이너를 빠르게 폐기하고 새로이 구축할 수 있다. 즉, 도커를 사용하면 코드로 관리하는 인프라와 불변 인프라의 두 개념을 간단하고 낮은 비용으로 실현할 수 있다.\n애플리케이션 구성 관리의 용이성 도커 컨테이너는 애플리케이션과 인프라를 함께 담은 상자다. 이 상자를 여러 개 조합하여 시스템을 구성할 수 있어야 한다. 이를 위해 시스템 전체에 대한 적절한 구성 관리가 필요해졌다.\n이런 문제는 도커에서 이미 해결했다. 여러 컨테이너를 사용하는 애플리케이션을 쉽게 관리할 수 있도록 도커 컴포즈(Docker Compose) 라는 도구를 제공한다. 도커 컴포즈를 사용하면 yaml 포맷으로 작성된 설정 파일로 컨테이너를 정의하거나 컨테이너 간의 의존 관게를 정의해 시작 순서를 제어할 수 있어야 한다.\n도커 컴포즈를 이용하여 Redis 컨테이너 구성에 대한 정의를 하는 예\nversion: \u0026quot;3\u0026quot; services: web: image: gihyodocker/web ports: - \u0026quot;3000:3000\u0026quot; environemnt: REDIS_TARGET: redis depends_on: - redis redis: image: \u0026quot;redis:alpine\u0026quot;  대규모 트래픽 처리 같은 많은 작업을 해야 하는 시스템은 도커가 설치된 서버(도커 노드)를 여러 대 갖추고 이 노드 그룹에 필요한 만큼의 애플리케이션 컨테이너를 배포해야 한다. 도커 컴포즈가 단일 서버를 넘어 여러 서버에 걸쳐 있는 여러 컨테이너를 관리할 수 있도록 한 도구가 도커 스웜(Docker Swarm) 이다.\n여러 컨테이너를 관리하는 것만이 목적인 도커 컴포즈와 달리 도커 스웜은 컨테이너의 증감은 물론이고 노드의 리소스를 효율적으로 활용하기 위한 컨테이너 배치 및 로드 밸런싱 기능 등 더욱 실용적인 기능을 갖추고 있다. 또, 배포 시에도 롤링 업데이트(오래된 컨테이너와 새로운 컨테이너를 단계적으로 서비스에 교체 투입하는 것)가 가능해 운영 면에서도 장점이 많다. 이렇게 여러 서버에 걸쳐 있는 여러 컨테이너를 관리하는 기법을 컨테이너 오케스트레이션(container orchestration) 이라고 한다.\n컨테이너 오케스트레이션 분야에서 사실상 표준으로 자리 잡은 것은 쿠버네티스(Kubernetes) 다. 쿠버네티스는 구글이 오랫동안 컨테이너를 운영하면서 얻은 노하우를 담은 오픈 소스이고 도커 스웜보다 기능이 충실하며 확정성이 높다. 이에 대해서는 추후에 자세히 다루도록 하겠다.\n운영 환경에서 빛을 발하는 도커 도커는 실제 개발 환경 뿐만 아니라 운영 환경에서도 많이 사용된다. 도커에는 운영에 도움을 주기 위한 여러도구가 있는데, 임미 주요 클라우드 플랫폼(GCP, AWS 등)에 컨테이너 운영 환경이 갖춰져 있어 도커를 운영 환경에 적용하기 위한 진입 장벽이 많이 낮아져있다.\n새로운 개발 스타일 도커를 통해 인프라와 애플리케이션이 모두 컨테이너 형태로 제공되면서 인프라와 애플리케이션의 설정을 모두 코드 수준에서 쉽게 수정할 수 있게 됐다. 즉, 기존에는 명확했던 인프라 엔지니어와 서버 사이드 엔지니어의 영역 구분이 점점 희미해지고 있다.\n또한 도커는 서버 사이드 엔지니어와 인프라 엔지니어만의 전유물이 아니고 프론트엔드 및 모바일 개발에도 점차 기초 기술이 될 것이다.\n\n🐳 02.도커의 기초 - 도커 설치하기 🐳 OS별 설치 방법 도커를 설치하는 방법은 윈도우,리눅스,macOS냐에 따라 달라진다.\n사실 설치 방법에 대해서는 이미 블로그들에 많이 소개되어 링크를 첨부하도록 하겠다.\n  윈도우 도커 설치\n  리눅스 도커 설치\n  macOS 도커 설치\n  \n참고\n도커/쿠버네티스를 활용한 컨테이너 개발 실전 입문\n초보를 위한 도커 안내서\n","id":17,"section":"posts","summary":"더 자세한 내용은 부디 책을 참고하길 부탁드립니다. 목차 [Docker/도커] 01. 도커의 기초 - 도커란 무엇인가? 👉 [Docker/도커] 02. 도커의 기초 - 도","tags":["Devops"],"title":"[Docker/도커] 02. 도커의 기초 - 도커를 사용하는 의의 / 도커 설치하기","uri":"http://blog.cmstown.com/2020/09/docker_02/","year":"2020"},{"content":"목차   👉 [Docker/도커] 01. 도커의 기초 - 도커란 무엇인가? 👈\n  [Docker/도커] 02. 도커의 기초 - 도커를 사용하는 의의 / 도커 설치하기\n  [Docker/도커] 03.도커 컨테이너 배포 - 컨테이너로 애플리케이션 실행하기\n  [Docker/도커] 04.도커 컨테이너 배포 - 도커 이미지 다루기\n  [Docker/도커] 05.도커 컨테이너 배포 - 도커 컨테이너 다루기\n  [Docker/도커] 06.도커 컨테이너 배포 - 운영과 관리를 위한 명령\n  [Docker/도커] 07.도커 컨테이너 배포 - 도커 컴포즈로 여러 컨테이너 실행하기\n  [Docker/도커] 08.컨테이너 실전 구축 및 배포\n  \n🐳도커를 공부하기 전에\u0026hellip;🐳 최근 도커/쿠버네티스와 같은 운영환경이 개발에 주를 이루고 있다. 이에 먼저 컨테이너를 쉽게 이식하고 운영 환경에 굉장히 용이한 도커를 학습하고싶었다. 이에 본 글은 도커/쿠버네티스를 활용한 컨테이너 개발 실전 입문을 읽고 대략 총 20개의 글로 나누어 도커에 대해 작성할 예정이다.\n책을 요약하여 이루고자 하는 목표는 도커를 이해하고 기본적인 입문 단계에 이루어 실제 개발에 사용하고자하는 목표이다. 물론 빠르게 quick start하는 방법으로는 다른 좋은 블로그 글들이 많다. 그러나 나는 무조건 빠르게 시작하는 것보다 정확하게 이해하고 학습하는 것을 중요시 여긴다. 이에 따로 책 한권을 선정하여 공부하기로 결심하였고, 그렇다고 책 한권을 질질 끌 생각은 없다. 해당 책을 완독하는데 생각하는 기간은 10일 미만이다. 고로 빠르게 책을 학습해나가는 대신에, 본문 글의 중요한 내용(사실 다 중요하다..)을 요약하고 한다. 이에 도커에 대한 내용을 빠르게 학습하고 이후 쿠버네티스에 대한 글을 요약하도록 하겠다. 더 자세한 내용은 부디 책을 참고하길 부탁드립니다.\n\n🐳 01.도커의 기초 - 도커란 무엇인가? 🐳 사실 우리는 어떠한 기술을 사용하기 전에 이 기술을 왜? 사용해야하는지 알아야한다. 그렇기에 항상 기술의 등장 배경과 개념은 가장 중요한 챕터이다. 해당 챕터는 가장 중요한 시작이기에 가급적 책의 본문이에 모두 도커란 무엇인지 살펴보도록 하자.\n\n도커란 무엇인가 도커(Docker)는 컨테이너형 가상화 기술을 구현하기 위한 상주 애플리케이션과 이 애플리케이션을 조작하기 위한 명령형 도구로 구성되는 프로덕트이다. 애플리케이션 배포에 특화돼 있기 때문에 애플리케이션 개발 및 운영을 컨테이너 중심으로 할 수 있다.\n이 말을 조금 더 쉽게 이해시키기 위해 \u0026ldquo;애플리케이션 테스트에 사용할 경량 가상 환경\u0026quot;을 예를 들겠다.\n예를 들어, 웹 애플리케이션을 개발하기 위해 Apache나 Nginx 등의 웹 서버를 구축해야 한다고 가정해보자. 이를 위해서 우리는 평소에 정해진 웹 서버를 똑같이 다운로드 하는 과정을 반복적으로 거쳐야 한다. 그러나 이러한 기존 방법과 달리 도커를 활용하면 보다 편리하게 테스트 환경을 구축할 수 있다. 로컬에 도커만 설치되어있다면, 몇 줄짜리 도커 파일과 명령어 한 줄로 애플리케이션이나 미들웨어가 이미 갖춰진 테스트용 가상환경(도커 컨테이너)을 빠르게 구축할 수 있다.\n도커는 기존 가상화 소프트웨어보다 더 가볍게 동작한다. 그러므로 테스트 환경 뿐만 아니라 운영 환경 에서도 컨테이너를 사용할 수 있다.\n또한 도커는 이식성이 뛰어나다. 로컬 머신의 도커 환경에서 실행되던 컨테이너를 다른 서버에 있는 도커 환경에 배포하거나 반대로 다른 환겨엥서 동작하던 컨테이너를 로컬로 가져올 수 있다. 즉, 개발 환경과 운영 환경을 거의 동등하게 재현할 수 있다.\n이 외에도 컨테이너 간의 연동이나 클라우드 플랫폼 지원 등 여러 면에서 장점이 있다.\n도커는 시스템 개발 및 운영 환경에서 사용하는 것이 일반적이지만, 그 외에도 다양한 방법으로 활용할 수 있다. 이에 대한 방법은 추후에 배울 것이다.\n  설치가 번거로운 명령형 도구를 도커 컨테이너로 가져다 사용함으로써 호스트를 일정하게 유지하면서도 바로 실행할 수 있음\n  다양한 의존 라이브러리나 도구를도커 컨테이너에 포함시켜 배포함으로써 실행 환경과 상관없이 스크립트의 동적 재현성을 높임.\n  도커 컨테이너를 HTTP 부하테스트의 워커(worker)로 사용해 HTTP 요청 수를 증가 시킨다.\n  \n도커가 적합하지 않은 경우 물론 도커가 만능해결사는 아니다. 컨테이너는 운영 체제의 동작을 완전히 재현하지는 못한다. 이에 좀 더 엄밀한 리눅스 계열 운영 체제의 동작이 요구되는 가상 환경을 구축해야 한다면 기존 방법대로 VMWare나 VirtualBox 같은 가상화 소프트웨어를 사용하는 것이 낫다.\n또한 FreeBSD 같은 비리눅스 환경이 필요한 경우에도 도커가 적합하지 않다. 도커는 애초에 가상화 소프트웨어와는 지향하는 바가 다르며, 이들과 경쟁하기 위한 제품도 아니기 때문이다. 다만 애플리케이션을 배포하는 목적에 특화된 박스라고 생각하는 편이 좋다.\n\n도커의 역사 2013년 봄 닷클라우드(dotCloud, 현재는 Docker)사의 엔지니어였던 솔로몬 하익스(Solomon Hykes)가 최초로 도커를 오픈 소스로 공개했다. 이에 도커는 점차 널리 퍼져 나가며 현재는 컨테이너 관련 기술의 사실상 표준 지위를 차지하고 있다. 그 뒤로 크로스 플랫폼 지원을 확대하고 엔터프라이즈용 지원을 보강하면서 기업과 개인 등 다양한 계층으로 사용층을 넓히고 있다.\n도커와 관련된 오픈 소스 제품 개발 경쟁도 치열하다. 컨테이너 오케스트레이션 도구 분야에서는 도커 사가개발을 주도하는 도커 스윔(DockerSwarm) 외에도 현재 이분야에서 한발 앞서 있다는 평가를 받는 쿠버네티스(Kubernets), 아파치 메소스(Apache Mesos) 등이 있다.\n\n도커의 기본 개념 컨테이너형 가상화 기술 도커는 컨테이너형 가상화 기술 을 사용한다.\n컨테이너형 가상화 자체는 도커 이전에도 존재하던 기술이다. 도커가 등장하기 전에는 LXC(Linux Containers)가 유명했는데, 도커도 초기에는 컨테이너형 가상화를 구현하는데 LXC를 런타임(현재는 runC)으로 사용했다. 컨테이너형 가상화를 사용하면 가상화 소프트웨어 없이도 운영 체제의 리소스를 격리해 가상 운영 체제를 만들 수 있다. 이 가상 운영 체제를 컨테이너라고 한다.\n이와 달리, 운영 체제 위에서 가상화 소프트웨어를 사용해 하드웨어를 에뮬레이션하는 방법으로 게스트 운영 체제를 만드는 방식을 호스트 운영 체제 가상화(ex. VMWare..)라고 한다. 컨테이너형 가상화와 비교하면 구조적으로 오버헤드가 더 크다.\n애플리케이션이 중심이 되는 도커 LXC(Linux Containers)는 호스트 운영 체제 가상화보다 성능 면에서 유리하다는 장점으로 시스템 컨테이너로서 어느 정도 자리를 잡았다. 그러나 다른 LXC 호스트에서 실행했을 떄 LXC 설정의 차이로 인해 기대했던 대로 애플리케이션이 동작하지 않는 등의 문제가 있었다.\n반면 도커는 컨테이너가 갖는 성능적인 이점을 잘 살리면서도 애플리케이션 배포에 초점을 맞췄다.\nDocker와 LXC의 차이점\n  호스트 운영 체제의 영향을 받지 않는 실행 환경(Docker Engine을 이용한 실행 환경 표준화)\n  DSL(Dockerfile)을 이용한 컨테이너 구성 및 애플리케이션 배포 정의\n  이미지 버전 관리\n  레이어 구조를 갖는 이미지 포맷(차분 빌드가 가능함)\n  도커 레지스트리(이미지 저장 서버 역할을 함)\n  프로그램 가능한 다양한 기능의 API\n  결론적으로 보면 도커는 환경의 영향을 덜 받고 배포가 간단하다.\n\n참고\n도커/쿠버네티스를 활용한 컨테이너 개발 실전 입문\n초보를 위한 도커 안내서\n","id":18,"section":"posts","summary":"목차 👉 [Docker/도커] 01. 도커의 기초 - 도커란 무엇인가? 👈 [Docker/도커] 02. 도커의 기초 - 도커를 사용하는 의의 / 도커 설치하기 [Docke","tags":["Devops"],"title":"[Docker/도커] 01. 도커의 기초 - 도커란 무엇인가?","uri":"http://blog.cmstown.com/2020/09/docker_01/","year":"2020"},{"content":"Spring Singleton VS Java Singleton(스프링 싱글톤과 자바 싱글톤의 차이) 최근 프로젝트를 하던도중 싱글톤으로 구현해야하는 클래스가 생겼는데, Spring에서 singleton으로 구현하는 것(scope을 singleton으로 빈 등록)과 자바 싱글톤으로 구현하는 것에 어떠한 차이가 있을지 궁금해서 내용을 찾아보았다.\n결론   스프링 싱글톤은 컨테이너 당 하나 생성된다.\n  자바 싱글톤은 클래스당 하나가 생성된다.\n  ","id":19,"section":"posts","summary":"Spring Singleton VS Java Singleton(스프링 싱글톤과 자바 싱글톤의 차이) 최근 프로젝트를 하던도중 싱글톤으로 구현해야하는 클래스가 생겼는데, Spring에서 s","tags":null,"title":"Spring Singleton VS Java Singleton","uri":"http://blog.cmstown.com/2020/08/singleton/","year":"2020"},{"content":"property 프로퍼티  다양한 방법으로 정의할 수 있는 설정값 Environment의 역할은 프로퍼티 소스 실행 및 프로퍼티 값 가져오기 application에 등록된 여러가지 key-value 쌍으로 제공되는 property에 접근할수 있는 기능  우선순위  StandardServletEnvironment의 우선순위  ServletConfig 매개변수 ServeltContext 매개변수 JNDI(java compiler) JVM 시스템 프로퍼티(-Dkey = \u0026ldquo;value\u0026rdquo;) JVM 시스템 환경 변수(운영 체제 환경 변수)    사용방법   환경변수(VMoption)\n다음과 같이 VM options에 설정을 해주고, AppRunner.java 파일에서 다음과 같이 코드를 작성해보자.\n@Component public class AppRunner implements ApplicationRunner { @Autowired ApplicationContext ctx; @Override public void run(ApplicationArguments args) throws Exception { Environment environment = ctx.getEnvironment(); System.out.println(environment.getProperty(\u0026quot;app.name\u0026quot;)); } }  그리고 실행하면 \u0026ldquo;spring5\u0026rdquo; 라는 단어가 출력이 된다.\n  properties \u0026amp; @PropertySource\n위 사진처럼 새롭게 app.properties 파일을 만들고 그 안에\napp.name=spring  를 작성하고 밑에 순서대로 진행한다.\nDemoApplication.java\n@SpringBootApplication @PropertySource(\u0026quot;classpath:/app.properties\u0026quot;) public class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } }  AppRunner.java\n@Component public class AppRunner implements ApplicationRunner { @Autowired ApplicationContext ctx; @Autowired BookRepository bookRepository; @Override public void run(ApplicationArguments args) throws Exception { Environment environment = ctx.getEnvironment(); System.out.println(environment.getProperty(\u0026quot;app.about\u0026quot;)); } }  이렇게 작성후 실행하면 \u0026ldquo;spring\u0026quot;이라는 단어가 출력된다.\n만약 이 둘을 혼용해서 사용하면 VMoption이 우선순위이다.\n  @Value\n. . . @Value(\u0026quot;${app.name}\u0026quot;) String name; . . .  이렇게 사용시에 환경변수로 설정한 값을 가지게된다.\n  스프링 부트의 외부 설정 참고  기본 프로퍼티 소스 지원 프로파일까지 고려한 계층형 프로퍼티 우선 순위 제공  ","id":20,"section":"posts","summary":"property 프로퍼티 다양한 방법으로 정의할 수 있는 설정값 Environment의 역할은 프로퍼티 소스 실행 및 프로퍼티 값 가져오기 application에 등록된 여","tags":null,"title":"[Spring Core(스프링 프레임워크 핵심기술)] 08. IoC 컨테이너 : 프로퍼티","uri":"http://blog.cmstown.com/2020/07/spring_core_08/","year":"2020"},{"content":"profile ApplicationContext extends EnvironmentCapable application context는 bean factory뿐만 아니라 다양한 기능들을 제공한다.\n그 중에서 구현하고 있는 EnviromentCapable에서 제공하는 기능은 크게 2가지가 있는데, 그 중 하나인 프로파일 기능을 공부해보자.\n프로파일 해당 기능은 spring의 application context의 environment의 기능 중 하나\n프로파일 유즈케이스 각각의 환경마다 혹은 특정한 환경에서 다른 빈을 설정하기 위한 요구사항을 충족시키기 위해 사용한다.\n 테스트 환경에서 A라는 빈을 사용하고, 배환경에서 B라는 빈을 쓰고 싶을 때 모니터링/테스트/배포 각각 목적에 맞게 빈을 사용하고 싶을 때  프로파일 정의하기 간단하게 처음에 enviroment의 profile에 어떠한 정보가 담겨있는지 살펴보자.\nAppRunner.java\n@Component public class AppRunner implements ApplicationRunner { @Autowired ApplicationContext ctx; @Override public void run(ApplicationArguments args) throws Exception { Environment environment = ctx.getEnvironment(); System.out.println(Arrays.toString(environment.getActiveProfiles())); System.out.println(Arrays.toString(environment.getDefaultProfiles())); } }  위와 같은 runner를 하나 만들어주고 enviroment에서 어떠한 값이 출력되는지 살펴보자.\n(ApplicationContext가 EnvironmentCpapble을 구현하고 있기에 위와 같이 사용 가능하다)\n출력 결과는 다음과 같다.\n[] [default]  여기서 default profile은 말 그대로 기본적으로 가져가는 프로파일이다.\n이제는 새로운 프로파일을 정의해보자. 이를 위해서 아래와 같이 코드를 작성해보자.\nBookRepository.java\npublic class BookRepository { }  TestBookRepository.java\npublic class TestBookRepository extends BookRepository{ }  TestConfiguration.java\n@Configuration @Profile(\u0026quot;test\u0026quot;) public class TestConfiguration { @Bean public BookRepository bookRepository() { return new TestBookRepository(); } }  AppRunner.java\n@Component public class AppRunner implements ApplicationRunner { @Autowired ApplicationContext ctx; @Autowired BookRepository bookRepository; @Override public void run(ApplicationArguments args) throws Exception { Environment environment = ctx.getEnvironment(); System.out.println(Arrays.toString(environment.getActiveProfiles())); System.out.println(Arrays.toString(environment.getDefaultProfiles())); } }  코드를 다 작성했다면 실행을 해보자.\n우리는 실행에 실패했다는 결과를 확인할 수 있다.\n그 이유는 BookRepository 빈 등록을 @Profile(\u0026ldquo;test\u0026rdquo;) 어노테이션을 이용하여 test profile일 때만 사용되도록 설정하였기 때문이다.\n그렇다면 우리의 실행 profile을 test로 바꾸어보자.\n먼저 우측 상단의 Edit Configurations를 클릭한다.\n이후 크게 2가지 방법이 존재하는데, 첫번째는 Active Profiles를 다음과 같이 설정하는 것이다.\n혹은 Enviroment의 VM options에 다음과 같이 설정하는 것이다.\n이후 확인해주면 정상적으로 수행되는 것을 확인할 수 있다.\n지금까지 코드에서 TestConfiguration.java에 빈등록을 일일이 해주었는데, 이제 쉽게 @Profile 어노테이션으로 설정해주는 방법을 알아보자. 이를 위해서 먼저 TestConfiguration.java 파일을 삭제한고 기존의 코드를 아래와 같이 바꾸어보자.\nTestBookRepository.java\n@Repository @Profile(\u0026quot;test\u0026quot;) public class TestBookRepository extends BookRepository{ }  이후 실행해보면 정상적으로 실행되는 것을 알 수 있다.\n참고로 @Profile(\u0026quot;!test\u0026rdquo;)로 설정하면 test가 아닌 모든 프로파일에 적용된다. 즉, default 환경에서뿐만 아니라 profile이 test가 아니면 다 적용 가능하다. 이와 관련된 내용은 스프링 공식문서 를 참고하면 좋다.\n","id":21,"section":"posts","summary":"profile ApplicationContext extends EnvironmentCapable application context는 bean factory뿐만 아니라 다양한 기능들을 제공한다. 그 중에서 구현하고 있는 EnviromentCapable에서 제공하","tags":null,"title":"[Spring Core(스프링 프레임워크 핵심기술)] 07. IoC 컨테이너 : 프로파일","uri":"http://blog.cmstown.com/2020/07/spring_core_07/","year":"2020"},{"content":"빈의 스코프 Scope  싱글톤(default) 프로토타입  Request Session WebSocket \u0026hellip;    Single.java\n@Component public class Single { }  Proto.java\n@Component @Scope(\u0026quot;prototype\u0026quot;) public class Proto { }  AppRunner.java\n@Component public class AppRunner implements ApplicationRunner { @Autowired ApplicationContext ctx; @Override public void run(ApplicationArguments args) throws Exception { System.out.println(\u0026quot;single\u0026quot;); System.out.println(ctx.getBean(Single.class)); System.out.println(ctx.getBean(Single.class)); System.out.println(ctx.getBean(Single.class)); System.out.println(\u0026quot;proto\u0026quot;); System.out.println(ctx.getBean(Proto.class)); System.out.println(ctx.getBean(Proto.class)); System.out.println(ctx.getBean(Proto.class)); } }  실제로 위와 같이 코드를 작성후 실행하면\nsingle com.spring.core.autowired.demo.Single@58472096 com.spring.core.autowired.demo.Single@58472096 com.spring.core.autowired.demo.Single@58472096 proto com.spring.core.autowired.demo.Proto@337bbfdf com.spring.core.autowired.demo.Proto@52d97ab6 com.spring.core.autowired.demo.Proto@4da6d664  single은 하나의 값만 출력되고, proto는 매번 다른 값이 출력되는 것을 확인 할 수 있다.\n프로토타입 빈이 싱글톤 빈을 참조하면? Proto.java\n@Component @Scope(\u0026quot;prototype\u0026quot;) public class Proto { @Autowired Single single; }  위 코드와 같이 작성할 경우 우리가 의도한대로, Proto는 매번 새로 생성되고, Single은 한번만 생성된다.\n싱글톤 빈이 프로토타입 빈을 참조하면? Single.java\n@Component public class Single { @Autowired Proto proto; public Proto getProto(){ return proto; } }  위 코드를 작성하고,\nAppRunner.java\n@Component public class AppRunner implements ApplicationRunner { @Autowired ApplicationContext ctx; @Override public void run(ApplicationArguments args) throws Exception { System.out.println(\u0026quot;proto by single\u0026quot;); System.out.println(ctx.getBean(Single.class).getProto()); System.out.println(ctx.getBean(Single.class).getProto()); System.out.println(ctx.getBean(Single.class).getProto()); } }  실제로 위와 같이 코드를 작성후 실행하면\nproto by single com.spring.core.autowired.demo.Proto@4745e9c com.spring.core.autowired.demo.Proto@4745e9c com.spring.core.autowired.demo.Proto@4745e9c  single안의 proto가 매번 다른 값을 보여주지 않고, 동일한 값을 보여주는 것을 확인할 수 있다.\n이를 해결하는 방법\n  proxyMode 설정\n위의 코드에서 아래의 파일을 수정해주자.\nProto.java\n@Component @Scope(value = \u0026quot;prototype\u0026quot;, proxyMode = ScopedProxyMode.TARGET_CLASS) public class Proto { }  이후 실행하면 모든 인스턴스가 매번 달라지는 것을 알 수 있다.\n여기서 proxyMode = ScopedProxyMode.TARGET_CLASS의 의미는, 아래의 그림처럼 Proxy를 거쳐 참조하게끔 하는 것이다.\n  ObjectProvider 사용\nSingle.java\n@Component public class Single { @Autowired ObjectProvider\u0026lt;Proto\u0026gt; proto; public Proto getProto(){ return proto.getIfAvailable(); } }  위 방법은 코드를 직접 변경하여 추가적인 작업이 필요하다.\n  ","id":22,"section":"posts","summary":"빈의 스코프 Scope 싱글톤(default) 프로토타입 Request Session WebSocket \u0026hellip; Single.java @Component public class Single { } Proto.java @Component @Scope(\u0026quot;prototype\u0026quot;) public class Proto { } AppRunner.java @Component public class AppRunner implements ApplicationRunner { @Autowired ApplicationContext ctx; @Override public void run(ApplicationArguments args) throws Exception { System.out.println(\u0026quot;single\u0026quot;); System.out.println(ctx.getBean(Single.class)); System.out.println(ctx.getBean(Single.class)); System.out.println(ctx.getBean(Single.class)); System.out.println(\u0026quot;proto\u0026quot;); System.out.println(ctx.getBean(Proto.class)); System.out.println(ctx.getBean(Proto.class)); System.out.println(ctx.getBean(Proto.class)); }","tags":null,"title":"[Spring Core(스프링 프레임워크 핵심기술)] 06. IoC 컨테이너 : 빈의 스코프","uri":"http://blog.cmstown.com/2020/07/spring_core_06/","year":"2020"},{"content":"@Component와 Component-Scan 컴포넌트 스캔 주요 기능 @Component  @Repository @Service @Controller @Configuration  @Componenet-Scan   spring 3.1 부터 지원\n  @ComponentScan 어노테이션부터 component scan을 시작하여 해당 파일이 있는 패키지 안의 모든 것을 scan한다.\n예를 들어 아래와 같은 패키지 구조를 이루고 있을 떄\n  @SpringBootApplication public class DemoApplication { @Autowired MyService myService; public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } }  위와 같이 코드를 작성하면 빈을 찾을 수 없다는 빨간 밑줄이 나오게 된다.\n실제 내부 코드를 보면\n@ComponentScan( excludeFilters = {@Filter( type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class} ), @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class} )}  다음과 같이 Filter가 존재하는 것을 확인할 수 있다.\n이떄 function을 사용하여 빈 등록을 하면 다른 패키지의 빈을 찾을 수 있다.\n@SpringBootApplication public class DemoApplication { @Autowired MyService myService; public static void main(String[] args) { new SpringApplicationBuilder() .sources(DemoApplication.class) .initializers((ApplicationContextInitializer\u0026lt;GenericApplicationContext\u0026gt;) applicationContext -\u0026gt; { applicationContext.registerBean(MyService.class); }) .run(args); } }  위의 코드를 구현해주고 실행하면 정상적으로 MyService도 빈 등록이 되어져 실행되는 것을 알 수 있다.\n동작 원리   @ComponentScan은 스캔할 패키지와 애노테이션에 대한 정보\n  실제 스캐닝은 ​ConfigurationClassPostProcessor​라는 ​BeanFactoryPostProcessor​에\n의해 처리 됨.\n  ","id":23,"section":"posts","summary":"@Component와 Component-Scan 컴포넌트 스캔 주요 기능 @Component @Repository @Service @Controller @Configuration @Componenet-Scan spring 3.1 부터 지원 @ComponentScan 어노테이션부터 component scan을 시작하여 해당 파일이 있는 패키지 안의 모든 것을 sc","tags":null,"title":"[Spring Core(스프링 프레임워크 핵심기술)] 05. IoC 컨테이너 : @Component와 Component-Scan","uri":"http://blog.cmstown.com/2020/07/spring_core_05/","year":"2020"},{"content":"@Autowired 필요한 의존 객체의 \u0026ldquo;타입\u0026quot;에 해당하는 빈을 찾아 주입한다.\n사용할 수 있는 위치 클래스 주입 BookRepository.java\npublic class BookRepository { }  BookService.java\n@Service public class BookService { BookRepository bookRepository; @Autowired public BookService(BookRepository bookRepository){ this.bookRepository = bookRepository; } }  DemoApplication.java\n@SpringBootApplication public class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } }  위 경우에 BookRepository가 빈 등록이 안되어있어 오류\n이후 다음과 같이 BookRepository를 수정해보자.\nBookRepository.java\n@Repository public class BookRepository { }  이후 실행시 정상적으로 작동하는 것을 확인할 수 있다.\nSetter 주입 setter로 주입하는 과정을 확인해보자.\nBookRepository.java\npublic class BookRepository { }  BookService.java\n@Service public class BookService { BookRepository bookRepository; @Autowired public void setBookRepository(BookRepository bookRepository) { this.bookRepository = bookRepository; } }  실행하면 오류가 뜨는 것을 확인 할 수 있다.\n여기서 \u0026ldquo;BookService 자체의 인스턴스는 만들 수 있는거 아닌가?\u0026rdquo; 라는 의문을 가질 수 있다.\n실제로 BookService라는 인스턴스 자체는 만들 수 있는데, 다만 @Autowired가 있어서 의존성을 주입하려고 시도하는 과정이 실패하는 것이다.\n결론적으로 BookService 인스턴스는 만들 수 있지미나 @Autowirder가 있어서 실패하는 것이다.\n이 경우에 @Autowired가 필수적인게 아니라고하면 @Autowired(required = false) 로 하면 정상적으로 실행된다.\n(required : 기본값은 true(따라서 못 찾으면 애플리케이션 구동 실패))\n필드 주입 BookService.java\n@Service public class BookService { @Autowired(required = false) BookRepository bookRepository; }  required가 false이기 때문에, 정상적으로 실행이 가능하다.\n\n주입이 여러개인 경우 추가적으로 다음과 같은 클래스를 생성해보자.\nMyBookRepository.java\n@Repository public class MyBookRepository extends BookRepository{ }  MinseongBookRepository.java\n@Repository public class MinseongBookRepository extends BookRepository{ }  이렇게 BookRepository를 상속받는 새로운 repository 2개를 만들어보자.\n이후 BookService를 다음과 같이 만들어준다.\nBookService.java\n@Service public class BookService { @Autowired BookRepository bookRepository; }  어떠한 결과가 나올까?\nParameter 0 of constructor in com.spring.core.autowired.demo.BookService required a single bean, but 2 were found: - minseongBookRepository: defined in file [/Users/choeminseong/IdeaProjects/study/spring/core/autowired/target/classes/com/spring/core/autowired/demo/MinseongBookRepository.class] - myBookRepository: defined in file [/Users/choeminseong/IdeaProjects/study/spring/core/autowired/target/classes/com/spring/core/autowired/demo/MyBookRepository.class] Action: Consider marking one of the beans as @Primary, updating the consumer to accept multiple beans, or using @Qualifier to identify the bean that should be consumed  우리는 위와 같은 결과를 확인할 수 있다.\nbookRepository에 주입할 대안이 2개이기 때문에 어떤것을 주입해야할지 모른다는 문구와 함께 3가지 대안이 나온다.\n1. Consider marking one of the beans as @Primary @Primary 어노테이션을 사용하여 사용하고 싶은 빈이 무엇인지 마킹해라\nMinseongRepository.java\n```java @Repository @Primary public class MinseongBookRepository extends BookRepository{ } ```  위의 코드와 같이 원하는 빈에 @Primary 어노테이션을 활용하면 정상적으로 코드가 수행된다.\n2. updating the consumer to accept multiple beans 모든 빈을 받아들이자\n```java @Service public class BookService { @Autowired List\u0026lt;BookRepository\u0026gt; bookRepositories; } ```  위의 코드처럼 여러개의 빈을 주입 받도록 하면 정상적으로 코드가 수행된다.\n3. using @Qualifier to identify the bean that should be consumed @Qualifier 어노테이션을 사용하자\n```java @Service public class BookService { @Autowired @Qualifier(\u0026quot;minseongBookRepository\u0026quot;) BookRepository bookRepository; } ```  위의 코드와 같이 BookService에 명시적으로 어떠한 빈을 주입받는지 설정해주면 정상적으로 작동된다.\n4. 변수명으로 식별해주는 방법 위의 3가지 방법 외에도 변수명으로 식별해주는 방법이 존재한다.\nBookService.java\n```java @Service public class BookService { @Autowired BookRepository minseongBookRepository; } ```  이렇게해도 정상적인 실행은 되나 추천되는 방법은 아니다.\n동작 원리  BeanPostProcessor  새로 만든 빈 인스턴스를 수정할 수 있는 라이프 사이클 인터페이스   AutowiredAnnotationBeanPostProcessor enxtend BeanPostProcessor  스프링이 제공하는 @Autowired와 @Value 그리고 JSR-330의 @Inject를 지원하는 어노테이션 처리기    ","id":24,"section":"posts","summary":"@Autowired 필요한 의존 객체의 \u0026ldquo;타입\u0026quot;에 해당하는 빈을 찾아 주입한다. 사용할 수 있는 위치 클래스 주입 BookRepository.java public class BookRepository { } BookService.java @Service public class BookService { BookRepository bookRepository; @Autowired public BookService(BookRepository bookRepository){ this.bookRepository","tags":null,"title":"[Spring Core(스프링 프레임워크 핵심기술)] 04. @Autowired","uri":"http://blog.cmstown.com/2020/07/spring_core_04/","year":"2020"},{"content":"2. IoC 컨테이너 2부 : ApplicationContext와 다양한 빈 설정 방법 스프링 IoC 컨테이너의 역할  빈 인스턴스 생성 의존관계설정 빈 제공  ApplicationContext 크게 두가지로 나누어진다\n ClassPathXmlApplicationContext (XML) AnnotationConfigApplicationContext (Java)  자세하게 살펴보자.\n  기존의 빈 등록 방식\nclass 정보\npublic class BookRepository { }  public class BookService { BookRepository bookRepository; public void setBookRepository(BookRepository bookRepository) { this.bookRepository = bookRepository; } }  application.xml에 다음과 같이 작성함\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;beans xmlns=\u0026quot;http://www.springframework.org/schema/beans\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026quot;\u0026gt; \u0026lt;bean id=\u0026quot;bookService\u0026quot; class=\u0026quot;com.test.spring.core.applicationcontext.applicationcontext.BookService\u0026quot; scope=\u0026quot;singleton\u0026quot; autowire=\u0026quot;default\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;bookRepository\u0026quot; ref=\u0026quot;bookRepository\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026quot;bookRepository\u0026quot; class=\u0026quot;com.test.spring.core.applicationcontext.applicationcontext.BookRepository\u0026quot;/\u0026gt; \u0026lt;/beans\u0026gt;  DemoApplication.java\npublic class DemoApplication { public static void main(String[] args) { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\u0026quot;application.xml\u0026quot;); } }    Component-Scan 사용(Spring 2.5 부터 가능한 방법)\nclass 정보\n@Component public class BookRepository { }  @Service public class BookService { @Autowired BookRepository bookRepository; public void setBookRepository(BookRepository bookRepository) { this.bookRepository = bookRepository; } }  application.xml\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;beans xmlns=\u0026quot;http://www.springframework.org/schema/beans\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xmlns:context=\u0026quot;http://www.springframework.org/schema/context\u0026quot; xsi:schemaLocation=\u0026quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026quot;\u0026gt; \u0026lt;context:component-scan base-package=\u0026quot;com.test.spring.core.applicationcontext.applicationcontext\u0026quot;/\u0026gt; \u0026lt;/beans\u0026gt;  DemoApplication.java\npublic class DemoApplication { public static void main(String[] args) { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\u0026quot;application.xml\u0026quot;); } }  특정 패키지 이하의 모든 클래스 중에 @Component 애노테이션을 사용한 클래스를 빈으로 자동으로 등록 해 줌.\n  Java 설정\n빈 설정을 xml이 아닌 자바로 설정할 수 없을까 해서 등장한 방법.\nclass 정보\npublic class BookRepository { }  public class BookService { BookRepository bookRepository; public void setBookRepository(BookRepository bookRepository) { this.bookRepository = bookRepository; } }  ApplicationConfig.java\n@Configuration public class ApplicationConfig { @Bean public BookRepository bookRepository() { return new BookRepository(); } // method parameter로 주입받아서도 사용 가능 @Bean public BookService bookService() { BookService bookService = new BookService(); bookService.setBookRepository(bookRepository()); return bookService; } }  DemoApplication.java\npublic class DemoApplication { public static void main(String[] args) { ApplicationContext context = new AnnotationConfigApplicationContext(ApplicationContext.class); } }    @ComponentSacn 등장\nApplicaitonConfig에 일일이 등록해줘야하는 단점에 등장\nApplicationConfig.java\n@Configuration @ComponentScan(basePackageClasses = DemoApplication.class) ppublic class ApplicationConfig { }  @ComponentScan 이용시 @ComponentScan(basePackage = \u0026ldquo;com.도메인\u0026hellip;\u0026quot;) 보다 @ComponentScan(basePackageClasses = DemoApplication.class)을 사용하는 것이 타입 세잎하다. basePackageClasses는 해당 클래스가 있는 곳부터 scan하는 방식이다.\nDemoApplication.java\n@SpringBootAplication public class DemoApplication { public static void main(String[] args) { } }    ","id":25,"section":"posts","summary":"2. IoC 컨테이너 2부 : ApplicationContext와 다양한 빈 설정 방법 스프링 IoC 컨테이너의 역할 빈 인스턴스 생성 의존관계설정 빈 제공 ApplicationContext 크게 두가지로","tags":null,"title":"[Spring Core(스프링 프레임워크 핵심기술)] 03. IoC 컨테이너 2부 : ApplicationContext와 다양한 빈 설정 방법","uri":"http://blog.cmstown.com/2020/07/spring_core_03/","year":"2020"},{"content":"스프링 IoC 컨테이너와 빈 IoC(Inversion of Control) 의존 관계 주입(DI, Dependency Injection)이라고도 하며, 어떤 객체가 사용하는 의존 객체를 직접 만들어 사용하는게 아니라, 주입 받아 사용하는 방법을 말 함.\n1. 스프링 IoC 컨테이너   BeanFactory\n 스프링 IoC의 가장 최상위 인터페이스    애플리케이션 컴포넌트의 중앙 저장소\n  빈 설정 소스로 부터 빈 정의를 읽어들이고, 빈을 구성하고 제공한다\n  2. Bean   스프링 IoC 컨테이너가 관리 하는 객체\n 단순 클래스가 모두 빈이 아니라, @Repository, @Service 등 실제로 IoC 컨테이너가 관리하는 객체들을 빈이라고 한다.    의존성 주입을 하기 위해서는 빈이되야 한다.\n  Spring IoC 컨테이너에 등록된 빈의 장점\n 의존성 관리  TestServcie { private TestRepository repository = new TestRepository(); }  @Service TestService { @Autowired private TestRepository repository; }  두가지 코드 중에서 위의 경우에는 TestRepostiroy를 테스트해야 할 경우 해당 객체를 수정할 수 없다. 그러나 아래의 코드는 주입을 하기 때문에 수정이 가능하여 용이하다.\n  Scope\nScope에는 다음과 같이 2가지가 있다.\n  싱글톤(Spring IoC에서 관리하는 빈들은 기본적으로 싱글톤이다) : 하나의 객체 생성\n  프로포토타입 : 매번 다른 객체 생성\n    lifecycle interface\n    3. ApplicationContext  BeanFactory  메시지 소스 처리 기능(i18n) 이벤트 발행 기능 리소스 로딩 기능    ","id":26,"section":"posts","summary":"스프링 IoC 컨테이너와 빈 IoC(Inversion of Control) 의존 관계 주입(DI, Dependency Injection)이라고도 하며, 어떤 객체가 사용하는 의존 객체를 직접 만들어 사용하는게 아니라, 주","tags":null,"title":"[Spring Core(스프링 프레임워크 핵심기술)] 02. 스프링 IoC 컨테이너와 빈","uri":"http://blog.cmstown.com/2020/07/spring_core_02/","year":"2020"},{"content":"[Spring Core(스프링 프레임워크 핵심기술)] 01 - 내가 스프링 핵심기술을 공부하게 된 이유 스프링을 공부한지 1년이 다되간다, 스프링을 이용하여 다양한 프로젝트를 진행하였다. 누군가가 나에게 \u0026ldquo;스프링 할 줄 아나?\u0026rdquo; 라고 물어본다면 \u0026ldquo;그렇다\u0026quot;라고 자신있게(?) 대답할 수 있을 것 같다. 그러나 누군가가 나에게 \u0026ldquo;스프링을 잘 아나?\u0026rdquo; 라고 물어본다면 대답을 하지 못할 것이다.\n앞서 말한 이야기에서 사실 스프링을 잘 할줄 아는 것도 아니다. 다만, 할 수 있는 부분에 비해 아는 것이 현저히 적기에 그러한 예를 들었다. 현재 스프링으로 개발을 하지만 비교적 원론적인 개념들이 아직도 많이 부족하다 느끼고 학습할 내용이 많다. 이에 이를 공부해야겠다는 필요성을 느끼고 스프링을 더 알아보고자 학습 계획을 세웠다.\n물론 이 외에도 스프링에 대해 알아야할 것이 많다, 그러나 원론적인 부분을 먼저 알아야 추후 관련된 부분을 학습하는 것이 맞다고 생각한다. 그렇게 어떻게 공부할 것인지 생각해보았고, 가장 효율적이라고 생각하는 인터넷 강의를 채택하게 되었다. 인터넨 강의는 백기선님의 강의로 진행할 것이고 방학동안 꾸준히 공부하여 스프링에 대한 기술을 향상시킬 것이다.\n강의 계획 강의의 목차는 다음과 같다.\n 스프링 IOC 리소스 Validation 데이터 바인딩 SpEL 스프링 AOP NullSafety  강의는 총 23강의에 5시간 정도 걸린다.\n현재 해당 공부 외에도 공부하고 있는 것들이 많고 여러 프로젝트들을 진행하고있어서 많은 시간을 할애하지는 못할 것 같다. 그러나 꾸준히, 정확히 공부하여 빠르게 해당 내용들을 체화할 예정이다. 이에 하루에 1시간 정도 할애하여 일주일 안에 강의를 완강할 계획이다. 그러나 이는 너무 타이트할 일정일 수 있기에 일주일 안에 완강을 목표로 하되, 여러 변수들을 고려하여 일주일정도 더 기한을 줄 예정이다. 즉, 2주 정도의 기간안에 완강과 함께 블로그에 학습 내용들을 정리할 것이다.\n항상 몰랐던 부분을 학습하게 되는 것은 재밌는 것 같다. 어쩔수해야하는 공부가 아닌, 내 의지에 의한 공부는 정말 재미있다. 더 깊게 공부하여 완벽에 가까운(?) 스프링 개발자가 되야겠다!\n","id":27,"section":"posts","summary":"[Spring Core(스프링 프레임워크 핵심기술)] 01 - 내가 스프링 핵심기술을 공부하게 된 이유 스프링을 공부한지 1년이 다되간다, 스프링을 이용하여 다양한 프로젝트","tags":null,"title":"[Spring Core(스프링 프레임워크 핵심기술)] 01. 내가 스프링 핵심기술을 공부하게 된 이유","uri":"http://blog.cmstown.com/2020/06/spring_core_01/","year":"2020"},{"content":"[JAVA] - GC(Garbage Collection) GC(Garbage Collection)는 Java 프로세스가 동작하는 과정에서 불필요한 또는 더이상은 사용하지 않는 객체들을 메모리에서 제거함으로써, Java 프로세스가 한정된 메모리를 효율적으로 사용할 수 있게 해준다.\nstop the world\nGC 실행을 위해 JVM이 애플리케이션을 멈추는 것.\nGC 실행시 GC 실행을 위한 스레드를 제외하고 모두 멈춘다.\nGC 튜닝 은 이러한 stop the world 시간을 줄이는 것을 말한다.\nMark and Sweep\nGC 과정을 일컫는 단어.\n Mark : GC가 스택의 모든 변수 또는 Reachable 객체를 스캔하면서 각각 어떤 객체를 참조하고 있는지 찾는 과정(이 과정에서 stop the world 발생) Sweep : Mark되어 있지 않는 객체들을 힙에서 제거하는 과정  Minor GC \u0026amp; Major GC\nJVM의 Heap은 Young, Old, Perm 세 영역으로 나뉜다. Young영역에서 발생한 GC를 Minor GC, 나머지 두영역에서 발생한 GC를 Major GC라고 한다.\n  Young\n 새롭게 생성한 객체가 위치. 구조 : eden, survivor(2개) eden영역에 최초로 객체가 만들어지고, Survivor 영역을 통해서 Old 영역으로 이동    Old\n Young 영역에서 reachable 상태를 유지해 살아남은 객체가 복사된다. Young 영역보다 크게 할당하며, 크기가 큰 만큼 Young 영역보다 GC는 적게 발생한다. GC의 종류는 JAVA의 버전이 다양해짐에 따라 GC도 다양해졌다. 여기서는 CMS GC와 G1 GC 정도만 설명을 한다.   CMS GC - 속도는 빠르나, CPU를 더 많이 사용한다.\nInitial mark 단계에서 클래스 로더에서 가장 가까운 객체 중 살아 있는 객체만 찾는 것으로 끝낸다. 따라서, 멈추는 시간이 굉장히 짧다.\nConcurrent Mark 단계에서는 방금 살아있다고 확인한 객체에서 참조하고 있는 개체들을 따라가 확인한다.\nReamark 단게에서는 Concurrent Mark 단계에서 새로 추가되거나 참조가 끊긴 객체를 확인하다.\n마지막으로 Concurrent Sweep 단계에서 쓰레드를 정리하는 작업을 실행한다.\n  G1 GC\n바둑판의 각 영역에 객체를 할당하고 GC를 실행한다.\n해당 영역이 꽉 차면 다른 영역에서 객체를 할당하고 GC를 실행한다.\n즉, Young → Old 영역으로 이동하는 단계가 사라진 GC 방식\n      Perm(Method Area) : 클래스와 메소드 정보와 같이 자바 언어 레벨에서는 거의 사용되지 않는 영역이다.\n  \n더 자세한 사항은 아래 참고 주소를 확인하면 좋다.\n  참고\n Java Garbage Collection    ","id":28,"section":"posts","summary":"[JAVA] - GC(Garbage Collection) GC(Garbage Collection)는 Java 프로세스가 동작하는 과정에서 불필요한 또는 더이상은 사용하지 않는 객체들을 메모리에서 제거함으로써, Java 프로세스가 한","tags":null,"title":"[JAVA] - GC(Garbage Collection)","uri":"http://blog.cmstown.com/2020/06/gc/","year":"2020"},{"content":"[Python 기초] - 클래스 클래스의 개념  id() : 클래스에 의해 생성된 \u0026lsquo;객체\u0026rsquo;의 식별자를 반환하는 함수 \u0026lsquo;객체\u0026rsquo;는 \u0026lsquo;클래스\u0026rsquo;에 의해 생성된 실체  클래스 생성 및 선언 class Car :\r# 속성(변수)\rcount = 0 # 클래스 변수\r# 생성자\rdef __init__(self, color, speed) :\r# 인스턴스 변수\rself.color = color\rself.speed = speed\r# 클래스 변수\rCar.count += 1\r# 메소드\rdef getName(self) :\rreturn self.color\rdef getSpeed(self) :\rreturn self.speed\rdef upSpeed(self, value) :\rself.speed += value\rdef downSpeed(self, value) :\rself.speed -= value\rcar = Car('검정', 0)\rprint('%s의 현재 속도는 %d입니다.' %(car.getName(), car.getSpeed()))\rcar.color = \u0026quot;파랑\u0026quot;\rcar.speed = 5\rcar.upSpeed(30)\rprint('%s의 현재 속도는 %d입니다.' %(car.getName(), car.getSpeed()))\r 검정의 현재 속도는 0입니다.\r파랑의 현재 속도는 35입니다.\r 클래스의 상속 상속을 구현하는 문법 class SubClass(SuperClass) :\r# ~~\r 메서드 오버라이딩 구현 코드 ## 부모 클래스 ##\rclass Car :\rspeed = 0\rdef upSpeed(self, vlaue) :\rself.speed += value\rclass Sedan(Car) :\rdef upSpeed(self, value) :\rself.speed += value\rif self.speed \u0026gt; 150 :\rself.speed = 150\r 클래스 심화 클래스의 특별한 메소드  del() 메소드  소멸자, 생성자와 반대로 인스턴스 삭제할 때 자동 호출   repr() 메소드  인스턴스를 print() 문으로 출력할 때 실행   add() 메소드  인스턴스 사이에 덧셈 작업이 일어날 때 실행되는 메소드   비교 메소드  lt(), le(), gt(), ge(), eq(), ne() 순서대로 \u0026lt;. \u0026lt;=, \u0026gt;. \u0026gt;=, ==, !=    추상 메소드 class SuperClass :\rdef method(self) : #\rraise NotImplementedError()\rclass SubClass(SuperClass) :\rdef method(self) :\rprint('abstract method')\r ","id":29,"section":"posts","summary":"[Python 기초] - 클래스 클래스의 개념 id() : 클래스에 의해 생성된 \u0026lsquo;객체\u0026rsquo;의 식별자를 반환하는 함수 \u0026lsquo;객체\u0026rsquo;는 \u0026","tags":null,"title":"[Python 기초] - 클래스","uri":"http://blog.cmstown.com/2020/06/python_06_class/","year":"2020"},{"content":"[Python 기초] - 함수와 모듈 함수 기본 함수 만들기 def hello(name) : # 함수 선언\rreturn name +'님, 안녕하세요!'\rhello('홍길동') # 함수 호출\r pass 예약어  이름만 만들어 놓고 내용은 pass 예약어를 사용하여 비울 수 잇음  # 오류인 상황\rif True :\r# True일 때 아무런 할 일이 없다고 빈 줄로 둘 때 오류 발생\relse :\rprint('거짓')\r# 정상 작동\rif True :\rpass\relse :\rprint('거짓')\r 함수의 매개변수 전달  매개변수의 개수를 지정해 전달하는 방법  def para_func(v1, v2) :\rreturn v1 + v2\r 매개변수에 기본값을 설정해 놓고 전달하는 방법  def para_func(v1, v2 = 1)\rreturn v1 ** v2\r 매개변수의 개수를 지정하지 않고 전달하는 방법  def para_func(*para) :\rresult = 0\rfor num in para :\rresult += num\rreturn result\r  함수 호출할 때 딕셔너리의 형식의 매개변수를 키 = 값 형식으로 사용  def dic_func(**para) :\rfor k in para.keys() :\rprint('%s --\u0026gt; %d명입니다.' % (k, para[k]))\rdic_func(트와이스=9, 소녀시대=7, 걸스데이=4, 블랙핑크=4)\r 인수 이해하기 위치나 키워드로 인수 설정 def print_student_info(name, birth, major='CS', country='KOR') :\rprint('이름 :', name, ', 생년월일 : ', birth, ', 전공 : ', major, ', 국적 : ', country)\rprint_student_info('홍길동', '2020-06-09')\rprint_student_info('홍길동', '2020-06-09', 'SERVER') print_student_info(birth='2020-06-10', name='길동 홍')\r 출력 결과\n이름 : 홍길동 , 생년월일 : 2020-06-09 , 전공 : CS , 국적 : KOR\r이름 : 홍길동 , 생년월일 : 2020-06-09 , 전공 : SERVER , 국적 : KOR\r이름 : 길동 홍 , 생년월일 : 2020-06-10 , 전공 : CS , 국적 : KOR\r 키워드로만 호출하기 def concat(*args, sep='/'):\rreturn sep.join(args)\rconcat('a', 'b', 'c')\r'a/b/c'\rconcat('a', 'b', 'c', sep = '.')\r'a.b.c'\rconcat(sep='-', 'a','b', 'c')\r# SyntaxError\r# 개수가 정해져 있지 않은 인수는 함수 선언 시 가장 뒤쪽에 배치하여야 한다.\r 언패킹 인수 리스트 활용하기 args = 5, 10\rlist(range(*args))\r# [5, 6, 7, 8, 9]\r 모듈 모듈의 생성과 사용 Module1.py\ndef func1():\rprint('func1')\rdef func2():\rprint('func2')\r Module2.py\nimport Module1\rModule1.func1()\rModule2.func2()\r   모듈병을 생략하고 사용하고 싶을 때\n from 모듈명 import 함수1, 함수2 from 모듈명 import *  Module3.py\nfrom Modul1 import func1, func2\rfunc1()\rfunc2()\r   모듈의 종류  표준 모듈 : 파이썬에서 제공하는 모듈 사용자 정의 모듈 : 사용자가 직접 정의한 모듈 서드 파티 모듈 : 파이썬이 아닌 외부 회사나 단체에서 제공하는 모듈 모듈의 목록 확인 방법  모듈명.builtin_module_names dir(모듈명)    함수의 응용 패키지  모듈을 주제별로 분리할 때 사용   임포트 형식  from 패키지명.모듈명 import 함수명\r 내부 함수, lambda, map()  내부 함수  def outFunc(v1, v2) :\rdef inFunc(num1, num2) :\rreturn num1 + num2\rreturn inFunc(v1, v2)\rprint(outFunc(10,20))\r## 출력 결과 ##\r30\r outFunc() 함수 밖에서 호출하면 오류\nprint(inFunc(10,20)) # 불가능\r   람다 함수\n 쓰고 버리는 일시적인 함수로 함수가 생성된 곳에서만 필요 간단한 기능을 일반적인 함수와 같이 정의해두고 쓰는 것이 아닌 필요한 곳에 즉시 사용 후 버릴 수 있음 람다에는 return 문이 포함되어 있지 않으며 반환값을 만드는 표현식이 있음  g = lambda x: x**2\rprint(g(8))\r64\rf = lambda x ,y=7: x + y\rprint(f(3))\r10\rmyList = [1, 2, 3, 4, 5]\radd10 = lambda num : num + 10\rmyList = list(map(add10, myList))\rprint(myList)\r## 출력 결과 ##\r[11, 12, 13, 14, 15]\r# 두 리스트의 각 자릿수를 합쳐서 새로운 리스트로 만들기\rlist1 = [1, 2, 3, 4]\rlist2 = [10, 20, 30, 40]\rhapList = list(map(lambda n1,n2 : n1 + n2, list1, list2))\rprint(hapList)\r## 출력 결과 ##\r[11, 22, 33, 44]\r   제너레이터와 yield  yield 문 : 함수를 종결하지 않으면서 값을 계속 반환  def number_generator():\ryield 0\ryield 1\ryield 2\rfor i in number_generator():\rprint(i)\r ## 출력 결과 ##\r0\r1\r2\r ","id":30,"section":"posts","summary":"[Python 기초] - 함수와 모듈 함수 기본 함수 만들기 def hello(name) : # 함수 선언 return name +'님, 안녕하세요!' hello('홍길동') # 함수 호출 pass 예약어 이름만 만들어 놓고 내","tags":null,"title":"[Python 기초] - 함수와 모듈","uri":"http://blog.cmstown.com/2020/06/python_05_function/","year":"2020"},{"content":"[Python 기초] - 문자열의 개념 문자열의 개념 ss = '파이썬' * 3\r## 출력 결과 ##\r'파이썬파이썬파이썬'\r  문자열의 모든 글자 뒤에 $를 붙여서 출력하는 코드  ss = '파이썬짱!'\rsslen = len(ss)\rfor i in range(0, sslen) :\rprint(ss[i] + '$', end = '')\r 문자열 메소드 대, 소문자 변환  upper() : 소문자 → 대문자 lower() : 대문자 → 소문자 swapcase() : 대문자 ←→ 소문자 capitalize(0 : 첫문자를 대문자로 변환 title() 각 단어의 앞글자만 대문자로 변환  검색  s.count(\u0026lsquo;like\u0026rsquo;) : \u0026lsquo;like\u0026rsquo;라는 문자열이 발생한 횟수 리턴 s.find(\u0026lsquo;like\u0026rsquo;)  문자열 s에서 \u0026lsquo;like\u0026rsquo;의 오프셋 리턴 찾는 문자열 없을 경우 -1 리턴   s.find(\u0026lsquo;like\u0026rsquo;, 숫자) : 문자열 숫자 번 위치부터 검색 s.rfind(\u0026lsquo;like\u0026rsquo;) : find와 동일하나, 오른쪽부터 검색 s.index(\u0026lsquo;like\u0026rsquo;)  문자열 s에서 \u0026lsquo;like\u0026rsquo;의 오프셋 리턴 찾는 문자열이 없을 경우 예외 발생   s.rindex(\u0026lsquo;like\u0026rsquo;) : index와 같지만 오른쪽부터 검색 s.startswith(\u0026lsquo;i like\u0026rsquo;) : i like로 시작하는 문자열인가? bool 타입 리턴(True, False) s.endswith(\u0026lsquo;you\u0026rsquo;) : \u0026lsquo;you\u0026rsquo;로 끝나는 문자열인가? bool 타입 리턴(True, False) s.startswith(\u0026lsquo;i like\u0026rsquo;, 7) startswith을 7번쨰 문자열부터 검사 s.endswith(\u0026lsquo;you\u0026rsquo;, 7) endswith을 7번째 문자열부터 검사  문자열 편집/치환  s.strip() : 좌우 공백 삭제 s.rstrip() : 오른쪽 공백 삭제 s.lstrip() : 왼쪽 공백 삭제  ss = ' 파 이 썬 '\rss.strip()\rss.rstrip()\rss.lstrip()\r## 출력 결과 ##\r'파 이 썬'\r' 파 이 썬'\r'파 이 썬 '\r  s.strip(\u0026lsquo;\u0026lt;\u0026gt;\u0026rsquo;) : 앞뒤의 특정 문자 삭제, \u0026lsquo;\u0026lt;\u0026gt;\u0026rsquo; 삭제 s.replace(\u0026lsquo;파이썬\u0026rsquo;, \u0026lsquo;Python\u0026rsquo;) : \u0026lsquo;파이썬\u0026rsquo;을 \u0026lsquo;Python\u0026rsquo;으로 치환  문자열 분리/결합  s.split() : 공백으로 분리 s.splitlines() : 라인 단위로 분리 \u0026lsquo;:'.join(s) : \u0026lsquo;:\u0026rsquo; 문자로 결합 s.split(':\u0026rsquo;, 2) : \u0026lsquo;:\u0026rsquo; 문자로 2번만 분리 s.rsplit(':\u0026rsquo;, 1) : 오른쪽부터 한번만 분리  함수명에 대입 : map() 함수  map(함수명, 리스트명)  before = ['2019', '12, '31']\rafter = list(map(int, before))\rafter\r## 출력 결과 ##\r[2019, 12, 31]\r 문자열 정렬, 채우기  center() : 문자열 가운데 정렬 ljust() : 문자열 왼쪽 정렬 rjust() : 문자열 오른쪽 정렬 zfill() : 오른쪽 정렬, 왼쪽 빈 공간은 0으로 채움  문자열 구성 파악(bool type return)  isdigit() : 문자열이 숫자인지 아닌지 확인 isalpha() : 문자열이 문자(한글, 영어)인지 아닌지 확인 isalnum() : 글자와 숫자가 섞여있는지 아닌지 확인 islower() : 전체가 소문자로만 구성되었는지 아닌지 확인 isupper() : 전체가 대문자로만 구성되었는지 아닌지 확인 isspace() : 공백 문자로만 구성되었는지 아닌지를 확인  ","id":31,"section":"posts","summary":"[Python 기초] - 문자열의 개념 문자열의 개념 ss = '파이썬' * 3 ## 출력 결과 ## '파이썬파이썬파이썬' 문자열의 모든 글자 뒤에 $를 붙여서 출력하는 코드 ss = '파이썬","tags":null,"title":"[Python 기초] - 문자열의 개념","uri":"http://blog.cmstown.com/2020/06/python_04_string/","year":"2020"},{"content":"[Python 기초] - 제어문과 데이터 구조 데이터 정렬 : sorted() 함수  리스트  nums = 4, 2, 5, 7, 1, 3\rsorted(nums)\r[1, 2, 3, 4, 5, 7]\rsorted(nums, reverse = True)\r[7, 5 , 4, 3, 2, 1]\rnums\r(4, 2, 5, 7, 1, 3(\r  딕셔너리  programmer_dict = {'Python':5, 'C':2, 'C++':3, 'Java':4, 'Ruby':1}\rsorted(programmer_dict.keys())\rsorted(programmer_dict.values())\r 제어문과 데이터 타입 조합 A = ['blue', 'yellow', 'red']\rB = ['red', 'green', 'blue']\rpairs = []\rfor a in A :\rfor b in B :\rif a != b :\rpairs.append((a,b))\rpairs\r[('blue', 'red'), ('blue', 'green'), ... ]\rnew_pairs = [(a, b) for a in A for b in B if a != b] # (a, b) 소괄호를 안감싸면 컴파일 에러\r  세트 타입 구성  a = {x for x in 'abracadabra' if x not in 'abc'}\r{'d', 'r'}\r  딕셔너리 타입 구성  square_dic = {x: x**2 for x in (2, 4, 6)}\rsquare_dic\r{2: 4, 4: 16, 6: 36}\r  enumerate()  korean_foods_enum = enumerate(korean_foods)\rfor index, food in korean_foods_enums:\rprint(index, food)\r## 출력 결과 ##\r0 kimchi\r1 bibimbab\r2 tteok-bokki\r ","id":32,"section":"posts","summary":"[Python 기초] - 제어문과 데이터 구조 데이터 정렬 : sorted() 함수 리스트 nums = 4, 2, 5, 7, 1, 3 sorted(nums) [1, 2, 3, 4, 5, 7] sorted(nums, reverse = True) [7, 5 , 4, 3, 2, 1] nums (4, 2, 5, 7, 1, 3( 딕셔너리 programmer_dict = {'Python':5, 'C':2, 'C++':3, 'Java':4, 'Ruby':1}","tags":null,"title":"[Python 기초] - 제어문과 데이터 구조","uri":"http://blog.cmstown.com/2020/06/python_03_control/","year":"2020"},{"content":"[Python 기초] - 튜플,세트 그리고 딕셔너리 다양한 데이터 타입 컴퓨터 자원의 효율적 사용을 위해 상황에 맞는 데이터 구조를 선택해야 질 높은 프로그램을 개발할 수 있음\n 튜플 타입 : 값을 변경할 수 없음(←→ 리스트) 세트 타입 : 중복 데이터를 허용하지 않음 딕셔너리 타입 : 색인이 아닌 특정 키로 값을 불러올 수 있음  튜플 개념  immutable 열거 데이터의 집합 값을 변경할 수 있는 리스트 타입과 달리, 한 번 값이 정해지면 항목의 값을 변경할 수 없음  튜플 타입  \u0026lsquo;서로 다른 종류의 데이터 타입\u0026rsquo;으로 이루어진 항목들을 변수에 바로 풀어서 할당하거나 색인을 매길 때 사용  리스트 타입  \u0026lsquo;동일한 자료 타입\u0026rsquo;으로 이루어진 항목들을 리스트 내에서 순차적으로 추출할 때 사용  선언 및 사용  소괄호 기호(())로 감싸거나, 아예 감싸지 않는 방법으로 선언  card = 'red', 4, '다이아모든', True # 튜플 생성\rcard\r# ('red', 4, '다이아모늗', True) 출력\rcard[-1] = False # -\u0026gt; 불가능\r  빈 튜플 만들기  empty_tuple = ()\rempty_tuple2 = tuple()\r  항목이 하나 있는 튜플 생ㅇ성  one = ('하나')\rtype(one)\r# \u0026lt;class 'str'\u0026gt; 출력\rone_item = '하나',\rtype(one_item)\r# \u0026lt;class 'tuple'\u0026gt; 출력\r 튜플 패킹과 튜플 언패킹  튜플 패킹 : 문자열, 숫자, 논리 타입으로 이루어진 여러 개의 데이터가 하나의 튜플로 포장된 것 튜플 언패킹 : 튜플을 항목별로 각각 풀어서 변수에 저장하는 것  card = 'red', 4, '다이아몬드', True # 튜플 생성(패킹)\ra, b, c, d = card # 튜플 항목 개별 할당(언패킹)\ra # 'red' 출력\r 튜플 ↔ 리스트 card = 'red', 4, '다이아몬드', True\rcard_list = list(card)\rtype(card_list)\r\u0026lt;class 'list'\u0026gt;\r# ['red', 4, '다이아몬드', True]\rcard_tuple = tuple(card_list)\rtype(card_tuple)\r\u0026lt;class 'tuple'\u0026gt;\rcard_tuple\r# ('red', 4, '다이아몬드', True)\r 튜플은 append, index 삭제, 값 변경이 불가능하다.\n세트 개념 세트 타입은 데이터 중복을 허용하지 않고 순서가 없는 데이터 지합을 위한 데이터 타입\n선언 및 사용  쉼표 기호(,)로 구분된 항목을 중괄호 기호({})로 감싸는 것 \u0026lsquo;in\u0026rsquo; : 값이 있으면 Ture, 없으면 False 반환  languages = {'C++', 'Python', 'C', 'C', 'C++', 'Python'}\rlanguages\r# {'Python', 'C++', 'C'} 출력\r'Python' in languages\rTrue\r'R' in languages\rFalse\r  빈 세트 타입 생성  try_empty_set = {} # -\u0026gt; 이것은 딕셔너리 타입\rreal_empty_set = set() # -\u0026gt; 올바른 빈 세트 데이터 생성\r  사용 예제  a = set('abracadabra')\r# {'a', 'r', 'b', 'c', 'd'} 출력\rb = set('alacazam')\ra-b\r{'r', 'd', 'b'} # a와 b의 차집합\ra | b\r{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'} # a와 b의 합집합\ra \u0026amp; b\r{'a', 'c'} # a와 b의 교집합\ra^b\r{'r', 'd', 'b', 'm', 'z', 'l'} # a와 b의 여집합(합집합 - 교집합)\r 딕셔너리 개념  \u0026lsquo;딕셔너리 타입\u0026rsquo;은 전체 항목이 정렬되지 않은 키와 값의 쌍으로 구성된 데이터 모음 변경할 수 있는 데이터 타입 \u0026lsquo;키:값\u0026rsquo;의 형태로 표기하며 각 쌍은 쉼표 기호(,)로 구분하고 전체 집합은 중괄호 기호({})로 감사는 방식 딕셔너리에는 순서가 없어 생성한 순서대로 딕셔너리가 구성 중복된 키가 있을 경우 마지막에 있는 키를 적용  student1 = {'학번' : 1000, '이름' : '홍길동', '학번' : 2000}\r# {'학번' : 2000, '이름' : '홍길동'} 출력\r 선언 및 사용 programmer_dict = {'Python' : 5, 'C': 2, 'C++' : 3, 'JAVA' : 4}\rprogrammer_dict['Python']\r# 5 출력\r  값 변경 및 값 추가  programmer_dict['Python'] = 7\rprogrammer_dict['Python']\r# 7 출력\rprogrammer_dict['JvavScript'] = 1\r# {'Python' : 5, 'C': 2, 'C++' : 3, 'JAVA' : 4, 'JavaScript' : 1} 출력\r  키 값 확인 : 내장 함수 keys(), values 사용 반환 값은 dict_keys() 타입으로 반환되며 익숙한 리스트로 활용할 경우 lsit() 함수 활용  programmer_dict.keys()\rdict_keys(['Python', 'C', 'C++', 'Java', 'Ruby'])\rprogrammer_dict.values()\rdict_values([5, 2, 3, 4])\rlist(programmer_dict.keys())\r['Python', 'C', 'C++', 'Java', 'Ruby']\r  특정 키워드를 확인할 경우 \u0026lsquo;in\u0026rsquo; 사용  'Python' in programmer_dict\rTrue\r'R' not in programmer_dict\rTrue\r  특정 항목 삭제 : del / 전체 항목 삭제 : 내장 함수 clear()  del programmer_dict['Ruby']\rdel(programmer_dict['C++'], programmer_dict['C'])\rprogrammer_dict.clear()\r  없는 키를 찾을 때 \u0026lsquo;딕셔너리명[키]\u0026lsquo;를 사용하면 오류, 하지만 \u0026lsquo;딕셔너리.get(키)' 를 사용하면 아무것도 반환하지 않고 정상 실행 딕셔너리.items() 하면를 사용하면 튜플 형태로도 구할 수 있음  정렬 키로 정렬한 후 딕셔너리 추출\nimport operator # operator.itemgetter() 함수 사용을 위해 import\rtrainDic, trainList = {}, []\rtrainDic = {'Thomas' : '토마스', 'Edward' : '에드워드', 'Henry' : '헨리'}\rtrainList = sorted(trainDic.items(), key = operator.itemgetter(0))\r# 값으로 정렬을 원할시 0이아닌 1 입력\r 컴프리헨션  값이 순차적인 리스트를 한 줄로 만드는 간단한 방법 리스트 = [수식 for 항목 in range() if 조건식]  numList = [num for num in range(1, 6)]\rnumList # [1, 2, 3, 4, 5] 출력\rnumList = [num for num in range(1, 21) if num % 3 == 0]\rnumList # [3, 6, 9, 12, 15, 18] 출력\r 동시에 여러 리스트에 접근  zip() 함수를 사용해 동시에 여러 리스트에 접근  foods = ['떡볶이', '짜장면', '라면', '피자', '맥주', '치킨', '삼겹살']\rsides = ['오뎅', '단무지', '김치']\rfor food, side in zip(foods, sides) :\rprint(food, ' --\u0026gt; ', side)\r## 출력 결과 ##\r떡볶이 --\u0026gt; 오뎅\r짜장면 --\u0026gt; 단무지\r라면 --\u0026gt; 김치\r  두 리스트를 튜플이나 딕셔너리로 짝지을 때 zip() 함수 사용  tupList = list(zip(foods, sides))\rdic = dict(zip(foods, sides))\rtupList\rdic\r## 출력 결과 ##\r[('떡볶이', '오뎅'), ('짜장면', '단무지'), ('라면', '김치')]\r{'떡볶이': '오뎅', '짜장면': '단무지', '라면': '김치'}\r  얕은 복사의 방지  newList = oldList[:]\r ","id":33,"section":"posts","summary":"[Python 기초] - 튜플,세트 그리고 딕셔너리 다양한 데이터 타입 컴퓨터 자원의 효율적 사용을 위해 상황에 맞는 데이터 구조를 선택해야 질 높은 프로그램을 개발할 수 있음 튜플","tags":null,"title":"[Python 기초] - 튜플,세트 그리고 딕셔너리","uri":"http://blog.cmstown.com/2020/06/python_02_collections/","year":"2020"},{"content":"[Python 기초] - 리스트 리스트 기본  리스트 생성  리스트명 = [값1, 값2, 값3]\r  리스트의 색인  num_list = [3, 1, 5, 2]\r# 양수핼인 0 1 2 3\r# 음수색인 -4 -3 -2 -1\r  길이  len(num_list)\r# 4 출력\r  리스트 조작 함수   리스트 자르기  num_list = [3, 1, 5, 2]\rnum_list[1:3] # 1부터 2까지 자르기\r[1, 5]\rnum_list[:2] # 1까지 자르기\r[3, 1]\rnum_list[1:] # 1부터 자르기\r[1, 5, 2]\rnum_list[:] # 전체 복사\r[3, 1, 5, 2]\r  리스트의 덧셈/곱셈 연산  aa = [10, 20, 30]\rbb = [40, 50, 60]\raa + bb\raa * 3\r# 출력\r# [10, 20, 30, 40, 50, 60]\r# [10, 20, 30, 10, 20, 30, 10, 20, 30]\r  리스트의 항목 건너뛰며 추출  aa = [10, 20, 30, 40, 50, 60, 70]\raa[::2] # [10, 30, 50, 70]\raa[::-2] # [70, 50, 30, 10]\r  리스트 안에 리스트 넣기  aa = [10, 20, 30]\raa[1] = [200, 201]\raa\r[10, [200, 201], 30]\r  리스트 삭제  1. aa = []; # [] 출력\r2. aa = None; # 출력 없음\rex)\raa = [10, 20, 30, 40, 50]\raa[1:4] = []\r# [10, 50]\r  2차원 리스트  aa = [[1,2,3,4], [5,6,7,8], [9,10,11,12]]\r ","id":34,"section":"posts","summary":"[Python 기초] - 리스트 리스트 기본 리스트 생성 리스트명 = [값1, 값2, 값3] 리스트의 색인 num_list = [3, 1, 5, 2] # 양수핼인 0 1 2 3 # 음수색인 -4 -3 -2 -1 길이 len(num_list) # 4 출력","tags":null,"title":"[Python 기초] - 리스트","uri":"http://blog.cmstown.com/2020/06/python_01_list/","year":"2020"},{"content":"Observer pattern(옵저버 패턴) 이번에 학습할 디자인 패턴은 옵저버 패턴 입니다.\nObserver pattern(옵저버 패턴)이란? 위키에서는 다음과 같이 정의합니다.\n 옵서버 패턴(observer pattern)은 객체의 상태 변화를 관찰하는 관찰자들, 즉 옵저버들의 목록을 객체에 등록하여 상태 변화가 있을 때마다 메서드 등을 통해 객체가 직접 목록의 각 옵저버에게 통지하도록 하는 디자인 패턴이다. 주로 분산 이벤트 핸들링 시스템을 구현하는 데 사용된다. 발행/구독 모델로 알려져 있기도 하다.\n 예제와 함께 커맨드 패턴에 대해 자세히 알아보도록 하겠습니다.\n여러가지 방식으로 성적 출력하기 성적을 출력해주는 클래스가 다음과 같이 있다고 하자.\n  ScoreRecord 클래스: 점수를 저장/관리하는 클래스\n  DataSheetView 클래스: 점수를 목록형태로 출력하는 클래스\n  코드로 구현하면 다음과 같다.\npublic class Client {\rpublic static void main(String[] args) {\rScoreRecord scoreRecord = new ScoreRecord();\rDataSheetView dataSheetView = new DataSheetView(scoreRecord, 3);\rscoreRecord.setDataSheetView(dataSheetView);\rfor(int i = 1; i \u0026lt;= 5; i++){\rint score = i * 10;\rSystem.out.println(\u0026quot;Adding \u0026quot; + score);\rscoreRecord.addScore(score);\r}\r}\r}\rclass ScoreRecord {\rprivate List\u0026lt;Integer\u0026gt; scores = new ArrayList\u0026lt;\u0026gt;();\rprivate DataSheetView dataSheetView;\rpublic void setDataSheetView(DataSheetView dataSheetView){\rthis.dataSheetView = dataSheetView;\r}\rpublic void addScore(int score){\rthis.scores.add(score);\rdataSheetView.update();\r}\rpublic List\u0026lt;Integer\u0026gt; getScoredRecord(){\rreturn scores;\r}\r}\rclass DataSheetView {\rprivate ScoreRecord scoreRecord;\rprivate int viewCount;\rpublic DataSheetView(ScoreRecord scoreRecord, int viewCount) {\rthis.scoreRecord = scoreRecord;\rthis.viewCount = viewCount;\r}\rpublic void update(){\rList\u0026lt;Integer\u0026gt; record = scoreRecord.getScoredRecord();\rdisplayScore(record, viewCount);\r}\rpublic void displayScore(List\u0026lt;Integer\u0026gt; record, int viewCount){\rSystem.out.print(\u0026quot;List of \u0026quot; + viewCount + \u0026quot; entries: \u0026quot;);\rfor (int i = 0; i \u0026lt; viewCount \u0026amp;\u0026amp; i \u0026lt; record.size(); i++){\rSystem.out.println(record.get(i) + \u0026quot; \u0026quot;);\r}\rSystem.out.println();\r}\r}\r 해당 코드를 보고 다음과 같은 문제에 대해 고민해보자.\n  성적을 다른 방식으로 출력하고 싶다면 어떤 변경작업을 해야 하는가? 에를 들어 성적을 목록으로 출력하지 않고 최소/최대값만을 출력하려면?\n  성적을 동시에 여러 가지 형태로 출력하려면 어떤 변경 작업을 해야 하는가?\n  프로그램이 실행 시에 성적의 출력 대상이 변경되는 것을 지원한다면 어떤 변경 작업을 해야 하는가?\n  현재 코드에서 다음과 같은 작업을 할 경우, 뷰가 추가될때마다 ScoreRecord에 추가해줘야 하기 때문에 ScoreRecord가 지나치게 비대해지고, 이외에도 코드의 중복도 발생할 것이다.\n이에 성적 통보 대상이 변경되더라도 ScoreRecord 클래스를 그대로 재사용할 수 있도록 옵저버 패턴을 이용하여 클래스 구조를 바꿔보자.\n여러가지 방식으로 성적 출력하기(옵저버 패턴) 먼저 옵저버 패턴은\n위와 같은 클래스 구조로 이루어져야 한다.\n옵저버 패턴은 통보 대상 객체의 관리를 Subject 클래스와 Observer 인터페이스로 일반화한다. 그러면 데이터 변경을 통보하는 클래스(ConcreteSubject)는 통보 대상 클래스/객체ConcreteObserver)에 대한 의존성을 제거 할 수 있다. 결과적으로 옵저버 패턴은 통보 대상 클래스나 대상 객체의 변경에도 ConcreteSubject 클래스를 수정 없이 그대로 사용할 수 있도록 한다.\n옵저버 패턱을 적용하면 클래스 구조는 위와 같아집니다.\n그리고 코드는 다음과 같습니다.\ninterface Observer {\rabstract public void update();\r}\rabstract class Subject {\rprivate List\u0026lt;Observer\u0026gt; observers = new ArrayList\u0026lt;\u0026gt;();\rpublic void attach(Observer observer){\robservers.add(observer);\r}\rpublic void detach(Observer observer){\robservers.remove(observer);\r}\rpublic void notifyObservers(){\rfor (Observer o : observers) o.update();\r}\r}\rclass ScoreRecord extends Subject {\rprivate List\u0026lt;Integer\u0026gt; scores = new ArrayList\u0026lt;\u0026gt;();\rpublic void addScore(int score){\rthis.scores.add(score);\rnotifyObservers();\r}\rpublic List\u0026lt;Integer\u0026gt; getScoredRecord(){\rreturn scores;\r}\r}\rclass DataSheetView implements Observer {\rprivate ScoreRecord scoreRecord;\rprivate int viewCount;\rpublic DataSheetView(ScoreRecord scoreRecord, int viewCount) {\rthis.scoreRecord = scoreRecord;\rthis.viewCount = viewCount;\r}\rpublic void update(){\rList\u0026lt;Integer\u0026gt; record = scoreRecord.getScoredRecord();\rdisplayScore(record, viewCount);\r}\rpublic void displayScore(List\u0026lt;Integer\u0026gt; record, int viewCount){\rSystem.out.print(\u0026quot;List of \u0026quot; + viewCount + \u0026quot; entries: \u0026quot;);\rfor (int i = 0; i \u0026lt; viewCount \u0026amp;\u0026amp; i \u0026lt; record.size(); i++){\rSystem.out.println(record.get(i) + \u0026quot; \u0026quot;);\r}\rSystem.out.println();\r}\r}\rclass MinMaxView implements Observer {\rprivate ScoreRecord scoreRecord;\rpublic MinMaxView(ScoreRecord scoreRecord){\rthis.scoreRecord = scoreRecord;\r}\r@Override\rpublic void update() {\rList\u0026lt;Integer\u0026gt; record = scoreRecord.getScoredRecord();\rdisplayMinMax(record);\r}\rprivate void displayMinMax(List\u0026lt;Integer\u0026gt; record){\rint min = Collections.min(record, null);\rint max = Collections.max(record, null);\rSystem.out.println(\u0026quot;Min: \u0026quot; + min + \u0026quot; Max: \u0026quot; + max);\r}\r}\rpublic class Client {\rpublic static void main(String[] args) {\rScoreRecord scoreRecord = new ScoreRecord();\rDataSheetView dataSheetView3 = new DataSheetView(scoreRecord, 3);\rDataSheetView dataSheetView5 = new DataSheetView(scoreRecord, 5);\rMinMaxView minMaxView = new MinMaxView(scoreRecord);\rscoreRecord.attach(dataSheetView3);\rscoreRecord.attach(dataSheetView5);\rscoreRecord.attach(minMaxView);\rfor(int i = 1; i \u0026lt;= 5; i++){\rint score = i * 10;\rSystem.out.println(\u0026quot;Adding \u0026quot; + score);\rscoreRecord.addScore(score);\r}\r}\r}\r \n참고\n JAVA 객체지향 디자인 패턴   ","id":35,"section":"posts","summary":"Observer pattern(옵저버 패턴) 이번에 학습할 디자인 패턴은 옵저버 패턴 입니다. Observer pattern(옵저버 패턴)이란? 위키에서는 다음과 같이 정의합니다.","tags":null,"title":"[DesignPattern] Observer pattern(옵저버 패턴)","uri":"http://blog.cmstown.com/2020/06/08_observer_pattern/","year":"2020"},{"content":"Command pattern(커맨드 패턴) 이번에 학습할 디자인 패턴은 커맨드 패턴 입니다.\nCommand pattern(커맨드 패턴)이란? 위키에서는 다음과 같이 정의합니다.\n 커맨드 패턴(Command pattern)이란 요청을 객체의 형태로 캡슐화하여 사용자가 보낸 요청을 나중에 이용할 수 있도록 매서드 이름, 매개변수 등 요청에 필요한 정보를 저장 또는 로깅, 취소할 수 있게 하는 패턴이다.\n  커맨드 패턴에는 명령(command), 수신자(receiver), 발동자(invoker), 클라이언트(client)의 네개의 용어가 항상 따른다. 커맨드 객체는 수신자 객체를 가지고 있으며, 수신자의 메서드를 호출하고, 이에 수신자는 자신에게 정의된 메서드를 수행한다. 커맨드 객체는 별도로 발동자 객체에 전달되어 명령을 발동하게 한다. 발동자 객체는 필요에 따라 명령 발동에 대한 기록을 남길 수 있다. 한 발동자 객체에 다수의 커맨드 객체가 전달될 수 있다. 클라이언트 객체는 발동자 객체와 하나 이상의 커맨드 객체를 보유한다. 클라이언트 객체는 어느 시점에서 어떤 명령을 수행할지를 결정한다. 명령을 수행하려면, 클라이언트 객체는 발동자 객체로 커맨드 객체를 전달한다.\n 예제와 함께 커맨드 패턴에 대해 자세히 알아보도록 하겠습니다.\n만능 버튼 만들기 우리가 만능 버튼을 만들어야한다는 문제에 앞서, 일반적으로 램프와 버튼 관계의 클래스를 만들면 다음과 같이 만들 수 있습니다.\n이와 같이 클래스를 만들었을 때, 다음과 같은 문제점을 고민해봅시다.\n  버튼이 눌렸을 때 램프를 켜는 대신에 다른 기능을 수행하기 위해서는 어떤 변경 작업을 해야 되는가? 예를 들어 버튼이 눌리면 알람을 시작시키려면?\n  버튼이 눌렸을 때 수행되는 기능을 프로그램이 동작할 때 결정하기 위해서는?\n  \n이러한 문제점을 해결하기 위해 커맨드 패턴을 이용해봅시다.\n커맨드 패턴에는 총 4가지의 역할이 존재합니다.\n Invoker   기능의 실행을 요청하는 호출자 클래스  Command    실행될 기능에 대한 인터페이스\n  실행될 기능을 execute 메세드로 표현\n  ConcreteCommand   실제로 실행되는 기능을 구현(Command 구현 클래스)  Receiver   ConcreteCommand에서 execute 메소드를 구현할 때 필요한 클래스  그렇다면 위에 클래스에 4가지 역할을 대입하면 다음과 같습니다.\n Invoker - Button Command ConcreteCommand - LampOnCommand, AlarmStartCommand Receiver - Lamp, Alarm  결론적으로 다음과 같은 클래스 구조가 나옵니다.\n다음과 같은 클래스 구조를 갖게되면, 동적으로 command를 설정함과 동시에 여러 기능들을 추가적으로 구현하는데 어렵지않게 됩니다.\n\n참고\n JAVA 객체지향 디자인 패턴   ","id":36,"section":"posts","summary":"Command pattern(커맨드 패턴) 이번에 학습할 디자인 패턴은 커맨드 패턴 입니다. Command pattern(커맨드 패턴)이란? 위키에서는 다음과 같이 정의합니다.","tags":null,"title":"[DesignPattern] Command pattern(커맨드 패턴)","uri":"http://blog.cmstown.com/2020/06/07_command_pattern/","year":"2020"},{"content":"Sigleton pattern(싱글톤 패턴) 이번에 학습할 디자인 패턴은 싱글톤 패턴 입니다.\nSigleton pattern(싱글톤 패턴)이란? 위키에서는 다음과 같이 정의합니다.\n 싱글턴 패턴(Singleton pattern)을 따르는 클래스는, 생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나이고 최초 생성 이후에 호출된 생성자는 최초의 생성자가 생성한 객체를 리턴한다. 이와 같은 디자인 유형을 싱글턴 패턴이라고 한다. 주로 공통된 객체를 여러개 생성해서 사용하는 DBCP(DataBase Connection Pool)와 같은 상황에서 많이 사용된다.\n Sigleton pattern(싱글톤 패턴) 구현 방법? 싱글톤을 구현하는 방법에는 Eager Initialization, Static Block Initialization, Lazy Initialization, Thread Safe Singleton, Bill Pugh Singleton Implementaion, Enum Singleton 등 다양한 방법이 있습니다. 이중 가장 널리 쓰이는 Bill Pugh Singleton Implementaion 으로 구현하는 방법을 소개해드리도록 하겠습니다.\npublic class Singleton {\rprivate Singleton(){}\rprivate static class SingletonHelper{\rprivate static final Singleton INSTANCE = new Singleton();\r}\rpublic static Singleton getInstance(){\rreturn SingletonHelper.INSTANCE;\r}\r}\r 해당 코드는 synchronized를 사용하지 않기 때문에 성능 저하와 멀티 스레드의 환경에서 모두 유용하여 널리 쓰입니다.\n간략하게 싱글톤 패턴에 대해 소개해드렸는데, 싱글톤 패턴의 경우 무작정 사용하기보다는 정말 필요한 상황에서만 사용해야 메모리 관리면에서도 효율적으로 관리할 수 있습니다. 이점 참고하셔서 효율적인 코드 작성하셨으면 좋겠습니다. 감사합니다.\n\n출처\n [생성 패턴] 싱글톤(Singleton) 패턴을 구현하는 6가지 방법  ","id":37,"section":"posts","summary":"Sigleton pattern(싱글톤 패턴) 이번에 학습할 디자인 패턴은 싱글톤 패턴 입니다. Sigleton pattern(싱글톤 패턴)이란? 위키에서는 다음과 같이 정의합니다.","tags":null,"title":"[DesignPattern] Sigleton pattern(싱글톤 패턴)","uri":"http://blog.cmstown.com/2020/06/06_sigleton_pattern/","year":"2020"},{"content":"Strategy pattern(전략 패턴) 이번에 학습할 디자인 패턴은 전략 패턴 입니다.\nStrategy pattern(전략 패턴)이란? 위키에서는 다음과 같이 정의합니다.\n 전략 패턴(strategy pattern) 또는 정책 패턴(policy pattern)은 실행 중에 알고리즘을 선택할 수 있게 하는 행위 소프트웨어 디자인 패턴이다.\n 예제를 보고 이해해봅시다.\n예제 - 로봇 만들기 우리는 공격과 이동 기능이 있는 TaekwonV, Atom 로봇을 만든다고 가정하자, 그렇다면 다음과 같은 클래스 구조를 생각할 수 있다.\n해당 클래스를 보며 다음과 같은 문제에 대해 생각해보자.\n  새로운 로봇을 만들어 기존의 공격 또는 이동 방법을 추가하거나 수정하려면 어떻게 할까? 예를 들어 새로웃 로봇(선가드)를 만들어 태권V의 미사일 공격 기능을 추가하려면?\n  기존 로봇의 공격 또는 이동 방법을 수정하려면 어떤 변경 작업을 해야하는가?\n  먼저 기존의 클래스 구조를 따라서 새로운 로븟을 만들려면\n다음과 같은 클래스를 추가하면 된다. 그러나 로봇이 추가될 때 마다 attack과 move 메소드를 수정해주어야 하고, 로봇들이 같은 기능을 할 경우 코드의 중복이 많이 생길 것이다.\n이에 우리는 전략 패턴을 이용해보자.\n예제 - 로봇 만들기(전략 패턴 이용)  Robot의 멤버로 MovingStrategy와 AttackStrategy가 멤버 변수가 사진에서 누락되었습니다.  기존의 클래스 구조와 비교를 하면 MovingStrategy, AttackStrategy와 같은 인터페이스를 만들고, 해당 클래스들을의 구체 클래스를 만드는 것을 확인하실 수 있습니다. 이후 Robot클래세 setter을 이용하여 move와 attack의 동작을 달리 할 수 있게 하였습니다.\n이를 통해 추후 각 로봇들이 추가됨에 따라 반복되는 기능은 쉽게 구현할 수 있고, 기능들을 동적으로 변경할 수 있게 되었습니다.\n\n참고\n JAVA 객체지향 디자인 패턴   ","id":38,"section":"posts","summary":"Strategy pattern(전략 패턴) 이번에 학습할 디자인 패턴은 전략 패턴 입니다. Strategy pattern(전략 패턴)이란? 위키에서는 다음과 같이 정의합니다. 전략 패","tags":null,"title":"[DesignPattern] Strategy pattern(전략 패턴)","uri":"http://blog.cmstown.com/2020/06/05_strategy_pattern/","year":"2020"},{"content":"Abstract factory pattern(추상 팩토리 패턴) 이번에 학습할 디자인 패턴은 추상 팩토리 패턴 입니다.\n추상 팩토리 패턴이란? 위키에서는 다음과 같이 정의합니다.\n 추상 팩토리 패턴(Abstract factory pattern)은 다양한 구성 요소 별로 \u0026lsquo;객체의 집합\u0026rsquo;을 생성해야 할 때 유용하다. 이 패턴을 사용하여 상황에 알맞은 객체를 생성할 수 있다.\n 문장으로 이해하는 것보다 정확한 예제로 이해해봅시다!\n엘리베이터 부품 업체 변경하기 다음은 LG와 현대 업체의 모터와 문을 지원하는 클래스들의 다이어그램입니다.\nMotor, Door Class의 핵심 메소드는 다음과 같습니다.\nclass Motor{\rpublic void move(Direction direction){\r// 1) 이미 이동 중이면 무시한다.\r// 2) 만약 문이 열려 있으면 문을 닫는다.\r// 3) 모터를 구동해서 이동시킨다.\r// 4) 모터의 상태를 이동중으로 설정한다.\r}\r}\rclass Door{\rpublic void open(){\r// 1) 이미 문이 열려있으면 무시한다.\r// 2) 문을 연다 -\u0026gt; 이 부분만 LG, 현대에서 달라짐\r// 3) 문의 상태를 닫힘으로 설정한다.\r}\r 이를 유념하고, 위의 클래스다이어그램이 구현된 코드들을 살펴 봅시다.\nenum DoorStatus { CLOSED, OPENED }\rabstract class Door {\rprivate DoorStatus doorStatus;\rpublic Door() {\rthis.doorStatus = DoorStatus.CLOSED;\r}\rpublic DoorStatus getDoorStatus() {\rreturn doorStatus;\r}\rpublic void close() {\rif(doorStatus == DoorStatus.CLOSED)\rreturn;\rdoorStatus = DoorStatus.CLOSED;\r}\rprotected abstract void doClose();\rpublic void open() {\rif(doorStatus == DoorStatus.OPENED)\rreturn;\rdoorStatus = DoorStatus.OPENED;\r}\rprotected abstract void doOpen();\r}\rclass LGDoor extends Door{\r@Override\rprotected void doClose() {\rSystem.out.println(\u0026quot;close LG Door\u0026quot;);\r}\r@Override\rprotected void doOpen() {\rSystem.out.println(\u0026quot;open LG Door\u0026quot;);\r}\r}\rclass HyundaiDoor extends Door{\r@Override\rprotected void doClose() {\rSystem.out.println(\u0026quot;close Hyundai Door\u0026quot;);\r}\r@Override\rprotected void doOpen() {\rSystem.out.println(\u0026quot;open Hyundai Door\u0026quot;);\r}\r}\r 먼저 Door와 관련된 클래스들은 템플릿 메소드 패턴이 적용된 것을 확인하실 수 있습니다.\n이후 모터와 도어 클래스에 팩토리 메서드를 적용해보겠습니다.\nenum Direction { UP, DOWN }\renum VendorID { LG, HYUNDAI }\rclass MotorFactory{\rpublic static Motor createMotor(VendorID vendorID){\rMotor motor = null;\rswitch (vendorID){\rcase LG:\rmotor = new LGMotor();\rbreak;\rcase HYUNDAI:\rmotor = new HyundaiMotor();\rbreak;\r}\rreturn motor;\r}\r}\rclass DoorFactory{\rpublic static Door createDoor(VendorID vendorID){\rDoor door = null;\rswitch (vendorID){\rcase HYUNDAI:\rdoor = new HyundaiDoor();\rbreak;\rcase LG:\rdoor = new LGDoor();\rbreak;\r}\rreturn door;\r}\r}\renum MotorStatus { MOVING, STOPPED }\rabstract class Motor {\rprivate MotorStatus motorStatus;\rprivate Door door;\rpublic Motor(){\rmotorStatus = MotorStatus.STOPPED;\r}\rpublic MotorStatus getMotorStatus(){\rreturn this.motorStatus;\r}\rpublic void setMotorStatus(MotorStatus motorStatus){\rthis.motorStatus = motorStatus;\r}\rpublic void move(Direction direction){\rMotorStatus motorStatus = getMotorStatus();\rif(motorStatus == motorStatus.MOVING){\rreturn;\r}\rdoor.close();\rmoveMotor(direction);\rsetMotorStatus(MotorStatus.MOVING);\r}\rprotected abstract void moveMotor(Direction direction);\rpublic void stop(){\rmotorStatus = MotorStatus.STOPPED;\r}\rpublic void setDoor(Door door){\rthis.door = door;\r}\r}\rclass LGMotor extends Motor{\r@Override\rprotected void moveMotor(Direction direction) {\rSystem.out.println(\u0026quot;move LG Motor \u0026quot; + direction);\r}\r}\rclass HyundaiMotor extends Motor{\r@Override\rprotected void moveMotor(Direction direction) {\rSystem.out.println(\u0026quot;move Hyundai Motor\u0026quot; + direction);\r}\r}\rpublic class Client {\rpublic static void main(String[] args) {\rDoor lgDoor = DoorFactory.createDoor(VendorID.LG);\rMotor lgMotor = MotorFactory.createMotor(VendorID.LG);\rlgMotor.setDoor(lgDoor);\rlgDoor.open();\rlgMotor.move(Direction.UP);\r}\r}\r 이전에 배웠던 패턴들을 이용해보았는데, 이를 통해 부품의 교체가 수월해 보입니다. 그러나 현재는 Door와 Motor의 부품만 필요로하는데, 그 외 여러가지 부품들이 필요한 경우 에는 어떻게 대응해야 할까요?\n예를 들어 총 8개의 부품이 추가된다면, 다음과 같이 8개의 Factory Class들을 만들어야 할 것입니다.\n이렇게 되면 부품이 생길 때마다 팩토리 클래스를 만들어야 해서 코드의 복잡도는 더 커질 것입니다. 이에 해결책으로 다음과 같은 방법을 정의하였습니다.\n위 다이어그램은 부품이 아니라 제조업체 별로 팩토리를 정의하였습니다.\n이를 소스코드로 보면 다음과 같습니다.\nabstract class ElevatorFactory{\rpublic abstract Motor createMotor();\rpublic abstract Door createDoor();\r}\rclass LGElevatorFactory extends ElevatorFactory{\r@Override\rpublic Motor createMotor() {\rreturn new LGMotor();\r}\r@Override\rpublic Door createDoor() {\rreturn new LGDoor();\r}\r}\rclass HyundaiElevatorFactory extends ElevatorFactory{\r@Override\rpublic Motor createMotor() {\rreturn new HyundaiMotor();\r}\r@Override\rpublic Door createDoor() {\rreturn new HyundaiDoor();\r}\r}\rpublic class Client {\rpublic static void main(String[] args) {\rElevatorFactory elevatorFactory = new LGElevatorFactory();\rDoor door = elevatorFactory.createDoor();\rMotor motor = elevatorFactory.createMotor();\rmotor.setDoor(door);\rdoor.open();\rmotor.move(Direction.UP);\r}\r}\r 부품별로 팩토리를 만드는 것이 아닌 제조사별로 팩토리 클래스를만들어 비교적 간겨한 코드가 작성되었습니다.\n추가적으로 삼성 엘리베이터가 다음과 같이 추가된다면 어떻게할까요?\n이는 다른 코드와 마찬가지로 다음과 같이 코드를 작성할 것입니다.\nclass SamsungElevatorFactory extends ElevatorFactory{\r@Override\rpublic Motor createMotor() {\rreturn new SamsungMotor();\r}\r@Override\rpublic Door createDoor() {\rreturn new SamsungDoor();\r}\r}\rclass SamsungDoor extends Door{\r@Override\rprotected void doClose() {\rSystem.out.println(\u0026quot;close Samsung Door\u0026quot;);\r}\r@Override\rprotected void doOpen() {\rSystem.out.println(\u0026quot;open Samsung Door\u0026quot;);\r}\r}\rclass SamsungMotor extends Motor{\r@Override\rprotected void moveMotor(Direction direction) {\rSystem.out.println(\u0026quot;moce Samsung Motor\u0026quot;);\r}\r}\rpublic class Client {\rpublic static void main(String[] args) {\rElevatorFactory elevatorFactory = new SamsungElevatorFactory();\rDoor door = elevatorFactory.createDoor();\rMotor motor = elevatorFactory.createMotor();\rmotor.setDoor(door);\rdoor.open();\rmotor.move(Direction.UP);\r}\r}\r 손 쉽게 다른 제조업체의 엘리베이터도 추가할 수 있습니다! 그러면 이제 이제까지 배웠던 디자인 패턴들을 적용하여 더 코드를 효율적이게 만들지 생각해보면 더 좋은 학습니다. 예를들어, Factory 클래스를 생성하는 부분을 팩토리 메소드 패턴을 적용하여 설계하자. 그리고 제조업체 별 팩토리는 1개만 필요하다면, 싱글톤 패턴을 적용해보면 보다 더 간결하고 명확한 다이어그램이 그려질 겁니다. 해당 코드는 오늘 다루지않겠지만 모두 시간이되면 고민해보고 적용해보시면 좋을 것 같습니다!\n\n참고\n JAVA 객체지향 디자인 패턴   ","id":39,"section":"posts","summary":"Abstract factory pattern(추상 팩토리 패턴) 이번에 학습할 디자인 패턴은 추상 팩토리 패턴 입니다. 추상 팩토리 패턴이란? 위키에서는 다음과 같이 정의합니다. 추상 팩","tags":null,"title":"[DesignPattern] Abstract factory pattern(추상 팩토리 패턴)","uri":"http://blog.cmstown.com/2020/06/04_abstact_factory_pattern/","year":"2020"},{"content":"RESTful API를 설계할 때 내가 만난 대부분은 주로 \u0026ldquo;수정\u0026rdquo; 기능에 대헤 PUT 을 사용하게 됩니다. 그러나 수정할 때 무조건 PUT 을 이용하는 것을 옳지 못한 방법입니다. 수정할 때는 PUT 말고 PATCH 가 있는데, 오늘 이 둘의 차이점을 간략하게 소개하고자 합니다.\nPUT  자원의 전체 수정, 자원내 모든 필드가 필요하다.\n PATCH  자원의 일부분 수정, 자원내 일부 필드가 필요하다.\n 예를 들어, 다음과 같은 User 정보가 있다고 가정해봅시다.\n{ name : \u0026quot;test_name\u0026quot; nickname : \u0026quot;test_nickname\u0026quot; email : \u0026quot;test@test.com\u0026quot; }  /users/{userId} URl에 PUT과 PATCH 로 다음과 같이 수정된 값을 요청해보면\n{ \u0026quot;nickname\u0026quot;: \u0026quot;test_nicknmae2\u0026quot; }  먼저 PUT의 경우에는\n{ name : null nickname : \u0026quot;test_nickname2\u0026quot; email : null }  PATCH는\n{ name : \u0026quot;test_name\u0026quot; nickname : \u0026quot;test_nickname2\u0026quot; email : \u0026quot;test@test.com\u0026quot; }  로 보내게됩니다. 위의 상황에서 PUT은 자원의 전체를 보내지않고 일부분만 보내게되면 나머지 데이터가 유실된채 null값이 들어가게 됩니다. 그렇기에 수정할 때 무조건적으로 PUT을 사용하는게 아닌, 적절하게 PUT과 PATCH를 이용하여 사용해야된다는 것을 알 수 있습니다.\n사실 너무 당연한 이야기로 들리시는 분들도 있지만, 의외로 모르시는 분들이 많아 포스팅을 간략하게 작성해보았습니다. 오해가 있을만한 정보가 있거나 궁금한게 있으시면 언제든지 댓글 남겨주세요🙋‍♂️\n","id":40,"section":"posts","summary":"RESTful API를 설계할 때 내가 만난 대부분은 주로 \u0026ldquo;수정\u0026rdquo; 기능에 대헤 PUT 을 사용하게 됩니다. 그러나 수정할 때 무조건 PUT 을 이용하는 것을 옳지","tags":null,"title":"[HTTP Method] PUT과 PATCH의 차이점","uri":"http://blog.cmstown.com/2020/06/put_vs_patch/","year":"2020"},{"content":"Factory method pattern(팩토리 메소드 패턴) 이번에 학습할 디자인 패턴은 \u0026ldquo;팩토리 메소드 패턴\u0026rdquo; 입니다.\n팩토리 메소드 메서드 패턴이란? 위키에서는 다음과 같이 설명합니다.\n Factory method는 부모(상위) 클래스에 알려지지 않은 구체 클래스를 생성하는 패턴이며. 자식(하위) 클래스가 어떤 객체를 생성할지를 결정하도록 하는 패턴이기도 하다. 부모(상위) 클래스 코드에 구체 클래스 이름을 감추기 위한 방법으로도 사용한다.\n 이번에도 역시나 예제로 자세히 살펴보도록 합시다.\n\n여러 방식의 엘리베이터 스케줄링 방법 지원하기(일반) 엘리베이터 제어 시스템에서 다양한 엘리베이터 스케줄링을 지원한다고 했을 때, 다음과 같은 구조의 클래스가 있다고 가정해봅시다.\n  ElevatorManager Class : 여러 엘리베이터 중에서 스케줄링에 따라서 하나의 엘리베이터를 선택하고 이동시킴\n  EleveatorController Class : 하나의 엘리베이터 이동을 제어하는 클래스\n  ThroughputScheduler Class : 처리량을 기준으로 스케줄링하는 클래스\n  코드로 표현하면, 다음과 같습니다.\nenum Direction {UP, DOW}\rclass ElevatorManager {\rprivate List\u0026lt;ElevatorController\u0026gt; controllers;\rprivate ThroughputScheduler scheduler;\rpublic ElevatorManager(int controllerCount){\rcontrollers = new ArrayList\u0026lt;ElevatorController\u0026gt;(controllerCount);\rfor(int i = 0; i \u0026lt; controllerCount; i++){\rElevatorController controller = new ElevatorController(i);\rcontrollers.add(controller);\r}\rscheduler = new ThroughputScheduler();\r}\rpublic void requestElevator(int destination, Direction direction){\rint selectedElevator = scheduler.selectElevator(this, destination, direction);\rcontrollers.get(selectedElevator).gotoFloor(destination);\r}\r}\rclass ElevatorController {\rprivate int id;\rprivate int curFloor;\rpublic ElevatorController(int id) {\rthis.id = id;\rcurFloor = 1;\r}\rpublic void gotoFloor(int destination){\rSystem.out.println(\u0026quot;Elevator [\u0026quot; + id + \u0026quot;] Floor: \u0026quot; + curFloor);\rcurFloor = destination;\rSystem.out.println(\u0026quot; ==\u0026gt; \u0026quot; + curFloor);\r}\r}\rclass ThroughputScheduler {\rpublic int selectElevator(ElevatorManager manager, int destination, Direction direction){\r// 실제 구현하지는 않음\rreturn 0;\r}\r}\rpublic class Client {\rpublic static void main(String[] args) {\rElevatorManager em = new ElevatorManager(1);\rem.requestElevator(4, Direction.UP);\r}\r}\r 먼저 코도를 잘 읽어가며 각 클래스들의 기능들을 자세히 파악해봅시다. 이후 다음과 문제점을 어떻게 해결할지 생각해봅시다.\n  🙋‍♂️문제점\n  현대 ElevatorManager는 ThroughputScheduler를 이용하고 있다. 즉 엘리베이터의 처리량을 최대화시키는 전략을 사용하고 있다. 만약 다른 스케쥴링 전략을 사용해야 한다면? 예를 들어 사용자의 대기시간을 최소화시키는 엘리베이터를 선택하는 전략을 사용해야 한다면?\n  스케쥴링 전략이 프로그램 실행 중에 변경을 해야 한다면? 즉, 동적 스케쥴링을 지원해야 한다면 어떻게 해야할까? 예를 들어 오전에는 대기시간 최소화 전략을 사용하고 오후에는 처리량 최대화 전략을 사용해야 한다면?\n    먼저 기존에 자주 사용하는 패턴으로 \u0026ldquo;Strategy Patter(전략 패턴)\u0026rdquo; 을 생각하기 쉽습니다. 그렇다면 해당 패턴으로 위와 같은 문제를 해결해봅시다!\n\n여러 방식의 엘리베이터 스케줄링 방법 지원하기(Strategy patter 적용) 스트래티지 패턴을 적용하면, 다음과 같이 클래스 구조가 나오게 됩니다.\n위의 다이어그램에서 ElevatorController가 표현되어있지 않지만, ElevatorManager와 연결되어있다고 생각하고 보면 된다.\n해당 구조를 보면 ElevatorSheduler를 구현한 클래스들이 생겨서, 위의 문제점을 해결할 수 있을 것으로 보입니다. 실제 코드를 봐볼까요?\ninterface ElevatorScheduler {\rpublic int selectElevator(ElevatorManager manager, int destination, Direction direction);\r}\rclass ThroughputScheduler implements ElevatorScheduler{\r@Override\rpublic int selectElevator(ElevatorManager manager, int destination, Direction direction){\r// 실제 구현하지는 않음\rreturn 0;\r}\r}\rclass ResponseTimeScheduler implements ElevatorScheduler {\r@Override\rpublic int selectElevator(ElevatorManager manager, int destination, Direction direction) {\r// 실제 구현하지는 않음\rreturn 1;\r}\r}\renum Direction {UP, DOW}\rclass ElevatorManager {\rprivate List\u0026lt;ElevatorController\u0026gt; controllers;\rpublic ElevatorManager(int controllerCount){\rcontrollers = new ArrayList\u0026lt;ElevatorController\u0026gt;(controllerCount);\rfor(int i = 0; i \u0026lt; controllerCount; i++){\rElevatorController controller = new ElevatorController(i);\rcontrollers.add(controller);\r}\r}\rpublic void requestElevator(int destination, Direction direction){\rElevatorScheduler scheduler;\rint hour = Calendar.getInstance().get(Calendar.HOUR_OF_DAY);\rif(hour \u0026lt; 12) {\rscheduler = new ResponseTimeScheduler();\r}\relse{\rscheduler = new ThroughputScheduler();\r}\rint selectedElevator = scheduler.selectElevator(this, destination, direction);\rcontrollers.get(selectedElevator).gotoFloor(destination);\r}\r}\r 확실히 이전 문제점을 해결한 것 같습니다. 그러나 ElevatorManager의 requestElevator method를 자세히 살펴보도록 하겠습니다. requestElevator()는 이미 선택된 전략을가지고 엘리베이터를 이동시키는 것이 해당 메소드의 책임입니다. 그런데 현재 코드에서는 전략까지 해당 메소드에서 선택하기 때문에 함수 설계 원칙에 어긋나게 됩니다.\nint hour = Calendar.getInstance().get(Calendar.HOUR_OF_DAY);\rif(hour \u0026lt; 12) {\rscheduler = new ResponseTimeScheduler();\r}\relse{\rscheduler = new ThroughputScheduler();\r}\r 위의 코드는 requestElevator에 있으면 옳은 방법은 아닙니다. 예를들어 현재 오전/오후에 나누어져 스케쥴러를 다르게 하지만, 특별한 공휴일, 평일, 주말마다 다르게 구현하기 위해서는 현재의 코드로는 표현하기 무리가 있어 보입니다. 그렇기에 전략을 선택하는 기능 을 분리하는게 좋아보입니다.\n\n여러 방식의 엘리베이터 스케줄링 방법 지원하기(Factory method pattern 적용) 팩토리 메소드 패턴을 이용하여 스케줄링 전략에 맞는 객체를 생성하는 코드를 별도로 정의하여봅시다. 그러면 다음과 같은 구조가 나오게 됩니다.\n기존의 클래스들에 SchedulerFactory가 추가된 것을 확인하실 수 있습니다. 해당 클래스에서는 전략들을 생성하는 알고리즘에 의해서 만들어진 Schedular를 반환하게끔 합니다. 즉, 스케줄러를 선택하는 행위는 SchedulerFactory가 하게 됩니다.\n이를 실제 코드로 살펴보도록 하겠습니다!\nenum Direction {UP, DOWN}\rclass ElevatorManager {\rprivate List\u0026lt;ElevatorController\u0026gt; controllers;\rprivate SchedulingStrategyID strategyID;\rpublic ElevatorManager(int controllerCount, SchedulingStrategyID strategyID){\rcontrollers = new ArrayList\u0026lt;ElevatorController\u0026gt;(controllerCount);\rfor(int i = 0; i \u0026lt; controllerCount; i++){\rElevatorController controller = new ElevatorController(i);\rcontrollers.add(controller);\r}\rthis.strategyID = strategyID;\r}\rpublic void setStrategyID(SchedulingStrategyID strategyID){\rthis.strategyID = strategyID;\r}\rpublic void requestElevator(int destination, Direction direction){\rElevatorScheduler scheduler = SchedulerFactory.getScheduler(strategyID);\rSystem.out.println(scheduler);\rint selectedElevator = scheduler.selectElevator(this, destination, direction);\rcontrollers.get(selectedElevator).gotoFloor(destination);\r}\r}\rclass ElevatorController {\rprivate int id;\rprivate int curFloor;\rpublic ElevatorController(int id) {\rthis.id = id;\rcurFloor = 1;\r}\rpublic void gotoFloor(int destination){\rSystem.out.println(\u0026quot;Elevator [\u0026quot; + id + \u0026quot;] Floor: \u0026quot; + curFloor);\rcurFloor = destination;\rSystem.out.println(\u0026quot; ==\u0026gt; \u0026quot; + curFloor);\r}\r}\renum SchedulingStrategyID {RESPONSE_TIME, THROUGHPUT, DYNAMIC}\rclass SchedulerFactory {\rpublic static ElevatorScheduler getScheduler(SchedulingStrategyID strategyID){\rElevatorScheduler scheduler = null;\rswitch (strategyID) {\rcase RESPONSE_TIME:\rscheduler = new ResponseTimeScheduler();\rbreak;\rcase THROUGHPUT:\rscheduler = new ThroughputScheduler();\rbreak;\rcase DYNAMIC: {\rint hour = Calendar.getInstance().get(Calendar.HOUR_OF_DAY);\rif(hour \u0026lt; 12) {\rscheduler = new ResponseTimeScheduler();\r}\relse{\rscheduler = new ThroughputScheduler();\r}\rbreak;\r}\r}\rreturn scheduler;\r}\r}\rinterface ElevatorScheduler {\rpublic int selectElevator(ElevatorManager manager, int destination, Direction direction);\r}\rclass ThroughputScheduler implements ElevatorScheduler{\r@Override\rpublic int selectElevator(ElevatorManager manager, int destination, Direction direction){\r// 실제 구현하지는 않음\rreturn 0;\r}\r}\rclass ResponseTimeScheduler implements ElevatorScheduler {\r@Override\rpublic int selectElevator(ElevatorManager manager, int destination, Direction direction) {\r// 실제 구현하지는 않음\rreturn 1;\r}\r}\rpublic class Client {\rpublic static void main(String[] args) {\rElevatorManager emWithResponseTimerScheduler = new ElevatorManager(2, SchedulingStrategyID.RESPONSE_TIME);\remWithResponseTimerScheduler.requestElevator(10, Direction.UP);\rElevatorManager emWithThroughputScheduler = new ElevatorManager(2, SchedulingStrategyID.RESPONSE_TIME);\remWithThroughputScheduler.requestElevator(10, Direction.UP);\rElevatorManager emWithDynamicScheduler = new ElevatorManager(2, SchedulingStrategyID.RESPONSE_TIME);\remWithDynamicScheduler.requestElevator(10, Direction.UP);\r}\r}\r SchedulerFactory Class를 보면 확실히 이전과 다르게 스케줄러를 선택하는 책임이 분리가 되는 것을 확인하실 수 있습니다.\n추가적으로 스케줄러는 지속적으로 사용되기 때문에 각각의 스케줄러를 싱글톤 패턴까지 적용하면 더 성능적으로 효율적인 구조가 될 수 있습니다. 그러나 오늘 이 시간에서는 팩토리 메소드 패턴을 설명하기 위한 시간이기 때문에, 생략하고 이 부분은 스스로 고민하시고 적용해보시면 좋을 것 같습니다:D\n더불어 팩토리 메소드 패턴은 상속을 이용하여 구현을 할 수도 있는데 간단하게만 설명하도록 하겠습니다.\n디자인 패턴을 구현하는데 절대적인 방법은 없습니다. 디자인 패턴은 다양한 방법으로 적용할 수 있기에 예제에 나온 방법만 생각하시지마시고 원론적인 부분을 이해하여 필요할 때 실제 프로젝트에 적용하며 학습하시면 좋을 것 같습니다.\n\n결과적으로 위의 과정을 통해서 Factory method pattern을 이용하면 객체의 생성 코드를 별도의 클래스/메소드로 분리함으로써 객체 생성의 변화를 대비하는데 굉장히 유용한 것을 알 수 있었습니다.\n\n참고\n JAVA 객체지향 디자인 패턴   ","id":41,"section":"posts","summary":"Factory method pattern(팩토리 메소드 패턴) 이번에 학습할 디자인 패턴은 \u0026ldquo;팩토리 메소드 패턴\u0026rdquo; 입니다. 팩토리 메소드 메서드 패턴이란","tags":null,"title":"[DesignPattern] Factory method pattern(팩토리 메소드 패턴)","uri":"http://blog.cmstown.com/2020/06/03_factory_method_pattern/","year":"2020"},{"content":"Template Method Pattern(템플릿 메소드 패턴) 이번에 학습할 디자인 패턴은 \u0026ldquo;템플릿 메소드 패턴\u0026rdquo; 입니다.\n템플릿 메서드 패턴이란?  알고리즘의 구조를 변경하지 않고 알고리즘의 특정 단계들을 다시 정의할 수 있게 해준다.\n 위의 내용은 위키에 나온 정의입니다. 해당 문장을 다시 표현하자면 \u0026ldquo;구현시 달라질 수 있는 메소드들을 구현클래스에서 선언 후 호출\u0026quot;하는 디자인 패턴입니다.\n백문이 불여일견, 같이 예제를 가지고 살펴보도록 합시다.\n엘레베이터 제어 시스템에서 모터를 구동시키는 기능(일반 ver) 엘레베이터 제어 시스템에서 도터를 구동시킬 떄 여러 회사의 모터를 지원하기 위해서는 어떻게 할까?\n먼저 다음과 같은 구조의 클래스가 있다고 생각해봅시다.\n HyundiaMotor Class : 모터를 제어하여 엘리베이터를 이동시키는 클래스가 Door Class : 문을 열거나 다는 기능을 제공하는 클래스  이를 코드로 표현하면 다음과 같습니다\nenum DoorStatus { CLOSED, OPENED }\renum MotorStatus { MOVING, STOPPED }\renum Direction { UP, DOWN }\rclass Door {\rprivate DoorStatus doorStatus;\rpublic Door() {\rthis.doorStatus = DoorStatus.CLOSED;\r}\rpublic DoorStatus getDoorStatus() {\rreturn doorStatus;\r}\rpublic void close() {\rdoorStatus = DoorStatus.CLOSED;\r}\rpublic void open() {\rdoorStatus = DoorStatus.OPENED;\r}\r}\rclass HyundaiMotor {\rprivate Door door;\rprivate MotorStatus motorStatus;\rpublic HyundaiMotor(Door door) {\rthis.door = door;\rthis.motorStatus = MotorStatus.STOPPED;\r}\rprivate void moveHyundaiMotor(Direction direction){\rSystem.out.println(\u0026quot;Hyundai Motor 구동\u0026quot;);\r}\rpublic MotorStatus getMotorStatus() {\rreturn motorStatus;\r}\rprivate void setMotorStatus(MotorStatus motorStatus){\rthis.motorStatus = motorStatus;\r}\rpublic void move(Direction direction){\rMotorStatus motorStatus = getMotorStatus();\rif(motorStatus == MotorStatus.MOVING)\rreturn;\rDoorStatus doorStatus = door.getDoorStatus();\rif(doorStatus == DoorStatus.OPENED)\rdoor.close();\rmoveHyundaiMotor(direction);\rsetMotorStatus(MotorStatus.MOVING);\r}\r}\r 위와 같은 코드를 가지고 실제 현대모터를 가지고 윗층으로 이동시키는 코드를 작성하면\npublic class Client {\rpublic static void main(String[] args) {\rDoor door = new Door();\rHyundaiMotor hyundaiMotor = new HyundaiMotor(door);\rhyundaiMotor.move(Direction.UP);\r}\r}\r 다음과 같이 구현할 수 있습니다.\n지금까지 현대 모터를 가지고 실행되는 엘리베이터를 만들었는데, 어떠한 상황이 생겨서 LG 모터를 사용해야 한다고 생각해봅시다. 어떻게 해야할까요?\n먼저 LG Moter라는 클래스를 다음과 같이 구현할 것입니다.\nclass LGMoter {\rprivate Door door;\rprivate MotorStatus motorStatus;\rpublic LGMoter(Door door) {\rthis.door = door;\rthis.motorStatus = MotorStatus.STOPPED;\r}\rprivate void moveLGMoter(Direction direction){\rSystem.out.println(\u0026quot;LG Motor 구동\u0026quot;);\r}\rpublic MotorStatus getMotorStatus() {\rreturn motorStatus;\r}\rprivate void setMotorStatus(MotorStatus motorStatus){\rthis.motorStatus = motorStatus;\r}\rpublic void move(Direction direction){\rMotorStatus motorStatus = getMotorStatus();\rif(motorStatus == MotorStatus.MOVING)\rreturn;\rDoorStatus doorStatus = door.getDoorStatus();\rif(doorStatus == DoorStatus.OPENED)\rdoor.close();\rmoveLGMoter(direction);\rsetMotorStatus(MotorStatus.MOVING);\r}\r}\r 이렇게 구현하면 LGMoter도 마찬가지로 사용가능하게 될겁니다. 그러나 코드를 보면 MoveLGMoter 메소드말고는 바뀐 부분이 없습니다. 이는 OCP 원칙에 위배됩니다. 그래서 다음과 같이 클래스 구조를 변경할 것입니다.\n이렇게 하면 OCP원칙을 지키며 모터를 상속만해주면 다양한 모터들을 구현할 수 있는 것으로 보입니다. 코드로 구현하면 다음과 같습니다.\nabstract class Motor {\rprotected Door door;\rprivate MotorStatus motorStatus;\rpublic Motor(Door door) {\rthis.door = door;\rmotorStatus = MotorStatus.STOPPED;\r}\rpublic MotorStatus getMotorStatus() {\rreturn motorStatus;\r}\rprotected void setMotorStatus(MotorStatus motorStatus) {\rthis.motorStatus = motorStatus;\r}\r}\rclass HyundaiMotor extends Motor {\rpublic HyundaiMotor(Door door) {\rsuper(door);\r}\rprivate void moveHyundaiMotor(Direction direction){\rSystem.out.println(\u0026quot;Hyundai Motor 구동\u0026quot;);\r}\rpublic void move(Direction direction){\rMotorStatus motorStatus = getMotorStatus();\rif(motorStatus == MotorStatus.MOVING)\rreturn;\rDoorStatus doorStatus = door.getDoorStatus();\rif(doorStatus == DoorStatus.OPENED)\rdoor.close();\rmoveHyundaiMotor(direction);\rsetMotorStatus(MotorStatus.MOVING);\r}\r}\rclass LGMoter extends Motor {\rpublic LGMoter(Door door) {\rsuper(door);\r}\rprivate void moveLGMoter(Direction direction){\rSystem.out.println(\u0026quot;LG Motor 구동\u0026quot;);\r}\rpublic void move(Direction direction){\rMotorStatus motorStatus = getMotorStatus();\rif(motorStatus == MotorStatus.MOVING)\rreturn;\rDoorStatus doorStatus = door.getDoorStatus();\rif(doorStatus == DoorStatus.OPENED)\rdoor.close();\rmoveLGMoter(direction);\rsetMotorStatus(MotorStatus.MOVING);\r}\r}\r 비교적 깔끔해진 코드를 볼 수있습니다. 그러나 자세히 move 메소드를 살펴보면 현대와 LG 모터 모두 똑같은 코드가 중복되는 부분이 보입니다. 지금 2개의 모터를 예제로 들었지만 이후 10개,100개의 모터와 호환이 되어야한다면 수 많은 코드가 중복되어 해당 로직이 변경된다고 하면 10번, 100번 넘게 코드를 수정해야하는 높은 유지보수 비용이 발생합니다. 그렇다면 어떻게 이를 대처할까요?\n엘레베이터 제어 시스템에서 모터를 구동시키는 기능(템플릿 메소드 패턴 적용 ver) 이러한 상황에서 템플릿 메소드 패턴을 활용하는 것을 살펴보도록 하겠습니다. 패턴을 적용하면 다음과 같은 구조가 나오게 됩니다.\n얼핏 보면 크게 달라진게 없어보이지만, Motor 추상 클래스에 move와 moveMotor 메소드가 추가된것을 확인하실 수 있습니다. 이를 코드를 통해 자세히 확인해봅시다.\nabstract class Motor {\rprivate Door door;\rprivate MotorStatus motorStatus;\rpublic Motor(Door door) {\rthis.door = door;\rmotorStatus = MotorStatus.STOPPED;\r}\rpublic MotorStatus getMotorStatus() {\rreturn motorStatus;\r}\rprivate void setMotorStatus(MotorStatus motorStatus) {\rthis.motorStatus = motorStatus;\r}\rpublic void move(Direction direction){\rMotorStatus motorStatus = getMotorStatus();\rif(motorStatus == MotorStatus.MOVING)\rreturn;\rDoorStatus doorStatus = door.getDoorStatus();\rif(doorStatus == DoorStatus.OPENED)\rdoor.close();\rmoveMotor(direction);\rsetMotorStatus(MotorStatus.MOVING);\r}\rprotected abstract void moveMotor(Direction direction);\r}\rclass HyundaiMotor extends Motor {\rpublic HyundaiMotor(Door door) {\rsuper(door);\r}\rpublic void moveMotor(Direction direction){\rSystem.out.println(\u0026quot;Hyundai Motor 구동\u0026quot;);\r}\r}\rclass LGMotor extends Motor {\rpublic LGMotor(Door door) {\rsuper(door);\r}\rpublic void moveMotor(Direction direction){\rSystem.out.println(\u0026quot;LG Motor 구동\u0026quot;);\r}\r}\r Motor 추상 클래스에 move메소드를 구현하고 moveMotor 추상 메소드를 활용하여 HyudaMotor와 LGMotor가 훨씬 간소해졌습니다. 뿐만 아니라 전체적인 코드량도 감소하였고, move의 로직이 변경될 떄 Motor의 move 메소드만 변경하면되서 유지보스 측면에서도 훨씬 좋아졌습니다.\n위와 같은 상황을 보았을 떄, 템플릿 메소드 패턴을 활용하면 전체적인 알고리즘을 구현하면서 상이한 부분은 하위 클래스에서 구현할 수 있도록 해 주는 디자인 패턴으로서 전체적인 알고리즘의 코드를 재사용하는데 유용하다는 것을 알 수 있었습니다.\n참고\n JAVA 객체지향 디자인 패턴   ","id":42,"section":"posts","summary":"Template Method Pattern(템플릿 메소드 패턴) 이번에 학습할 디자인 패턴은 \u0026ldquo;템플릿 메소드 패턴\u0026rdquo; 입니다. 템플릿 메서드 패턴이란? 알고","tags":null,"title":"[DesignPattern] Template Method Pattern(템플릿 메소드 패턴)","uri":"http://blog.cmstown.com/2020/05/02_templete_method_pattern/","year":"2020"},{"content":"코디미 상담 후기 - 백엔드 개발자를 꿈꾸는 초보 개발자에 대한 조언 최근 코덕이라는 이사이트를 애용하는데, 해당 사이트에서 코디미 라는 곳을 알게되었습니다. 코디미는 개발자 취업/커리어/이력서 등 다양한 고민을 상담해주는 곳인데, 평소 존경하던 우아한 형제 개발자 이동욱(a.k.a jojoldu)님이 1차적으로 무료로 상담을 해준다고해서 후다닥 신청했습니다.\n\r평소 백엔드 개발을 그 동안 진행해오면서 공부해야될 것이 너무 많고 알아야할 것도 많아서 너무 막막했는데, 그래서 고민이 술술(?) 나왔던 것 같습니다. 그렇게 은근한 기대를 하며 하루를 보내던 도중\n\r다음과 같은 메일을 받았고, 이후 동욱님에게 고민한 내용에 대한 답변도 받게되었습니다. 답변 내용은 굉장히 도움이 많이 되었고 저와 같은 초보 개발자분들에게 도움이 될만한 내용들이 충분히 담아져있었습니다. 이에 질문 했던 내용과 답변들을 공유하여 저와 같은 초보 개발자분들에게 도움을 드리고자 글을 작성합니다.\n질문 내용 사실 질문 내용이 엄청 구체적이지는 않은 것 같은데, 그래도 동욱님이 제 질문의 의도를 잘 이해주셔서 다행입니다..ㅎ. 무튼 제가 동욱님에게 질문을 간략하게 정리하면 다음과 같습니다.(정말 간략하게 정리했어요..대충한거 아님..ㅎ)\n  대기업SI 보다는 기술 기반의 서비스 기업에 취업하고 싶습니다. 해당하는 기업에 백엔드 개발자로 취업하기 위해서는 어떠한 준비를 하는게 좋을까요?\n  공부를 하다보면 학생으로서 접하기 힘든 다양한 현업 기술들을 듣게 됩니다. 이러한 부분을 반드시 학습해야하는지? 혹은 현재 공부하던 내용들에 대한 깊은 이해를 점검하는게 좋을지?\n  private repository들에 대한 어필을 할 수 있는 방법이 무엇이 있을까요?\n  기업에서 요구하는 신입 백엔드 개발자 능력은 어느 정도인가요?\n  위의 내용과 같이 크게 4가지로 나누어 질문을 드렸습니다.\n질문 답변 동욱님께서는 1,2,4번의 질문들을 묶어서 답변해주셨고, 이후 3번 질문에 대한 답변도 말씀해주셨습니다. 내용은 길지만 핵심만 간략하게 설명드리도록 하겠습니다.\n질문 1,2,4\n  요즘 모든 기업들은 코딩 테스트 를 진행한다. 지금부터 꾸준하게 코딩 테스트 를 준비하는 것을 추천한다.\n  본인만의 학습 방법을 찾아야한다.\n  스프링으로 백엔드 개발 공부를 한다고, 회사에 가서 스프링으로 백엔드를 할 거라는 보장은 없다. 회사에서 \u0026ldquo;전 스프링만 해서 프론트는 하고 싶지 않아요.\u0026quot;, \u0026ldquo;전 스프링만 해서 장고는 몰라요.\u0026quot; 라는 답변을 하면 그것이 과연 신입으로서 좋은 자세일까?\n  즉, 새로운 무언가를 배울 때, 빠르게 학습할 수 있는 본인만의 학습 방법 을 찾는게 중요하다.\n    1~2개의 기술만 하더라도 이에 대해 깊게 파고자 하는 습관을 들이는게 중요\n 많은 기술을 간단하게 사용하는 것은 전혀 도움이 되지 않는다. 그것보다는 프로젝트를 진행하면서 많은 문제 들을 직면하고 단순히 해결하는 것만이 아니라 \u0026ldquo;왜 발생했는지?\u0026rdquo;, \u0026ldquo;왜 해결됐는지?\u0026rdquo;, \u0026ldquo;이 기술이 어떠한 구조인지?\u0026quot; 등을 상세하게 파악하는게 중요하다.    먼저 배운것과 역량은 다르다\n 현업의 기술들을 학생으로서 익힌다하여도 책에 있는 예제, 간단한 듀토리얼 정도를 구현하는 것에 대해 전부일텐데, 누구나 시작하면 도달 할 수 있는 정도의 레벨만 가진 분을 연봉 4천,5천을 주며 뽑아야할 이유가 있는지?    신입 개발자가 당장 실무에서 쓰는 기술을 알아야 채용이 되는 것은 아니라는 예\n  \r신입기준으로는 당장 쓸 구체적인 응용기술을 아는 것도 당연히 선택을 받는데 도움이 됩니다.\r실무자들이 면접을 볼때 같이 나눌수 있는 이야기가 많아지기 때문입니다.\r특히 신입이라도 당장 와서 일할수 있는 사람을 찾는 조직에서는 실무기술을 가급적 많이 아는 사람을 선호할듯합니다.\r그런데 실무 기술을 써본 경험이 있어도 그 기술에 대해 자세히 설명할수 없다면 오히려 경험 안했다고 이야기하는 것보다 더 부정적인 영향을 미칠수 있습니다.\r예를 들면 Java로 DB를 쓰는 개발을 해봤다고했는데 그게 MyBatis를 썼는지 JPA를 썼는지도 모르는 경우입니다.\r반면 잠깐 써보고 아직 깊이 모르는 기술이라도 구체적인 이야기를 체계적으로 할 수 있다면 더 긍적적인 요인이 됩니다.\r예를 들어 MyBatis를 처음 썼는데 어떤 상황이 어려웠고, 알고보니 MyBatis의 어떤 특성 때문이였고, 이를 어떻게 해결했는지 등에 대한 구체적인 이야기를 하는 사람이면, '이 사람은 쓰는 기술에 대해서 제대로 파악을 하려고 했구나'를 느낄수 있습니다.\r그런 사람이면 MyBatis를 당장 안 쓰고 JPA를 쓰는 프로젝트에라도 바로 적응할수 있겠구나 하는 느낌을 줍니다.\r신입 개발자를 채용할때는 현재 할 수 있는 일이 얼마나 되는지를 넘어서 앞으로 얼마나 발전가능성이 있는지에 더 중점을 둬야된다고 생각합니다.\r면접관 입장에서는 자신이 잘 아는 기술을 단편적으로 물어보는것에 그치지 않고 사람이 가진 학습 능력, 학습 의지 등을 파악해야하는데, 당연히 쉬운 일은 아닙니다.\r지원자 입장에서는 성장가능성을 표현할수 있는 방법은 여러가지일 것 같습니다.\r위와 같이 실무에서 쓰는 이미 잘 알고 있고, 그걸 학습해온 과정을 잘 설명하는 것도 하나의 방법입니다.\r학교에서 한 팀 프로젝트라도 남 다르게 한 면이 있다면 실무기술을 잘 몰라도 충분히 앞으로 성장 가능성을 보여줄수 있다고 생각합니다.\r코딩 테스트에서 문제를 센스있게 파악한다던지, 유창하고 거침없이 코딩을 할 수 있는것도 자신을 잘 드러낼수 있는 방법입니다.\r글을 쓰다보니 '신입개발자로 지원할 때는 자신이 앞으로 빠른 속도로 발전할수 있다는 가능성을 보여주는 것이 중요한데 실무에서 쓰는 기술을 일부 아는 것은 그 방법 중의 하나이다. 그러나 유일한 방법은 아니다.' 정도로 제 생각은 정리가되네요.\r글을 쓰다보니 몇년전의 어느 인턴 지원자의 면접이 기억납니다.\rLinux 커널에 관심이 많은 학생이였는데, 사실 제가 인턴의 업무로 염두에 두었던 분야는 그쪽은 아니였습니다.\r코딩 테스트도 제가 계획한 둔 인턴 과제에서는 쓰지 않을 C++로 하기도했습니다.\r당시에 엄격한 기준으로 채점을 하는 시스템을 이용해서 코딩 테스트를 했는데, 그 시스템의 판정으로는 그 학생은 문제를 통과하지 못했습니다.\r그렇지만 거의 답에 근접한 방식으로 코딩을 했고, 무엇보다 유창하고 거침없이 코딩을 하는 모습이 인상적이였습니다.\r하나의 방법이 잘 안되자 그 다음 생각나는 아이디어를 바로 빠르게 타이핑해나갔습니다.\r저는 그 학생을 합격시키고, 연관된 업무가 있을만한 다른 프로젝트 쪽에 추천을 드렸습니다.\r인턴을 거쳐서 그 학생은 최종 입사를 했습니다.\r그런데 처음 그 신입사원이 했던 분야는 그 학생이 깊게 팠던 Linux 커널등과 관련된 분야는 아니였습니다.\rJava 웹개발과 JavaScript와 Angular.js로 FE개발까지 했던것으로 알고 있습니다.\r그때의 인턴은 몇년이 지나서 Linux 커널에 코드 기여를하고 Deview 2018에 [대형 컨테이너 클러스터에서의 고가용성](https://deview.kr/2018/schedule/268) 라는 발표를 하기도했습니다.\r그 발표를 두고 어떤 분들은 DEVIEW 2018의 최고의 발표라고도 말씀을 하셨듯습니다.\r  백엔드 개발자가 참고할만한 좋은 글 추천  질문 3\n 남들에게 공개하지 못하는 코드는 어필할 방법은 없다. 어느 면접관이든 코드에 더 관심을 갖기 때문이다. 그렇기에 이전 프로젝트보다 훨씬 좋은 퀄리티로 본인만의 사이드 프로젝트를 public하게 진행하는 것이 좋을 것 같다.  그 외\n  문제를 해결해 나가는 과정을 블로그 에 정리하여라.\n  최근 회사의 추세는 인턴을 뽑아 괜찮은 분들을 정규직 전환을 시키는 형태로 가고 있다. 막학기에 준비하는 것보다 지금부터(현재 3학년) 내년 인턴 합격을 준비하는 것이 좋을 것이다.\n  위에 간략하게 답변을 정리해보았는데, 사실 제가 간략하게 정리해서 그렇지 더 좋은 말씀들이 많았습니다. 그러면 이렇게 좋은 이야기를 저는 어떻게 행동으로 옮길 수 있을까요? 이에 대하여 많은 고민을 하게 됩니다. 그리고 다음과 같은 계획을 세우게 됩니다.\n앞으로 나는  WHY 에 집중하는 개발자가 될 것입니다.   사실 이는 어찌보면 당연한 부분이다. 내가 jvm에서 동작하는 언어를 선택하였다면, 왜? 선택하였는지 이유를 말할 수 있어야한다. 만약 실제 기업 면접에서 \u0026ldquo;OOO을 사용하셨는데, 왜 사용하셨는지 말씀해주실 수 있나요?\u0026quot; 라고 물어보았을 떄, 단순하게 \u0026ldquo;그냥..많이 하길래\u0026rdquo; 라는 두루뭉실한 말은 이유가 될 수 없습니다. 앞으로 개발하는데 있어서 무언가를 선택 하고 사용할 때 왜 내가 선택하고, 사용했는지 당당히 말할 수 있도록 해야겠습니다.  -\n꾸준한 알고리즘 공부를 진행할 것입니다.    사실 이 부분은 대다수가 인지하고 있을거라 생각합니다. IT기업 대부분이 코딩 테스트를 지향하고 있고, 실제로 인적성으로만 걸렀던 몇몇 대기업들도 코딩 테스트로 전환되고 있는 추세다.\n  이를 위해서 나는 6월 중순(현재 학교 재학 + 프로젝트를 동시에 3개 진행중이라 시간적인 여유가 없다..)부터 구체적으로 알고리즘 공부 계획을 세워 꾸준하게 역량을 키우도록 할 것입니다.\n  블로그 활동 을 꾸준하게 할 것입니다.   블로그는 남에게 나를 어필할 수 있는 좋은 수단인 것 같습니다. 앞으로 내가 문제를 직면했을 때, 어떻게 해결해나가는 과정을 추후 면접자분들에게도 어필 할 수 있도록 블로그 글을 작성할 것입니다. (목표는 이동욱님 블로그..ㅋ)  넓은 범위의 역량 을 습득할 것입니다.   여기서 넓은 범위란 무작정 많은 기술을 공부하고 습득할 것이라는 말이 아닙니다! 제가 말한 넓은 범위란 너무 백엔드 개발에 국한된 공부가 아닌 인접한 공부(프론트, 디비 등)를 말씀드린 것입니다!  제가 성장함에 필요한 조건(?)들을 나열해보았습니다. 앞으로 개발 공부를 진행하는 동안 다음과 같은 조건을 필히 지켜가며 공부하다보면 현업에서도 인정받고 저 또한 누군가에게 귀감이 되는 사람이 될거라 생각합니다.\n그럼 이 글을 읽으시는 모든 개발자분들 모두 꾸준한 성장을 이루어 원하는 결과를 얻길 바라며 글을 마치겠습니다! 모두 화이팅입니다 :D\n","id":43,"section":"posts","summary":"코디미 상담 후기 - 백엔드 개발자를 꿈꾸는 초보 개발자에 대한 조언 최근 코덕이라는 이사이트를 애용하는데, 해당 사이트에서 코디미 라는 곳을 알게되었습니다. 코디","tags":null,"title":"코디미 상담 후기 - 백엔드 개발자를 꿈꾸는 초보 개발자에 대한 조언","uri":"http://blog.cmstown.com/2020/05/%EC%A0%95%EB%B3%B4_002/","year":"2020"},{"content":"AWS EC2를 이용하여 Spring Boot 배포하기(3) 안녕하세요! 오늘은 지난 포스팅에 이어서 서버에서 Spring Boot를 배포하는 과정을 안내해드리도록 하겠습니다. 우리는 github 레포지토리가 존재한다는 가정하에 진행하겠습니다.\n1. 호스트 네임 변경하기 EC2 서버에 접속하면, \u0026ldquo;ubuntu@ip - ip주소\u0026quot;가 등장하는데 ip주소만 봤을 때, 어떠한 서비스인지 알 수 없으니 호스트 네임을 변경해주도록 합시다.\n먼저,\n sudo vim /etc/cloud/cloud.cfg\n 라는 명령어를 이용하여 cloud.cfg를 열어줍니다. 이후 방향키를 내려가며 \u0026ldquo;preserve_hostname: false\u0026quot;을 true로 변경해줍니다.\n 참고 : vi 에디터 사용법  이후\n sudo hostnamectl set-hostname \u0026ldquo;호스트이름\u0026rdquo;\n 명령어를 이용해 호스트이름을 설정해주고 \u0026ldquo;reboot\u0026rdquo; 명령어를 이용해 서버를 재시작해주시면 다음과 같이 정상적으로 호스트이름이 설정된 것을 확인하실 수 있습니다.\n\n2. Java 8 설치 먼저 서버에 Java 8을 설치해주어야한다(나는 배포 할 프로젝트가 8버전이다)\n Ubuntu에서 Java 8 설치 글을 참고해주세요!   3. MySQL 설치 이후 MySQL도 설치해 봅시다.\n Ubuntu에서 MySQL 설치 글을 참고해주세요!  \n3. git clone 하기 EC2에는 기본적으로 git이 설치가 되어있습니다, 그렇기에 바로 git clone을 시도해줍니다.\n git clone 본인 repository\n 🙋‍♂️주의 : Permission denied(publickey)가 나오게 되면 해당 블로그 글을 참고해 키를 등록해주세요\n이렇게 하게 되면 root안에 방금 clone한 폴더가 등장합니다.\n이후\n dir\n 명령어를 사용해 clone한 폴더가 생겼는지 확인하고,\n cd 폴더명 // 현재 위치를 [폴더명]으로 이동 sudo chmod 777 ./gradlew // ./gradlew에게 권한을 부여 sudo ./gradlew build // gradle build  명령어를 순차적으로 실행하고, jar파일의 이름을 찾아\n $ java –jar [이름].jar \u0026amp;\n 명령어를 실행하면 서버에 배포가 됩니다.\n지금까지 AWS EC2에 Spring Boot 배포하는 것을 소개해드렸는데, 사실 제 블로그 글에 부족한게 많습니다. 사실 추후에 RDS를 사용하여 배포하는 것을 보여드리기 위해 지금은 중간중간 생략한 과정도 많아 그냥 참고용으로만 봐주시면 감사하겠습니다. 추가적으로 궁금하신 사항들은 저에게 물어보셔도되고 훌륭한 다른 포스팅들을 검색하셔도 됩니다.\n추후 RDS를 이용하는 법에 대해서도 간단히 소개해드릴 예정이니 그때 뵙겠습니다. 그럼 20000!!\n참고 문헌\n 스프링 부트와 AWS로 혼자 구현하는 웹 서비스  ","id":44,"section":"posts","summary":"AWS EC2를 이용하여 Spring Boot 배포하기(3) 안녕하세요! 오늘은 지난 포스팅에 이어서 서버에서 Spring Boot를 배포하는 과정을 안내해드리도록 하겠습니다. 우리는 github","tags":null,"title":"AWS EC2를 이용하여 Spring Boot 배포하기(3)","uri":"http://blog.cmstown.com/2020/05/aws_ec2_03/","year":"2020"},{"content":"AWS EC2를 이용하여 Spring Boot 배포하기(2) - AWS EC2 서버 접속 오늘은 AWS EC2 서버에 접속하는 과정을 소개해드리도록 하겠습니다. 먼저 시작하기 전에 해당 글은 윈도우 를 이용하여 접속하는 방법을 안내해드리는 점 참고해주세요!\n1. putty 다운로드 및 키 발급 윈도우에서는 Mac과 같이 ssh 접속하기에 불편한 점이 많아 별도의 클라이언트를 설치해줍니다.\n1. putty 사이트에서 다운로드 후 putty.exe,puttygen.exe 모두 다운로드하였으면, puttygen.exe 부터 실행시켜줍니다. 이후 Load를 클릭합니다. 2. 이전 AWS 발급한 Pem 키가 저장되어있는 곳을 찾아 클릭해줍시다. 그러면 다음과 같이 키가 발급되었다는 팝업창이 나옵니다.\n3. 이후 Save private Key 를 클릭해 안전한 장소에 발급된 키를 저장해줍니다. 2. putty를 이용하여 AWS EC2 서버 접속 1. 먼저 AWS에서 인스턴스와 연결한 탄력적 ip를 알아옵니다. 그리고 다음 사진과 같이 Host Name을 설정해줍니다.(자신의 탄력적 ip를 적으시면 됩니다) 주의 : 이전에 AWS 보안그룹에 22포트는 내 IP에서만 접근이 가능하도록 설정하였습니다. 설정한 IP의 장소가 맞는지 확인해주세요!\n2. 이후 왼쪽 카테고리의 Connection - SSH - Auth로 이동하여 이전에 발급한 ppk를 Browse..를 클릭하여 불러옵니다. 주의 : pem키를 찾을 때 모든 파일에서 찾기를 하셔야 pem키가 보입니다.\n3. ppk를 잘 불러왔으면, 다시 왼쪽 카테고리에서 제일 위에 있는 Session 으로 이동합니다. 이후 Saved Sessions 에 본인의 서비스명을 입력하고 Save 해줍시다. 이후 저장한 세션을 선택 후 Open 해줍시다! 3. AWS EC2 접속 open 해주면 보안 알림창이 처음에 나오는데 그냥 \u0026lsquo;예\u0026rsquo;를 눌러주시면 됩니다. 그러면 이후 다음과 같은화면이 나오며 접속이 완료됩니다!\n그럼 다음 포스팅에서 본격적으로 AWS EC2 서버에 Spring Boot를 배포하는 작업을 보여드리겠습니다. 다음 포스팅에서 봐용~!👐\n참고 문헌\n 스프링 부트와 AWS로 혼자 구현하는 웹 서비스  ","id":45,"section":"posts","summary":"AWS EC2를 이용하여 Spring Boot 배포하기(2) - AWS EC2 서버 접속 오늘은 AWS EC2 서버에 접속하는 과정을 소개해드리도록 하겠습니다. 먼저 시작하기 전에 해당 글은 윈도우 를 이","tags":null,"title":"AWS EC2를 이용하여 Spring Boot 배포하기(2)","uri":"http://blog.cmstown.com/2020/05/aws_ec2_02/","year":"2020"},{"content":"AWS EC2를 이용하여 Spring Boot 배포하기(1) 저는 지금까지 AWS EC2를 이용하여 여러번 서버를 배포해보았었는데요. 이번에 그 과정들을 간단하게 블로그에 담고자 글을 작성합니다.\n먼저 시작하기 전에 제가 배포하려는 서비스는 다음과 같습니다.\n 실제 운영할 서비스는 아니고 간단한 토이 프로젝트의 느낌이다. 나는 빠르게 프로젝트를 배포하여야한다. 나는 현재 돈이 없다..(ㅜㅜ)  이러한 조건의 서비스를 배포하기 위해서 PAAS의 Heroku도 생각했지만, 예전에 Heroku를 사용했을 떄, 서버 region이 외국에 있고 Cold Start 문제가 있어 서비스를 운영하는데 어려움을 많이 느꼇습니다. 그렇기에 AWS에서 제공해주는 프리 티어를 이용하여 간단하게 EC2 서버에 서비스를 배포할 계획을 하였습니다. 그러면 시작해보도록 하겠습니다!\n\n 본 글은 AWS에 회원가입 모두 완료되었다는 가정하에 진행됩니다.\n EC2 인스턴스 생성하기  \n1. 인스턴스 시작 먼저 인스턴스를 만들어주기 위해 EC2 대시보드로 이동합시다!\n이동하게 되면 위와 같은 화면을 마주하게 되는데요~, 여기서 화면 중앙의 인스턴스 시작 버튼을 눌러줍시다.\n\n2. 단계 1: Amazon Machine Image(AMI) 선택 AWS EC2에서는 Amazaon Linux, Ubunto, SUSE 등 다양한 OS를 제공하고 있습니다. 저는 이중에서 \u0026ldquo;Ubuntu Server 18.04 LTS (HVM), SSD Volume Type\u0026rdquo; 를 선택하겠습니다.\n🤷‍♂️ Why?\n  OS는 Window와 Linux가 대표적인데, 보안적인 부분이나 비용적인 부분에서 Window보다 좋기 때문에 대체적으로 서버는 Linux를 이용합니다.\n  그렇다면 Linux 기반의 OS에도 여러가지가 있는데, 왜 Ubunto인가?\n 저는 EC2는 프리티어로만 사용할 예정이고 실제 Linux에 대해 전반적으로 지식이 많은게 아닌 초보자이기 때문에, 쉽게 접할 수 있는 Ubuntu를 선택하였습니다.    Ubuntu는 2년바다 크게 업데이트가 진행된다, 그래서 최근 20.4버전이 나와있다. 그러나 최신 버전이라고 무조건 좋다는 법은 없다. 출시된지 아직 한달도 안되었기 떄문에 그 동안 검증된 18.04 버전을 선택하겠다.\n  사실 내가 사용하려는 수준에서는 이 모든게 크게 상관없을 듯 하다(?)\n  어찌됐든 AMI른 선택해주었다면 다음 단계로 넘어가보자.\n\n3. 단계 2: 인스턴스 유형 선택 여기서는 t2.micro를 선택하시면 됩니다~\n🤷‍♂️ Why?\n  앞서 말했다시피 현재 배포할 서비스는 지속적으로 관리할 서비스가 아닙니다. 잘된다면 서비스를 계속 운영할 수 있겠지만 현재 상황에서는 그러한 계획이 없기 떄문에, 무료로 제공되는 \u0026ldquo;프리티어\u0026quot;를 이용할 것입니다. 그렇기에 선택의 여지가 없습니다..\n(돈 없는 학식은 웁니다 ㅜㅜ)\n   참고  해당 유형에 대해 간략하게 설명드리면 \u0026ldquo;T시리즈\u0026quot;라고 불리는 유형이다. 이 서비스는 크레딧 이라는 일종의 CPU를 사용할 수 있는 포인트 개념이 있습니다. 관련된 내용은 해당 블로그를 참고하시면 좋을 것 같습니다. T2 instance 특징은 무엇인가요?    \n4. 단계 3: 인스턴스 세부 정보 구성 해당 사항은 추가적으로 건드리지 않고 그대로 진행하겠습니다!\n🤷‍♂️ Why?\n  현재 한대의 서버를 가지고 간단한 프로젝트를 배포하기 위해서이니, 별다른 설정을 하지않겠습니다.\n  추가적으로 해당 관련 정보를 수정하기 위해서는 추가적인 공부가 필요할 것 같아 당장 EC2를 이용하기 위해서는 그대로 넘어가도록하겠습니다.\n  \n5. 단계 4: 스토리지 추가 해당 스토리지의 크기를 30으로 설정해줍시다!\n🤷‍♂️ Why?\n 프리 티어에서는 최대 30GB의 스토리지를 사용할 수 있기 떄문에 우리는 최~대한 이를 활용하기 위해서 최대한으로 설정해줍시다!  \n6. 단계 5: 태그 추가 태그는 웹 콘솔에서 표기될 태그인 Name 태그를 등록합니다.\n(태그 추가 클릭 - 키에 Name입력 - 값에 본인의 서비스를 나타낼 수 있는 값을 입력)\n🤷‍♂️ Why?\n 여러 인스턴스가 있을 경우 이를 태그별로 구분하기 위해 본인의 서비스를 나타낼 수 있는 값으로 등록을합니다.  \n7. 단계 6: 보안 그룹 구성 보안 그룹은 사진과 같이 규칙을 추가하겠습니다.\n🤷‍♂️ Why?\n  22포트\n  22포트의 경우는 AWS EC2에 터미널로 접속할 떄를 이야기합니다. 해당 포트는 내 IP에서만 접속하게끔 설정을 하였는데요, 이유는 pem키가 없으면 접속이 불가능하나 pem키가 노출되었을 때 서버에서 비트 코인 채굴 서버로 이용될 수 있기 떄문입니다! 그러므로 내 IP로설정하고 장소가 이동될 떄 마다 내 IP를 다시 받아 이용하시는게 보안적으로 좋습니다 :D\n  말도 안 되는 과금의 추억. 요금 폭탄\n    80,443 포트\n http,https 통신을 위해 기본적으로 추가해줍니다~.    \n8. 단계 7: 인스턴스 시작 검토   해당 단계에서는 그동안 저희가 설정했던 부분들이 일괄적으로 나오게 됩니다. 이상없는지 확인해주고 시작하기 버튼을 클릭합시다!\n  이후 새 키 페어 생성 을 설정하고(기존 키 페어가 없다는 가정하에 진행하겠습니다.) 키 페어 이름을 서비스와 연관지어 짓고, 키 페어 다운로드를 클릭합니다. 이후 키 페어를 안전한 위치에 저장해줍니다.\n  위 과정이 완료되었으면 인스턴스 시작을 클릭합니다!\n  다음과 같은 화면이 나오면 다시 EC2 대시보드로 이동해봅시다.\n\n9. 인스턴스 생성 확인 짜잔-! 인스턴스 상태가 초록불과 함께 running이라 나와있으면 해당 인스턴스가 잘 실행되고 있음을 뜻합니다.(인스턴스가 생성되고 실행되는 과정까지 시간이 소요될 수 있습니다.)\n잠깐! 저희가 EC2 서버를 실제 접속하기 전에 해야할 일이 있습니다!\n\n10. 탄력적 IP 할당 인스턴스는 하나의 서버이기 떄문에 IP가 존재합니다. 인스턴스 생성시 항상 새 IP를 할당받고, 같은 인스턴스를 중지하고 다시 시작할 떄도 새 IP가 할당됩니다. 그렇게 되면 매번 접속해야 하는 IP가 변경되어 PC에서 매번 접속시 IP 주소를 확인해야하는 번거로움이 있습니다. 그렇기에 고정 IP를 가지게 해야하는데요, 우리는 이를 위해서 탄력적 IP를 할당합시다.\n1. 먼저 탄력적 IP 메뉴를 클릭합니다. 2. 탄력적 IP 주소 할당 을 클릭합니다. 3. 다음 화면에서 할당을 클릭합니다. 4. 탄력적 IP를 할당받으신걸 확인하실 수 있습니다. 그러면 이전에 저희가 만든 인스턴스와 탄력적 IP를 연결해보도록 하겠습니다! 먼저 퍼블릭 IPv4 주소 밑의 IP를 클릭합시다. 5. 이후 그대로 탄력적 IP 주소 연결 을 클릭합니다. 6. 이후 이전에 만든 인스턴스와 프라이빗 IP 주소를 설정합니다. 처음 AWS EC2 이용하시는 분은 그냥 그대로 설정하시고 연결하시면 됩니다. 7. 아래와 같이 나오게되면, 탄력적 IP가 해당 인스턴스와 연결되었음을 알 수 있습니다. 실제로 EC2 인스턴스를 확인하면 탄력적 IP가 연결된것도 확인하실 수 있습니다!\n지금까지 EC2 인스턴스 생성과 탄력적 IP 주소 연결까지의 과정을 소개해드렸습니다. 다음 포스팅에는 본격적으로 AWS EC2에 접속하는 방법과 서버에 Spring Boot를 배포하는 과정을 소개해드릴게요. 그럼 다음 포스팅떄 뵙겠습니다 :D\n참고 문헌\n 스프링 부트와 AWS로 혼자 구현하는 웹 서비스  ","id":46,"section":"posts","summary":"AWS EC2를 이용하여 Spring Boot 배포하기(1) 저는 지금까지 AWS EC2를 이용하여 여러번 서버를 배포해보았었는데요. 이번에 그 과정들을 간단하게 블로그에 담고자 글을","tags":null,"title":"AWS EC2를 이용하여 Spring Boot 배포하기(1)","uri":"http://blog.cmstown.com/2020/05/aws_ec2_01/","year":"2020"},{"content":"DecoratorPattern(데코레이터 패턴) 데코레인터 패턴이란?  객체의 결합 을 통해 기능을 동적으로 유연하게 확장 할 수 있게 해주는 패턴\n 위의 한 문장으로 정확히 무엇인지 정확히 이해하기 힘듭니다, 아래의 내용을 통해 데코레이터 패턴을 살펴봅시다!\n도로 표시 방법 조합하기(데코레이터 패턴을 모를 떄 ver) 도로가 있을 떄 차선을 표시해야할 떄 우리는 어떻게 클래스를 만들까?\n도로가 있을 떄 차선을 표시하기 위해 기본적으로 2가지 클래스를 만들어보았습니다!\n RodaDisplay Class : 기본 도로 표시 기능을 제공하는 클래스 RoadDIsplayWithLane Class : 기본 도로 표시에 추가적으로 차선을 표시하는 클래스  이 둘을 코드로 표현하면 다음과 같습니다~\npublic class Client {\rpublic static void main(String[] args) {\rSystem.out.println(\u0026quot;첫번째 draw\u0026quot;);\rRoadDisplay roadDisplay = new RoadDisplay();\rroadDisplay.draw();\rSystem.out.println(\u0026quot;\\n두번째 draw\u0026quot;);\rRoadDisplay roadDisplayWithLane = new RoadDisplayWithLane();\rroadDisplayWithLane.draw();\r}\r}\rclass RoadDisplay{\rpublic void draw(){\rSystem.out.println(\u0026quot;도로 기본 표시\u0026quot;);\r}\r}\rclass RoadDisplayWithLane extends RoadDisplay{\rpublic void draw(){\rsuper.draw();\rdrawLane();\r}\rprivate void drawLane(){\rSystem.out.println(\u0026quot;차선 표시\u0026quot;);\r}\r}\r 위의 코드 중 main을 보면 \u0026ldquo;draw()\u0026ldquo;라는 메소드를 사용하여 기능을 통일 시켜주었습니다. 그래서 결과를 보면\n첫번째 draw\r도로 기본 표시\r두번째 draw\r도로 기본 표시\r차선 표시\r 다음과 같이 출력이 됩니다. 동일한 \u0026ldquo;draw()\u0026ldquo;메소드를 수행했지만 다른 출력값이 나오는 것을 확인할 수 있습니다.\n기능만 봐서는 잘 작동하는 것 같은데,,과연 해당 코드에 문제점이 없을까요?🤔\n문제점이 있는지 확인하기 위해 다음과 같은 사항을 체크해봅시다!\n  또 다른 추가적인 도로 표시 기능을 구현하고 싶다면 어떻게 해야 하는가?(도로 표시에 교통량도 표시하고싶다면..!?)🚖🚖🚖\n  뿐만아니라 여러가지 추가 기능의 조합하여 제공하고 싶다면 어떻게 해야 할까요? 예를 들어 기본 도로 표시에 차선 표시 기능과 교통량 표시 기능을 함께 제공하고 싶다면요! 🏞 + 🚖🚖🚖\n  위의 사항들을 다음과 같이 시도해봅시다!\n추가적으로 RoadDisplay를 상속받는 RoadDisplayWithTraffic 클래스를 구현하는거죠!! 즉, 코드를 보면 다음과 같습니다!\npublic class Client {\rpublic static void main(String[] args) {\rSystem.out.println(\u0026quot;첫번째 draw\u0026quot;);\rRoadDisplay roadDisplay = new RoadDisplay();\rroadDisplay.draw();\rSystem.out.println(\u0026quot;\\n두번째 draw\u0026quot;);\rRoadDisplay roadDisplayWithLane = new RoadDisplayWithLane();\rroadDisplayWithLane.draw();\rSystem.out.println(\u0026quot;\\n세번째 draw\u0026quot;);\rRoadDisplay roadDisplayWithTraffic = new RoadDisplayWithTraffic();\rroadDisplayWithTraffic.draw();\r}\r}\rclass RoadDisplay{\rpublic void draw(){\rSystem.out.println(\u0026quot;도로 기본 표시\u0026quot;);\r}\r}\rclass RoadDisplayWithLane extends RoadDisplay{\rpublic void draw(){\rsuper.draw();\rdrawLane();\r}\rprivate void drawLane(){\rSystem.out.println(\u0026quot;차선 표시\u0026quot;);\r}\r}\rclass RoadDisplayWithTraffic extends RoadDisplay{\rpublic void draw(){\rsuper.draw();\rdrawTraffic();\r}\rprivate void drawTraffic(){\rSystem.out.println(\u0026quot;교통량 표시\u0026quot;);\r}\r}\r 이 코드의 실행 결과도\n첫번째 draw\r도로 기본 표시\r두번째 draw\r도로 기본 표시\r차선 표시\r세번째 draw\r도로 기본 표시\r교통량 표시\r 로 잘 수행이됩니다. 그렇다면 이와 같은 방식으로 기능들을 조합하여 사용하자는 두번째 사항 에 부합되도록 하려면 어떻게할까요?\n위와 같은 표처럼 많은 기능을 구현하기 위해 우리는 다음과 같이 코드를 작성해야할지 모릅니다..\nclass RoadDisplay{\rpublic void draw(){\rSystem.out.println(\u0026quot;도로 기본 표시\u0026quot;);\r}\r}\rclass RoadDisplayWithLane extends RoadDisplay{\rpublic void draw(){\rsuper.draw();\rdrawLane();\r}\rprivate void drawLane(){\rSystem.out.println(\u0026quot;차선 표시\u0026quot;);\r}\r}\rclass RoadDisplayWithTraffic extends RoadDisplay{\rpublic void draw(){\rsuper.draw();\rdrawTraffic();\r}\rprivate void drawTraffic(){\rSystem.out.println(\u0026quot;교통량 표시\u0026quot;);\r}\r}\rclass RoadDisplayWithCrossing extends RoadDisplay{\rpublic void draw(){\rsuper.draw();\rdrawCrossing();\r}\rprivate void drawCrossing(){\rSystem.out.println(\u0026quot;교차료 표시\u0026quot;);\r}\r}\rclass RoadDisplayWithLaneTraffic extends RoadDisplay{\rpublic void draw(){\rsuper.draw();\rdrawLane();\rdrawTraffic();\r}\rprivate void drawLane(){\rSystem.out.println(\u0026quot;차선 표시\u0026quot;);\r}\rprivate void drawTraffic(){\rSystem.out.println(\u0026quot;교통량 표시\u0026quot;);\r}\r}\rclass RoadDisplayWithLaneCrossing extends RoadDisplay{\rpublic void draw(){\rsuper.draw();\rdrawLane();\rdrawCrossing();\r}\rprivate void drawLane(){\rSystem.out.println(\u0026quot;차선 표시\u0026quot;);\r}\rprivate void drawCrossing(){\rSystem.out.println(\u0026quot;교차료 표시\u0026quot;);\r}\r}\r.\r.\r.\r.\r.\r 위의 코드를 보면 무언가 문제가 있다고 느껴지시지 않나요? 위의 코드를 보면 중복된 코드들이 많이 보입니다. \u0026ldquo;차선 표시\u0026quot;를 print해주는 문장만 벌써 3개 등장했습니다.. 그러면 기능들이 추가될 떄마다 중복된 코드는\u0026hellip;.\n맞습니다..기능이 추가될 떄마다 우리는 불필요한 하드 코딩을 하게 됩니다.\n그러면 데코레이터 패턴을 적용하면 어떻게 해결될까요!?\n데코레이터 패턴 적용 ver 다음은 데코레이터 패턴을 적용한 후의 클래스 다이어그램입니다.\n훨씬 간결해진 구조 보이시나요!? 기존에 기능들을 조합하기 위해 조합되는 기능만큼 클래스들을 생성했는데, 데코리에터 패턴을 이용하면 고유한 기능들 개수만큼만 클래스를 생성해주시면 됩니다! 그러면 코드를 볼까요?\npublic class Client {\rpublic static void main(String[] args) {\rDisplay roadWithLaneAndTraffic = new TrafficDecorator(\rnew LaneDecorator(\rnew CrossingDecorator(\rnew RoadDisplay()\r)\r)\r);\rSystem.out.println(\u0026quot;--- draw 호출 ---\u0026quot;);\rroadWithLaneAndTraffic.draw();\r}\r}\rabstract class Display{\rpublic abstract void draw();\r}\rclass RoadDisplay extends Display{\r@Override\rpublic void draw() {\rSystem.out.println(\u0026quot;도로 기본 표시\u0026quot;);\r}\r}\rclass DisplayDecorator extends Display{\rprivate Display decorateDisplay;\rpublic DisplayDecorator(Display decorateDisplay){\rthis.decorateDisplay = decorateDisplay;\r}\r@Override\rpublic void draw() {\rdecorateDisplay.draw();\r}\r}\rclass LaneDecorator extends DisplayDecorator{\rpublic LaneDecorator(Display decorateDisplay){\rsuper(decorateDisplay);\r}\r@Override\rpublic void draw() {\rsuper.draw();\rdrawLane();\r}\rprivate void drawLane(){\rSystem.out.println(\u0026quot;\\t차선 표시\u0026quot;);\r}\r}\rclass CrossingDecorator extends DisplayDecorator{\rpublic CrossingDecorator(Display decorateDisplay){\rsuper(decorateDisplay);\r}\r@Override\rpublic void draw() {\rsuper.draw();\rdrawCrossing();\r}\rprivate void drawCrossing(){\rSystem.out.println(\u0026quot;\\t횡단보도 표시\u0026quot;);\r}\r}\rclass TrafficDecorator extends DisplayDecorator{\rpublic TrafficDecorator(Display decorateDisplay){\rsuper(decorateDisplay);\r}\r@Override\rpublic void draw() {\rsuper.draw();\rdrawTraffic();\r}\rprivate void drawTraffic(){\rSystem.out.println(\u0026quot;\\t교통량 표시\u0026quot;);\r}\r}\r 수행결과\n--- draw 호출 ---\r도로 기본 표시\r횡단보도 표시\r차선 표시\r교통량 표시\r main안의 코드들을 살펴봅시다! 예전에 해당 기능을 구현하기 위해서는 새로 클래스를 만들어서 구현했는데, 데코레이터 페턴이 적용된 현재는 생성자 DisplayDecorator 클래스를 상속받는 클래스들의 생성자에 구현하고자 하는 기능들을 추가하면 간단하게 구현됩니다. 즉, 새로운 클래스 구현이 아닌 생성자에 필요한 기능을 담는 것으로 기능의 조합이 가능해집니다!\n이로써 우리는 앞으로 데코레이터 패턴을 이용하여 기본 기능에 추가될 수 있는 많은 수의 부가 기능에 대해서 다양한 조합을 동적으로 구현할 수 있습니다~!\n참고\n JAVA 객체지향 디자인 패턴   ","id":47,"section":"posts","summary":"DecoratorPattern(데코레이터 패턴) 데코레인터 패턴이란? 객체의 결합 을 통해 기능을 동적으로 유연하게 확장 할 수 있게 해주는 패턴 위의 한 문장","tags":null,"title":"[DesignPattern] Decorator Pattern(데코레이터 패턴)","uri":"http://blog.cmstown.com/2020/05/01_decorator_pattern/","year":"2020"},{"content":"문제링크 \n사용언어  c++  \n주의사항   방금그곡 서비스에서는 음악 제목, 재생이 시작되고 끝난 시각, 악보를 제공한다.\n  네오가 기억한 멜로디와 악보에 사용되는 음은 C, C#, D, D#, E, F, F#, G, G#, A, A#, B 12개이다.\n  각 음은 1분에 1개씩 재생된다. 음악은 반드시 처음부터 재생되며 음악 길이보다 재생된 시간이 길 때는 음악이 끊김 없이 처음부터 반복해서 재생된다. 음악 길이보다 재생된 시간이 짧을 때는 처음부터 재생 시간만큼만 재생된다.\n  음악이 00:00를 넘겨서까지 재생되는 일은 없다.\n  조건이 일치하는 음악이 여러 개일 때에는 라디오에서 재생된 시간이 제일 긴 음악 제목을 반환한다. 재생된 시간도 같을 경우 먼저 입력된 음악 제목을 반환한다.\n  조건이 일치하는 음악이 없을 때에는 (None)을 반환한다.\n  \n문제풀이 처음 문제를 풀때 \u0026lsquo;#\u0026lsquo;을 고려하지못하여서, 마지막에 m과 melody를 비교하기 힘들었다, 이후 처음부터 멜로디들의 코드를 \u0026ldquo;C, C#, D, D#, E, F, F#, G, G#, A, A#, B \u0026ldquo;로 구별하여 vector에 담아 비교하니 쉽게 구현할 수 있었다. 다만 문제를 어떻게 풀지 생각하는건 쉬웠는데..실제로 구현해보니 시간이 너..무 오래걸렸다..\n문제풀이 방식은 다음과 같다.\n  musicinfos의 string 정보를 \u0026lsquo;,\u0026lsquo;로 split하여 곡 정보를 받아온다.\n  이후 시작시간과 끝시간을 이용하여 총 재생시간을 구한다.\n  음악 정보의 멜로디를 비교하기 전에 총 재생시간이 이전에 조건이 일치했던 음악이 있는지와 그 음악의 재생시간보다 큰지 비교한다.\n  이후 해당 음악정보가 조건이 일치한지 검색한다.\n  조건에 일치하면 answer에 곡 제목을 담아준다.\n  여기서 melody들을 그냥 string으로 비교하는 것보다 코드별로 분리하는 함수를 만들어서 코드들을 순서대로 vector에 담아 비교하는 것이 더 쉽다.\n코드를 보면 다음과 같다.\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; // 4 6 7 8 9 12 15 18 19 vector\u0026lt;string\u0026gt; splitChar(string str, char ch){ vector\u0026lt;string\u0026gt; v; int ind = 0; for(int i = 0; i \u0026lt; str.size(); i++){ if(str[i] == ch){ v.push_back(str.substr(ind, i - ind)); ind = i + 1; } } v.push_back(str.substr(ind, str.size()-1)); return v; } bool searchMelody(vector\u0026lt;string\u0026gt; m, vector\u0026lt;string\u0026gt; melody){ bool result = true; for(int i = 0; i \u0026lt; melody.size(); i++){ if(melody[i] != m[0]) continue; int k = i; for(int j = 0; j \u0026lt; m.size(); j++){ if(melody[k] != m[j]) { result = false; break; } k++; } if(result) { return result; } result = true; } return false; } vector\u0026lt;string\u0026gt; findMelodyCode(string melody){ vector\u0026lt;string\u0026gt; melodyCode; for(int j = 0; j \u0026lt; melody.size() - 1; j++){ string code = \u0026quot;\u0026quot;; code += melody[j]; if(melody[j+1] == '#'){ code += melody[j+1]; j++; } melodyCode.push_back(code); } if(melody[melody.size() - 1] != '#'){ string code = \u0026quot;\u0026quot;; code += melody[melody.size() - 1]; melodyCode.push_back(code); } return melodyCode; } string solution(string m, vector\u0026lt;string\u0026gt; musicinfos) { string answer = \u0026quot;(None)\u0026quot;; int currentTime = 0; for(int i = 0; i \u0026lt; musicinfos.size(); i++){ vector\u0026lt;string\u0026gt; musicinfo = splitChar(musicinfos[i], ','); vector\u0026lt;string\u0026gt; startTime = splitChar(musicinfo[0], ':'); vector\u0026lt;string\u0026gt; endTime = splitChar(musicinfo[1], ':'); int sumTime = (stoi(endTime[0]) - stoi(startTime[0]))*60 + (stoi(endTime[1]) - stoi(startTime[1])); if(currentTime \u0026gt; sumTime) continue; if(currentTime == sumTime){ if(answer != \u0026quot;(None)\u0026quot;) continue; } vector\u0026lt;string\u0026gt; melodyCode = findMelodyCode(musicinfo[3]); vector\u0026lt;string\u0026gt; melody; for(int j = 0; j \u0026lt; sumTime; j++){ int ind = j%melodyCode.size(); melody.push_back(melodyCode[ind]); } if(searchMelody(findMelodyCode(m), melody)){ answer = musicinfo[2]; currentTime = sumTime; } } return answer; }  ","id":48,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 방금그곡 서비스에서는 음악 제목, 재생이 시작되고 끝난 시각, 악보를 제공한다. 네오가 기억한 멜로디와 악보에 사용되는 음은 C, C#, D,","tags":null,"title":"프로그래머스 - [3차] 방금그곡","uri":"http://blog.cmstown.com/2020/04/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_022/","year":"2020"},{"content":"문제링크 \n사용언어  c++  \n주의사항   비트마스킹을 이용하여 풀 수 있는 문제이다. 기본적인 비트연산자에 대하여 숙지하여야한다.\n dfs로도 풀 수 있긴하다.    관계 데이터베이스에서 릴레이션(Relation)의 튜플(Tuple)을 유일하게 식별할 수 있는 속성(Attribute) 또는 속성의 집합 중, 다음 두 성질을 만족하는 것을 후보 키(Candidate Key)라고 한다.\n  유일성(uniqueness) : 릴레이션에 있는 모든 튜플에 대해 유일하게 식별되어야 한다.\n  최소성(minimality) : 유일성을 가진 키를 구성하는 속성(Attribute) 중 하나라도 제외하는 경우 유일성이 깨지는 것을 의미한다. 즉, 릴레이션의 모든 튜플을 유일하게 식별하는 데 꼭 필요한 속성들로만 구성되어야 한다.\n    \n문제풀이 해당 문제를 비트마스킹으로 푸는 코드를 이해하는데 오래걸렸다..애초에 비트연산자를 안쓴지 오래되어 까먹은 부분도 있고, 이러한 문제유형을 접해본게 처음인지라 나에게는 많이 어려웠다.\n해당 문제를 비트마스킹으로 풀기 전에 이론적으로 내가 생각한 부분은 이렇다.\n  colum개수만큼 for문을 진행하면서 colum의 개수중 i개를 조합한다.\n  이후 조합된 colum이 후보키가 될 수 있는지 확인한다.\n  이렇게 선출된 후보키들중 다른 후보키에 포함되는 경우 다른 후보키를 후보키에서 제외한다.\n 예시) \u0026ldquo;이름\u0026quot;이라는 칼럼자체가 후보키가 될 수있으면 {\u0026ldquo;이름\u0026rdquo;,\u0026ldquo;학번\u0026rdquo;},{\u0026ldquo;이름\u0026rdquo;,\u0026ldquo;전공\u0026rdquo;} 등 \u0026ldquo;이름\u0026quot;이 들어간 후보키는 최소성에 어긋난다.    위와 같이 과정을 생각하고 막상 코드를 구현하려했더니 dfs밖에 생각이 나지 않았다. 그래서 코드를 구현하다보니 내가 많이 복잡하게 구현한다는 느낌을 받아 검색을 통해 비트마스킹을 이용하여 문제를 풀 수 있다는 것을 알게되었다. 비트마스킹을 이용하여 문제를 푸는게 처음이라 코드를 이해하고 적용하는데 오래걸렸다. 코드는 다음과 같다.\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int countBits(int n){ int ret = 0; while(n){ if(n \u0026amp; 1) ret++; n = n \u0026gt;\u0026gt; 1; } return ret; } bool cmp(int a, int b){ a = countBits(a); b = countBits(b); return a \u0026lt; b; } bool check(vector\u0026lt;vector\u0026lt;string\u0026gt; \u0026gt; relation , int rowSize, int colSize, int subset){ // 예시) relation, 6, 4, 1(= 0001) // subset의 값에 있는 같은 자리에 대헤서 후보키가 될 수 있는지 검사한다. for(int i = 0; i \u0026lt; rowSize - 1; i++){ for(int j = i + 1; j \u0026lt; rowSize; j++){ bool isSame = true; for(int k = 0; k \u0026lt; colSize; k++){ if ((subset \u0026amp; 1 \u0026lt;\u0026lt; k) == 0) continue; // subset의 자리에 없는 colum은 지나친다. // 한 row에 값잍 틀린게 있으면(즉, 후보키가 될 수 있으면) isSame에 flase를 주고 해당 row에서 다음 row를 검사한다. // 예시로 subset = 3(0011) 일 때, 검색하는 row의 3번째자리나 4번째자리에 값중 하나만 달라도 후보키가 될 수 있다. if (relation[i][k] != relation[j][k]) { isSame = false; break; } } if (isSame) return false; // 해당 row의 값이 같으면 후보키가 될 수 없다. } } return true; } int solution(vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; relation) { int answer = 0; int rowSize = relation.size(); int colSize = relation[0].size(); vector\u0026lt;int\u0026gt; candidates; // colSize로 표현할 수 있는 비트개수만큼 for문 진행 for(int i = 1; i \u0026lt; (1 \u0026lt;\u0026lt; colSize); i++){ // 후보키가 될 수 있는지 여부를 탐색 if(check(relation, rowSize, colSize, i)) candidates.push_back(i); } // colum의 개수가 작은 순서대로 정렬 sort(candidates.begin(), candidates.end(), cmp); while(!candidates.empty()){ // sort된 후보키중 가장 작은 후보키를 답으로 제출 int n = candidates[0]; candidates.erase(candidates.begin()); answer++; // 이후 해당 후보키가 포함된 후보키들은 답에서 제외 for(int i = 0; i \u0026lt; candidates.size(); i++){ if((n \u0026amp; candidates[i]) == n){ candidates.erase(candidates.begin() + i); i = -1; } } } return answer; }  ","id":49,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 비트마스킹을 이용하여 풀 수 있는 문제이다. 기본적인 비트연산자에 대하여 숙지하여야한다. dfs로도 풀 수 있긴하다. 관계 데이터","tags":null,"title":"프로그래머스 - 후보키","uri":"http://blog.cmstown.com/2020/04/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_021/","year":"2020"},{"content":"문제링크 \n사용언어  c++  \n주의사항  최솟값이 8보다 크면 -1을 return 합니다.  \n문제풀이  해당 문제는 DP로 풀지못하여 DFS를 활용하였습니다. Count가 9이상이면 -1을 리턴하기때문에 N은 최대 9번 연속으로 나열될 수 있습니다. 코드는 다음과 같습니다.  #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int minNum = 9; void dfs(int count, int number, int current, int target) { if(count \u0026gt; 8) return; if(current == target){ minNum = min(minNum, count); } int tmp = 0; for(int i = 0; i \u0026lt; 8 - count; i++){ tmp = tmp*10 + number; dfs(count + 1 + i, number, current + tmp, target); dfs(count + 1 + i, number, current / tmp, target); dfs(count + 1 + i, number, current * tmp, target); dfs(count + 1 + i, number, current - tmp, target); } } int solution(int N, int number) { int answer = 0; dfs(0, N, 0, number); if(minNum \u0026gt;= 9) answer = -1; else answer = minNum; return answer; }  ","id":50,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 최솟값이 8보다 크면 -1을 return 합니다. 문제풀이 해당 문제는 DP로 풀지못하여 DFS를 활용하였습니다. Count가 9이상이면","tags":null,"title":"프로그래머스 - N으로 표현","uri":"http://blog.cmstown.com/2020/04/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_020/","year":"2020"},{"content":"문제링크 \n사용언어  c++  \n주의사항  double형으로 값들을 계산할 경우 부동소수점에 유의해야 한다.  \n문제풀이 해당 문제를 풀기위한 순서는 다음과 같다.\n lines를 ' ' 단위로 1차적으로 split한다.   마지막 단어인 \u0026rsquo;s\u0026rsquo;는 빼준다.   1번에의하여 split된 시간값을 \u0026lsquo;:\u0026rsquo; 단위로 다시한번 split해준다.\n  2번에의하여 split된 값들을 이용하여 시작시간과 종료시간을 구하여 값을 저장한다.\n   시작 시간을 구할 떄, 0.001초에 해당하는 값은 더해주어야한다.(처리시간은 시작시간과 끝시간을 포함)  각각 로그들의 시작시간과 종료시간별로 1초가 지난 값들 안에 다른 로그들이 범위에 들어있는지 확인하여 최대 처리량을 구한다.  #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; double abs(double num){ if(num \u0026gt; 0) return num; return -num; } vector\u0026lt;string\u0026gt; splitByChar(string str, char ch){ vector\u0026lt;string\u0026gt; result; int ind = 0; for(int i = 0; i \u0026lt; str.size(); i++){ if(str[i] == ch){ result.push_back(str.substr(ind, i - ind)); ind = i + 1; } } result.push_back(str.substr(ind, str.size() - ind )); return result; } int solution(vector\u0026lt;string\u0026gt; lines) { int answer = 0; int size = lines.size(); vector\u0026lt;long\u0026gt; startTime; vector\u0026lt;long\u0026gt; endTime; for(int i = 0; i \u0026lt; size; i++){ vector\u0026lt;string\u0026gt; line = splitByChar(lines[i], ' '); vector\u0026lt;string\u0026gt; time = splitByChar(line[1], ':'); long d = (long)(stoi(time[0])*60*60*1000 + stoi(time[1])*60*1000 + stod(time[2])*1000); startTime.push_back(d - stod(line[2])*1000 + 1); endTime.push_back(d); } for(int i = 0; i\u0026lt; size; i++){ long s = startTime[i]; long e = endTime[i]; int tmp1 = 0; int tmp2 = 0; for(int j = 0; j \u0026lt; size; j++){ long cs = startTime[j]; long ce = endTime[j]; if(s \u0026lt;= ce \u0026amp;\u0026amp; s + 999 \u0026gt;= cs) tmp1++; if(e \u0026lt;= ce \u0026amp;\u0026amp; e + 999 \u0026gt;= cs) tmp2++; } answer = max(answer, max(tmp1,tmp2)); } return answer; }  ","id":51,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 double형으로 값들을 계산할 경우 부동소수점에 유의해야 한다. 문제풀이 해당 문제를 풀기위한 순서는 다음과 같다. lines","tags":null,"title":"프로그래머스 - [1차] 추석 트래픽","uri":"http://blog.cmstown.com/2020/04/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_019/","year":"2020"},{"content":"문제링크 \n사용언어  c++  \n주의사항   입력으로 판의 높이 m, 폭 n과 판의 배치 정보 board가 들어온다.\n  2 ≦ n, m ≦ 30\n  board는 길이 n인 문자열 m개의 배열로 주어진다. 블록을 나타내는 문자는 대문자 A에서 Z가 사용된다.\n 문제를 풀때 이 부분을 놓치면 9번 TC를 통과하지 못하게 된다.    \n문제풀이 해당 문제를 풀기 위해서 문제를 이해하고 어떻게 해야 문제를 풀 수 있을지 생각해보았다.\n  2x2블록들을 찾는다.\n  1번에서 찾은 블록들을 빈 블록 처리를 해준다.\n  블록들을 아래로 떨어트려 준다.\n  1~3 과정을 2x2블록을 찾지 못할 떄까지 진행한다.\n  2x2블록을 찾지 못하였으면 비어있는 블록들의 개수를 세준다.\n  위의 과정을 거치면 우리는 답을 구할 수 있다는 것을 알 수 있다. 그러면 코드로 구현해보자.\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; vector\u0026lt;string\u0026gt; friendsBoard; int nx[] = {0, 0, 1, 1}; int ny[] = {0, 1, 0, 1}; int answer = 0; // 블록을 아래로 떨어트리는 함수 void pushBoard(){ int w = friendsBoard[0].size(); int h = friendsBoard.size(); for(int i = h - 1; i \u0026gt;= 0; i--){ for(int j = w - 1; j \u0026gt;= 0; j--){ if(friendsBoard[i][j] != 'x') continue; int ind = -1; for(int k = i; k \u0026gt;= 0; k--){ if(friendsBoard[k][j] != 'x') { ind = k; break; } } if(ind == -1) continue; int cur = i; for(int k = ind; k \u0026gt;= 0; k--){ if(cur \u0026lt; 0) break; friendsBoard[cur][j] = friendsBoard[k][j]; friendsBoard[k][j] = 'x'; cur--; } } } } // 2x2 블록을 찾는 함수 bool findFriends(){ vector\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; boardLocation; int w = friendsBoard[0].size(); int h = friendsBoard.size(); for(int i = 0; i \u0026lt; h; i++){ for(int j = 0; j \u0026lt; w; j++){ bool find[4] = {false, }; char v = friendsBoard[i][j]; if(v == 'x') continue; for(int k = 0; k \u0026lt; 4; k++){ int x = i + nx[k]; int y = j + ny[k]; if(0 \u0026gt; x || 0 \u0026gt; y || x \u0026gt;= h || y \u0026gt;= w ) break; if(v == friendsBoard[x][y]){ find[k] = true; continue; } break; } if(find[0] \u0026amp;\u0026amp; find[1] \u0026amp;\u0026amp; find[2] \u0026amp;\u0026amp; find[3]){ for(int k = 0; k \u0026lt; 4; k++){ boardLocation.push_back(make_pair(i + nx[k], j + ny[k])); } find[0] = find[1] = find[2] = find[3] = false; } } } for(int i = 0; i \u0026lt; boardLocation.size(); i++){ int x = boardLocation[i].first; int y = boardLocation[i].second; friendsBoard[x][y] = 'x'; } if(boardLocation.size() == 0){ return false; } return true; } // 비어있는 블락을 찾는 함수 void findAnswer(){ int w = friendsBoard[0].size(); int h = friendsBoard.size(); for(int i = 0; i \u0026lt; h; i++){ for(int j = 0; j \u0026lt; w; j++){ if(friendsBoard[i][j] == 'x') answer++; } } } int solution(int m, int n, vector\u0026lt;string\u0026gt; board) { friendsBoard = board; bool find = true; findFriends(); while(find){ pushBoard(); find = findFriends(); } findAnswer(); return answer; }  ","id":52,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 입력으로 판의 높이 m, 폭 n과 판의 배치 정보 board가 들어온다. 2 ≦ n, m ≦ 30 board는 길이 n인 문자열 m개의 배열로 주어진","tags":null,"title":"프로그래머스 - [1차] 프렌즈4블록","uri":"http://blog.cmstown.com/2020/03/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_018/","year":"2020"},{"content":"문제링크 \n사용언어  c++  \n주의사항   문자열의 길이 : 1,000,000이하의 자연수\n  문자열은 모두 소문자로 이루어져 있습니다.\n  \n문제풀이 처음에 for문을 계속 돌려줘가며 탐색하는 방식으로 문제를 풀었다. 그러나 이 방식은 효율성 테스트를 통과하지 못하였고 다른 방법을 모색하였다. 이를 해결하기 위한 좋은 방법으로는 stack 자료구조를 활용하는 방법이다. 과정은 다음과 같다.\n  첫 글자는 무조건 stack에 담는다.\n  이후 두번째 글자부터 for문을 진행한다.\n  for문을 진행하면서 stack의 top에 있는 글자와 현재 글자가 같다면 stack을 pop 시켜준다.\n  같지 않다면 stack에 push해준다.\n  위와 같은 과정을 계속 진행하며 stack이 비어있다면 answer를 1로 변환해준다.\n  위 과정에서 stack에 top을 가르키기 전에 stack이 비어있는지 확인하여 비어있다면 비교하지 않고 해당 값을 push 해줘야한다. 코드를 보면 다음과 같다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;stack\u0026gt; using namespace std; int solution(string s) { int answer = 0; stack\u0026lt;char\u0026gt; st; st.push(s[0]); for(int i = 1; i \u0026lt; s.size(); i++){ if(st.empty()){ st.push(s[i]); continue; } if(st.top() == s[i]){ st.pop(); continue; } st.push(s[i]); } if(st.empty()) answer = 1; return answer; }  ","id":53,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 문자열의 길이 : 1,000,000이하의 자연수 문자열은 모두 소문자로 이루어져 있습니다. 문제풀이 처음에 for문을 계속 돌려","tags":null,"title":"프로그래머스 - 짝지어 제거하기","uri":"http://blog.cmstown.com/2020/03/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_017/","year":"2020"},{"content":"문제링크 \n사용언어  c++  \n주의사항   행의 개수 N : 100,000 이하의 자연수\n  열의 개수는 4개이고, 땅(land)은 2차원 배열로 주어집니다.\n  점수 : 100 이하의 자연수\n  \n문제풀이 처음 문제를 풀 때는 재귀로 문제에 접그하였더니 예제는 통과하였지만, 실행을 하니 모두 실패가 나왔다. 그래서 DP로 접근하여 문제를 풀기로 했다. 문제 풀이 과정은 다음과 같다.\n  행의 두번째 줄부터 열을 차례대로 검사한다.\n  해당칸은 이전 행에서 열이 같잊않은 칸들 중 가장 큰수를 더한값이 된다. 즉, n = n + max(n-1)(열이 같지 않은 칸 중 가장 큰 값) 이라는 점화식이 이용된다.\n  마지막 행까지 검사가 끝나면 마지막 행에서 가장 큰 값을 찾아 답을 구한다.\n  이를 코드로 표현하면 다음과 같습니다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int landW; int landH; int answer; void dfs(int x, int y, int sum, vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; land){ if(x \u0026gt;= landH || y \u0026gt;= landW){ return; } sum += land[x][y]; answer = max(answer, sum); for(int i = 0; i \u0026lt; landW; i++){ if(i == y) continue; dfs(x+1, i, sum, land); } } int solution(vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; land) { answer = 0; landH = land.size(); landW = land[0].size(); for(int i = 0; i \u0026lt; landH; i++){ for(int j = 0; j \u0026lt; landW; j++){ dfs(i,j,0, land); } } return answer; }  ","id":54,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 행의 개수 N : 100,000 이하의 자연수 열의 개수는 4개이고, 땅(land)은 2차원 배열로 주어집니다. 점수 : 100 이하의 자연수 문제풀이","tags":null,"title":"프로그래머스 - 땅따먹기","uri":"http://blog.cmstown.com/2020/03/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_016/","year":"2020"},{"content":"문제링크 \n사용언어  c++  \n주의사항   조건 1. n의 다음 큰 숫자는 n보다 큰 자연수 입니다.\n  조건 2. n의 다음 큰 숫자와 n은 2진수로 변환했을 때 1의 갯수가 같습니다.\n  조건 3. n의 다음 큰 숫자는 조건 1, 2를 만족하는 수 중 가장 작은 수 입니다.\n  \n문제풀이 문제의 조건에 맞게 문제의 풀이 과정은 다음과 같이 진행하였다.\n  n을 2진법으로 변환한데 1의 갯수를 센다.\n  n+1 부터 1000000까지 차례대로 2진법 변환을 하며 1의 갯수를 센다.\n  2번 과정을 반복하다 n의 2진법의 1의 갯수와 같은게 있으면 answer에 값을 저장하고 끝낸다.\n  위 과정을 코드로 표현하면 다음과 같습니다.\nusing namespace std; int cntN(int n){ int cnt = 0; while(n \u0026gt; 1){ if(n%2 == 1) cnt++; n /= 2; } return cnt; } int solution(int n) { int answer = 0; int current = cntN(n); for(int i = n+1; i \u0026lt; 1000001; i++){ if(current == cntN(i)){ answer = i; break; } } return answer; }  ","id":55,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 조건 1. n의 다음 큰 숫자는 n보다 큰 자연수 입니다. 조건 2. n의 다음 큰 숫자와 n은 2진수로 변환했을 때 1의 갯수가 같습니다. 조건 3.","tags":null,"title":"프로그래머스 - 다음 큰 숫자","uri":"http://blog.cmstown.com/2020/03/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_015/","year":"2020"},{"content":"문제링크 \n사용언어  c++  \n주의사항  DP를 적용하여 문제를 풀지않으면 시간 초과가 된다.  \n문제풀이  array[N][N] = (array[N-1][N], array[N][N-1], array[N-1][N-1]) 중 가장 작은 값 + 1\n 위의 점화식을 이용하여 문제를 풀면된다. 다만, 맨 윗줄과 맨 왼쪽줄을 제외하고 검사를 하기 때문에 해당 부분에 1값이 있는지 확인해줘야한다. 코드를 보면 다음과 같다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; bool visited[1002][1002]; void dfs(int x, int y){ } int solution(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; board) { int answer = 0; int h = board.size(); int w = board[0].size(); // 검사를 1,1부터 시작하기 때문에, 맨윗줄과 왼쪽줄에 1값이 있는지 검사한다. for(int i = 0; i \u0026lt; h; i++){ if(board[i][0] == 1) { answer = 1; break; } } for(int i = 0; i \u0026lt; w; i++){ if(board[0][i] == 1) { answer = 1; break; } } // DP를 이용하여 최대 넓이를 구한다. for(int i = 1; i \u0026lt; h; i++){ for(int j = 1; j \u0026lt; w; j++){ if(board[i][j] == 0) continue; // 진행하는 값이 0이라면 패스한다. board[i][j] = min(board[i-1][j-1], min(board[i-1][j],board[i][j-1])) + 1; // DP answer = max(board[i][j]*board[i][j], answer); // answer에 최대 넓이 값을 비교한다. } } return answer; }  ","id":56,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 DP를 적용하여 문제를 풀지않으면 시간 초과가 된다. 문제풀이 array[N][N] = (array[N-1][N], array[N][N-1], array[N-1][N-1]) 중 가장 작은 값 + 1 위의 점화식을 이용하여 문제를 풀면된다","tags":null,"title":"프로그래머스 - 가장 큰 정사각형 찾기","uri":"http://blog.cmstown.com/2020/03/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_014/","year":"2020"},{"content":"문제링크 \n사용언어  c++  \n주의사항   카펫의 테두리는 브라운이고, 테두리를 제외한 부분은 빨간색이다. 이 조건을 통해 두가지 공식이 나온다.\n  넓이*높이 = brown + red\n  (넓이 - 2)(높이 - 2) = red\n -2인 이유는, 높이의 경우 전체 높이에서 맨 위,아래 칸(테두리)을 뺀 값이고, 넓이의 경우 맨 왼쪽,오른쪽 칸(테두리)을 뺀 값이기 때문이다.      \n문제풀이 위 조건을 통해 넓이와 높이는 최소 3부터 시작되는 것을 알 수 있다. 그리하여 높이를 3부터 시작하여 차례대로 탐색하여 위 공식에 부합되는 값들을 구하면 된다. 코드는 다음과 같다.\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; solution(int brown, int red) { vector\u0026lt;int\u0026gt; answer; int sum = brown + red; for(int i = 3; i \u0026lt; sum; i++ ){ if(sum % i == 0){ int height = i; int weight = sum/height; if((height - 2)*(weight - 2) == red){ answer.push_back(weight); answer.push_back(height); break; } } } return answer; }  ","id":57,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 카펫의 테두리는 브라운이고, 테두리를 제외한 부분은 빨간색이다. 이 조건을 통해 두가지 공식이 나온다. 넓이*높이 = brown + red (넓이","tags":null,"title":"프로그래머스 - 카펫","uri":"http://blog.cmstown.com/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_013/","year":"2020"},{"content":"\n### [백준 문제 바로가기](https://www.acmicpc.net/problem/2217) #### 사용 언어  C++  적용 알고리즘   브루트 포스\n  DFS\n  주의사항  크기가 양수인 부분수열 중에서 그 수열의 원소를 다 더한 값이 S가 되는 경우의 수  문제풀이  해당 문제는 중복되지 않는 수열 조합의 합의 문제로 볼 수 있다. 그래서 재귀를 통해 문제를 풀었는데 틀렸다고 나왔다..첫 코드는 다음과 같다.  #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int N, S; int cnt; vector\u0026lt;int\u0026gt; v; void solution(int ind, int sum) { if (N \u0026lt;= ind) { return; } if (sum == S) { cnt++; } solution(ind + 1, sum + v[ind]); solution(ind + 1, sum); } int main() { cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; for (int i = 0; i \u0026lt; N; i++) { int tmp; cin \u0026gt;\u0026gt; tmp; v.push_back(tmp); } v.push_back(0); solution(0, 0); cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; }  왜 틀렸는지 이유를 보았더니, S가 0일때 중복해서 cnt값이 증가되는 것을 알수있다. 즉, 그래서 해당 부분을 수정하여 다시 작성하였다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int N, S; int cnt; vector\u0026lt;int\u0026gt; v; void solution(int ind, int sum) { if (N \u0026lt;= ind) { return; } if (sum + v[ind] == S) { cnt++; } solution(ind + 1, sum + v[ind]); solution(ind + 1, sum); } int main() { cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; for (int i = 0; i \u0026lt; N; i++) { int tmp; cin \u0026gt;\u0026gt; tmp; v.push_back(tmp); } v.push_back(0); solution(0, 0); cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; }  sum과 S를 비교하는 if문에서 sum 대신에 sum + v[ind]를 비교하며 앞서 틀렸던 오류를 해결하였다. 현재 sum이 아닌 다음 sum값을 미리 비교하므로 어떠한 수도 조합하지 않았을 때 비교하는 경우는 없을 것이다.\n","id":58,"section":"posts","summary":"### [백준 문제 바로가기](https://www.acmicpc.net/problem/2217) #### 사용 언어 C++ 적용 알고리즘 브루트 포스 DFS 주의사","tags":["브루트 포스트"],"title":"백준 1182 - 부분수열의 합","uri":"http://blog.cmstown.com/2020/02/%EB%B0%B1%EC%A4%801182/","year":"2020"},{"content":"문제링크 \n사용언어  c++  \n주의사항   stock에 있는 밀가루는 오늘(0일 이후)부터 사용됩니다.\n  stock과 k는 2 이상 100,000 이하입니다.\n  dates의 각 원소는 1 이상 k 이하입니다.\n  supplies의 각 원소는 1 이상 1,000 이하입니다.\n  dates와 supplies의 길이는 1 이상 20,000 이하입니다.\n  k일 째에는 밀가루가 충분히 공급되기 때문에 k-1일에 사용할 수량까지만 확보하면 됩니다.\n  dates에 들어있는 날짜는 오름차순 정렬되어 있습니다.\n  dates에 들어있는 날짜에 공급되는 밀가루는 작업 시작 전 새벽에 공급되는 것을 기준으로 합니다. 예를 들어 9일째에 밀가루가 바닥나더라도, 10일째에 공급받으면 10일째에는 공장을 운영할 수 있습니다. 밀가루가 바닥나는 경우는 주어지지 않습니다.\n  \n문제풀이 해당 문제는 우선순위 큐를 이용하여 풀 수 있다. 우선순위 큐를 통해 stock이 k값을 넘어갈때까지 자신이 공급받을 수 있는 밀가루를 공급받으면 된다. 이를 코드로 표현하면 다음과 같다.\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; int solution(int stock, vector\u0026lt;int\u0026gt; dates, vector\u0026lt;int\u0026gt; supplies, int k) { int answer = 0; priority_queue\u0026lt;int\u0026gt; pq; int before_stock = 0; int search_index = 0; // stock이 k를 이상일떄까지 while(stock \u0026lt; k){ int dates_size = dates.size(); // 필요한 supplies를 공급받기 위해 반복문 수행 for(int i = search_index; i \u0026lt; dates_size; i++){ // supplies를 받을 수 있는 날짜의 supplies를 pq에 저장 if(before_stock \u0026lt;= dates[i] \u0026amp;\u0026amp; dates[i] \u0026lt;= stock){ search_index = i + 1; // 저장한 날짜의 인덱스 값 저장(추후 마지막으로 저장된 인덱스 값부터만 for문) pq.push(supplies[i]); } } before_stock = stock; // 이전 stock에 현재 stock을 저장 stock += pq.top(); // 현재 stock에 pq중 가장 많은 값을 저장 pq.pop(); // 사용한 supplies값을 pop answer++; // answer 추가 } return answer; }  ","id":59,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 stock에 있는 밀가루는 오늘(0일 이후)부터 사용됩니다. stock과 k는 2 이상 100,000 이하입니다. dates의 각 원소는 1","tags":null,"title":"프로그래머스 - 라면 공장","uri":"http://blog.cmstown.com/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_012/","year":"2020"},{"content":"문제링크 \n사용언어  c++  \n주의사항   숫자는 1~9까지만 존재한다\n  동일한 숫자는 없다\n  \n문제풀이 일단 문제에서 답이될 수는 123~987에서 0을 포함하거나, 동일한 숫자가 있는 경우를 제외한 모든 숫자가 처음에 답이 될 수 있다. 이후 baceball에 담겨있는 숫자와 스트라이크,볼 정보를 통해 숫자들을 다 비교하며 답이 될 수 없는 수는 완전히 제외 하다보면 답이 될 수있는 수의 개수를 구할 수 있다.\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int solution(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; baseball) { int answer = 0; int baseball_size = baseball.size(); vector\u0026lt;string\u0026gt; answers; // 가능한 모든 경우의 수 추가 for(int i = 123; i \u0026lt;= 987; i++){ string number = to_string(i); // 숫자에 0이 들어가있거나 동일한 숫자가 들어있으면 추가X if(number[1] == '0' || number[2] == '0' || number[0] == number[1] || number[1] == number[2] || number[0] == number[2]){ continue; } answers.push_back(number); } // baseball에 담긴 for(int i = 0; i \u0026lt; baseball_size; i++){ string number = to_string(baseball[i][0]); int answers_size = answers.size(); for(int j = answers.size() - 1; j \u0026gt;= 0; j--){ int strike = 0; int ball = 0; string check = answers[j]; for(int k = 0; k \u0026lt; 3; k++){ if(number[k] == check[k]){ strike++; } if(number[k] == check[(k+1)%3] || number[k] == check[(k+2)%3]){ ball++; } } if(baseball[i][1] == strike \u0026amp;\u0026amp; baseball[i][2] == ball) continue; answers.erase(answers.begin() + j); } } answer = answers.size(); return answer; }  ","id":60,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 숫자는 1~9까지만 존재한다 동일한 숫자는 없다 문제풀이 일단 문제에서 답이될 수는 123~987에서 0을 포함하거나, 동일한 숫","tags":null,"title":"프로그래머스 - 숫자 야구","uri":"http://blog.cmstown.com/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_011/","year":"2020"},{"content":"문제링크 \n사용언어  c++  \n주의사항  서로 다른 옷의 조합의 수를 구하는 공식을 생각해보자.  \n문제풀이 처음에 공식을 생각하지 않은 채, 재귀로 조합으로 경우의 수를 구하여 시간초과가 났다. 이에 다른 풀이법이 있을 것을 예상하고 일정한 공식을 찾아보았다.\n 옷의 종류가 얼굴, 상의, 하의 인 경우\n   (얼굴 개수 + 1)(상의 개수 + 1)(하의 개수 + 1) - 1 이다\n 여시서 (+ 1)은 해당 옷을 입지않은 경우고, 마지막에 있는 (-1)은 전체 옷을 아무것도 안입을 떄이다.    즉, 해당 공식을 코드로 표현하면 다음과 같다.\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;map\u0026gt; using namespace std; int solution(vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; clothes) { int answer = 1; map\u0026lt;string, int\u0026gt; m; vector\u0026lt;string\u0026gt; order; // 중보되는 옷을 구한다 int clothes_size = clothes.size(); for (int i = 0; i \u0026lt; clothes_size; i++) { if (m[clothes[i][1]] == 0) { m[clothes[i][1]]++; order.push_back(clothes[i][1]); continue; } m[clothes[i][1]]++; } // 공식 수행 for (int i = 0; i \u0026lt; order.size(); i++) { answer = answer * (m[order[i]] + 1); } answer -= 1; return answer; }  ","id":61,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 서로 다른 옷의 조합의 수를 구하는 공식을 생각해보자. 문제풀이 처음에 공식을 생각하지 않은 채, 재귀로 조합으로 경우의 수를 구하여 시","tags":null,"title":"프로그래머스 - 위장","uri":"http://blog.cmstown.com/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_010/","year":"2020"},{"content":"문제링크 \n사용언어  c++  \n주의사항  종이접기를 진행할 떄마다 생기는 규칙을 찾아야한다.  \n문제풀이 문제의 예제만으로는 규칙을 찾기 어려워 n=4일 떄 값을 직접 구해보아 규칙을 찾기로 하였다. n=4일 떄 값을 구하니 규칙이 보이기 시작하였다, 내가 세운 규칙은 다음과 같다.\n n = 1, 0\n  n = 2, 0 0 1\n  n = 3, 001 0 011\n  n = 4, 0010011 0 0011011\n 위 규칙을 해석하면 다음과 같다.\n  종이를 접었을 때 나오는 결과의 가운데는 항상 0(\u0026lsquo;V\u0026rsquo;)이다.\n  n = n-1 +'0\u0026rsquo; + (n-1의 가운데가 1인 값) 이다.\n 즉, 가운제를 기준으로 왼쪽은 이전에 접었던 결과와 같고, 오른쪽은 이전에 접었던 결과에서 가운데만 1(\u0026lsquo;ㅅ\u0026rsquo;)인 값이다.    위의 규칙을 코드로 작성하면 다음과 같다.\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; solution(int n) { vector\u0026lt;int\u0026gt; answer; if(n == 1) { answer.push_back(0); return answer; } if(n == 2){ answer.push_back(0); answer.push_back(0); answer.push_back(1); return answer; } string result = \u0026quot;001\u0026quot;; for(int i = 3; i \u0026lt;= n; i++){ string tmp = result; string tmp2 = result; tmp2[result.size()/2] = '1'; result = tmp + '0' + tmp2; } int result_size = result.size(); for(int i = 0; i \u0026lt; result_size; i++){ answer.push_back(result[i] - '0'); } return answer; }  ","id":62,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 종이접기를 진행할 떄마다 생기는 규칙을 찾아야한다. 문제풀이 문제의 예제만으로는 규칙을 찾기 어려워 n=4일 떄 값을 직접 구해보아","tags":null,"title":"프로그래머스 - 종이접기","uri":"http://blog.cmstown.com/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_009/","year":"2020"},{"content":"문제링크 \n사용언어  c++  \n주의사항   어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다.\n 조합하여 가장 큰 수가 아닌 숫자 순서를 유지하며 k개의 수를 제거하는 것을 의미한다.    \n문제풀이 처음 문제를 풀 떄 조합을 하여 가장 큰수 인줄 알았지만, 숫자 순서를 유지한채 k개의 수를 제거하는 문제였다. 문제를 풀기 위해 어떻게 해야 가장 큰수를 구할지 생각해보았다. 먼저, answer의 길이 = (number의 길이 - k) 이다. 그러므로 answer의 길이 를 number의 길이 - k 만큼 보장한다는 전제하여 앞에서부터 가장 큰 수를 선택하면 된다. 해당 과정을 단계별로 설명하면 다음과 같다.\n  0 부터 number.size - (number.size() - k) 까지 중에 가장 큰 수 선택하여 answer에 추가\n  k를 1만큼 감소\n  1,2 과정을 number.size() - k가 0이 될 때까지 혹은 answer의 길이가 초기의 number의 길이 - k 와 같을 때까지 진행한다.\n  이후 answer의 길이가 초기의 number의 길이 - k 와 같지 않다면 이전에 저장한 큰 수의 인덱스부터 number의 끝까지 answer의 뒤에 추가해준다.\n  이를 코드로 표현하면\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; string solution(string number, int k) { string answer = \u0026quot;\u0026quot;; int number_size = number.size(); int value = -1; int value_ind; int kk = k; int default_last = number_size - k; k= number_size - k; for(int i = 0; i \u0026lt;= (number_size - k); i++){ if(answer.size() == default_last) break; if(k == 0) { break; } int tmp = number[i] - '0'; if(value \u0026lt; tmp){ value = tmp; value_ind = i; } if(i == (number_size - k)){ i = value_ind; value = -1; --k; answer += number[value_ind]; } } answer += number.substr(value_ind+1); return answer; }  ","id":63,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다. 조합하여 가장 큰 수가 아닌 숫자 순서를 유지하며 k개의","tags":null,"title":"프로그래머스 - 큰 수 만들기","uri":"http://blog.cmstown.com/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_008/","year":"2020"},{"content":"문제링크 \n사용언어  c++  \n주의사항  1,2,4 숫자가 반복 진행 되므로 3진법을 구하는 방법과 비슷하게 진행하면 된다.  \n문제풀이   124 나라에서는 10진법 124 수로 표현되는 과정을 보자.\n 3으로 몫을 계속해서 나누고 나머지가 0일 떄 몫을 -1 한다.    11(10진법)일 때 11/3 = 3 ... 2 3/3 = 1 -1 ... 0 // 나머지가 0이므로 몫을 -1한다. 나머지들을 밑에서부터 나열하면 02가 된다. 9(10진법) 9/3 = 3 - 1 ... 0 2/3 = 0 ... 2 나머지들을 밑에서부터 나열하면 20가 된다.  여기서 0을 4라고 생각하면 답은 순서대로 42, 24가 된다.\n그러면 위와 같은 식을 코드로 구현해보자.\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; string solution(int n) { string answer = \u0026quot;\u0026quot;; char num[3] = {'4', '1', '2'}; // 나머지를 인덱스로하는 실제값 while(true){ if(n == 0){ break; } else{ int tmp = n%3; answer = num[tmp] + answer; n /= 3; if(tmp == 0) n--; } } return answer; }  위 코드와 과정을 이해하였다면 어떠한 진법 변환 문제도 적용할 수 있을 것이다 :D\n","id":64,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 1,2,4 숫자가 반복 진행 되므로 3진법을 구하는 방법과 비슷하게 진행하면 된다. 문제풀이 124 나라에서는 10진법 124 수로 표현되는 과정을 보","tags":null,"title":"프로그래머스 - 124 나라의 숫자","uri":"http://blog.cmstown.com/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_007/","year":"2020"},{"content":"Chapter 09 - 단위 테스트  사실 단위 테스트는 한 챕터로 설명하기에 부족한면이 없지않아 있다. 해당 챕터는 추후에 정리할 \u0026ldquo;자바와 JUnit을 활용한 실용주의 단위 테스트\u0026rdquo;라는 책을 가지고 정리해가며 공부할 때 더 다뤄볼 예정이다. 그러므로 해당 챕터는 생략하겠다.\n","id":65,"section":"posts","summary":"Chapter 09 - 단위 테스트 사실 단위 테스트는 한 챕터로 설명하기에 부족한면이 없지않아 있다. 해당 챕터는 추후에 정리할 \u0026ldquo;자바와 JUnit을 활용한 실용주","tags":null,"title":"Chapter 09 - 단위 테스트","uri":"http://blog.cmstown.com/2020/02/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C_009/","year":"2020"},{"content":"알고리즘 문제를 풀면서 어떠한 문제를 풀 때 어떠한 알고리즘을 적용해야하는 특징이 보이는 경우가 있다. 그래서 그러한 특징들이 보일 떄 마다 정리하려고 한다.\n알고리즘 특징 1. DFS(깊이 우선 탐색) vs BFS(넓이 우선 탐색)\nDFS/BFS는 그래프 문제의 대표적인 알고리즘이라 많은 사람들이 많이들 접해봤을 거라 생각한다. 사실 DFS로만 BFS로만 문제를 풀어야하는 경우는 거의 없다. 왠만하면 두 알고리즘 적용이 다 가능하다. 그래서 필자같은 경우에도 특별하게 메모리 초과가 날 것 같지않으면 DFS가 편해 DFS로 문제를 거의 푼다.\n  DFS\n  재귀or스택을 이용하여 구현한다.\n 나는 주로 재귀를 통해 구현한다.      BFS\n  큐를 이용하여 구현한다.\n  나는 주로 최단 경로를 탐색할 떄 많이 적용한다.\n 가중치 없는 그래프의 최단 경로문제는 BFS로만 접근해야 한다고 한다.      \n2. Dynamic Programming(다이나믹 프로그래밍)\n일정한 규칙을 가지고 결과를 도출하는 문제들은 거의 DP이다. 사실 DP에서 점화식 만 구하면 어지간하면 답을 구하지만 처음 보는 문제의 점화식을 구하기는 절대 쉽지 않다. 그래서 내가 느끼기엔 더 많은 문제를 계속해서 풀어봐야 하는 것 같다.\n\n3. Greedy Algorithm(탐욕 알고리즘)\n코딩 테스트 및 여러가지 알고리즘 문제에서 대표적인 알고리즘이다. 해당 문제를 풀기 위해서는 정렬,자료구조 개념이 있으면 좋을 것 같다.\n\n3. Kruskal Algorithm(크루스칼 알고리즘)\n보통 최소 신장 트리의 구현(MST) 방법으로 채택되는 알고리즘이다.즉, 가장 적은 비용으로 모든 노드를 연결하기 위해 사용되는 알고리즘이다. 크루스칼 알고리즘에서는 Union-Finde(합집합 찾기) 를 사용한다.\n\n4. Dijkstra Algorithm(다익스트라 알고리즘)\n하나의 정점에서 다른 모든 정점까지의 최단 경로 를 구하는 문제에 사용된다. 보통 우선순위 큐(Priority Queue)를 활용해서 문제를 푼다.\n\n5. Floyd Warshall Algorithm(플로이드 와샬 알고리즘)\n다익스트라는 하나의 정점에서 다른 모든 정점이라면, 플로이드 와샬은 모든 정점에서 다른 모든 정점의 최단 경로 를 구하는 문제에 사용된다.\n\n6. Topological Sorting(위상 정렬)\n\n7. Strongly Connected Component(강한 결합 요소)\n\n","id":66,"section":"posts","summary":"알고리즘 문제를 풀면서 어떠한 문제를 풀 때 어떠한 알고리즘을 적용해야하는 특징이 보이는 경우가 있다. 그래서 그러한 특징들이 보일 떄 마다 정리하려고 한다. 알고리","tags":["알고리즘"],"title":"알고리즘 특징정리","uri":"http://blog.cmstown.com/2020/02/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%ED%8A%B9%EC%A7%95%EC%A0%95%EB%A6%AC/","year":"2020"},{"content":"문제링크 \n사용언어  c++  \n주의사항   문제의 제한사항을 주의깊게 보자\n  제한사항\n  전체 학생의 수는 2명 이상 30명 이하입니다.\n  체육복을 도난당한 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다.\n  여벌의 체육복을 가져온 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다.\n  여벌 체육복이 있는 학생만 다른 학생에게 체육복을 빌려줄 수 있습니다.\n  여벌 체육복을 가져온 학생이 체육복을 도난당했을 수 있습니다. 이때 이 학생은 체육복을 하나만 도난당했다고 가정하며, 남은 체육복이 하나이기에 다른 학생에게는 체육복을 빌려줄 수 없습니다.(이 제한사항이 중요한 것 같다)\n      \n문제풀이 처음 문제를 풀었을 때 제한사항 중 마지막 부분을 읽지 못하고 문제를 풀어 답이 틀렸다고 나왔다, 이후 어떤점이 문제가 있었는지 알기 위해 문제를 다시 읽어보았고 제한사항에서 놓친 부분이 있다는 것을 알게되어서 코드를 수정하고 제출하여 정답을 맞았다.\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int solution(int n, vector\u0026lt;int\u0026gt; lost, vector\u0026lt;int\u0026gt; reserve) { int answer = 0; vector\u0026lt;int\u0026gt; v(n+2,1); // 0~n+1까지 체육복 개수를 1로 초기화 // 체육복을 잃어버린 학생의 체육복 개수 1 감소 int lostSize = lost.size(); for(int i = 0; i \u0026lt; lostSize; i++){ v[lost[i]]--; } // 여분의 체육복을 가진 학생의 체육복 개수 1 증가 int reserveSize = reserve.size(); for(int i = 0; i \u0026lt; reserveSize; i++){ int ind = reserve[i]; v[ind]++; } for(int i = 0; i \u0026lt; reserveSize; i++){ int ind = reserve[i]; // 제한사항 마지막 부분에 해당하는 학생은 넘어간다. if(v[ind] \u0026lt; 2) continue; // 체육복은 앞에 있는 학생 먼저 나눠주고 앞에 학생이 체육복이 있다면 뒤에 학생을 확인한다. if(v[ind-1] == 0) v[ind-1]++; else if(v[ind+1] == 0) v[ind+1]++; } // 체육복을 가지고 있는 학생 수만큼 answer를 증가시킨다 for(int i = 1; i \u0026lt;= n; i++){ if(v[i] != 0) { answer++; } } return answer; }  ","id":67,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 문제의 제한사항을 주의깊게 보자 제한사항 전체 학생의 수는 2명 이상 30명 이하입니다. 체육복을 도난당한 학생의 수는 1명 이상 n명","tags":null,"title":"프로그래머스 - 체육복","uri":"http://blog.cmstown.com/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_006/","year":"2020"},{"content":"\n### [백준 문제 바로가기](https://www.acmicpc.net/problem/10610) #### 사용 언어  C++  적용 알고리즘   그리디 알고리즘\n  정렬\n  주의사항  재귀를 통해 순열을 구하여 정답을 찾았지만 메모리 초과가 나왔다.  문제풀이 초기에 순열을 통해 문제를 풀었지만 메모리 초과가 나와 다른 방법을 찾아보았다. 그 결과 30의 배수가 되기 위해서 두 가지 조건을 가져야 한다는 것을 알게 되었다.\n  마지막 일의 자리는 무조건 0이 되어야 한다.\n  마지막 숫자를 제외한 나머지 숫자들의 합은 3의 배수이다.\n  #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; vector\u0026lt;char\u0026gt; v; bool cmp(char c1, char c2) { return c1 \u0026gt; c2; } int main() { string str = \u0026quot;\u0026quot;; string answer = \u0026quot;\u0026quot;; int sum = 0; cin \u0026gt;\u0026gt; str; int strSize = str.size(); for (int i = 0; i \u0026lt; strSize; i++) { v.push_back(str[i]); } // 큰 숫자대로 정렬 sort(v.begin(), v.end(), cmp); // 마지막 숫자가 0이 아니면 30의 배수가 될 수 없다. if (v[strSize - 1] != '0') { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; return 0; } // 모든 수의 합을 구한다. for (int i = 0; i \u0026lt; strSize; i++) { sum += v[i] - '0'; answer += v[i]; } if (sum % 3 == 0) { cout \u0026lt;\u0026lt; answer \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; } }  ","id":68,"section":"posts","summary":"### [백준 문제 바로가기](https://www.acmicpc.net/problem/10610) #### 사용 언어 C++ 적용 알고리즘 그리디 알고리즘 정","tags":["그리디 알고리즘"],"title":"백준 10610 - 30","uri":"http://blog.cmstown.com/2020/02/%EB%B0%B1%EC%A4%8010610/","year":"2020"},{"content":"JWT(JSON Web Token)  프로젝트를 진행 중 모바일에서 로그인 API를 제공해야 될 일이 생겼다. 기존에 웹에서 프로젝트를 할 때는 session 정보를 이용하여 로그인 기능을 제공하였는데 모바일 환경에서 JWT를 이용하여 로그인 API를 제공한다는 것을 알게되고 실제 프로젝트에 적용해봤다. 프로젝트가 끝난 이후 JWT에 대헤서 다시 한번 상기시키고 문서로 개념을 정리해보려고 한다.\n\n1. JWT란?  JWT란 JSON Web Token의 약자로 Json 포맷을 이용하여 Claim(사용자 정보나 데이터 속성 등을 의미) 정보를 디지털 서명 하고 이후 비밀 서명 키로 검증하는 Web Token입니다.\n   두 개체에서 JSON 객체를 이용해 Self-contained 방식으로 정보를 안전한게 전달\n  JWT는 토큰 자체에 정보를 가지고 있다.\n  회원 인증, 정보 전달에 주로 사용\n  위의 말도 어렵다면 쉽게 정보를 가진 토큰을 통한 인증을 위해 사용된다고 이해하면 좋다.\n\n2. JWT 구조 JWT는 Header, Payload, Signature 로 3부분으로 JSON 형태를 Base64로 인코딩하여 이루져있다.\n  Header\n  토큰의 첫번째 파트이다.\n  전형적으로 2가지 파트로(alg 와 typ)으로 구성되어있다.\n  alg : 알고리즘 방식을 지정하며, 서명(Signature) 및 토큰 검증에 사용\n  typ : 토큰의 타입\n      Payload\n  토큰의 두번째 파트이고 Claim 정보를 담고있다. Claim은 총 3가지 파트로 나누어진다.\n  Claim\n  Registered claims(등록된 클레임)\n토큰 정보를 표현하기 위해 이미 정해진 종류의 데이트들이다. 모두 선택적으로 작성이 가능하며 사용할 것을 권장한다. 또한 JWT를 간결하게 위해 key는 모두 3글자이다.\n  iss : 토큰 발급자(issuer)\n  sub : 토큰 제목(subject)\n  aud : 토큰 대상자(audience)\n  exp : 토큰 만료 시간(expiration), NumericDate 형식으로 되어 있어야 함 ex) 1480849147370\n  nbf : 토큰 활성 날짜(not before), 이 날이 지나기 전의 토큰은 활성화되지 않음\n  iat : 토큰 발급 시간(issued at), 토큰 발급 이후의 경과 시간을 알 수 있음\n  jti : JWT 토큰 식별자(JWT ID), 중복 방지를 위해 사용하며 일회성 토큰(Access Token) 등에 사용\n  토큰\n    Public claims(공개 클레임)\n충돌 방지를 위해 공개된 클레임이다. 보통 URI형식으로 짓는다.\n  Private claims(비공개 클레임)\n서버와 클라이언트간에 협의된 클레임 이름이다.\n    Payload의 예제로는 다음과 같습니다.\n{ // 실제 프로젝트에 적용한 AccessToken 예제 \u0026quot;sub\u0026quot;: \u0026quot;AccessToken\u0026quot;, \u0026quot;iat\u0026quot;: 1581231911, \u0026quot;exp\u0026quot;: 1581232271, \u0026quot;uid\u0026quot;: \u0026quot;21\u0026quot; }    Verify Signature\nSignature(서명)은 토큰을 인코딩하거나 유효성 검증을 할 때 사용하는 고유한 암호화 코드이다. Signature는 Header와 Payload의 값을 인코딩(BASE64)하고, 이코딩한 값을 비밀 키를 이용해 Header에 정의한 알고리즘으로 해싱을 하고, 이 값을 BASE64로 인코딩하여 생산한다.\nHMACSHA256( base64UrlEncode(header) + \u0026quot;.\u0026quot; + base64UrlEncode(payload), your-256-bit-secret    \n3. JWT 장점과 단점 장점\n  JWT는 발급 후 토큰 검증만 하면 되기 때문에 저장소가 필요없다.\n  세션 정보를 유지할 필요가 없어, 로드밸런싱 환경에서 유리하다.\n  토큰 기반으로 하는 다른 인증 시스템에 접근이 가능하다.\n  정보를 가지고 있어 별도의 쿼리문을 줄일 수 있다.\n  단점\n  JWT는 한 번 발급되면 유효기간이 지나기 전까지 정보들을 탈취할 수 있다.\n Access Token과 Refresh Token을 이용해 피해를 줄일 수 있다.    payload 정보가 제한적이다.\n JWT는 서명에 의해 변조되지 않음을 보장할 순 있지만 데이터를 다른 사람이 볼 수 있으므로 Header나 Payload에 private한 정보는 넣지 않을 것을 권장합니다.    \n4. Access Token \u0026amp; Refresh Token 앞서 말한 JWT의 단점 중에 토큰을 탈취 당할 경우 보안에 취약하다는 단점이 있었다. 토큰의 유효기간은 길 수록 토큰이 탈취 당했을 떄 보안에 취약하게 된다. 그렇다고 토큰의 유효기간이 짧아지면 새 토큰을 발급받기 위해 로그인을 자주 시도해야 되게 된다. 이러한 문제점에서 해결 대안으로 나온 것이 Access Token과 Refresh Token 이다. 이 개념은 OAuth에서 나왔는데 이는 추후에 공부해도록 하겠다.\nAccess Token과 Refresh Token 모두 JWT 형태입니다. 로그인 완료되었을 떄 유효기간이 짧은 Access Token과 비교적 유효기간이 긴 Refresh Token을 발행합니다. Refresh Token은 Access Token의 유효기간이 만료되었을 떄 새로 Token을 발급해주는 열쇠가 됩니다.\n에를 들어보면\n  가정) Refresh Token은 유효기간이 2주, Access Token은 유효기간이 1시간이다.\n  사용자는 로그인을 하여 Refresh,Access Token을 받는다\n  사용자는 API 요청을 하다가 1시간이 지나면 Access Token이 만료된다.\n  Refresh Token의 유효기간이 지나지 않았다면 새롭게 Access Token을 발급받는다.\n  Refresh Token은 2주가 지나면 유효기간이 만료된다.\n  사용자는 새로 로그인을 한다.\n  위와 같은 과정을 통해 기존에 유효기간이 길 수록 보안에 취약한 Access Token으 단점을 보완하고, 유효기간을 줄일 경우 로그인을 자주 시도해야 된다는 단점을 Refresh Token으로 보완한 것을 알 수 있습니다.\n  위의 예시를 조금더 자세하게 그림으로 설명하면 다음과 같습니다.\n 여기서 9~11번은 무조건적인 상황은 아니다. 클라이언트에서 Access Token의 Payload를 통해 유효기간을 알기 떄문에 API 요청전에 토큰이 만료되면 클라이언트에서 토큰 재발급을 요청할수있다.  결론적으로 Refresh Token을 통해 Access Token을 단독적으로 사용했을 때보다 보안에 좋아졌다는 점을 알 수 있다. 그러나 Access Token이 만료될 떄마다 새롭게 발급받기 위해 HTTP 요청이 많아진다는 단점이 있습니다.\n\n5. 마무리 이번 문서를 통해 JWT를 다시 정리하며 개념을 확고히 잡은 것 같습니다. 혹여나 잘못된 정보가 있으면 언제든지 댓글 달아주시면 감사하겠습니다. 다음 JWT 예제 포스팅에서 뵙도록 하겠습니다 :D\n\n참고 자료\n  https://jwt.io/introduction\n  https://mangkyu.tistory.com/56\n  https://elfinlas.github.io/2018/08/12/whatisjwt-01/\n  https://brownbears.tistory.com/440\n  ","id":69,"section":"posts","summary":"JWT(JSON Web Token) 프로젝트를 진행 중 모바일에서 로그인 API를 제공해야 될 일이 생겼다. 기존에 웹에서 프로젝트를 할 때는 session 정보를 이용하여 로그인 기능을 제공하였는데 모바","tags":null,"title":"JWT(1) - JWT(JSON Web Token)란 무엇인가?","uri":"http://blog.cmstown.com/2020/02/%EA%B3%B5%EB%B6%80_jwt/","year":"2020"},{"content":"Spring Webflux  최근 교내 커뮤니티 동아리 유어슈에서 Spring Webflux를 이용하여 프로젝트를 하였다. 사실 기존 동아리 스펙이 webflux로 정해져서 어쩔수 없이 새로운 프로젝트에 사용하여서 webflux가 왜 필요한지? 어떠한 장점이 있는지? 등 이해도가 부족하다는 생각이 들었다. 그래서 앞으로 webflux를 정리하고 reactive programming을 이해하하는 과정을 문서로 담아 정리하려고 한다.\n연관된 나의 글  리엑티브 프로그래밍이란?  Spring Webflux란? reactive-stack 웹 프레임워크인 Spring Webflux는 Spring 5버전부터 추가되었다. Webflux는 non-blocking을 지향하고 Reactive Streams back pressure을 지원한다. 그리고 Sprinb MVC와 Spring Webflux는 같이 사용할 수 있다.\nSpring 웹 요청을 처리하는 방식\n 요청 매핑    웹 요청을 어느 핸들러에게 보낼지 결정\n  URL, 헤더\n  @RequestMapping\n  요청 바인딩    핸들러에 전달할 웹 요청 준비\n  웹 URL, 헤더, 쿠키, 바디 등\n  핸들러(controller) 실행   전달 받은 요청 정보를 이용해 로직을 수행하고 결과를 리턴  핸들러 결과 처리(응답 생성)   핸들러의 리턴 값으로 웹 응답 생성  @RestController public class MyController { @GetMapping(\u0026quot;/hello/{name}\u0026quot;) // 1. 요청 매핑 String hello(@PathVariable String name){ // 2. 요청 바인딩 return \u0026quot;Hello! \u0026quot; + name; // 3,4. 해들러 실행 후 결과 처리 } }  함수형 WebFlux가 웹 요청을 처리하는 방식\n 요청 매핑   RouterFunction  요청 바인딩  -HandlerFUnction\n핸들러 실행  -HandlerFUnction\n핸들러 결과 처리(응답 생성)  -HandlerFUnction\nspring webflux를 사용하는 이유   비동기-논블럭킹 리엑티브 개발에 사용\n  효율적으로 등장하는 고성능 웹 애플리케이션 개발\n  서비스간 호출이 많은 마이크로서비스 아키텍처에 적합\n  새로운 방식으로 개발해보고 싶은 호기심 충족\n 발표자 토비님께서는 이를 권장하지 않는다 하셨다.    thread pool hell 발생을 저하\n 일반적으로 spring은 멀티 스레드 기반으로 동작하고, 만약 blocking IO로 진행된다면 준비된 스레드보다 더 많은 요청이 들어올 경우 thread pool hell이 발생합니다. 하지만 webflux를 사용할 경우 비동기 non-blocking IO로 서버의 코어 갯수만큼 스레드가 할당되어 사용되기 때문에, thread pool hell이 발생을 줄일 수 있습니다.    검증된 JVM과 방대한 자바 생태계를 이용할 수 있는 장점이 있습니다.\n  webflux 작동원리 지원 웹 서버/컨테이너  Sel  \n참고자료\n 스프링캠프 강의 - 토비  20.02.07 아직 작성이 완료되지 않은 문서입니다 :D ","id":70,"section":"posts","summary":"Spring Webflux 최근 교내 커뮤니티 동아리 유어슈에서 Spring Webflux를 이용하여 프로젝트를 하였다. 사실 기존 동아리 스펙이 webflux로 정해져서 어쩔수 없이 새로운","tags":["spring webflux"],"title":"리액티브","uri":"http://blog.cmstown.com/2020/02/%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_webflux/","year":"2020"},{"content":"문제링크 \n사용언어  c++  \n\n주의사항   대각선이 지나가는 단위 정사각형의 개수를 구하는 수학적인 공식\n  h + w - (h와w의 최대공약수)\n  사실 왜 이러한 공식이 나오는 지 이해는 못하였다.\n    answer의 자료형이 괜히 long long이 아니다.\n  \n문제풀이 h와 w의 최대공약수를 구하고 공식을 적용하면 문제가 나온다. 사실 공식을 알지 못하는 상태에서 다른사람들은 어떻게 문제를 풀었는지\u0026hellip;정말 대단하다.\nusing namespace std; long long solution(int w,int h) { long long answer = 1; // 최대 공약수 구하기 int gdc = 0; long long sum = (long long)w * (long long)h; int minNum = (w \u0026gt; h) ? h : w; for(int i = minNum; i \u0026gt;= i; i--){ if(w%i ==0 \u0026amp;\u0026amp; h%i == 0){ gdc = i; break; } } // 공식 적용 answer = (long long)(sum- (w+h-gdc)); return answer; }  ","id":71,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 대각선이 지나가는 단위 정사각형의 개수를 구하는 수학적인 공식 h + w - (h와w의 최대공약수) 사실 왜 이러한 공식이 나오는 지 이해","tags":null,"title":"프로그래머스 - 멀쩡한 사각형","uri":"http://blog.cmstown.com/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_005/","year":"2020"},{"content":"\n### [백준 문제 바로가기](https://www.acmicpc.net/problem/2217) #### 사용 언어  C++  적용 알고리즘   그리디 알고리즘\n  정렬\n  문제풀이  k개의 로프를 사용하여 중량이 w인 물체를 들어올릴 때, 각각의 로프에는 모두 고르게 w/k 만큼의 중량이 걸리게 된다.\n 위의 문항을 잘 이해했다면 쉽게 문제를 풀 수 있다. w/k 만큼의 중량은 가장 적은 중량을 들어올리는 로프의 중량보다 클수 없다. 그러므로 가장 작은 중량을 들어올리는 로프부터 차례대로 보다 큰 중량을 들어올리는 로프들을 함께 사용하여 가장 많은 중량을 올리는 게 답이 될 수 있다. 말이 어려울 수 있는데 코드를 보며 이해해보도록 하자.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main() { int tc = 0; int maxWeight = 0; // 들어올릴수 있는 가장 큰 중량의 값을 저장하는 변수 vector\u0026lt;int\u0026gt; lope; // 로프의 중량을 담는다 cin \u0026gt;\u0026gt; tc; for (int i = 0; i \u0026lt; tc; i++) { int weight; cin \u0026gt;\u0026gt; weight; lope.push_back(weight); } // 중량이 적은 순서대로 정렬한다. sort(lope.begin(), lope.end()); // i번째 로프 부터 i+1~tc의 로프를 함께 이용하여 들어올리는 중량의 값을 구하여 더 큰 중량의 값을 저장한다. for (int i = 0; i \u0026lt; tc; i++) { maxWeight = max(maxWeight, lope[i] * (tc - i)); } cout \u0026lt;\u0026lt; maxWeight \u0026lt;\u0026lt; endl; }  ","id":72,"section":"posts","summary":"### [백준 문제 바로가기](https://www.acmicpc.net/problem/2217) #### 사용 언어 C++ 적용 알고리즘 그리디 알고리즘 정렬","tags":["그리디 알고리즘"],"title":"백준 2217 - 로프","uri":"http://blog.cmstown.com/2020/02/%EB%B0%B1%EC%A4%802217/","year":"2020"},{"content":"\n### [백준 문제 바로가기](https://www.acmicpc.net/problem/1049) #### 사용 언어  C++  적용 알고리즘   그리디 알고리즘\n  정렬\n  주의사항  문제의 주어진 조건을 잘 파악하고 경우의 수를 나누어야 한다.  문제풀이  문제의 내용과 조건을 보면 3가지의 경우에 한해서 답을 구할 수있다.    가장 싼 세트 가격으로 구매했을 경우\n  가장 싼 세트 가격과 가장 싼 낱개 가격으로 구매했을 경우\n  가장 싼 낱개 가격으로 구매했을 경우\n   가장 싼 세트 가격과 낱개 가격은 sort를 통해 쉽게 구할 수 있다.  #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; bool compare(pair\u0026lt;int, int\u0026gt; p1, pair\u0026lt;int, int\u0026gt; p2) { return p1.second \u0026lt; p2.second; } int main() { int N, M; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; vector\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; brand; int minMoney = 987654321; for (int i = 0; i \u0026lt; M; i++) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; brand.push_back(make_pair(a, b)); } // 1. 모든 기타줄을 세트로만 구매했을 때 sort(brand.begin(), brand.end()); int setPrice = brand[0].first; // 가장 저렴한 세트의 가격 int setCnt = N / 6; // 세트로 나눠지는 개수 int piece = N % 6; // 세트로 나눠지고 남는 낱개 개수 minMoney = (piece == 0) ? setCnt * setPrice : (setCnt + 1)*setPrice; // 세트 개수로 나누어졌을 때 // 2. 세트 + 낱개로 구매했을 때 sort(brand.begin(), brand.end(), compare); minMoney = min(minMoney, setPrice*setCnt + piece * brand[0].second); // 3. 모든 기타줄을 낱개로만 구매했을 때 minMoney = min(minMoney, brand[0].second*N); cout \u0026lt;\u0026lt; minMoney \u0026lt;\u0026lt; endl; }  ","id":73,"section":"posts","summary":"### [백준 문제 바로가기](https://www.acmicpc.net/problem/1049) #### 사용 언어 C++ 적용 알고리즘 그리디 알고리즘 정렬","tags":["그리디 알고리즘"],"title":"백준 1049 - 기타줄","uri":"http://blog.cmstown.com/2020/02/%EB%B0%B1%EC%A4%801049/","year":"2020"},{"content":"Chapter 08 - 경계  외부에서 사용하느 코드 또한 우리 내부코드와 \u0026ldquo;깨끗하게\u0026rdquo; 통합시켜야 한다.\n\n1. 서드파티 코드 사용하기    서드파티란?\n  Map같은 경우 가급적이면 Wrapping을 하여 사용하자.\n 공개된 API에서 인자로 받거나 리턴하지 마라.    \n2. 경계를 탐험하고 공부하기    서드파티를 사용할 때 우리가 사용할 코드에 대헤서는 충분히 테스트 할 필요가 있다.\n  테스트는 값어치를 한다.\n  메인 로직에 영향을 주지 않으며 서드파티 코드를 이해할 수 있다.\n  이러한 테스트는 새 버전으로 이전에 도움을 준다.\n    \n3. 아직 존재하지 않는 코드 사용하기    아직 개발되지 않은 모듈이 필요한데, 기능은 커녕 인터페이스조차 구현되지 않은 경우가 있다.\n 필요한 인터페이스를 만들어 활용하자(임시)    \n결론    서드파티를 이용할 때 내부코드와 \u0026ldquo;깨끗하게\u0026rdquo; 통합시키자\n  서드파티 코드를 충분히 테스트하며 연습하자.\n  ","id":74,"section":"posts","summary":"Chapter 08 - 경계 외부에서 사용하느 코드 또한 우리 내부코드와 \u0026ldquo;깨끗하게\u0026rdquo; 통합시켜야 한다. 1. 서드파티 코드 사용하기 서드파티란? Map","tags":null,"title":"Chapter 08 - 경계","uri":"http://blog.cmstown.com/2020/02/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C_008/","year":"2020"},{"content":"문제링크 \n사용언어  c++  \n\n주의사항   큐와 우선순위 큐의 개념에 알고있어야 한다.\n 우선순위 큐는 항상 값이 높은 것을 앞으로 보낸다.    \n문제풀이 언뜻 보면 굉장히 쉬워보였는데, 정작 문제를 풀지 못하였다. 우선순위 큐를 활용해서 어찌저찌해서 풀 수 있을 것 같은데 방법이 생각이 안났다.\n문제는 큐 와 우선순위 큐 를 이용하면 간단하게 풀 수 있었다. 코드의 주석을 통해 설명하겠다.\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int solution(vector\u0026lt;int\u0026gt; priorities, int location) { int answer = 0; // 큐와 우선순위 큐를 적절히 활용하는게 이번 풀이의 핵심이다. queue\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; q; priority_queue\u0026lt;int\u0026gt; pq; // 큐에는 인덱스와 우선순위 정보를 차례대로, 우선순위 큐에는 우선순위 정보만을 담는다. for(int i = 0; i \u0026lt; priorities.size(); i++){ q.push(make_pair(i, priorities[i])); pq.push(priorities[i]); } int index = 1; while(!q.empty()){ // 현재 큐의 우선순위 값과 우선순위 큐의 값이 일치하다면 if(q.front().second == pq.top()){ // 현재 큐의 인덱스 정보와 찾고자하는 인덱스 정보가 일치할 경우 index값을 answer에 저장하고 while문을 종료한다. if(location == q.front().first){ answer = index; break; } // 그렇지 않은 경우 index를 증가시켜주고, q와 pq를 pop시켜준다. else{ index++; q.pop(); pq.pop(); } } // 현재 큐의 우선순위 값과 우선순위 큐의 값이 불일치하다면 현재 큐의 우선순위보다 더 높은게 뒤에 있다는 소리이므로 현재 큐의 값들을 뒤로 빼준다. else{ q.push(q.front()); q.pop(); } } return answer; }  ","id":75,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 큐와 우선순위 큐의 개념에 알고있어야 한다. 우선순위 큐는 항상 값이 높은 것을 앞으로 보낸다. 문제풀이 언뜻 보면 굉장히 쉬워보였는데","tags":null,"title":"프로그래머스 - 프린터","uri":"http://blog.cmstown.com/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_004/","year":"2020"},{"content":"\n### [백준 문제 바로가기](https://www.acmicpc.net/problem/1931) #### 사용 언어  C++  적용 알고리즘   그리디 알고리즘\n  정렬\n  주의사항   처음 문제 풀 때 재귀를 통해 풀었으나 시간초과가 날 뿐더러 답도 틀렸었다..\n 답은 왜 틀렸는지 의문이다.    문제풀이 해당 문제는 다음과 같은 과정을 거치면 풀 수 있다.\n 회의가 끝나는 시간으로 정렬한다.(회의 끝나 시간이 작은게 앞으로)    끝나는 시간이 서로 같을 경우에는 회의의 시작시간으로 정렬한다.\n 위와 같이 정렬하는 이유는 회의 시작시간과 끝나는 시간이 같은 값이 있을 경우 더 많은 회의를 잡을 수 있기 때문이다.     가장 회의가 빨리 끝나는 회의가 첫 회의가 된다. 첫 회의의 끝나는 시간을 저장한다.\n  이후 for문을 돌리며 끝나는 회의시간 이후에 시작되는 회의시간을 차례대로 저장하며 count를 센다.\n  코드 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; vector\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; room; bool compare(pair\u0026lt;int, int\u0026gt; \u0026amp;p1, pair\u0026lt;int, int\u0026gt; \u0026amp;p2) { if (p1.second == p2.second) { return p1.first \u0026lt; p2.first; } return p1.second \u0026lt; p2.second; } int main() { int tc; cin \u0026gt;\u0026gt; tc; for (int i = 0; i \u0026lt; tc; i++) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; room.push_back(make_pair(a, b)); } sort(room.begin(), room.end(), compare); int cnt = 0; int end = 0; for (int i = 0; i \u0026lt; tc; i++) { if (end \u0026lt;= room[i].first) { end = room[i].second; cnt++; } } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; }  ","id":76,"section":"posts","summary":"### [백준 문제 바로가기](https://www.acmicpc.net/problem/1931) #### 사용 언어 C++ 적용 알고리즘 그리디 알고리즘 정렬","tags":["그리디 알고리즘"],"title":"백준 1931 - 회의실 배정","uri":"http://blog.cmstown.com/2020/02/%EB%B0%B1%EC%A4%801931/","year":"2020"},{"content":"Study TODO 리스트  이것도 공부하고 싶고, 저것도 공부하고 싶고 공부하고 싶은 내용들이 너무 많다\u0026hellip; 그래서 Study todo 리스트를 만들어보았다. 단기간 내에 모든 것을 하기 힘들겠지만 너무 조급해하지않고 차근차근 하나씩 공부해볼 예정이다.\n1. Spring\n  spring의 내부적인 개념\n  spring webflux\n  유어슈 프로젝트 코드 공부\n  reactive stream method 정리\n    spring batch\n  2. CI/CD\n  프로젝트에 적용해보기\n  travisci , aws Platform으로 적용완료(6월~)\n  jenkins 사용해보고싶다\n  3. Multi-Module 공부\n Multi-Module에 대하여 학습하고 프로젝트에 적용해보고 싶다.  4. Clean code\n 클린코드 정리중  5. DB 공부\n  MySQL\n 효율적인 ERM 작성을 위한 공부    6. HTTP 완벽 가이드(책) 공부\n 추후에 스터디를 열어볼까 생각중..  7. 알고리즘 공부\n 스터디 진행중(01.01 ~ 02.29)  8. 코틀린 공부\n  유어슈 프로젝트 때 코틀린으로 개발을 하였는데, 자바가 주언어여서 아직 서투르다..\n  yapp에서 스터디 예정\n  9. 도커/쿠버네티스 공부\n 생활코딩  10. AWS 공부\n 프리티어 버전으로 경험해보긴 했지만 정말 약간이라 더 학습이 필요하다.  11. 운영체제\n 학교 수업을 통해 공부할 예정  ","id":77,"section":"posts","summary":"Study TODO 리스트 이것도 공부하고 싶고, 저것도 공부하고 싶고 공부하고 싶은 내용들이 너무 많다\u0026hellip; 그래서 Study todo 리스트를 만들어보았다. 단기간 내에 모든 것","tags":["계획"],"title":"2020 학습하고 싶은 공부","uri":"http://blog.cmstown.com/2020/02/2020%EA%B3%84%ED%9A%8D_002/","year":"2020"},{"content":"Chapter 07 - 에러 핸들링  \n1. 리턴 코드 대신에 Exception을 사용하자!  기존에 flag를 이용하여 에러 코드를 리턴하거나 호출하는 측에서 예외처리를 하였다. 이런 방식은 예외처리를 잊어버리기 쉽고 로직을 헷갈리게 한다.\n\n// Bad public class DeviceController { ... public void sendShutDown() { DeviceHandle handle = getHandle(DEV1); // Check the state of the device if (handle != DeviceHandle.INVALID) { // Save the device status to the record field retrieveDeviceRecord(handle); // If not suspended, shut down if (record.getStatus() != DEVICE_SUSPENDED) { pauseDevice(handle); clearDeviceWorkQueue(handle); closeDevice(handle); } else { logger.log(\u0026quot;Device suspended. Unable to shut down\u0026quot;); } } else { logger.log(\u0026quot;Invalid handle for: \u0026quot; + DEV1.toString()); } } ... } // Good public class DeviceController { ... public void sendShutDown() { try { tryToShutDown(); } catch (DeviceShutDownError e) { logger.log(e); } } private void tryToShutDown() throws DeviceShutDownError { DeviceHandle handle = getHandle(DEV1); DeviceRecord record = retrieveDeviceRecord(handle); pauseDevice(handle); clearDeviceWorkQueue(handle); closeDevice(handle); } private DeviceHandle getHandle(DeviceID id) { ... throw new DeviceShutDownError(\u0026quot;Invalid handle for: \u0026quot; + id.toString()); ... } ... }  \n2. Try-Catch-Finally문을 먼저 쓰자    이로써 \u0026ldquo;Scrope 정의\u0026quot;가 가능하다.\n  ▽ 잘못된 input을 넣을 경우 StorageException을 제대로 던지는지 확인하는 테스트 코드\n  // Step 1: StorageException을 던지지 않으므로 이 테스트는 실패한다. @Test(expected = StorageException.class) public void retrieveSectionShouldThrowOnInvalidFileName() { sectionStore.retrieveSection(\u0026quot;invalid - file\u0026quot;); } public List\u0026lt;RecordedGrip\u0026gt; retrieveSection(String sectionName) { // dummy return until we have a real implementation return new ArrayList\u0026lt;RecordedGrip\u0026gt;(); } // Step 2: 이제 테스트는 통과한다. public List\u0026lt;RecordedGrip\u0026gt; retrieveSection(String sectionName) { try { FileInputStream stream = new FileInputStream(sectionName) } catch (Exception e) { throw new StorageException(\u0026quot;retrieval error\u0026quot;, e); } return new ArrayList\u0026lt;RecordedGrip\u0026gt;(); } // Step 3: Exception의 범위를 FileNotFoundException으로 줄여 정확히 어떤 Exception이 발생한지 체크하자. public List\u0026lt;RecordedGrip\u0026gt; retrieveSection(String sectionName) { try { FileInputStream stream = new FileInputStream(sectionName); stream.close(); } catch (FileNotFoundException e) { throw new StorageException(\u0026quot;retrieval error\u0026quot;, e); } return new ArrayList\u0026lt;RecordedGrip\u0026gt;(); }  \n3. Unchecked Exception을 사용하자    Unchecked Exception과 Checked Exception에 대하여 설명을 잘해준 블로그\n  상위 레벨 메소드에서 하위 레벨 메소드의 디테일에 대해 알아야 하기 때문에 캡슐화 또한 깨진다.\n  \n4. Exceptions로 문맥을 제공하자    예외가 발생한 이유와 좀 더 구체적인 Exception 타입을 제공하자.\n  catch문의 내용이 비슷하다면 하나로 묶어서 사용하자.\n  \n5. NULL을 리턴하지 말자    null을 리턴하고 싶은 생각이 들면 Special Case object를 리턴하자.\n Null Object Patter    서드파트 라이브러리 에서 null을 리턴할 가능성이 있다면 Exception을 던지거나 Special Case object를 리턴하자.\n  // Bad List\u0026lt;Employee\u0026gt; employees = getEmployees(); if (employees != null) { for(Employee e : employees) { totalPay += e.getPay(); } } // Good List\u0026lt;Employee\u0026gt; employees = getEmployees(); for(Employee e : employees) { totalPay += e.getPay(); } public List\u0026lt;Employee\u0026gt; getEmployees() { if( .. there are no employees .. ) return Collections.emptyList(); } }  \n6. NULL을 넘기지 말자    null을 메서드로 넘기는 것 또한 나쁘다\n  가장 이성적인 해법은 null을 파라미터로 받지 못하게 하는 것이다.\n  \n결론    예외처리는 가급적 Exception을 통해 처리를 해주는 것이 코드를 간결하게 한다.\n  null을 리턴하지도 넘기지도 말자.\n  \n출저 : https://github.com/Yooii-Studios/Clean-Code\n출저 : Clean Code 클린 코드 : 애자일 소프트웨어 장인 정신\n","id":78,"section":"posts","summary":"Chapter 07 - 에러 핸들링 1. 리턴 코드 대신에 Exception을 사용하자! 기존에 flag를 이용하여 에러 코드를 리턴하거나 호출하는 측에서 예외처리를 하였다. 이","tags":null,"title":"Chapter 07 - 에러 핸들링","uri":"http://blog.cmstown.com/2020/02/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C_007/","year":"2020"},{"content":"문제링크 \n사용언어  c++  주의사항  문자열은 제일 앞부터 정해진 길이만큼 잘라야 합니다.  \n문제풀이 문제풀이를 위해서 다음과 같은 과정을 거치게 됩니다.\n  문자열을 자를 단위는 \u0026ldquo;1 ~ (문자열 길이/2)\u0026quot; 입니다.\n  문자열 단위별로 제공되는 문자열을 압축해봅니다.\n  \u0026ldquo;문자열 총 길이 - (문자열 총 길이 / 문자열 자를 단위) * 문자열 자를 단위\u0026rdquo; 만큼은 압축에 포함되지 않기 때문에 별도 추가합니다.\n  이전에 가장 짧았던 문자열과 길이를 비교합니다.\n  #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int solution(string s) { int len = s.length(); int answer = len; // i = 문자열을 자를 단위 for(int i = 1; i \u0026lt;= (len/2); i++){ string result = \u0026quot;\u0026quot;; string tmp = s.substr(0, i); // 처음 비교해야 될 문자열 int cnt = 1; // 압축이 없을 경우 1 // 자를 문자열 단위만큼 이동하며 비교 for(int j = i; j \u0026lt;= len; j+=i){ // 현재 압축이 있다면 if(tmp == s.substr(j, i)){ cnt++; } // 현재 압축이 없다면 else{ // 지금까지 압축이 없었을 경우 if(cnt == 1){ result += tmp; } // 지금까지 압축이 있었을 경우 else{ result += (to_string(cnt) + tmp); } tmp = s.substr(j, i); cnt = 1; } } result += s.substr((len/i) * i); // 문자열을 자르는 단위에 포함 안되는 문자열 추가 answer = min(answer, (int)result.length()); } return answer; }  ","id":79,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 문자열은 제일 앞부터 정해진 길이만큼 잘라야 합니다. 문제풀이 문제풀이를 위해서 다음과 같은 과정을 거치게 됩니다. 문자열을 자를 단","tags":null,"title":"프로그래머스 - 문자열 압축","uri":"http://blog.cmstown.com/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_003/","year":"2020"},{"content":"\n### [백준 문제 바로가기](https://www.acmicpc.net/problem/1786) #### 사용 언어  C++  적용 알고리즘  그리디 알고리즘  문제풀이 다음과 같은 과정을 거쳐 문제를 풀었습니다.\n  재귀를 통해 순열을 구한다.\n  해당 순열이 부등호를 충족시키는지 검사한다. (부등호를 충족시킬 경우 해당 값을 저장한다.)\n  저장된 순열 값들을 정렬 후 가장 작은 값과 큰 값을 출력한다.\n  위의 세 과정을 거치면 문제의 답을 쉽게 구할 수 있습니다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; char Inequality[11]; bool visited[11]; vector\u0026lt;char\u0026gt; num; vector\u0026lt;string\u0026gt; answer; int tc; // 3. Inequality에 저장되어있는 부등호에 맞게 비교되는 수열인지 확인 bool isPossible() { for (int i = 0; i \u0026lt; tc; i++) { if (Inequality[i] == '\u0026gt;') { if (!(num[i] - '0' \u0026gt; num[i+1] - '0')) return false; } else if(Inequality[i] == '\u0026lt;'){ if (!(num[i] - '0' \u0026lt; num[i+1] - '0')) return false; } } return true; } // 1. 순열을 만드는 재귀 함수 void dfs(int index) { // Inequality의 index값이 tc와 같아질 경우 부등호에 맞는지 검증 if (index == tc) { if (isPossible()) { string tmp = \u0026quot;\u0026quot;; int size = num.size(); for (int i = 0; i \u0026lt; size; i++) { tmp += num[i]; } answer.push_back(tmp); } return; } for (int i = 0; i \u0026lt; 10; i++) { if (visited[i]) continue; visited[i] = true; num.push_back(i + '0'); dfs(index+1); visited[i] = false; num.pop_back(); } } int main() { cin \u0026gt;\u0026gt; tc; for (int i = 0; i \u0026lt; tc; i++) { char a; cin \u0026gt;\u0026gt; a; Inequality[i] = a; } dfs(-1); // 매개변수는 dfs를 실행했을 때 dfs(0)부터 시작할수 있도록 -1값을 준다. // 3. 정렬 후 정답 출력 sort(answer.begin(), answer.end()); cout \u0026lt;\u0026lt; answer[answer.size() - 1] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; answer[0] \u0026lt;\u0026lt; endl; }  ","id":80,"section":"posts","summary":"### [백준 문제 바로가기](https://www.acmicpc.net/problem/1786) #### 사용 언어 C++ 적용 알고리즘 그리디 알고리즘 문제","tags":["그리디 알고리즘"],"title":"백준 2529 - 부등호","uri":"http://blog.cmstown.com/2020/02/%EB%B0%B1%EC%A4%802529/","year":"2020"},{"content":"Chapter 06 - 객체와 자료구조  \n1. 자료 추상화   목록 6-1 구체적인 Point 클래스  public class Point { public double x; public double y; }   목록 6-2 추상적인 Point 클래스  public interface Point { double getX(); double getY(); void setCartesian(double x, double y); double getR(); double getTheta(); void setPolar(double r, double theta); }  목록 6-1같은 경우 내부 구졸르 노출하고. 목록 6-2는 구현을 완전히 숨긴다. 구현을 완전히 감추기 위해서는 추상화 가 필요하다. set,get 메서드로 변수를 다룬다고 클래스가 아니라, 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스다.\n\n2. 자료/객체 비대칭   객체 는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 제공한다.\n  자료 구조 는 자료를 그대로 공개하며 별다른 함수는 제공하지 않는다.\n  두 정의는 본질적으로 상반되며 두 개념은 사실상 정반대이다.\n 목록 6-5 절차적인 도형 (Procedural Shape)  public class Square { public Point topLeft; public double side; } public class Rectangle { public Point topLeft; public double height; public double width; } public class Circle { public Point center; public double radius; } public class Geometry { public final double PI = 3.141592653589793; public double area(Object shape) throws NoSuchShapeException { if (shape instanceof Square) { Square s = (Square)shape; return s.side * s.side; } else if (shape instanceof Rectangle) { Rectangle r = (Rectangle)shape; return r.height * r.width; } else if (shape instanceof Circle) { Circle c = (Circle)shape; return PI * c.radius * c.radius; } throw new NoSuchShapeException(); } }  객체 지향 프로그래머가 위 코드를 보면 의아해 할 것이다. 하지만 Geometry 클래스에 둘레 길이를 구하기 위해서 perimeter() 함수를 추가하고 싶을 경우 도형 클래스는 아무 영향도 받지 않는다. 반대로 새 도형을 추가하고 싶다면 Geometry 클래스에 속한 함수를 모두 고쳐야 한다. 그래서 두 조건은 완전히 정반대라고 할 수 있다.\n 목록 6-6 다형적인 도형 (Polymorphic Shape)  public class Square implements Shape { private Point topLeft; private double side; public double area() { return side * side; } } public class Rectangle implements Shape { private Point topLeft; private double height; private double width; public double area() { return height * width; } } public class Circle implements Shape { private Point center; private double radius; public final double PI = 3.141592653589793; public double area() { return PI * radius * radius; } }  이번에는 목록 6-6을 살펴보자. 객체 지향적인 도형 클래스다. 새 도형을 추가해서 기존 함수에 아무런 영향을 미치지 않는다. 반면 새 함수를 추가하고 싶다면 도형 클래스 전부를 고쳐야 한다.\n즉, 객체 지향 코드에서 어려운 변경은 절차적인 코드에서 쉬우며, 절차적인 코드에서 어려운 변경은 객체 지향 코드에서 쉽다. 그러므로 상황에 맞게 클래스 \u0026amp; 객체 지향 기법을 사용하거나, 절차적인 코드와 자료 구조를 적절하게 사용하는 것이 좋다.\n\n3. 디미터 법칩  모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙이다. 좀 더 정확히 표현하자면, 디미터 법칙은 \u0026ldquo;클래스 C의 메서드 f는 다음과 같은 객체의 메서드만 호출해야 한다\u0026rdquo; 고 주장한다.\n  클래스 C\n  f가 생성한 객체\n  int f(){ Module module = new Modele(); module.메서드() }   f 인수로 넘어온 객체  int f(Module module){ module.메서드() }   C 인스턴스 변수에 저장된 객체  class C { private Module module; ... int f(){ module.메서드(); } }  하지만 위 객체에서 허용된 메서드가 반환하는 객체의 메서드는 호출하면 안 된다.\n 기차 충돌  final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();  위와 같은 코드는 일반적으로 조잡하다 여겨지므로 가능하면 피하자.\n  잡종 구조\n 절반은 객체 절반은 자료 구조인 잡종 구조는 가급적이면 지양하자. 이는 어중간한 설계처럼 보인다.    자료 전달 객체(DTO)\n  \n결론    클래스를 만들 때 가급적이면 추상화 과정을 거쳐 만드는 것이 더 바람직한 클래스 설계라고 생각이 든다.\n  무조건 객체가 옳은 것은 아니다. 상황에 맞게 객체나 자료 구조를 사용하여야 한다.\n  \n출저 : https://github.com/Yooii-Studios/Clean-Code\n출저 : Clean Code 클린 코드 : 애자일 소프트웨어 장인 정신\n","id":81,"section":"posts","summary":"Chapter 06 - 객체와 자료구조 1. 자료 추상화 목록 6-1 구체적인 Point 클래스 public class Point { public double x; public double y; } 목록 6-2 추상적인 Point 클래스 public interface Point { double getX(); double getY(); void setCartesian(double x, double y); double getR(); double getTheta(); void setPolar(double r, double","tags":null,"title":"Chapter 06 - 객체와 자료구조","uri":"http://blog.cmstown.com/2020/02/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C_006/","year":"2020"},{"content":"문제링크 \n사용언어  c++  \n문제유형  힙/우선순위 큐  \n주의 사항   vector를 가지고 sort후 문제를 풀었더니 효율성에서 통과하지 못하였다. 이는 우선순위 큐를 선언하여 문제를 해결하였다.\n  단순 vector를 가지고 실행한 결과   priority_queue를 가지고 실행한 결과     \n문제풀이 #include \u0026lt;string\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int k; int cnt; priority_queue\u0026lt;int\u0026gt; pq; bool compare (int a, int b){ return a \u0026gt; b; } bool check_scoville(){ int top = -pq.top(); bool result = true; if(top \u0026lt; k) result = false; return result; } int solution(vector\u0026lt;int\u0026gt; scoville, int K) { int answer = 0; // 전역변수 초기화 k = K; cnt = 0; for(int i = 0; i \u0026lt; scoville.size(); i++){ pq.push(-scoville[i]); // priority_queue는 별도 설정이 없으면 가장 큰 값이 top에 있기 때문에 -를 붙여 값들을 저장한다. } while(true){ int size = pq.size(); // 모든 값들이 K를 넘거나, 1개 밖에 값이 안남은 경우 if(check_scoville() || size == 1 ){ break; } // 기존에 가장 스코빌 지수가 적은 2개를 삭제하고 섞은 음식의 스코빌 지수를 저장 int a = -pq.top(); // 가장 스코빌 지수가 적은 값, 저장할 때 -를 붙여 저장하였기 때문에 꺼낼 때 다시 -기호를 붙여 양수의 값을 받아온다. pq.pop(); int b = -pq.top(); // 두번째로 스코빌 지수가 적은 값 pq.pop(); int c = a + b*2; // 섞은 음식의 스코빌 지수를 저장 pq.push(-c); cnt++; // 한번 섞었으므로 cnt가 1증가 } // 모든 스코빌 지수가 K보다 클 경우 if(check_scoville()){ answer = cnt; } // 그렇지 못할 경우(스코빌 지수가 한개 남았을 때) else answer = -1; return answer; }  ","id":82,"section":"posts","summary":"문제링크 사용언어 c++ 문제유형 힙/우선순위 큐 주의 사항 vector를 가지고 sort후 문제를 풀었더니 효율성에서 통과하지 못하였다. 이는 우선순위 큐를 선언","tags":null,"title":"프로그래머스 - 더 맵게","uri":"http://blog.cmstown.com/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_002/","year":"2020"},{"content":"문제링크 \n사용언어  c++  \n문제유형   dfs/bfs\n  그래프\n  \n주의 사항   전역 변수를 사용할 경우 함수 내에 초기화 코드를 꼭 작성하자\n 제출하면 답이 틀리려서 30분넘게 씨름했는데..solution 함수 위에 다음과 같은 주석이 있었다\u0026hellip;   // 전역 변수를 정의할 경우 함수 내에 초기화 코드를 꼭 작성해주세요.\n   \n문제풀이 해당 문제에서는 DFS 혹은 BFS를 이용하여 풀 수 있는 문제이다. 나는 DFS를 선택하여 문제를 풀어보았다.\n#include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; vec; bool visited[102][102]; int M, N; int dx[] = {-1, 0, 0, 1}; int dy[] = {0, -1, 1, 0}; int area; void dfs(int x, int y, int color){ visited[x][y] = true; area++; for(int i = 0; i \u0026lt; 4; i++){ int mx = x + dx[i]; int ny = y + dy[i]; if(0 \u0026gt; mx || mx \u0026gt; M-1 || 0 \u0026gt; ny || ny \u0026gt; N-1) continue; if(!visited[mx][ny] \u0026amp;\u0026amp; vec[mx][ny] == color){ dfs(mx,ny,color); } } } // 전역 변수를 정의할 경우 함수 내에 초기화 코드를 꼭 작성해주세요. vector\u0026lt;int\u0026gt; solution(int m, int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; picture) { int number_of_area = 0; int max_size_of_one_area = 0; // 전역변수 초기화 area = 0; M = m; N = n; vec = picture; // visited 2차원 배열을 초기화 안해서 계속 틀렸었다..아마 해당 문제에서는 전역변수 설정시 자동으로 false 설정이 안되나보다. for(int i = 0; i \u0026lt; m; i++){ for(int j = 0; j \u0026lt; n; j++){ visited[i][j] = false; } } for(int i = 0; i \u0026lt; m; i++){ for(int j = 0; j \u0026lt; n; j++){ if(!visited[i][j] \u0026amp;\u0026amp; vec[i][j] \u0026gt; 0){ area = 0; dfs(i, j, vec[i][j]); number_of_area++; max_size_of_one_area = max(area, max_size_of_one_area); } } } vector\u0026lt;int\u0026gt; answer(2); answer[0] = number_of_area; answer[1] = max_size_of_one_area; return answer; }  \n","id":83,"section":"posts","summary":"문제링크 사용언어 c++ 문제유형 dfs/bfs 그래프 주의 사항 전역 변수를 사용할 경우 함수 내에 초기화 코드를 꼭 작성하자 제출하면 답이 틀리려서 30분넘게 씨름했는데..so","tags":null,"title":"프로그래머스 - 카카오 프렌즈 컬러링북","uri":"http://blog.cmstown.com/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_001/","year":"2020"},{"content":"\n### [백준 문제 바로가기](https://www.acmicpc.net/problem/1786) #### 사용 언어  C++  적용 알고리즘  KMP 알고리즘  문제풀이 문제에서는 것은 단순 문자열 비교 알고리즘이 아니라 KMP나 라빈 카프 같은 효율적인 알고리즘을 요구합니다. 그러므로 저는 KMP 알고리즘을 이용하여 문제를 풀어보았습니다.\n코드는 다음과 같습니다. 설명은 주석으로 진행하겠습니다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; // vector를 사용하기 위해 선언 #include \u0026lt;string.h\u0026gt; // strlen을 사용하기 위해 선언 using namespace std; vector\u0026lt;int\u0026gt; place; // 문제에서 요구하는 답(겹치는 문자열의 개수, 위치)를 저장하기 위해 전역변수로 선언 // pattern(찾고자 하는 문자열)에 대하여 table을 만드는 함수 vector\u0026lt;int\u0026gt; makeTable(char *pattern) { int patternSize = strlen(pattern); vector\u0026lt;int\u0026gt; table(patternSize, 0); // pattern의 길이만큼 만들어줍니다. // table을 만드는 과정 int j = 0; for (int i = 1; i \u0026lt; patternSize; i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; pattern[i] != pattern[j]) { j = table[j - 1]; } if (pattern[i] == pattern[j]) { table[i] = ++j; // pattern i와 j의 값이 일치할 경우 table에 기록합니다. } } return table; } // parent(기존의 문자열)과 pattern(찾고자 하는 문자열)을 가지고 kmp 알고리즘을 수행합니다. void kmp(char *parent, char *pattern) { vector\u0026lt;int\u0026gt; table = makeTable(pattern); int parentSize = strlen(parent); int patternSize = strlen(pattern); int j = 0; for (int i = 0; i \u0026lt; parentSize; i++) { // parent와 pattern을 비교하기 때문에 parent길이만큼 확인 while (j \u0026gt; 0 \u0026amp;\u0026amp; parent[i] != pattern[j]) { j = table[j - 1]; } if (parent[i] == pattern[j]) { // j가 pattern의 길이-1과 같은 경우 if (j == patternSize - 1) { j = table[j]; place.push_back(i - patternSize + 2); // place vector에 인데스 저장 } // 길이가 같이 않을 경우 else { j++; } } } } int main() { char parent[1000002] = {}; char pattern[1000002] = {}; cin.getline(parent, 1000002); cin.getline(pattern, 1000002); kmp(parent, pattern); int size = place.size(); cout \u0026lt;\u0026lt; size \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; size; i++) { cout \u0026lt;\u0026lt; place[i] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }  ","id":84,"section":"posts","summary":"### [백준 문제 바로가기](https://www.acmicpc.net/problem/1786) #### 사용 언어 C++ 적용 알고리즘 KMP 알고리즘 문제풀이","tags":["KMP 알고리즘"],"title":"백준 1786 - 찾기","uri":"http://blog.cmstown.com/2020/02/%EB%B0%B1%EC%A4%801786/","year":"2020"},{"content":"Chapter 05 - 형식 맞추기  질서정연하고 깔끔하며, 일관적인 코드를 본다면 사람들에게 전문가가 짰다는 인상을 심어줄 수 있다. 반대로, 코드가 어수선해 보인다면 프로젝트 전반적으로 무성의한 태도로 작성했다고 생각할 것이다.\n\n1. 형식을 맞추는 목적  코드 형식은 의사소통의 일환이며 오늘 구현한 코드의 스타일과 가독성 수준은 용이성과 확장성에 지속적인 영향을 준다.\n 코드는 사라져도 스타일과 규율은 사라지지 않는다!\n \n2. 적절한 행 길이를 유지하라(코드의 세로 길이)  코드의 줄이 길어질 수록 코드를 이해하기 어렵기 때문에 코드의 줄을 200줄 내외로 정하여 개발하는 것이 좋다. 물론 이것이 반드시 지켜져야 될 엄격한 규칙은 아니지만 확실히 코드의 줄이 작을 수록 보기좋다.\n  신문 기사처럼 작성하라\n 신문 기사는 최상단에 표제, 첫 문단에는 요약된 기사 내용, 그리고 내려갈수록 세세한 내용 들이 등장한다. 코드 또한 이와 마찬가지로 소스파일 이름(표제) 은 간단하면서도 설명이 가능하게 지어 이름만 보고도 올바른 모듈을 살펴보고 있는지를 판단 할 수 있도록 한다. 소스파일의 첫 부분(요약 내용) 은 고차원 개념과 알고리즘을 설명한다. 아래로 내려갈수록 의도를 세세하게 묘사하며, 마지막에는 가장 저차원 함수(getter,setter같은)와 세부 내역이 나오게 한다.    개념은 빈 행으로 분리하여라\n  코드의 각 줄은 수식이나 절을 나타내고, 여러 줄의 묶음은 완결된 생각 하나를 표현한다. 생각 사이에는 빈 행을 넣어 분리하자.\n  같은 코드에 대헤서 빈 행을 다르게 표현한 코드를 보자.\n  // 빈 행을 넣지 않을 경우 package fitnesse.wikitext.widgets; import java.util.regex.*; public class BoldWidget extends ParentWidget { public static final String REGEXP = \u0026quot;'''.+?'''\u0026quot;; private static final Pattern pattern = Pattern.compile(\u0026quot;'''(.+?)'''\u0026quot;, Pattern.MULTILINE + Pattern.DOTALL); public BoldWidget(ParentWidget parent, String text) throws Exception { super(parent); Matcher match = pattern.matcher(text); match.find(); addChildWidgets(match.group(1));} public String render() throws Exception { StringBuffer html = new StringBuffer(\u0026quot;\u0026lt;b\u0026gt;\u0026quot;); html.append(childHtml()).append(\u0026quot;\u0026lt;/b\u0026gt;\u0026quot;); return html.toString(); } }  // 빈 행을 넣을 경우 package fitnesse.wikitext.widgets; import java.util.regex.*; public class BoldWidget extends ParentWidget { public static final String REGEXP = \u0026quot;'''.+?'''\u0026quot;; private static final Pattern pattern = Pattern.compile(\u0026quot;'''(.+?)'''\u0026quot;, Pattern.MULTILINE + Pattern.DOTALL ); public BoldWidget(ParentWidget parent, String text) throws Exception { super(parent); Matcher match = pattern.matcher(text); match.find(); addChildWidgets(match.group(1)); } public String render() throws Exception { StringBuffer html = new StringBuffer(\u0026quot;\u0026lt;b\u0026gt;\u0026quot;); html.append(childHtml()).append(\u0026quot;\u0026lt;/b\u0026gt;\u0026quot;); return html.toString(); } }    세로 밀집도\n  줄바꿈이 개념을 분리한다면, 세로 밀집도는 연관성을 의미한다. 즉, 서로 밀집한 코드 행은 세로로 가까이 놓여야 한다.\n  같은 코드에 대헤서 세로 밀집도를 다르게 표현한 코드를 보자.\n  // 의미없는 주석으로 변수를 떨어뜨려 놓아서 한눈에 파악이 잘 안된다. public class ReporterConfig { /** * The class name of the reporter listener */ private String m_className; /** * The properties of the reporter listener */ private List\u0026lt;Property\u0026gt; m_properties = new ArrayList\u0026lt;Property\u0026gt;(); public void addProperty(Property property) { m_properties.add(property); }  // 의미 없는 주석을 제거함으로써 코드가 한눈에 들어온다. // 변수 2개에 메소드가 1개인 클래스라는 사실이 드러난다. public class ReporterConfig { private String m_className; private List\u0026lt;Property\u0026gt; m_properties = new ArrayList\u0026lt;Property\u0026gt;(); public void addProperty(Property property) { m_properties.add(property); }    수직거리\n  서로 밀접한 개념은 세로로 가까이 둬야 한다. 타당한 근거가 없다면 서로 밀접한 개념은 한 파일에 속해야 마땅하다. 같은 파일에 속할 정도로 밀접한 두 개념은 세로 거리로 연관성(한 개념을 이해하는데 다른 개념이 중요한 정도)을 표현한다.\n  변수 선언\n 우리가 만든 함수는 매우 짧으므로(chapter03 참고)변수는 사용하는 위치에 최대한 가까이 선언한다.  // InputStream이 함수 맨 처음에 선언 되어있다. private static void readPreferences() { InputStream is = null; try { is = new FileInputStream(getPreferencesFile()); setPreferences(new Properties(getPreferences())); getPreferences().load(is); } catch (IOException e) { try { if (is != null) is.close(); } catch (IOException e1) { } } }  // 모두들 알다시피 루프 제어 변수는 Test each처럼 루프 문 내부에 선언 public int countTestCases() { int count = 0; for (Test each : tests) count += each.countTestCases(); return count; }  // 드물지만, 긴 함수에서는 블록 상단 또는 루프 직전에 변수를 선언 할 수도 있다. ... for (XmlTest test : m_suite.getTests()) { TestRunner tr = m_runnerFactory.newTestRunner(this, test); tr.addListener(m_textReporter); m_testRunners.add(tr); invoker = tr.getInvoker(); for (ITestNGMethod m : tr.getBeforeSuiteMethods()) { beforeSuiteMethods.put(m.getMethod(), m); } for (ITestNGMethod m : tr.getAfterSuiteMethods()) { afterSuiteMethods.put(m.getMethod(), m); } } ...    인스턴스 변수\n 인스턴스 변수는 클래스 맨 처음에 선언한다.(자바의 경우)    종속 함수\n  한 함수가 다른 함수를 호출한다면(종속 함수) 두 함수는 세로로 가까이 배치한다. 일반적으로 함수 호출 종속성은 아래방향으로 유지하므로, 호출되는 함수를 호출하는 함수보다 뒤에 배치한다.\n  아래의 코드에서 makeResponse 함수에서 getPageNameOrDefault 함수를 호출하기 때문에 더 위에 작성되었다.\n  public class WikiPageResponder implements SecureResponder { protected WikiPage page; protected PageData pageData; protected String pageTitle; protected Request request; protected PageCrawler crawler; public Response makeResponse(FitNesseContext context, Request request) throws Exception { String pageName = getPageNameOrDefault(request, \u0026quot;FrontPage\u0026quot;); loadPage(pageName, context); if (page == null) return notFoundResponse(context, request); else return makePageResponse(context); } private String getPageNameOrDefault(Request request, String defaultPageName) { String pageName = request.getResource(); if (StringUtil.isBlank(pageName)) pageName = defaultPageName; return pageName; } ...      \n3. 가로 형식 맞추기  보통 행은 80자에서 120자까지로 제한한다.\n  가로 공백과 밀집도\n 가로로는 공백을 사용해 밀접/느슨한 개념을 표현한다  private void measureLine(String line) { lineCount++; // 흔히 볼 수 있는 코드인데, 할당 연산자 좌우로 공백을 주어 왼쪽,오른쪽 요소가 확실하게 구분된다. int lineSize = line.length(); totalChars += lineSize; // 반면 함수이름과 괄호 사이에는 공백을 없앰으로써 함수와 인수의 밀접함을 보여준다 // 괄호 안의 인수끼리는 쉼표 뒤의 공백을 통해 인수가 별개라는 사실을 보여준다. lineWidthHistogram.addLine(lineSize, lineCount); recordWidestLine(lineSize); }   연산자의 우선순위를 강조하기 위해서도 공백을 사용한다.    들여쓰기\n 짧은 함수여도 들여쓰기는 가독성을 위해 사용하자.  public CommentWidget(ParentWidget parent, String text){super(parent, text);} public CommentWidget(ParentWidget parent, String text){ super(parent, text); } 위의 코드보다 아래의 코드가 훨씬 보기 좋다.    \n4. 팀 규칙  팀에 속해있다면 가장 우선시 되어야 할 규칙은 팀 규칙이다.\n\n5. 책의 저자가 사용하는 규칙이 드러나는 코드  public class CodeAnalyzer implements JavaFileAnalysis { private int lineCount; private int maxLineWidth; private int widestLineNumber; private LineWidthHistogram lineWidthHistogram; private int totalChars; public CodeAnalyzer() { lineWidthHistogram = new LineWidthHistogram(); } public static List\u0026lt;File\u0026gt; findJavaFiles(File parentDirectory) { List\u0026lt;File\u0026gt; files = new ArrayList\u0026lt;File\u0026gt;(); findJavaFiles(parentDirectory, files); return files; } private static void findJavaFiles(File parentDirectory, List\u0026lt;File\u0026gt; files) { for (File file : parentDirectory.listFiles()) { if (file.getName().endsWith(\u0026quot;.java\u0026quot;)) files.add(file); else if (file.isDirectory()) findJavaFiles(file, files); } } public void analyzeFile(File javaFile) throws Exception { BufferedReader br = new BufferedReader(new FileReader(javaFile)); String line; while ((line = br.readLine()) != null) measureLine(line); } private void measureLine(String line) { lineCount++; int lineSize = line.length(); totalChars += lineSize; lineWidthHistogram.addLine(lineSize, lineCount); recordWidestLine(lineSize); } private void recordWidestLine(int lineSize) { if (lineSize \u0026gt; maxLineWidth) { maxLineWidth = lineSize; widestLineNumber = lineCount; } } public int getLineCount() { return lineCount; } public int getMaxLineWidth() { return maxLineWidth; } public int getWidestLineNumber() { return widestLineNumber; } public LineWidthHistogram getLineWidthHistogram() { return lineWidthHistogram; } public double getMeanLineWidth() { return (double)totalChars/lineCount; } public int getMedianLineWidth() { Integer[] sortedWidths = getSortedWidths(); int cumulativeLineCount = 0; for (int width : sortedWidths) { cumulativeLineCount += lineCountForWidth(width); if (cumulativeLineCount \u0026gt; lineCount/2) return width; } throw new Error(\u0026quot;Cannot get here\u0026quot;); } private int lineCountForWidth(int width) { return lineWidthHistogram.getLinesforWidth(width).size(); } private Integer[] getSortedWidths() { Set\u0026lt;Integer\u0026gt; widths = lineWidthHistogram.getWidths(); Integer[] sortedWidths = (widths.toArray(new Integer[0])); Arrays.sort(sortedWidths); return sortedWidths; } }  \n결론    코드를 작성할 때 가로/세로 규칙을 적용해가며 작성하자.\n  내가 당장 쉽게 짜는 코드보다 모두가 쉽게 볼 수있는 코드를 작성하자.\n  \n출저 : https://github.com/Yooii-Studios/Clean-Code\n출저 : Clean Code 클린 코드 : 애자일 소프트웨어 장인 정신\n","id":85,"section":"posts","summary":"Chapter 05 - 형식 맞추기 질서정연하고 깔끔하며, 일관적인 코드를 본다면 사람들에게 전문가가 짰다는 인상을 심어줄 수 있다. 반대로, 코드가 어수선해 보인다면 프로젝트","tags":null,"title":"Chapter 05 - 형식 맞추기","uri":"http://blog.cmstown.com/2020/01/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C_005/","year":"2020"},{"content":"백준 문제 바로가기 사용 언어  C++  적용 알고리즘  위상 정렬 알고리즘  문제풀이 해당 문제에서 요구하는 것은 2가지이다.\n1. 모든 사람들이 만나는 시간 2. 1분도 쉬지 않고 달려야 하는 도로의 수 - 즉, 1번 요구사항에서 나온 시간에 딱 맞게 도착했을 때 거쳐간 도로의 수  2번째 요구사항이 나같은 경우 이해하기 힘들었는데, 쉽게 설명하자면 1번 요구사항에서 나온 시간만큼 걸려서 도착 도시에 도착했을 때, 시작 도시부터 거쳐간 도로의 개수를 구하면 된다. 해당 문제는 역추적 방식을 이용하면 문제를 쉽게 풀 수 있다.\n 먼저 지도 정보를 담을 클래스를 만들어주자.  class Edge { public: int node; int time; Edge(int node, int time) { this-\u0026gt;node = node; this-\u0026gt;time = time; } };  이후 위상 정렬 알고리즘을 사용하기 위한 변수들을 선언해준다.  int n; int start, goal; int inDegree[MAX]; int result[MAX], visited[MAX]; vector\u0026lt;Edge\u0026gt; map[MAX]; vector\u0026lt;Edge\u0026gt; reverseMap[MAX];   여기서 reverseMap이라는게 나온데 이는 visted배열과 함께 이후 역추적 때 사용하기 위해 선언한 것이다.  위상 정렬 함수를 선언해준다.  void topologySort() { queue\u0026lt;int\u0026gt; q; q.push(start); while (!q.empty()) { int current = q.front(); q.pop(); int mapSize = map[current].size(); for (int i = 0; i \u0026lt; mapSize; i++) { Edge next = Edge(map[current][i].node, map[current][i].time); int totalTime = next.time + result[current]; if (result[next.node] \u0026lt;= totalTime) { result[next.node] = totalTime; } if (--inDegree[next.node] == 0) { q.push(next.node); } } } cout \u0026lt;\u0026lt; result[goal] \u0026lt;\u0026lt; endl; }  역추적을 위한 함수를 선언해준다.  void traceBack() { queue\u0026lt;int\u0026gt; q; int count = 0; q.push(goal); while (!q.empty()) { int front = q.front(); q.pop(); int reverseMapSize = reverseMap[front].size(); for (int i = 0; i \u0026lt; size i++) { Edge next = Edge(reverseMap[front][i].node, reverseMap[front][i].time); if (result[front] - result[next.node] == next.time) { if (visited[next.node] == 0) { q.push(next.node); visited[next.node] = 1; } } } } cout \u0026lt;\u0026lt; count; }    이 함수안에서는 queue에 goal을 넣고 시작해서 시작점이 아닌 도착점에서 시작한다.\n  for문 안에 if조건문이 중요한 부분이다. 이미 result를 구했으므로 result 배열을 통해서 현재 도시까지의 거리 - 현재-1 도시까지의 거리 의 값이 다음 찾을 도시의 time정보랑 값이 같다면 해당 도로는 이전 거쳐가는 도로가 확실함으로 count를 증가시킨다.\n  이후 해동 도시를 queue에 다시 담지 않도록 방문 처리를 해준다음, queue에 담는다.\n  코드 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;algorithm\u0026gt; #define MAX 10002 using namespace std; class Edge { public: int node; int time; Edge(int node, int time) { this-\u0026gt;node = node; this-\u0026gt;time = time; } }; int n, start, goal; int inDegree[MAX], result[MAX], visited[MAX]; vector\u0026lt;Edge\u0026gt; map[MAX]; vector\u0026lt;Edge\u0026gt; reverseMap[MAX]; void topologySort() { queue\u0026lt;int\u0026gt; q; q.push(start); while (!q.empty()) { int current = q.front(); q.pop(); int mapSize = map[current].size(); for (int i = 0; i \u0026lt; mapSize; i++) { Edge next = Edge(map[current][i].node, map[current][i].time); int totalTime = next.time + result[current]; if (result[next.node] \u0026lt;= totalTime) { result[next.node] = totalTime; } if (--inDegree[next.node] == 0) { q.push(next.node); } } } cout \u0026lt;\u0026lt; result[goal] \u0026lt;\u0026lt; endl; } void traceBack() { queue\u0026lt;int\u0026gt; q; int count = 0; q.push(goal); while (!q.empty()) { int front = q.front(); q.pop(); int reverseMapSize = reverseMap[front].size(); for (int i = 0; i \u0026lt; size i++) { Edge next = Edge(reverseMap[front][i].node, reverseMap[front][i].time); if (result[front] - result[next.node] == next.time) { count++; if (visited[next.node] == 0) { q.push(next.node); visited[next.node] = 1; } } } } cout \u0026lt;\u0026lt; count; } int main() { int m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; m; i++) { int x, node, time; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; node \u0026gt;\u0026gt; time; map[x].push_back(Edge(node, time)); reverseMap[node].push_back(Edge(x, time)); inDegree[node]++; } cin \u0026gt;\u0026gt; start \u0026gt;\u0026gt; goal; topologySort(); traceBack(); }  ","id":86,"section":"posts","summary":"백준 문제 바로가기 사용 언어 C++ 적용 알고리즘 위상 정렬 알고리즘 문제풀이 해당 문제에서 요구하는 것은 2가지이다. 1. 모든 사람들이 만나는 시간 2. 1분도 쉬지 않고 달","tags":["위상 정렬 알고리즘"],"title":"백준 1948 - 임계경로","uri":"http://blog.cmstown.com/2020/01/%EB%B0%B1%EC%A4%801948/","year":"2020"},{"content":"Chapter 04 - 주석   나쁜 코드에 주석을 달지 마라. 새로 짜라. - 브라이언 W.커니핸, P.J.플라우거\n \n1. 불필요한 주석을 없애자.    주석은 코드로 의도를 표현하지 못하여 실패를 만회하기 위해 사용하는 것이다. 즉, 주석은 언제나 실패를 의미한다.\n  오래된 코드일수록 코드를 유지보수해도 주석을 유지보수하는 경우는 거의 없다.\n  \n2. 주석 대신 코드로 의도를 표현하라!  // 직원에게 복지 혜택을 받을 자격이 있는지 검사한다. if ((emplotee.flags \u0026amp; HOURLY_FLAG) \u0026amp;\u0026amp; (employee.age \u0026gt; 65)  위 코드를 주석을 제거하고 함수 이름만으로 표현하면\nif (employee.isEligibleForFullBenefits())  다음과 같은 코드가 된다. 훨씬 보기 좋지 않은가?\n\n3. 필요한 주석    법적인 주석 : 소스 파일 첫머리에 들어가는 저작권 정보와 소유권 정보 등\n // Copyright (C) 2003, 2004, 2005 by Object Montor, Inc. All right reserved. // GNU General Public License\n   정보를 제공하는 주석\n// kk:mm:ss EEE, MMM dd, yyyy 형식이다. Pattern timeMatcher = Pattern.compile(\u0026quot;\\\\d*:\\\\d*\\\\d* \\\\w*, \\\\w*, \\\\d*, \\\\d*\u0026quot;);    의도를 설명하는 주석\n// 스레드를 대량 생성하는 방법으로 어떻게든 경쟁 조건을 만들려 시도한다. for (int i = 0; i \u0026gt; 2500; i++) { WidgetBuilderThread widgetBuilderThread = new WidgetBuilderThread(widgetBuilder, text, parent, failFlag); Thread thread = new Thread(widgetBuilderThread); thread.start(); }    결과를 경고하는 주석\n// 여유 시간이 충분하지 않다면 실행하지 마십시오. public void _testWithReallyBigFile() { ... }    중요성을 강조하는 주석\nString listItemContent = match.group(3).trim(); // 여기서 trim은 정말 중요하다. trim 함수는 문자열에서 시작 공백을 제거한다. // 문자열에 시작 공백이 있으면 다른 문자열로 인식되기 때문이다. new ListItemWidget(this, listItemContent, this.level + 1); return buildList(text.substring(match.end()));    공개 API에서 Javadocs\n 설명이 잘 된 공개 API는 참으로 유용하고 만족스럽다. 공개 API를 구현한다면 반드시 훌륭한 Javadocs 작성을 추천한다. 하지만 여느 주석과 마찬가지로 Javadocs 역시 독자를 오도하거나, 잘못 위치하거나, 그릇된 정보를 전달할 가능성이 존재하는 것 역시 잊으면 안 된다.    \n4. 나쁜 주석    주절거리는 주석(특별한 이유없이 달리는 주석)\n  같은 이야기를 중복하는 주석\n  오해의 여지가 있는 주석\n  의무적으로 다는 주석\n 모든 함수에 Javadocs를 달거나 모든 변수에 주석을 달아야 한다는 규칙은 어리석기 그지없다. 이런 주석은 코드를 복잡하게 만들며, 거짓말을 퍼뜨리고, 혼동과 무질서를 초래한다. 아래와 같은 주석은 아무 가치도 없다.  /** * * @param title CD 제목 * @param author CD 저자 * @param tracks CD 트랙 숫자 * @param durationInMinutes CD 길이(단위: 분) */ public void addCD(String title, String author, int tracks, int durationInMinutes) { CD cd = new CD(); cd.title = title; cd.author = author; cd.tracks = tracks; cd.duration = durationInMinutes; cdList.add(cd); }    소스 코드 관리 시스템이 해주는 것들\n  저자를 표시하는 주석\n  이력(기록)을 표시하는 주석\n  주석으로 처리한 코드\n 소스 코드 관리 시스템은 우리의 지난 코드들을 보관해준다.      위치를 표시하는 주석\n  닫는 괄호에 다는 주석\n  전역 정보(소스 코드 전체적으로 다는 주석)\n 주석은 반드시 근처에 있는 코드에 한해서만 기술하자.    비공개 코드에서 Javadocs\n 공개 API에서는 Javadocs가 유용하지만 공개하지 않을 코드이면 Javadocs는 쓸모가 없다.    \n결론    좋은 주석의 예시로 TODO 주석 같은게 있었지만, 이는 현재 다른 툴로 충분히 다룰수 있으므로 제외하였다.\n  사실 나쁜 주석으로 여러 예시들을 나열 했는데, 좋은 주석 예제들을 자세히보고 그 외의 주석들은 안다는게 편할듯 하다.\n  예전에야 주석이 잘 짜여져야 보기 편하다 했지만, 확실히 불필요한 주석은 가독성을 저해하고 유지보수가 되면서 왜곡된 정보들이 노출되는 것 같다. 앞으로 주석은 가급적 지양하고 함수명과 변수명을 통해 내 의도가 드러나도록 만들도록 해야겠다.\n  \n출저 : https://github.com/Yooii-Studios/Clean-Code\n출저 : Clean Code 클린 코드 : 애자일 소프트웨어 장인 정신\n","id":87,"section":"posts","summary":"Chapter 04 - 주석 나쁜 코드에 주석을 달지 마라. 새로 짜라. - 브라이언 W.커니핸, P.J.플라우거 1. 불필요한 주석을 없애자. 주석은 코드로 의도를 표현하지 못하여","tags":null,"title":"Chapter 04 - 주석","uri":"http://blog.cmstown.com/2020/01/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C_004/","year":"2020"},{"content":"Chapter 03 - 함수  이번 시간에는 clean한 함수를 만드는 방법에 공부하였다. 어떻게 해야 좋은 함수를 만들 수 있는지 같이 확인 해 보자. 1. 함수는 작을수록(분리될수록) 좋다.   다음은 코드의 예시다, 위의 코드보다 아래 코드처럼 5줄 이내로 줄여서 사용할 것을 권장한다.  public static String renderPageWithSetupsAndTeardowns( PageData pageData, boolean isSuite) throws Exception { boolean isTestPage = pageData.hasAttribute(\u0026quot;Test\u0026quot;); if (isTestPage) { WikiPage testPage = pageData.getWikiPage(); StringBuffer newPageContent = new StringBuffer(); includeSetupPages(testPage, newPageContent, isSuite); newPageContent.append(pageData.getContent()); includeTeardownPages(testPage, newPageContent, isSuite); pageData.setContent(newPageContent.toString()); } return pageData.getHtml(); }  public static String renderPageWithSetupsAndTeardowns( PageData pageData, boolean isSuite) throws Exception { if (isTestPage(pageData)) includeSetupAndTeardownPages(pageData, isSuite); return pageData.getHtml(); }    에네르기파를 자제하자\n 우리는 간혹 if~else 문으로 depth가 3단계 넘어가는 경우도 보게된다. 그러한 코드는 가독성 뿐만 아니라 상당히 비효율적인 코드이다.    \n2. 함수는 하나의 기능만!   함수는 한 가지 기능만 해야한다. 한가지 함수내에서 기능들을 여러가지 나눌 수 있다면 그 함수는 하나가 아닌 여러작업을 하는 함수이다.  \n3. 함수 당 추상화 수준은 하나로    한 함수 내에서 추상화 수준은 섞이지 않고 동일해야 된다.\n  내려가기 규칙(위에서 아래로 코드 읽기)\n 함수 추상화 부분이 한번에 한단계씩 낮아지는 것이 가장 이상적이다.    \n4. switch는 댜형적 객체를 생성하는 코드 안에서만 사용을 권장한다.    물론 불가피한 상황에서는 적절히 이용할 수 있다.\n  switch를 abstract factory에 숨겨 다형적 코드를 생성하는 예\n  public abstract class Employee { public abstract boolean isPayday(); public abstract Money calculatePay(); public abstract void deliverPay(Money pay); } public interface EmployeeFactory { public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType; } public class EmployeeFactoryImpl implements EmployeeFactory { public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType { switch (r.type) { case COMMISSIONED: return new CommissionedEmployee(r) ; case HOURLY: return new HourlyEmployee(r); case SALARIED: return new SalariedEmploye(r); default: throw new InvalidEmployeeType(r.type); } } }  \n5. 함수 인수  함수에서 이상적인 인수 개수는 0개(무항). 인수는 코드 이해에 방해가 되는 요소이므로 최선은 0개이고, 차선은 1개뿐인 경우이다. 출력인수(함수의 반환 값이 아닌 입력 인수로 결과를 받는 경우)는 이해하기 어려우므로 왠만하면 쓰지 않는 것이 좋겠다.\n  많이 쓰이는 단항 형식\n  인수에 질문을 던지는 경우\n boolean fileExists(“MyFile”);    인수를 뭔가로 변환해 결과를 변환하는 경우\n InputStream fileOpen(“MyFile”);    이벤트 함수일 경우 (이 경우에는 이벤트라는 사실이 코드에 명확하게 드러나야 한다.)\n    플래그 인수\n bool값을 넘기는 것 자체가 함수의 기능이 하나가 아닌 것을 입증하게 된다. 즉, 플래그 인수는 쓰지말자.    단항 함수\n  단항 함수는 함수와 인수가 동사/명사 쌍을 이루어야 한다.\n writeField(name);    함수이름에 키워드(인수 이름)을 추가하면 인수 순서를 기억할 필요가 없다.\n assertExpectedEqualsActual(expected, actual);      다항 함수\n  단항 함수보다 한번에 알아보기 힘들다. 이항 함수의 경우에는 무조건적으로 지양해야 할 대상은 아니지만 가능하면 단항 함수로 변경하여 사용하자.\n  결론적으로 매개변수가 많아질수록 코드의 이해도는 떨어질 것이다.\n  많은 매개변수를 전달해야 할 때 클래스로 변수를 넘길수는 없는지 생각해보자.\n  때로는 String format 같은 인수 개수가 가변적인 경우도 필요하다.\n    \n6. 부수 효과를 일으키지 말자!  부수효과는 함수에서 한 가지 역할만 하겠다고 약속하고 거짓말을 하는 셈이다.\n\n7. 명령과 조회를 분리하라  함수는 객체 상태를 변겅하거나, 객체 정보를 반환하거나 둘 중 하나다. 둘 다 수행해서는 안된다.\n\n\u0026lt;br?\n8. 오류코드보다 예외를 사용하자  try/catch 를 사용하면 코드가 훨씬 간결해진다.\n if/else 로 정상 작동과 오류 처리 작동을 뒤섞는 구조는 정말 보기 안좋다. 그러므로 try/catch 로 예외 처리를 진행하자.  // 보기 안좋은 if/else로 정상/오류 작동 처리 if (deletePage(page) == E_OK) { if (registry.deleteReference(page.name) == E_OK) { if (configKeys.deleteKey(page.name.makeKey()) == E_OK) { logger.log(\u0026quot;page deleted\u0026quot;); } else { logger.log(\u0026quot;configKey not deleted\u0026quot;); } } else { logger.log(\u0026quot;deleteReference from registry failed\u0026quot;); } } else { logger.log(\u0026quot;delete failed\u0026quot;); return E_ERROR; }  // try/catch를 사용한 예외 처리 public void delete(Page page) { try { deletePageAndAllReferences(page); } catch (Exception e) { logError(e); } } private void deletePageAndAllReferences(Page page) throws Exception { deletePage(page); registry.deleteReference(page.name); configKeys.deleteKey(page.name.makeKey()); } private void logError(Exception e) { logger.log(e.getMessage()); }  \n9. 코드의 중복은 없애자   중복은 모든 소프트웨어에서 악의 근원이다. 중복된 코드는 하나의 함수로 만들어 재사용하자.  \n10. 구조적 프로그래밍  다익스크라의 구조적 프로그래밍의 원칙을 따르자면 모든 함수와 함수 내 모든 블록에 입구와 출구가 하나여야 된다. 즉, 함수는 return문이 하나여야 되며, 루프 안에서 break나 continue를 사용해선 안된며 goto는 절대로, 절대로 사용하지 말자. 함수가 클 경우에만 상당 이익을 제공하므로, 함수를 작게 만든다면 오히려 여러차례 사용하는 것이 함수의 의도를 표현하기 쉬워진다.\n그런데 구조적 프로그래밍의 목표와 규율은 공감하지만 함수가 작다면 위 규칙은 별 이익을 제공하지 못한다. 함수가 아주 클 때만 상당한 이익을 제공한다. 그러므로 함수를 작게 만든다면 간혹 return, break, continue를 사용해도 괜찮다. 오히려 때로는 단일 입/출구 규칙보다 의도를 표현하기 쉬워진다.\n결론    이 문서에서 다루지는 않았지만 chapter02 - 의미있는 이름에서 함수명을 짓는 방법도 나와있으니 참고하면 좋을 것 같다.\n  처음부터 완벽히 위의 10개의 규칙들을 적용하며 함수를 만들면 좋지만, 사람이다보니 처음부터 완벽할수는 없다. 차근차근 습관을 길들이도록 하자.\n  \n출저 : https://github.com/Yooii-Studios/Clean-Code\n출저 : Clean Code 클린 코드 : 애자일 소프트웨어 장인 정신\n","id":88,"section":"posts","summary":"Chapter 03 - 함수 이번 시간에는 clean한 함수를 만드는 방법에 공부하였다. 어떻게 해야 좋은 함수를 만들 수 있는지 같이 확인 해 보자. 1. 함수는 작을수록(분리될수록","tags":null,"title":"Chapter 03 - 함수","uri":"http://blog.cmstown.com/2020/01/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C_003/","year":"2020"},{"content":"백준 문제 바로가기 사용 언어  C++  적용 알고리즘  다익스트라 알고리즘  문제풀이 이 문제는 얼핏 보면 단순 다익스트라 알고리즘을 한번 적용하여 풀 수 있는 문제로 보인다. 그러나 문제를 잘 들여다 보면 다음과 같은 문구를 확인할 수 있다.\n 세준이는 한번 이동했던 정점은 물론, 한번 이동했던 간선도 다시 이동할 수 있다. 하지만 반드시 최단 경로로 이동해야 한다는 사실에 주의하라. 1번 정점에서 N번 정점으로 이동할 때, 주어진 두 정점을 반드시 거치면서 최단 경로로 이동하는 프로그램을 작성하시오.\n 이 문구를 통해 우리는 반드시 주어진 두 정점을 거쳐 1부터 N번의 정점으로 이동하여야 한다. 위 문제를 해결하기 위해서 반드시 거쳐야 할 두 정점을 a,b라고 가정해보면 다음과 같은 과정이 나온다.\n1. a-\u0026gt;b로 이동하는 과정\n  1 -\u0026gt; a -\u0026gt; b -\u0026gt; N\n  dijkstra(1-\u0026gt;a) + dijkstra(a-\u0026gt;b) + dijkstra(b-\u0026gt;N)\n  2. b-\u0026gt;a로 이동하는 과정\n  1 -\u0026gt; b -\u0026gt; a -\u0026gt; N\n  dijkstra(1-\u0026gt;b) + dijkstra(b-\u0026gt;a) + dijkstra(a -\u0026gt; N)\n  총 2가지의 과정 중 적은 과정을 택하여 값으로 출력하면 된다. 그리하여 작성된 코드를 보면 다음과 같다.\n코드 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; const int INF = 1000000; // 과정을 진행할 때 INF가 3번 더해지는 경우가 있으니 이를 고려하여 INF값을 설정하여야 한다. const int MAX = 10000; int N, E; vector\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; graph[MAX]; int visited[MAX]; void dijkstra(int start) { visited[start] = 0; priority_queue\u0026lt;pair\u0026lt;int,int\u0026gt; \u0026gt; pq; pq.push(make_pair(0, start)); while (!pq.empty()) { int current = pq.top().second; int distance = -pq.top().first; pq.pop(); int size = graph[current].size(); for(int i = 0; i \u0026lt; size; i++){ int next = graph[current][i].first; int nextDistance = distance + graph[current][i].second; if (nextDistance \u0026lt; visited[next]) { visited[next] = nextDistance; pq.push(make_pair(-nextDistance, next)); } } } } // 초기화 void init() { fill(\u0026amp;visited[0], \u0026amp;visited[MAX - 1], INF); } // 다익스트라 알고리즘 실행 후 원하는 경로가 있는지 확인 int isINF(int goal) { if (visited[goal] == INF) return INF; else return visited[goal]; } int isPossible(int a, int b, int c, int d) { init(); dijkstra(a); int a_b = isINF(b); init(); dijkstra(b); int b_c = isINF(c); init(); dijkstra(c); int c_d = isINF(d); // 3개의 경로 중 하나라도 경로가 없으면 두 정점을 거쳐서 1부터 N까지 갈 수 없으므로 INF값을 리턴 if (a_b == INF || b_c == INF || c_d == INF) return INF; // 3개의 경로 모두 값이 있으면 합계 리턴 return a_b + b_c + c_d; } int main() { cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; E; int a, b, c; int start, goal; for (int i = 0; i \u0026lt; E; i++) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; // 무방향 그래프이므로 a에서 b로 가는 것과 b에서 a로 가는 것 둘다 받아야 한다. graph[a].push_back(make_pair(b, c)); graph[b].push_back(make_pair(a, c)); } cin \u0026gt;\u0026gt; start \u0026gt;\u0026gt; goal; int one = isPossible(1, start, goal, N); int two = isPossible(1, goal, start, N); int result = min(one, two); // 두가지 과정 모두 경로가 없으면 -1 리턴 cout \u0026lt;\u0026lt; (result \u0026gt;= INF ? -1 : result); }  ","id":89,"section":"posts","summary":"백준 문제 바로가기 사용 언어 C++ 적용 알고리즘 다익스트라 알고리즘 문제풀이 이 문제는 얼핏 보면 단순 다익스트라 알고리즘을 한번 적용하여 풀 수 있는 문제로 보인다. 그","tags":["다익스트라 알고리즘"],"title":"백준 1504 - 특정한 최단 경로","uri":"http://blog.cmstown.com/2020/01/%EB%B0%B1%EC%A4%801504/","year":"2020"},{"content":"Chapter 02 - 의미있는 이름  \n1. 의도가 담긴 이름을 짓자    변수명/메서드명을 통해서 역할을 추정할 수 있도록 이름을 짓자.\n  별도의 주석이 필요 없을 정도로 명확하게 이름을 짓자.\n  예시\n  int d; (X) -\u0026gt; int elapsedTimeInDays; public void getThem(){ ... } (x) -\u0026gt; public void getFlaggedCells(){ ... } (o)  \n2. 그릇된 정보를 피하자.    중의적인 의미를 피하자.\n  개발자에게 특수한 의미를 가지는 단어(Collection - list 등)는 실제 컨테이너가 해당 타입이 아닌 경우 변수명에 넣지 말자.\n  예시\n  String[] customerList; (x) -\u0026gt; List\u0026lt;String\u0026gt; customerList; (o)  \n3. 불용어(noise word)를 사용하지 말자.    클래스 이름에 Manager, Processor, Data, Info 같은 불용어를 붙이지 말자.\n  예시\n  Class StudentInfo{ ... } (x) -\u0026gt; Class Student{ ... } (o)  \n4. 발음하기 쉬운 이름을 사용하자.    숫자를 혼용하지 말자.\n  우리가 아는 단어 위주로 사용하자.\n  \n5. 검색하기 쉬운 이름을 사용하자.    상수는 static final과 같이 정희하여 사용하자.\n  변수의 이름은 변수의 범위에 비례하여 길어진다.\n  6. 클래스/메서드   변수\n 변수명에 해당 변수의 타입등을 적지말자.    클래스\n 명사 혹은 명사구(Custemer, Student)를 사용하고 동사는 사용하지 말자.    메서드\n  동사 혹은 동사구(updatePayment, deleteAccount)하자.\n  접근자는 get, 변경자는 set, 조건자는 is로 시작하자. (should, has 도 가능)\n  생성자를 오버로드할 경우 정적 팩토리 메서드를 사용하고 해당 생성자를 private로 선언한다.\n 예시  Complex fulcrumPoint = new Complex(23.0); (x) Complex fulcrumPoint = Complex.FromRealNumber(23.0); (o)      \n7. 함부로 이름을 줄이지 말자. GS (x) -\u0026gt; GasStation (o)  \n결론    사실 위의 내용 말고 \u0026quot; -를 사용하자\u0026rdquo;, \u0026ldquo;-를 하지말자\u0026rdquo; 라는 내용이 더 있다. 하지만 근본적인 내용들은 위의 내용과 겹칠 뿐더러 오히려 더 나열하면 헷갈릴 것 같아 정리 내용에서 제외하였다.\n  결론적으로 이름을 성의있게 지어야 한다는 것을 알게 되었다. 나 역시도 어느정도 성의 있게 지켜가며 이름을 지었지만 이번 공부를 통해 더 명확하게 이름을 지을 수 있을 것 같다.\n  \n출저 : https://github.com/Yooii-Studios/Clean-Code\n출저 : Clean Code 클린 코드 : 애자일 소프트웨어 장인 정신\n","id":90,"section":"posts","summary":"Chapter 02 - 의미있는 이름 1. 의도가 담긴 이름을 짓자 변수명/메서드명을 통해서 역할을 추정할 수 있도록 이름을 짓자. 별도의 주석이 필요 없을 정도로 명확하게 이름을 짓자","tags":null,"title":"Chapter 02 - 의미있는 이름","uri":"http://blog.cmstown.com/2020/01/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C_002/","year":"2020"},{"content":"01.21부로 클린 코드에 대하여 요약한 게시글을 보고 나만의 후기를 남길 예정이다.\n책은 우선시 되는 다른 공부가 어느정도 정리되면 그 때 읽어볼 예정이다.\n\nChapter 01 - 깨끗한 코드  \n1. 나쁜 코드  우리는 종종 당장의 문제를 해결하기 위해 나쁜 코드(가독성,효율성,등 여러면에서)를 작성하고는 한다. 이러한 코드들은 당장의 문제를 해결해 줄 뿐이지 추후 결과적으로는 우리에게 최악의 상황을 초래한다. 그렇기 때문에 초기에 나쁜 코드가 아닌 클린한 코드를 작성하는 것이 중요하다.\n\n2. 보이스카우트 규칙   \u0026ldquo;Leave the campground cleaner than you found it.\u0026rdquo;\n 위 문구는 보이스카우트에서 인용된 문구이다. 이 말을 우리(프로그래머)의 언어로 받아 들이면 다음과 같다.\n \u0026ldquo;눈 앞에 더러운 코드가 보이면 조금이라도(변수명,if문 한줄) 개선하여라\u0026rdquo;\n 한번에 모든걸 하려면 어렵다. 그러나 조금씩이라도 변화를 지속하다보면 그것이 습관이되고 결국에는 근본적인 문제점 또한 해결 될 것이다.\n\n3. 같이 읽어보면 좋은 책  클린 코드에서는 이 책이 Agile Sorfware Development의 프리퀄이라고 말하였다. 추후에 해당 책도 읽어보면 좋을 듯 하다.\n\n결론    깨끗한 코드를 만들기 위해서 무작정 당장의 문제 해결에 집중하지 말고 장기적인 관점에서 코드를 작성하다.\n  보이스카우트 규칙에 따라 많이는 아니더라도 조금씩이라도 코드를 고쳐나가자.\n  Agile Sorfware Development을 시간이 되면 읽어보자.\n  \n출저 : https://github.com/Yooii-Studios/Clean-Code\n출저 : Clean Code 클린 코드 : 애자일 소프트웨어 장인 정신\n","id":91,"section":"posts","summary":"01.21부로 클린 코드에 대하여 요약한 게시글을 보고 나만의 후기를 남길 예정이다. 책은 우선시 되는 다른 공부가 어느정도 정리되면 그 때 읽어볼 예정이다. Chapter 01 -","tags":null,"title":"Chapter 01 - 깨끗한 코드","uri":"http://blog.cmstown.com/2020/01/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C_001/","year":"2020"},{"content":"백준 문제 바로가기 사용 언어  C++  적용 알고리즘  다이나믹 프로그래밍  문제풀이   포도주 잔을 선택하면 그 잔에 들어있는 포도주는 모두 마셔야 하고, 마신 후에는 원래 위치에 다시 놓아야 한다. 연속으로 놓여 있는 3잔을 모두 마실 수는 없다.   문제의 조건 중 위 두가지 조건으로 보아 일정한 규칙을 세울 수 있다.\n포도주를 마실때 총 3가지 조건으로 나누어지게 된다.\n첫번째 포도주인 경우\n 현재까지의 포도주 양 = 현재 포도주 양 + 이전까지의 포도주 양\n 두번째 포도주인 경우\n 현재까지의 포도주 양 = 현재 포도주 양 + 이전 포도주 양 + 현재-3까지의 포도주 양\n 세번째 포도주인 경우(건너띄는 포도주)\n 현재까지의 포도주 양 = 이전까지의 포도주 양\n 이를 통해 다음과 같은 코드가 나오게 되었다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; long long int podo[10002]; long long int dp[10002]; int main() { int n; long long int maxPodo; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; podo[i]; } if (n == 1) { cout \u0026lt;\u0026lt; podo[1]; return 0; } else if (n == 2) { cout \u0026lt;\u0026lt; max(podo[1], (podo[1] + podo[2])); return 0; } dp[1] = podo[1]; dp[2] = dp[1] + podo[2]; maxPodo = dp[2]; for (int i = 3; i \u0026lt;= n; i++) { dp[i] = max(podo[i] + dp[i - 2], max((podo[i] + podo[i - 1] + dp[i - 3]), dp[i-1]) ); maxPodo = max(maxPodo, dp[i]); } cout \u0026lt;\u0026lt; maxPodo; }  ","id":92,"section":"posts","summary":"백준 문제 바로가기 사용 언어 C++ 적용 알고리즘 다이나믹 프로그래밍 문제풀이 포도주 잔을 선택하면 그 잔에 들어있는 포도주는 모두 마셔야 하고, 마신 후에는 원래 위치에","tags":["다이나믹 프로그래밍"],"title":"백준 2156 - 포도주 시식","uri":"http://blog.cmstown.com/2020/01/%EB%B0%B1%EC%A4%802156/","year":"2020"},{"content":"☞ 백준 문제 바로가기[9465- 스티커]\n\u0026nbsp;\n\u0026nbsp;\n사용 언어\n- C++\n\u0026nbsp;\n﻿적용 알고리즘\n- Dynamic Programing(다이나믹 프로그래밍)\n-\u0026nbsp;관련 동영상 강의 바로가기\n\u0026nbsp;\n\u0026nbsp;\n관련 문제\n- 백준\n\u0026nbsp;-\u0026gt;\u0026nbsp;1149,\u0026nbsp;9465,\u0026nbsp;2579, 1003, 11726, 11727 2133, 14852, 11048, 1309,\u0026nbsp; 2156, 2864, 1965, 2293, 11066, 9461, 1520, 10942\n\u0026nbsp;\n문제 풀이\n다이나믹 프로그래밍(Dynamic Programing) 문제를 풀 때에는 항상\u0026nbsp;문제의 조건과\u0026nbsp;하나의 값을 가질 수 있는 경우이다.\n현재 문제에서의 조건은 다음과 같다.\n\n1. 스티커는 2N의 크기이다.\n2. 뗀 스티커의 왼쪽,위,오른쪽,아래의 스티커는 사용 할 수 없다.\n\n따라서 왼쪽부터 스티커를 뗀다고 하면, 최종적으로 마지막 (0,N),(1,N)의 스티커 중 하나는 뗴어져야한다. 이를 가지고 조건을 만든다면.\n1) 마지막 스티커가 첫번째 줄인 경우 - (0,N)\n(1) 이전 스티커가 현재 스티커 기준으로 왼쪽 대각선 아래인 경우 - (1,N-1)\n현재 스티커까지의 합 = 현재 스티커 + 왼쪽 대각선 아래 스티커까지의 합\ndp([0][N]) = [0][N] + dp([1][N-1])\u0026nbsp;\n(2) 이전 스티커가 현재 스티커 기준으로 왼쪽에서 두번째인 경우 - (0, N-2)\n현재 스티커까지의 합 = 현재 스티커 + 왼쪽 두번째 스티커까지의 합\ndp([0][N]) = [0][N] + dp([0][N-2])\n(3) 이전 스티커가 현재 스티커 기준으로 왼쪽에서 두번째, 대각선 아래인 경우 - (1, N-2)\n현재 스티커까지의 합 = 현재 스티커 + 왼쪽 두번째,대각선 아래 스티커까지의 합\ndp([0][N]) = [0][N] + dp([1][N-2])\n\n- dp([0][N]) = (1),(2),(3) 중에 가장 큰 값\n\n2) 마지막 스티커가 두번째 줄인 경우 - (1,N)\n(1) 이전 스티커가 현재 스티커 기준으로 왼쪽 대각선 위인 경우 - (0,N-1)\n현재 스티커까지의 합 = 현재 스티커 + 왼쪽 대각선 위 스티커까지의 합\ndp([1][N]) = [1][N] + dp([0][N-1])\u0026nbsp;\n(2) 이전 스티커가 현재 스티커 기준으로 왼쪽에서 두번째인 경우 - (1, N-2)\n현재 스티커까지의 합 = 현재 스티커 + 왼쪽 두번째 스티커까지의 합\ndp([1][N]) = [1][N] + dp([1][N-2])\n(3) 이전 스티커가 현재 스티커 기준으로 왼쪽에서 두번째, 대각선 위인 경우 - (1, N-2)\n현재 스티커까지의 합 = 현재 스티커 + 왼쪽 두번째,대각선 위 스티커까지의 합\ndp([1][N]) = [1][N] + dp([0][N-2])\n\n- dp([1][N]) = (1),(2),(3) 중에 가장 큰 값\n\n최종적으로 dp[0][N]과 dp[1][N] 중에 큰 값이 답이 될 수 있다.\u0026nbsp;\n\n이를 통해 스티커와 DP 배열을 선언한다.\n\n12int\u0026nbsp;sticker[2][100002];int\u0026nbsp;dp[2][100002];cs이후 앞에서 설명한 조건을 통해 최대값을 구한 후 출력하면 문제를 해결 할 수 있다.\n123456789dp[0][1]\u0026nbsp;=\u0026nbsp;sticker[0][1];dp[1][1]\u0026nbsp;=\u0026nbsp;sticker[1][1];\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;j\u0026nbsp;=\u0026nbsp;2;\u0026nbsp;j\u0026nbsp;\u0026lt;=\u0026nbsp;n;\u0026nbsp;j++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[0][j]\u0026nbsp;=\u0026nbsp;sticker[0][j]\u0026nbsp;+\u0026nbsp;max(dp[1][j\u0026nbsp;-\u0026nbsp;1],\u0026nbsp;max(dp[0][j\u0026nbsp;-\u0026nbsp;2],\u0026nbsp;dp[1][j\u0026nbsp;-\u0026nbsp;2]));\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[1][j]\u0026nbsp;=\u0026nbsp;sticker[1][j]\u0026nbsp;+\u0026nbsp;max(dp[0][j\u0026nbsp;-\u0026nbsp;1],\u0026nbsp;max(dp[0][j\u0026nbsp;-\u0026nbsp;2],\u0026nbsp;dp[1][j\u0026nbsp;-\u0026nbsp;2]));}\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;max(dp[0][n],\u0026nbsp;dp[1][n])\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;endl;Colored by Color Scriptercs\n\u0026nbsp;\n\u0026nbsp;\n최종 코드\n\n12345678910111213141516171819202122232425262728293031323334353637383940#include\u0026nbsp;\u0026lt;iostream\u0026gt;#include\u0026nbsp;\u0026lt;algorithm\u0026gt;\u0026nbsp;using\u0026nbsp;namespace\u0026nbsp;std;\u0026nbsp;int\u0026nbsp;sticker[2][100002];//스티커를\u0026nbsp;저장할\u0026nbsp;배열int\u0026nbsp;dp[2][100002];//dp\u0026nbsp;전용\u0026nbsp;배열\u0026nbsp;int\u0026nbsp;main()\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;tc,n;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;tc;//테스트\u0026nbsp;케이스\u0026nbsp;입력\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;i\u0026nbsp;\u0026lt;\u0026nbsp;tc;\u0026nbsp;i++)\u0026nbsp;{//테스트\u0026nbsp;케이스\u0026nbsp;만큼\u0026nbsp;반복\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;n;//스티커\u0026nbsp;크기\u0026nbsp;입력\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;j\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;j\u0026nbsp;\u0026lt;\u0026nbsp;2;\u0026nbsp;j++)\u0026nbsp;{//스티커\u0026nbsp;값\u0026nbsp;입력\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;k\u0026nbsp;=\u0026nbsp;1;\u0026nbsp;k\u0026nbsp;\u0026lt;=\u0026nbsp;n;\u0026nbsp;k++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;sticker[j][k];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;//dp\u0026nbsp;첫번째\u0026nbsp;값\u0026nbsp;입력\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[0][1]\u0026nbsp;=\u0026nbsp;sticker[0][1];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[1][1]\u0026nbsp;=\u0026nbsp;sticker[1][1];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;//dp\u0026nbsp;구하기\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;j\u0026nbsp;=\u0026nbsp;2;\u0026nbsp;j\u0026nbsp;\u0026lt;=\u0026nbsp;n;\u0026nbsp;j++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[0][j]\u0026nbsp;=\u0026nbsp;sticker[0][j]\u0026nbsp;+\u0026nbsp;max(dp[1][j\u0026nbsp;-\u0026nbsp;1],\u0026nbsp;max(dp[0][j\u0026nbsp;-\u0026nbsp;2],\u0026nbsp;dp[1][j\u0026nbsp;-\u0026nbsp;2]));\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[1][j]\u0026nbsp;=\u0026nbsp;sticker[1][j]\u0026nbsp;+\u0026nbsp;max(dp[0][j\u0026nbsp;-\u0026nbsp;1],\u0026nbsp;max(dp[0][j\u0026nbsp;-\u0026nbsp;2],\u0026nbsp;dp[1][j\u0026nbsp;-\u0026nbsp;2]));\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;//최종\u0026nbsp;값\u0026nbsp;출력\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;max(dp[0][n],\u0026nbsp;dp[1][n])\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;endl;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;//스티커와\u0026nbsp;DP\u0026nbsp;배열\u0026nbsp;초기화\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;j\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;j\u0026nbsp;\u0026lt;=\u0026nbsp;n;\u0026nbsp;j++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[0][j]\u0026nbsp;=\u0026nbsp;sticker[0][j]\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[1][j]\u0026nbsp;=\u0026nbsp;sticker[1][j]\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}Colored by Color Scriptercs\n\n추가적으로 질문사항이 있으시면 언제든지 댓글을 달아주세요:D\n\n\u0026nbsp;\n\n\u0026nbsp;\n\n\u0026nbsp;\n\n\u0026nbsp;\n","id":93,"section":"posts","summary":"☞ 백준 문제 바로가기[9465- 스티커] \u0026nbsp; \u0026nbsp; 사용 언어 - C++ \u0026nbsp; ﻿적용 알고리즘 - Dynamic Programing(다이나믹 프로그래밍) -\u0026nbsp;관련 동영상","tags":["다이나믹 프로그래밍"],"title":"백준 9465 - 스티커","uri":"http://blog.cmstown.com/2020/01/%EB%B0%B1%EC%A4%809465/","year":"2020"},{"content":"☞ 백준 문제 바로가기[2579- 계단 오르기]\n\u0026nbsp;\n\u0026nbsp;\n사용 언어\n- C++\n\u0026nbsp;\n﻿적용 알고리즘\n- Dynamic Programing(다이나믹 프로그래밍)\n-\u0026nbsp;관련 동영상 강의 바로가기\n\u0026nbsp;\n\u0026nbsp;\n관련 문제\n- 백준\n\u0026nbsp;-\u0026gt;\u0026nbsp;1149,\u0026nbsp;9465,\u0026nbsp;2579, 1003, 11726, 11727 2133, 14852, 11048, 1309,\u0026nbsp; 2156, 2864, 1965, 2293, 11066, 9461, 1520, 10942\n\u0026nbsp;\n문제 풀이\n문제에서 주어진 조건들을 먼저 살표보면 다음과 같습니다.\n\n1. 계단은 한번에 1개 혹은 2개를 오를 수 있다.\n2. 계단은 연속으로 3칸을 오를 수 없다.\n3. 마지막 계단은 무조건 밟아야한다.\n\n따라서 마지막 계단을 밟아야한다면 다음과 같이 두 조건으로 분류 할 수 있습니다.\n1) 마지막 계단이 처음 밟는 계단일 경우\n마지막 계단까지의 값 = 마지막 계단 값 + [마지막 - 2]까지 밟았던 값들의 총합\nN = N + dp(n-2)\n\n2) 마지막 계단이 마지막으로(두번째로) 밟는 계단일 경우\n마지막 계단까지의 값 = 마지막 계단 값 + [마지막 - 1] 계단의 값 + [마지막 - 3] 까지 밟았던 값들의 총합\nN = N + N-1 +dp(n-3)\n\n이를 통해 N을 stair(=현재 계단)이라고 하고 하면 다음과 같이 전역 변수를 선언 할 수 있습니다.\n\n12int\u0026nbsp;stair[301];int\u0026nbsp;dp[301];cs이어서 두가지의 경우 중 큰 값들을 나란히 넣어주고 최종적으로 마지막 계단 값을 출력하면 결과를 도출해 낼 수 있습니다.\n\n123456dp[1]\u0026nbsp;=\u0026nbsp;stair[1];dp[2]\u0026nbsp;=\u0026nbsp;stair[2]\u0026nbsp;+\u0026nbsp;dp[1];for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;3;\u0026nbsp;i\u0026nbsp;\u0026lt;=\u0026nbsp;tc;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[i]\u0026nbsp;=\u0026nbsp;stair[i]\u0026nbsp;+\u0026nbsp;\u0026nbsp;max(dp[i\u0026nbsp;-\u0026nbsp;2],\u0026nbsp;(stair[i\u0026nbsp;-\u0026nbsp;1]\u0026nbsp;+\u0026nbsp;dp[i\u0026nbsp;-\u0026nbsp;3]));}cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;dp[tc];Colored by Color Scriptercs\n\u0026nbsp;\n\u0026nbsp;\n최종 코드\n\n12345678910111213141516171819202122#include\u0026nbsp;\u0026lt;iostream\u0026gt;#include\u0026nbsp;\u0026lt;algorithm\u0026gt;\u0026nbsp;using\u0026nbsp;namespace\u0026nbsp;std;\u0026nbsp;int\u0026nbsp;stair[301];int\u0026nbsp;dp[301];\u0026nbsp;int\u0026nbsp;main()\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;tc;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;tc;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;1;\u0026nbsp;i\u0026nbsp;\u0026lt;=\u0026nbsp;tc;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;stair[i];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[1]\u0026nbsp;=\u0026nbsp;stair[1];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[2]\u0026nbsp;=\u0026nbsp;stair[2]\u0026nbsp;+\u0026nbsp;dp[1];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;3;\u0026nbsp;i\u0026nbsp;\u0026lt;=\u0026nbsp;tc;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[i]\u0026nbsp;=\u0026nbsp;stair[i]\u0026nbsp;+\u0026nbsp;\u0026nbsp;max(dp[i\u0026nbsp;-\u0026nbsp;2],\u0026nbsp;(stair[i\u0026nbsp;-\u0026nbsp;1]\u0026nbsp;+\u0026nbsp;dp[i\u0026nbsp;-\u0026nbsp;3]));\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;dp[tc];}\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;Colored by Color Scriptercs\n추가적으로 질문사항이 있으시면 언제든지 댓글을 달아주세요:D\n\n\u0026nbsp;\n\n\u0026nbsp;\n\n\u0026nbsp;\n","id":94,"section":"posts","summary":"☞ 백준 문제 바로가기[2579- 계단 오르기] \u0026nbsp; \u0026nbsp; 사용 언어 - C++ \u0026nbsp; ﻿적용 알고리즘 - Dynamic Programing(다이나믹 프로그래밍) -\u0026nbsp;관련 동","tags":["다이나믹 프로그래밍"],"title":"백준 2579 - 계단 오르기","uri":"http://blog.cmstown.com/2020/01/%EB%B0%B1%EC%A4%802579/","year":"2020"},{"content":"☞ 백준 문제 바로가기[1149 - RGB거리]\n\u0026nbsp;\n\u0026nbsp;\n사용 언어\n- C++\n\u0026nbsp;\n﻿적용 알고리즘\n- Dynamic Programing(다이나믹 프로그래밍)\n-\u0026nbsp;관련 동영상 강의 바로가기\n\u0026nbsp;\n\u0026nbsp;\n관련 문제\n- 백준\n\u0026nbsp;-\u0026gt;\u0026nbsp;1149,\u0026nbsp;9465,\u0026nbsp;2579, 1003, 11726, 11727 2133, 14852, 11048, 1309,\u0026nbsp; 2156, 2864, 1965, 2293, 11066, 9461, 1520, 10942\n\u0026nbsp;\n문제 풀이\n해당 문제에서 요구하는 것은 하나의 집에 대헤서 이웃하는 집(i-1,i+1)과 다른 페인트를 색칠하게 하는 것이다. 그리하여 모든 집을 칠하는 최소 페인트 비용을 구하면된다.\n우선 하나의 집에 대헤서 각각의 페인트 비용을 저장하기 위해 다음과 같은 전역 변수를 선언해주었다.\n\n1int\u0026nbsp;cost[1001][3];cs그리고 문제 해결을 위해서 다음과 같은 접근을 하게 되었다.\n\n12345\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;1;\u0026nbsp;i\u0026nbsp;\u0026lt;\u0026nbsp;n;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cost[i][0]\u0026nbsp;=\u0026nbsp;cost[i][0]\u0026nbsp;+\u0026nbsp;min(cost[i\u0026nbsp;-\u0026nbsp;1][1],\u0026nbsp;cost[i\u0026nbsp;-\u0026nbsp;1][2]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cost[i][1]\u0026nbsp;=\u0026nbsp;cost[i][1]\u0026nbsp;+\u0026nbsp;min(cost[i\u0026nbsp;-\u0026nbsp;1][0],\u0026nbsp;cost[i\u0026nbsp;-\u0026nbsp;1][2]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cost[i][2]\u0026nbsp;=\u0026nbsp;cost[i][2]\u0026nbsp;+\u0026nbsp;min(cost[i\u0026nbsp;-\u0026nbsp;1][0],\u0026nbsp;cost[i\u0026nbsp;-\u0026nbsp;1][1]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}Colored by Color Scriptercs\n﻿이를 가지고 최종적으로 가장 비용이 적은 결과를 출력하게 되었다.\u0026nbsp;\n\n1cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;min(cost[n\u0026nbsp;-\u0026nbsp;1][0],\u0026nbsp;min(cost[n\u0026nbsp;-\u0026nbsp;1][1],\u0026nbsp;cost[n\u0026nbsp;-\u0026nbsp;1][2]));cs실제로 문제의 예제를 가지고 테스트하면\n1. 첫번째\nR : 26[R]\nG : 40[G]\nB : 83[B]\n\u0026nbsp;\n2. 두번째\u0026nbsp;\nR : 49[R] + 40[첫번째의 G]\nG : 60[G] + 26[첫번째의\u0026nbsp;R]\nB : 57[B] + 26[첫번째의 R]\n\u0026nbsp;\n4. 세번째\u0026nbsp;\nR : 13[R] + ( 57 + 26[첫번째의 R])[두번째의 B] = 96\nG: 89[G]...\nB : 99[B]...\n최종적으로 나온 값의 가장 작은 값이 예체의 출력값과 같은 것을 확인 할 수 있다.\n\u0026nbsp;\u0026nbsp;\n\n최종 코드\n\n123456789101112131415161718192021222324252627#include\u0026nbsp;\u0026lt;iostream\u0026gt;#include\u0026nbsp;\u0026lt;algorithm\u0026gt;\u0026nbsp;using\u0026nbsp;namespace\u0026nbsp;std;\u0026nbsp;int\u0026nbsp;cost[1001][3];\u0026nbsp;int\u0026nbsp;main()\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;n;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;r,\u0026nbsp;g,\u0026nbsp;b;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;n;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;i\u0026nbsp;\u0026lt;\u0026nbsp;n;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;cost[i][0]\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;cost[i][1]\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;cost[i][2];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;1;\u0026nbsp;i\u0026nbsp;\u0026lt;\u0026nbsp;n;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cost[i][0]\u0026nbsp;=\u0026nbsp;cost[i][0]\u0026nbsp;+\u0026nbsp;min(cost[i\u0026nbsp;-\u0026nbsp;1][1],\u0026nbsp;cost[i\u0026nbsp;-\u0026nbsp;1][2]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cost[i][1]\u0026nbsp;=\u0026nbsp;cost[i][1]\u0026nbsp;+\u0026nbsp;min(cost[i\u0026nbsp;-\u0026nbsp;1][0],\u0026nbsp;cost[i\u0026nbsp;-\u0026nbsp;1][2]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cost[i][2]\u0026nbsp;=\u0026nbsp;cost[i][2]\u0026nbsp;+\u0026nbsp;min(cost[i\u0026nbsp;-\u0026nbsp;1][0],\u0026nbsp;cost[i\u0026nbsp;-\u0026nbsp;1][1]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;min(cost[n\u0026nbsp;-\u0026nbsp;1][0],\u0026nbsp;min(cost[n\u0026nbsp;-\u0026nbsp;1][1],\u0026nbsp;cost[n\u0026nbsp;-\u0026nbsp;1][2]));}Colored by Color Scriptercs\n﻿\n\n\n추가적으로 질문사항이 있으시면 언제든지 댓글을 달아주세요:D\n\n\u0026nbsp;\n\n\u0026nbsp;\n","id":95,"section":"posts","summary":"☞ 백준 문제 바로가기[1149 - RGB거리] \u0026nbsp; \u0026nbsp; 사용 언어 - C++ \u0026nbsp; ﻿적용 알고리즘 - Dynamic Programing(다이나믹 프로그래밍) -\u0026nbsp;관련 동","tags":["다이나믹 프로그래밍"],"title":"백준 1149 - RGB거리","uri":"http://blog.cmstown.com/2020/01/%EB%B0%B1%EC%A4%801149/","year":"2020"},{"content":"백준 문제 바로가기 #### 사용 언어  C++  적용 알고리즘  최소 스패닝 트리 합집합 찾기  문제풀이 일반적으로 난이도가 쉬운 최소 스패닝 트리 문제를 풀 때, 가중치 값 기준으로 정렬 후 크르스칼 알고리즘을 적용하면 문제를 쉽게 풀 수 있습니다. 그러나 해당 문제는 가중치 값 기준으로 정렬할 때 다른 문제와 다르다는 것을 느낄 수 있습니다.\n먼저 정렬을 위해서 문제 중 이 한 문장을 잘 이해할 필요가 있겠습니다\n 두 행성 A(xA, yA, zA)와 B(xB, yB, zB)를 터널로 연결할 때 드는 비용은 min(|xA-xB|, |yA-yB|, |zA-zB|)이다.\n 이 문장을 통해 최종적으로 x,y,z 값을 각각 기준으로 정렬후 모든 값들을 vector에 넣어 정렬한 뒤 크루스칼 알고리즘을 적용하면 답이 나올 것을 예상할수 있었습니다.\n먼저 Planet 클래스와, Planet 클래스를 x,y,z 값으로 정렬 후 담아줄수 있는 Edge 클래스를 생성합니다.\n//행성 정보를 담아줄 Planet 클래스 class Planet { public: int node[3]; int index; Planet(int x, int y, int z, int index) { node[0] = x; node[1] = y; node[2] = z; this-\u0026gt;index = index; } }; //Planet Class를 x,y,z기준으로 각각 sort를 위해 만들어줍니다. bool cmpX (Planet \u0026amp;planet, Planet \u0026amp;planet2) { return planet.node[0] \u0026lt; planet2.node[0]; } bool cmpY(Planet \u0026amp;planet, Planet \u0026amp;planet2) { return planet.node[1] \u0026lt; planet2.node[1]; } bool cmpZ(Planet \u0026amp;planet, Planet \u0026amp;planet2) { return planet.node[2] \u0026lt; planet2.node[2]; } //sort이후 가중치 정보를 담아줄 Edge 클래스를 만들어줍니다. class Edge { public: int x, y; int value; Edge(int x, int y, int value) { this-\u0026gt;x = x; this-\u0026gt;y = y; this-\u0026gt;value = value; } bool operator \u0026lt;(Edge \u0026amp;edge) { return this-\u0026gt;value \u0026lt; edge.value; } };  이후 앞서 말씀드린 것처럼 x,y,z 기준으로 Plaent Class를 정렬 후 Edge Class에 담아 최종적으로 Edge Class를 정렬 후 크루스칼 알고리즘을 적용하면 결과가 나옵니다.\n//정렬 과정 sort(planet.begin(), planet.end(), cmpX); for (int i = 0; i \u0026lt; N - 1; i++) { edge.push_back(Edge(planet[i].index, planet[i + 1].index, abs(planet[i].node[0] - planet[i + 1].node[0]))); } sort(planet.begin(), planet.end(), cmpY); for (int i = 0; i \u0026lt; N - 1; i++) { edge.push_back(Edge(planet[i].index, planet[i + 1].index, abs(planet[i].node[1] - planet[i + 1].node[1]))); } sort(planet.begin(), planet.end(), cmpZ); for (int i = 0; i \u0026lt; N - 1; i++) { edge.push_back(Edge(planet[i].index, planet[i + 1].index, abs(planet[i].node[2] - planet[i + 1].node[2]))); } sort(edge.begin(), edge.end());  최종코드 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; class Planet { public: int node[3]; int index; Planet(int x, int y, int z, int index) { node[0] = x; node[1] = y; node[2] = z; this-\u0026gt;index = index; } }; bool cmpX (Planet \u0026amp;planet, Planet \u0026amp;planet2) { return planet.node[0] \u0026lt; planet2.node[0]; } bool cmpY(Planet \u0026amp;planet, Planet \u0026amp;planet2) { return planet.node[1] \u0026lt; planet2.node[1]; } bool cmpZ(Planet \u0026amp;planet, Planet \u0026amp;planet2) { return planet.node[2] \u0026lt; planet2.node[2]; } class Edge { public: int x, y; int value; Edge(int x, int y, int value) { this-\u0026gt;x = x; this-\u0026gt;y = y; this-\u0026gt;value = value; } bool operator \u0026lt;(Edge \u0026amp;edge) { return this-\u0026gt;value \u0026lt; edge.value; } }; int getParent(int parent[], int x) { if (parent[x] == x) return x; return getParent(parent, parent[x]); } void unionParent(int parent[], int x, int y) { x = getParent(parent, x); y = getParent(parent, y); if (x \u0026gt; y) parent[x] = y; else parent[y] = x; } bool findParent(int parent[], int x, int y) { x = getParent(parent, x); y = getParent(parent, y); if (x == y) return true; return false; } int dist[100002]; vector\u0026lt;Planet\u0026gt; planet; vector\u0026lt;Edge\u0026gt; edge; int main() { int N; int x, y, z; int sum = 0; cin \u0026gt;\u0026gt; N; for (int i = 0; i \u0026lt; N; i++) { cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; z; planet.push_back(Planet(x, y, z, i)); } for (int i = 0; i \u0026lt;= N; i++) { dist[i] = i; } sort(planet.begin(), planet.end(), cmpX); for (int i = 0; i \u0026lt; N - 1; i++) { edge.push_back(Edge(planet[i].index, planet[i + 1].index, abs(planet[i].node[0] - planet[i + 1].node[0]))); } sort(planet.begin(), planet.end(), cmpY); for (int i = 0; i \u0026lt; N - 1; i++) { edge.push_back(Edge(planet[i].index, planet[i + 1].index, abs(planet[i].node[1] - planet[i + 1].node[1]))); } sort(planet.begin(), planet.end(), cmpZ); for (int i = 0; i \u0026lt; N - 1; i++) { edge.push_back(Edge(planet[i].index, planet[i + 1].index, abs(planet[i].node[2] - planet[i + 1].node[2]))); } sort(edge.begin(), edge.end()); for (int i = 0; i \u0026lt; edge.size(); i++) { if (!(findParent(dist, edge[i].x, edge[i].y))) { sum += edge[i].value; unionParent(dist, edge[i].x, edge[i].y); } } cout \u0026lt;\u0026lt; sum; }  추가적인 질문사항 있으시면 언제든지 댓글 달아주시면 감사하겠습니다😊\n","id":96,"section":"posts","summary":"백준 문제 바로가기 #### 사용 언어 C++ 적용 알고리즘 최소 스패닝 트리 합집합 찾기 문제풀이 일반적으로 난이도가 쉬운 최소 스패닝 트리 문제를 풀 때, 가중치 값 기준으로 정렬","tags":["최소 스패닝 트리"],"title":"백준 2887 - 행성터널","uri":"http://blog.cmstown.com/2020/01/%EB%B0%B1%EC%A4%802887/","year":"2020"},{"content":"☞ 백준 문제 바로가기[ 1991 - 트리 순회]\n\u0026nbsp;\n\u0026nbsp;\n사용 언어\n- C++\n\u0026nbsp;\n﻿적용 알고리즘\n- 이진 트리 전위/중위/후위 순회 알고리즘\n-\u0026nbsp;관련 동영상 강의 바로가기\n\u0026nbsp;\n\u0026nbsp;\n관련 문제\n- 관련 문제들은 추후에 수정하도록 하겠습니다.\n\u0026nbsp;\n문제 풀이\n- 해당 문제는 이진 트리를 이용하여 순회 알고리즘을 사용하는 문제입니다.\n먼저 다음과 같이 이진 트리 구조를 가진 구조체를 만들어줍니다.\n\n\n12345typedef\u0026nbsp;struct\u0026nbsp;node\u0026nbsp;*tree;typedef\u0026nbsp;struct\u0026nbsp;node{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;char\u0026nbsp;data;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;tree\u0026nbsp;left,\u0026nbsp;right;};cs\n이후 전위/중위/후위 함수를 만들어줍니다.\n\n\n123456789101112131415161718192021222324//전위void\u0026nbsp;preorder(tree\u0026nbsp;tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;tr-\u0026gt;data;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;preorder(tr-\u0026gt;left);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;preorder(tr-\u0026gt;right);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}}//중위void\u0026nbsp;inorder(tree\u0026nbsp;tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;inorder(tr-\u0026gt;left);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;tr-\u0026gt;data;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;inorder(tr-\u0026gt;right);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}}//후위void\u0026nbsp;postorder(tree\u0026nbsp;tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;postorder(tr-\u0026gt;left);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;postorder(tr-\u0026gt;right);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;tr-\u0026gt;data;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}}cs\u0026nbsp;\n마지막으로 다음과 같이 데이터를 받고 출력해주면 정상적으로 결과가 나온 것을 확인 하실 수 있습니다.\n\n\n12345678910111213141516171819int\u0026nbsp;main()\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;node\u0026nbsp;nodes[27];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;nodeCnt;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;char\u0026nbsp;a,\u0026nbsp;b,\u0026nbsp;c;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;nodeCnt;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;i\u0026nbsp;\u0026lt;\u0026nbsp;nodeCnt;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;a\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;b\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;c;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;'A'\u0026nbsp;+\u0026nbsp;1].data\u0026nbsp;=\u0026nbsp;a;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;(b\u0026nbsp;==\u0026nbsp;'.')\u0026nbsp;?\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;'A'\u0026nbsp;+\u0026nbsp;1].left\u0026nbsp;=\u0026nbsp;NULL\u0026nbsp;:\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;'A'\u0026nbsp;+\u0026nbsp;1].left\u0026nbsp;=\u0026nbsp;\u0026amp;nodes[b\u0026nbsp;-\u0026nbsp;'A'\u0026nbsp;+\u0026nbsp;1];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;(c\u0026nbsp;==\u0026nbsp;'.')\u0026nbsp;?\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;'A'\u0026nbsp;+\u0026nbsp;1].right\u0026nbsp;=\u0026nbsp;NULL\u0026nbsp;:\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;'A'\u0026nbsp;+\u0026nbsp;1].right\u0026nbsp;=\u0026nbsp;\u0026amp;nodes[c\u0026nbsp;-\u0026nbsp;'A'\u0026nbsp;+\u0026nbsp;1];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;preorder(\u0026amp;nodes[1]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;endl;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;inorder(\u0026amp;nodes[1]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;endl;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;postorder(\u0026amp;nodes[1]);;}Colored by Color Scriptercs\n최종 코드\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include\u0026nbsp;\u0026lt;iostream\u0026gt;\u0026nbsp;using\u0026nbsp;namespace\u0026nbsp;std;\u0026nbsp;typedef\u0026nbsp;struct\u0026nbsp;node\u0026nbsp;*tree;typedef\u0026nbsp;struct\u0026nbsp;node{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;char\u0026nbsp;data;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;tree\u0026nbsp;left,\u0026nbsp;right;};\u0026nbsp;//전위void\u0026nbsp;preorder(tree\u0026nbsp;tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;tr-\u0026gt;data;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;preorder(tr-\u0026gt;left);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;preorder(tr-\u0026gt;right);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}}//중위void\u0026nbsp;inorder(tree\u0026nbsp;tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;inorder(tr-\u0026gt;left);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;tr-\u0026gt;data;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;inorder(tr-\u0026gt;right);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}}//후위void\u0026nbsp;postorder(tree\u0026nbsp;tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;postorder(tr-\u0026gt;left);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;postorder(tr-\u0026gt;right);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;tr-\u0026gt;data;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}}\u0026nbsp;int\u0026nbsp;main()\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;node\u0026nbsp;nodes[27];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;nodeCnt;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;char\u0026nbsp;a,\u0026nbsp;b,\u0026nbsp;c;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;nodeCnt;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;i\u0026nbsp;\u0026lt;\u0026nbsp;nodeCnt;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;a\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;b\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;c;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;'A'\u0026nbsp;+\u0026nbsp;1].data\u0026nbsp;=\u0026nbsp;a;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;(b\u0026nbsp;==\u0026nbsp;'.')\u0026nbsp;?\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;'A'\u0026nbsp;+\u0026nbsp;1].left\u0026nbsp;=\u0026nbsp;NULL\u0026nbsp;:\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;'A'\u0026nbsp;+\u0026nbsp;1].left\u0026nbsp;=\u0026nbsp;\u0026amp;nodes[b\u0026nbsp;-\u0026nbsp;'A'\u0026nbsp;+\u0026nbsp;1];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;(c\u0026nbsp;==\u0026nbsp;'.')\u0026nbsp;?\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;'A'\u0026nbsp;+\u0026nbsp;1].right\u0026nbsp;=\u0026nbsp;NULL\u0026nbsp;:\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;'A'\u0026nbsp;+\u0026nbsp;1].right\u0026nbsp;=\u0026nbsp;\u0026amp;nodes[c\u0026nbsp;-\u0026nbsp;'A'\u0026nbsp;+\u0026nbsp;1];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;preorder(\u0026amp;nodes[1]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;endl;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;inorder(\u0026amp;nodes[1]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;endl;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;postorder(\u0026amp;nodes[1]);;}Colored by Color Scriptercs\n\n추가적으로 질문사항이 있으시면 언제든지 댓글을 달아주세요:D\n\n\u0026nbsp;\n","id":97,"section":"posts","summary":"☞ 백준 문제 바로가기[ 1991 - 트리 순회] \u0026nbsp; \u0026nbsp; 사용 언어 - C++ \u0026nbsp; ﻿적용 알고리즘 - 이진 트리 전위/중위/후위 순회 알고리즘 -\u0026nbsp;관련 동영상 강의 바로가기","tags":["이진 트리 알고리즘"],"title":"백준 1991 - 트리 순회","uri":"http://blog.cmstown.com/2020/01/%EB%B0%B1%EC%A4%801991/","year":"2020"},{"content":"IT 동아리 정보  업데이트 날짜 : 20 - 07 - 02\n1. YAPP   6-7월 / 12-1월\n  기획자 / 디자이너 / 개발자가 협업하는 환경\n  2. NEXTERS   5월 / 11월\n  별도의 기획자가 없고, 디자이너/개발자가 협업하는 환경\n  3. SOPT   3월 / 9월\n  추가적으로 학습하는 기간이 주어지고 하나의 주제를 학습하고 프로젝트를 시행한다.\n  새로운 분야를 배워보고싶으신 분들 추천\n  4. 프로그라피   2-3월 / 8월\n  주위에 정보가 없습니다\u0026hellip;\n  5. Mash-Up   3월 / 8-9월\n  각 직군별 스터디/모임이 존재하고, 학습하는 시간도 있다.\n  최종적으로 전체가 프로젝트를 진행하는 환경\n  6. DEPROMEET   2월 / 9월\n  주위에 정보가 없습니다\u0026hellip;\n  7. 멋쟁이사자처럼   2월\n  하나의 언어 및 프레임워크를 가르쳐주는 환경(루비 온 레일즈)에서 최근 파이썬으로 바꼈다고 한다.)\n  8. DDD   6 ~ 9 월\n  직장인 9 : 학생 1 의 비율로 진행된다는 특징.\n  위에 적힌 날짜는 대략적인 날짜이며 상황에 맞게 모든 동아리들이 모집 시즌이 변경되니 참고해주세요~.\n그 외 IT 활동  1. S/W 마에스트로(1월 중순 - 2월 중순)  정부에서 진행하는 IT 최고의 대외활동  2. 우아한 테크코스(10월 ~ 11월)  우아한형제에서 진행하는 인턴십  3. 우아한 테크캠프(5월)   우아한형제에서 진행하는 캠프, 1,2기는 서버직군, 3기는 프론트 직군 캠프를 진행한다고 한다.\n  지인피셜로 합격자중 절반이 우아한 형제에 입사했다는..\n  4. 스마일 게이트 서버캠프(11월)   방학기간 내에 다양한 학습과 프로젝트를 진행하는 캠프\n  대학생들 추천\n  5. 42SEOUL   정부 제공\n  비전공/전공 상관 없이 2년동안 지원금을 받으며 프로그래밍을 공부하는 환경\n  6. SSAFY(삼성 청년 소프트웨어 아카데미)  삼성에서 주관하여 알고리즘,프로젝트를 진행한다.  7. Slipp 스터디(6-7월/12-1월)  전문적인 분들이 이끌어주는 IT 스터디  8. 부스트코스  네이버에서 주관하여 진행하는 교육과정  ","id":98,"section":"posts","summary":"IT 동아리 정보 업데이트 날짜 : 20 - 07 - 02 1. YAPP 6-7월 / 12-1월 기획자 / 디자이너 / 개발자가 협업하는 환경 2. NEXTERS 5월 / 11월 별도의 기획자가 없고, 디자이","tags":["IT 정보","IT 동아리"],"title":"IT 동아리 정보","uri":"http://blog.cmstown.com/2020/01/%EC%A0%95%EB%B3%B4_001/","year":"2020"},{"content":"2020년 학업 계획  20-11-19 업데이트\n1. IT동아리\u0026lt;\n  YOURSSU 활동중(19.11.01~ )\n  YAPP\n  지원중(1.18 면접)\n  최종 합격(1.22)\n    NEXTERS\n 최종 합격(6월)    2. S/W 마에스트로\n  1월 중순~말 서류 접수\n  서류 준비중(1.22~)\n  코딩 데스트 1,2차 통과\n  최종 면접 탈락\u0026hellip;(5월)\n 가장 준비를 많이하고 기대했던 활동이라 상심이 컷다\u0026hellip;      3. 클린코드 공부\n   블로그 읽기    Clean Code 책 읽기    클린코드 정리중\n  4. Spring Framework 더 자유롭게 다루기\n   프로젝트 하면서 필요한 부분 학습    인프런 강의    Spring Core 강의 듣는 중(7월)\n  Spring Boot 강의 듣는 중(7월)\n    5. JPA/DB 공부\n   프로젝트 하면서 필요한 부분 학습    인프런 강의    초반에 강의를 들었으나 더욱 심도있는 공부가 필요함\n  queryDSL 공부해야할 듯(7월)\n    블로그 글 작성    6. 학점 4.0\n  평균 학점 3.5이상 유지하기\n 1학기 학점 : 4.13(7월)    7. 여름/겨울에 인턴활동\n  S/W마에스트로 활동중이라면 겨울에라도 지원하기\n  프로그래머스 여름 인턴쉽 지원\n  딜리셔스(신상마켓)\n 추후 인턴 입사 제의가 왔지만 네이버에서 진행중이어서 거절      네오위즈 인턴십 지원\n  서류 합\n  코딩 테스트 탈락(5월)\n 600점 만점 중 560점이어서 코테는 무조건 통과라고 생각했는데\u0026hellip;단톡방 사람들 보니 580 이상부터 합격했다고 한다\u0026hellip;.진짜 너무하네 ㅜㅜ      ICT 인턴십 지원\n 핀테크 스타트업 합격하였으나 네이버 인턴 떄문에 포기    네이버 웹툰 인턴 지원(진행중)\n 최종 합격      8. 꾸준한 알고리즘 공부\n  스터디 활동 (01/01 ~ 02.28 진행중)\n  github\n  인턴이 끝나고 다시 공부할 예정\n  9. 프로젝트 런칭\n  TEAMPLAY 런칭!\n  AZ(아재트) 애플리케이션 런칭\n  10. 꾸준한 블로그 포스팅\n  최소 1일 1포스팅\n  7월 피드백 : 1일 1포스팅까지는 무리지만 나름 꾸준하게 글은 작성 중\n  9월 피드백 : 8월 개인적으로 인턴 준비하는게 많아서 따로 포스팅하지 못했다\u0026hellip;물론 준비한만큼 결과가 좋게 나와서 다행이지만, 9월부터는 꾸준하게 할 예정.\n  11월 피드백 : 내가 학습했던 부분에 있어서 주로 깃헙에 정리하긴하지만, 공유할 가치가 있다 생각하는 글들 위주로 올리는 중\n    11. S/W 관련 공모전 나가보기\n  국방 데이터 공모전 준비\n 탈락 ㅜㅜ    12. ACM 도전\n  교내 입상이라도..\n 현재 상황에 힘들 듯 ㅜㅜ    13. AWS 공부\n RDS, S3, EC2, CodeDeploy 사용  14. 깃에 1일 1커밋\n 이 부분은 무조건적인 커밋은 아님, 깃헙에 커밋하지 않을뿐 현재 하루도 빠짐없이 공부는 하고 있다.  15. 삼성 SW 역량 테스트(A형) 취득\n  일단 알고리즘 공부좀 다시\u0026hellip;(7월)\n  현재 상황에 굳이 필요없다 생각\u0026hellip;(9월)\n  16. TDD로 개발하기!\n  이 부분 정말 안지켜지고 있다 ㅜㅜ\u0026hellip;,외부 강의라도 들을까 생각중..(7월)\n  실무에서 적용중이라면 그때 가서 배워볼 생각(9월)\n  17. 졸업 작품 준비\n  현재 PM, front, back 모든걸 다 맡을 예정\u0026hellip;(7월)\n  그래도 다행인게 우리과 특성상 웹개발자가 거의 없는데, 친구가 서버 쪽을 공부하고있어서 부분적으로 내가 도와주고 나도 프론트를 새로 공부할 수 있어서 다행이다.\n  그리고 사실 졸작 내년 5월에 전시하는데, 벌써 아이디어 정해져 기간이 많다 ㅎㅎ\n    기획 확정(11월)\n 1월부터 개발 진행할 예정    18. 해커톤 나가보기\n 엔젤핵 해커톤 참여  19. 장학금 받기\n  NHN IT미래인재릴레이 장학금(500만원) 수여!\n 이준호 회장님 감사합니다\u0026hellip;ㅎㅎ    ","id":99,"section":"posts","summary":"2020년 학업 계획 20-11-19 업데이트 1. IT동아리\u0026lt; YOURSSU 활동중(19.11.01~ ) YAPP 지원중(1.18 면접) 최종 합격(1.22) NEXTERS 최종 합격(6월)","tags":["계획"],"title":"2020 학업 계획","uri":"http://blog.cmstown.com/2020/01/2020%EA%B3%84%ED%9A%8D_001/","year":"2020"},{"content":"Reactive Programing\u0026nbsp;간단 정리!\n\u0026nbsp;\n안녕하세요,\u0026nbsp;이 글에서는 제가\u0026nbsp;Reactive Programing을 처음 접하게 되며 알게된 내용들을 간략하게 설명하고자합니다.\u0026nbsp;개인적인 이해가 담겨져있는 글이므로 정확하지 않은 부분에 대하여 언제든지 피드백 해주시면 감사하겠습니다:D\n\u0026nbsp;\n\u0026nbsp;\n\n\n\n\nReactive Programing이란?\n\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp;\n\n유어슈에 들어오고\u0026nbsp;Reactive Programing을 처음 접하게 되었습니다.\u0026nbsp;이후\u0026nbsp;Reactive Programing의 정의에 대하여 찾아보았고,\u0026nbsp;그중에서 가장 간결하면서 명확한 정의를 소개해드리겠습니다.\u0026nbsp;\n\u0026nbsp;\nReactive programming is programming with asynchronous data streams.\n\n리엑티브 프로그래밍은 비동기적 데이터 흐름을 처리하는 프로그래밍이다.\n\u0026nbsp;\n\u0026nbsp;Reactive Programming에서의 핵심은 모든 것들을 비동기적인 데이터의 흐름으로 간주한다는 것입니다. 다시 말하여 기존에 정해진 절차에 따라 작성한 코드가 실행되는 명령형 프로그래밍과는 다르게 리엑티브 프로그래밍은 데이터의 흐름을 정의하고 데이터가 변경되었을 때 연관되는 함수나 수식이 같이 변경되는 방식입니다.\u0026nbsp; 이것을 사용자의 입장에서 보았을 때\u0026nbsp; 실시간 반응이 이루어진다고 할 수 있습니다. 대표적으로 엑셀을 예로 들어보겠습니다.\n\u0026nbsp;A\n\u0026nbsp;B\n\u0026nbsp;C\n\u0026nbsp;6\n\u0026nbsp;7\n\u0026nbsp;= A1 + B1\n\n이라는 표가 있을 때 우리는 C1의 값으로 13을 기대할 수 있습니다.\n\u0026nbsp;A\n\u0026nbsp;B\n\u0026nbsp;C\n\u0026nbsp;6\n\u0026nbsp;7\n13\n\n실제로 수행 결과 13이 나오는 것을 알 수있습니다. 그렇다면 여기서 A를 10으로 변경하였을 때도 C는 13일까요?\n\n\u0026nbsp;A\n\u0026nbsp;B\n\u0026nbsp;C\n\u0026nbsp;10\n\u0026nbsp;7\n17\n결과는 17입니다. A가 변함에 따라 C의 값이 달라지게 됩니다. 우리는 엑셀을 통해서 데이터의 흐름에 따라 결과값이 다르게 표현되는 것을 확인 하실 수 있습니다.\n\u0026nbsp;\n\u0026nbsp;이러한 Reactive Programming은 함수형 프로그래밍(Functional Programming)을 지원 받습니다. 함수형 프로그래밍은\u0026nbsp; 데이터를 immutable하게 취급하고, 데이터 변경시 원본 데이터는 유지하고 새로운 데이터를 만들어 변경하고, 관점을 데이터가 아닌 Process에 집중하게 됩니다. 그리하여 Side-effect 최소화해 병렬처리에서 큰 장점을 가져오게 됩니다.\n\u0026nbsp;\n\u0026nbsp;\n​\n\n\n\n왜\u0026nbsp;Reactive Programing일까?\n\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;\u0026nbsp;\n\n\u0026nbsp;리엑티브 선언문에 따른\u0026nbsp;4가지 속성은 응답성,탄력성,유연성,메시지 구동으로 이루어져있고 내용은 다음과 같습니다.\n\u0026nbsp;\u0026nbsp;https://www.reactivemanifesto.org/ko\n응답성(Responsive):\u0026nbsp;시스템이 가능한 한 즉각적으로 응답하는 것을 응답성이 있다고 합니다.\u0026nbsp;응답성은 사용자의 편의성과 유용성의 기초가 되지만,\u0026nbsp;그것뿐만 아니라 문제를 신속하게 탐지하고 효과적으로 대처할 수 있는 것을 의미합니다.\u0026nbsp;응답성 있는 시스템은 신속하고 일관성 있는 응답 시간을 제공하고,\u0026nbsp;신뢰할 수 있는 상한선을 설정하여 일관된 서비스 품질을 제공합니다.\u0026nbsp;이러한 일관된 동작은 오류 처리를 단순화하고,\u0026nbsp;일반 사용자에게 신뢰를 조성하고,\u0026nbsp;새로운 상호작용을 촉진합니다.\n\n탄력성(Resilient):\u0026nbsp;시스템이\u0026nbsp;장애에 직면하더라도 응답성을 유지 하는 것을 탄력성이 있다고 합니다.\u0026nbsp;탄력성은 고가용성 시스템,\u0026nbsp;미션 크리티컬 시스템에만 적용되지 않습니다.\u0026nbsp;탄력성이 없는 시스템은 장애가 발생할 경우 응답성을 잃게 됩니다.\u0026nbsp;탄력성은\u0026nbsp;복제,\u0026nbsp;봉쇄,\u0026nbsp;격리, 위임에 의해 실현됩니다.\u0026nbsp;장애는 각각의\u0026nbsp;구성 요소에 포함되며 구성 요소들은 서로 분리되어 있기 때문에 이는 시스템이 부분적으로 고장이 나더라도,\u0026nbsp;전체 시스템을 위험하게 하지 않고 복구 할 수 있도록 보장합니다.\u0026nbsp;각 구성 요소의 복구 프로세스는 다른(외부의)\u0026nbsp;구성 요소에 위임되며 필요한 경우 복제를 통해 고가용성이 보장됩니다.\u0026nbsp;구성 요소의 클라이언트는 장애를 처리하는데에 압박을 받지 않습니다.\n\n유연성(Elastic):\u0026nbsp;시스템이 작업량이 변화하더라도 응답성을 유지하는 것을 유연성이라고 합니다.\u0026nbsp;리액티브 시스템은 입력 속도의 변화에 따라 이러한 입력에 할당된\u0026nbsp;자원을 증가시키거나 감소키면서 변화에 대응합니다.\u0026nbsp;이것은 시스템에서 경쟁하는 지점이나 중앙 집중적인 병목 현상이 존재하지 않도록 설계하여,\u0026nbsp;구성 요소를 샤딩하거나 복제하여 입력을 분산시키는 것을 의미합니다.\u0026nbsp;리액티브 시스템은 실시간 성능을 측정하는 도구를 제공하여 응답성 있고 예측 가능한 규모 확장 알고리즘을 지원합니다.\u0026nbsp;이 시스템은 하드웨어 상품 및 소프트웨어 플랫폼에 비용 효율이 높은 방식으로\u0026nbsp;유연성을 제공합니다.\n\n메시지 구동(Message Driven):\u0026nbsp;리액티브 시스템은\u0026nbsp;비동기 메시지 전달에 의존하여 구성 요소 사이에서 느슨한 결합,\u0026nbsp;격리,\u0026nbsp;위치 투명성을 보장하는 경계를 형성합니다.\u0026nbsp;이 경계는\u0026nbsp;장애를 메시지로 지정하는 수단을 제공합니다.\u0026nbsp;명시적인 메시지 전달은 시스템에 메시지 큐를 생성하고,\u0026nbsp;모니터링하며 필요시\u0026nbsp;배압을 적용함으로써 유연성을 부여하고,\u0026nbsp;부하 관리와 흐름제어를 가능하게 합니다.\u0026nbsp;위치 투명 메시징을 통신 수단으로 사용하면 단일 호스트든 클러스터를 가로지르든 동일한 구성과 의미를 갖고 장애를 관리할 수 있습니다.\u0026nbsp;논블로킹\u0026nbsp;통신은 수신자가 활성화가 되어 있을 때만\u0026nbsp;자원을 소비할 수 있기 때문에 시스템 부하를 억제할 수 있습니다.\n\u0026nbsp;\n\u0026nbsp;\n이러한 특징들가 더불어\u0026nbsp;과거보다\u0026nbsp;다양한 웹,앱의 UI 이벤트가 존재하는\u0026nbsp;현대에 더 나은 자원 활용과 확장성에 대한 필요성이 증가되고 더 나아가 모든 구현체가 상호운영할 수 있는 표준으로 특정 구현체에 얽매이는 감소가 추구되기 때문에\u0026nbsp;Reactive Programming이 사용됩니다.\u0026nbsp;\n\n\u0026nbsp;\n\n\n\n\n\n\n마무리\n\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;\u0026nbsp;\n\n간략하게\u0026nbsp;Reactive Programming을 알아보았는데,\u0026nbsp;단순히\u0026nbsp;Reactive Programming추종하며 따라가기 보다는 충분히 고민하고 이해하는게 좋을 것 같습니다.\u0026nbsp;이것으로 저의 첫번째 글은 마무리하고 추후에\u0026nbsp;Reactive Streams와 관련된 주제로 다음에 찾아뵙도록 하겠습니다:D\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n참고\n리엑티브 정의\nhttps://gist.github.com/staltz/868e7e9bc2a7b8c1f754#reactive-programming-is-programming-with-asynchronous-data-streams\n리엑티브 선언문\nhttps://www.reactivemanifesto.org/ko\u0026nbsp;\n","id":100,"section":"posts","summary":"Reactive Programing\u0026nbsp;간단 정리! \u0026nbsp; 안녕하세요,\u0026nbsp;이 글에서는 제가\u0026nbsp;Reactive Programing을 처음 접","tags":["spring webflux"],"title":"Reactive Programming이란?","uri":"http://blog.cmstown.com/2020/01/%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_reactive_programming/","year":"2020"},{"content":"☞ 백준 문제 바로가기[ 6497 - 전력난 ]\n\u0026nbsp;\n\u0026nbsp;\n사용 언어\n- C++\n\u0026nbsp;\n﻿적용 알고리즘\n- 크루스칼 알고리즘(Kruscal Algorithm)\n- 합집합 찾기 알고리즘(Union - Find)\n- 최소 스패닝 트리(MST)\n-\u0026nbsp;관련 동영상 강의 바로가기\n\u0026nbsp;\n\u0026nbsp;\n관련 문제\n-\u0026nbsp;1922(네트워크 연결),\u0026nbsp;1647(도시 분할 계획),\u0026nbsp;2887(행성 터널),\u0026nbsp;1197(최소 스패닝 트리)\n- 해당 문제들 풀이내용은 추후에 게시하도록 하겠습니다.\n\u0026nbsp;\n문제 풀이\n- 해당 문제는 크루스칼 알고리즘만 알고있다면 간단하게 풀수있는 MST 문제입니다. 먼저 코드를 보시면 다음과 같습니다.\n\u0026nbsp;\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include\u0026nbsp;\u0026lt;iostream\u0026gt;#include\u0026nbsp;\u0026lt;vector\u0026gt;#include\u0026nbsp;\u0026lt;algorithm\u0026gt;\u0026nbsp;using\u0026nbsp;namespace\u0026nbsp;std;\u0026nbsp;int\u0026nbsp;dist[200002];int\u0026nbsp;m,\u0026nbsp;n;\u0026nbsp;class\u0026nbsp;Edge\u0026nbsp;{public:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;node[2];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;value;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;Edge(int\u0026nbsp;x,\u0026nbsp;int\u0026nbsp;y,\u0026nbsp;int\u0026nbsp;value)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;this-\u0026gt;node[0]\u0026nbsp;=\u0026nbsp;x;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;this-\u0026gt;node[1]\u0026nbsp;=\u0026nbsp;y;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;this-\u0026gt;value\u0026nbsp;=\u0026nbsp;value;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;bool\u0026nbsp;operator\u0026nbsp;\u0026lt;\u0026nbsp;(Edge\u0026nbsp;\u0026amp;edge)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;return\u0026nbsp;this-\u0026gt;value\u0026nbsp;\u0026lt;\u0026nbsp;edge.value;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}};\u0026nbsp;int\u0026nbsp;getParent(int\u0026nbsp;parent[],\u0026nbsp;int\u0026nbsp;num)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(parent[num]\u0026nbsp;==\u0026nbsp;num)\u0026nbsp;return\u0026nbsp;num;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;return\u0026nbsp;parent[num]\u0026nbsp;=\u0026nbsp;getParent(parent,\u0026nbsp;parent[num]);}\u0026nbsp;void\u0026nbsp;unionParent(int\u0026nbsp;parent[],\u0026nbsp;int\u0026nbsp;x,\u0026nbsp;int\u0026nbsp;y)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;x\u0026nbsp;=\u0026nbsp;getParent(parent,\u0026nbsp;x);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;y\u0026nbsp;=\u0026nbsp;getParent(parent,\u0026nbsp;y);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(x\u0026nbsp;\u0026gt;\u0026nbsp;y)parent[x]\u0026nbsp;=\u0026nbsp;y;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;else\u0026nbsp;parent[y]\u0026nbsp;=\u0026nbsp;x;\u0026nbsp;}\u0026nbsp;bool\u0026nbsp;equalParent(int\u0026nbsp;parent[],\u0026nbsp;int\u0026nbsp;x,\u0026nbsp;int\u0026nbsp;y)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;x\u0026nbsp;=\u0026nbsp;getParent(parent,\u0026nbsp;x);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;y\u0026nbsp;=\u0026nbsp;getParent(parent,\u0026nbsp;y);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(x\u0026nbsp;==\u0026nbsp;y)\u0026nbsp;return\u0026nbsp;true;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;return\u0026nbsp;false;}\u0026nbsp;int\u0026nbsp;main()\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;vector\u0026lt;Edge\u0026gt;\u0026nbsp;map;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;while\u0026nbsp;(true)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;m\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;n;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(m\u0026nbsp;==\u0026nbsp;0\u0026nbsp;\u0026amp;\u0026amp;\u0026nbsp;n\u0026nbsp;==\u0026nbsp;0)\u0026nbsp;break;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;i\u0026nbsp;\u0026lt;=\u0026nbsp;m;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dist[i]\u0026nbsp;=\u0026nbsp;i;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;x\u0026nbsp;=\u0026nbsp;0,\u0026nbsp;y\u0026nbsp;=\u0026nbsp;0,\u0026nbsp;z\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;i\u0026nbsp;\u0026lt;\u0026nbsp;n;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;x\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;y\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;z;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;map.push_back(Edge(x,\u0026nbsp;y,\u0026nbsp;z));\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;sort(map.begin(),\u0026nbsp;map.end());\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;size\u0026nbsp;=\u0026nbsp;map.size();\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;sum\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;i\u0026nbsp;\u0026lt;\u0026nbsp;size;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;sum\u0026nbsp;+=\u0026nbsp;map[i].value;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;i\u0026nbsp;\u0026lt;\u0026nbsp;size;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(!equalParent(dist,\u0026nbsp;map[i].node[0],\u0026nbsp;map[i].node[1]))\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;unionParent(dist,\u0026nbsp;map[i].node[0],\u0026nbsp;map[i].node[1]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;sum\u0026nbsp;-=\u0026nbsp;map[i].value;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;sum\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;endl;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;map.clear(); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}}\n\n\u0026nbsp;\n\n\u0026nbsp;기본적인 크루스칼 알고리즘을 적용해 구하는 MST 구조와 같습니다. 다만 문제를 풀 때 주의하실 점은 문제 요구사항입니다.\n처음에 문제를 풀었을 때, 요구사항 중\u0026nbsp;\n\u0026nbsp;\n출력각 테스트 케이스마다 한 줄에 걸쳐 절약할 수 있는 최대 비용을 출력한다.\n\u0026nbsp;\n라는 내용을 인지하지 못하여서 최소 비용 값이 왜 다르지하고 한동안 코드를 다시 분석하는 행위를 반복하였습니다.\u0026nbsp;\n\u0026nbsp;\n추가적으로\n입력입력은 여러 개의 테스트 케이스로 구분되어 있다.\n각 테스트 케이스의 첫째 줄에는 집의 수 m과 길의 수 n이 주어진다. (1 ≤ m ≤ 200000,\u0026nbsp;m-1 ≤ n ≤ 200000)\n이어서 n개의 줄에 각 길에 대한 정보 x, y, z가 주어지는데, 이는 x번 집과 y번 집 사이에 양방향 도로가 있으며 그 거리가 z미터라는 뜻이다. (0 ≤ x, y \u0026lt; m,\u0026nbsp;x ≠ y)\n도시는 항상 연결 그래프의 형태이고(즉, 어떤 두 집을 골라도 서로 왕래할 수 있는 경로가 있다), 도시상의 모든 길의 거리 합은 231미터보다 작다.\n입력의 끝에서는 첫 줄에 0이 2개 주어진다.\n\u0026nbsp;\n라는 입력 조건에서 첫번째 줄과 마지막 줄 또한 무시하고 문제를 제출하였다가 틀렸습니다.\n\u0026nbsp;\n\u0026nbsp;\n그외에는 별다른 어려움은 없었던 것 같습니다! 코드에 대한 지적이나 풀이에 대한 질문은 댓글로 남겨주시면 확인 후 답장 메일이나 댓글을 달아드리겠습니다:D\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n","id":101,"section":"posts","summary":"☞ 백준 문제 바로가기[ 6497 - 전력난 ] \u0026nbsp; \u0026nbsp; 사용 언어 - C++ \u0026nbsp; ﻿적용 알고리즘 - 크루스칼 알고리즘(Kruscal Algorithm) - 합집합 찾기 알고리즘(Union - Find) - 최","tags":["크루스칼 알고리즘"],"title":"백준6497 - 전력난","uri":"http://blog.cmstown.com/2020/01/%EB%B0%B1%EC%A4%806497/","year":"2020"}],"tags":[{"title":"Devops","uri":"http://blog.cmstown.com/tags/devops/"},{"title":"IT 동아리","uri":"http://blog.cmstown.com/tags/it-%EB%8F%99%EC%95%84%EB%A6%AC/"},{"title":"IT 정보","uri":"http://blog.cmstown.com/tags/it-%EC%A0%95%EB%B3%B4/"},{"title":"KMP 알고리즘","uri":"http://blog.cmstown.com/tags/kmp-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"title":"spring webflux","uri":"http://blog.cmstown.com/tags/spring-webflux/"},{"title":"계획","uri":"http://blog.cmstown.com/tags/%EA%B3%84%ED%9A%8D/"},{"title":"그리디 알고리즘","uri":"http://blog.cmstown.com/tags/%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"title":"다이나믹 프로그래밍","uri":"http://blog.cmstown.com/tags/%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"},{"title":"다익스트라 알고리즘","uri":"http://blog.cmstown.com/tags/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"title":"브루트 포스트","uri":"http://blog.cmstown.com/tags/%EB%B8%8C%EB%A3%A8%ED%8A%B8-%ED%8F%AC%EC%8A%A4%ED%8A%B8/"},{"title":"알고리즘","uri":"http://blog.cmstown.com/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"title":"위상 정렬 알고리즘","uri":"http://blog.cmstown.com/tags/%EC%9C%84%EC%83%81-%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"title":"이진 트리 알고리즘","uri":"http://blog.cmstown.com/tags/%EC%9D%B4%EC%A7%84-%ED%8A%B8%EB%A6%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"title":"최소 스패닝 트리","uri":"http://blog.cmstown.com/tags/%EC%B5%9C%EC%86%8C-%EC%8A%A4%ED%8C%A8%EB%8B%9D-%ED%8A%B8%EB%A6%AC/"},{"title":"크루스칼 알고리즘","uri":"http://blog.cmstown.com/tags/%ED%81%AC%EB%A3%A8%EC%8A%A4%EC%B9%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}]}