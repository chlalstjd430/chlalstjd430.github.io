{"categories":[{"title":"2020 계획","uri":"https://chlalstjd430.github.io/categories/2020-%EA%B3%84%ED%9A%8D/"},{"title":"AWS","uri":"https://chlalstjd430.github.io/categories/aws/"},{"title":"IT 정보","uri":"https://chlalstjd430.github.io/categories/it-%EC%A0%95%EB%B3%B4/"},{"title":"JAVA","uri":"https://chlalstjd430.github.io/categories/java/"},{"title":"디자인패턴","uri":"https://chlalstjd430.github.io/categories/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/"},{"title":"리액티브 프로그래밍","uri":"https://chlalstjd430.github.io/categories/%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"},{"title":"백엔드","uri":"https://chlalstjd430.github.io/categories/%EB%B0%B1%EC%97%94%EB%93%9C/"},{"title":"백준 문제풀이","uri":"https://chlalstjd430.github.io/categories/%EB%B0%B1%EC%A4%80-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/"},{"title":"스터디","uri":"https://chlalstjd430.github.io/categories/%EC%8A%A4%ED%84%B0%EB%94%94/"},{"title":"스프링","uri":"https://chlalstjd430.github.io/categories/%EC%8A%A4%ED%94%84%EB%A7%81/"},{"title":"알고리즘","uri":"https://chlalstjd430.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"title":"클린코드","uri":"https://chlalstjd430.github.io/categories/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C/"},{"title":"파이썬","uri":"https://chlalstjd430.github.io/categories/%ED%8C%8C%EC%9D%B4%EC%8D%AC/"},{"title":"프로그래머스 문제풀이","uri":"https://chlalstjd430.github.io/categories/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/"}],"posts":[{"content":"@Autowired 필요한 의존 객체의 \u0026ldquo;타입\u0026quot;에 해당하는 빈을 찾아 주입한다.\n사용할 수 있는 위치 클래스 주입 BookRepository.java\npublic class BookRepository { }  BookService.java\n@Service public class BookService { BookRepository bookRepository; @Autowired public BookService(BookRepository bookRepository){ this.bookRepository = bookRepository; } }  DemoApplication.java\n@SpringBootApplication public class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } }  위 경우에 BookRepository가 빈 등록이 안되어있어 오류\n이후 다음과 같이 BookRepository를 수정해보자.\nBookRepository.java\n@Repository public class BookRepository { }  이후 실행시 정상적으로 작동하는 것을 확인할 수 있다.\nSetter 주입 setter로 주입하는 과정을 확인해보자.\nBookRepository.java\npublic class BookRepository { }  BookService.java\n@Service public class BookService { BookRepository bookRepository; @Autowired public void setBookRepository(BookRepository bookRepository) { this.bookRepository = bookRepository; } }  실행하면 오류가 뜨는 것을 확인 할 수 있다.\n여기서 \u0026ldquo;BookService 자체의 인스턴스는 만들 수 있는거 아닌가?\u0026rdquo; 라는 의문을 가질 수 있다.\n실제로 BookService라는 인스턴스 자체는 만들 수 있는데, 다만 @Autowired가 있어서 의존성을 주입하려고 시도하는 과정이 실패하는 것이다.\n결론적으로 BookService 인스턴스는 만들 수 있지미나 @Autowirder가 있어서 실패하는 것이다.\n이 경우에 @Autowired가 필수적인게 아니라고하면 @Autowired(required = false) 로 하면 정상적으로 실행된다.\n(required : 기본값은 true(따라서 못 찾으면 애플리케이션 구동 실패))\n필드 주입 BookService.java\n@Service public class BookService { @Autowired(required = false) BookRepository bookRepository; }  required가 false이기 때문에, 정상적으로 실행이 가능하다.\n주입이 여러개인 경우 추가적으로 다음과 같은 클래스를 생성해보자.\nMyBookRepository.java\n@Repository public class MyBookRepository extends BookRepository{ }  MinseongBookRepository.java\n@Repository public class MinseongBookRepository extends BookRepository{ }  이렇게 BookRepository를 상속받는 새로운 repository 2개를 만들어보자.\n이후 BookService를 다음과 같이 만들어준다.\nBookService.java\n@Service public class BookService { @Autowired BookRepository bookRepository; }  어떠한 결과가 나올까?\nParameter 0 of constructor in com.spring.core.autowired.demo.BookService required a single bean, but 2 were found: - minseongBookRepository: defined in file [/Users/choeminseong/IdeaProjects/study/spring/core/autowired/target/classes/com/spring/core/autowired/demo/MinseongBookRepository.class] - myBookRepository: defined in file [/Users/choeminseong/IdeaProjects/study/spring/core/autowired/target/classes/com/spring/core/autowired/demo/MyBookRepository.class] Action: Consider marking one of the beans as @Primary, updating the consumer to accept multiple beans, or using @Qualifier to identify the bean that should be consumed  우리는 위와 같은 결과를 확인할 수 있다.\nbookRepository에 주입할 대안이 2개이기 때문에 어떤것을 주입해야할지 모른다는 문구와 함께 3가지 대안이 나온다.\n1. Consider marking one of the beans as @Primary @Primary 어노테이션을 사용하여 사용하고 싶은 빈이 무엇인지 마킹해라\nMinseongRepository.java\n```java @Repository @Primary public class MinseongBookRepository extends BookRepository{ } ```  위의 코드와 같이 원하는 빈에 @Primary 어노테이션을 활용하면 정상적으로 코드가 수행된다.\n2. updating the consumer to accept multiple beans 모든 빈을 받아들이자\n```java @Service public class BookService { @Autowired List\u0026lt;BookRepository\u0026gt; bookRepositories; } ```  위의 코드처럼 여러개의 빈을 주입 받도록 하면 정상적으로 코드가 수행된다.\n3. using @Qualifier to identify the bean that should be consumed @Qualifier 어노테이션을 사용하자\n```java @Service public class BookService { @Autowired @Qualifier(\u0026quot;minseongBookRepository\u0026quot;) BookRepository bookRepository; } ```  위의 코드와 같이 BookService에 명시적으로 어떠한 빈을 주입받는지 설정해주면 정상적으로 작동된다.\n4. 변수명으로 식별해주는 방법 위의 3가지 방법 외에도 변수명으로 식별해주는 방법이 존재한다.\nBookService.java\n```java @Service public class BookService { @Autowired BookRepository minseongBookRepository; } ```  이렇게해도 정상적인 실행은 되나 추천되는 방법은 아니다.\n동작 원리  BeanPostProcessor  새로 만든 빈 인스턴스를 수정할 수 있는 라이프 사이클 인터페이스   AutowiredAnnotationBeanPostProcessor enxtend BeanPostProcessor  스프링이 제공하는 @Autowired와 @Value 그리고 JSR-330의 @Inject를 지원하는 어노테이션 처리기    ","id":0,"section":"posts","summary":"@Autowired 필요한 의존 객체의 \u0026ldquo;타입\u0026quot;에 해당하는 빈을 찾아 주입한다. 사용할 수 있는 위치 클래스 주입 BookRepository.java public class BookRepository { } BookService.java @Service public class BookService { BookRepository bookRepository; @Autowired public BookService(BookRepository bookRepository){ this.bookRepository","tags":null,"title":"[Spring Core(스프링 프레임워크 핵심기술)] 04. @Autowired","uri":"https://chlalstjd430.github.io/2020/07/spring_core_04/","year":"2020"},{"content":"2. IoC 컨테이너 2부 : ApplicationContext와 다양한 빈 설정 방법 스프링 IoC 컨테이너의 역할  빈 인스턴스 생성 의존관계설정 빈 제공  ApplicationContext 크게 두가지로 나누어진다\n ClassPathXmlApplicationContext (XML) AnnotationConfigApplicationContext (Java)  자세하게 살펴보자.\n  기존의 빈 등록 방식\nclass 정보\npublic class BookRepository { }  public class BookService { BookRepository bookRepository; public void setBookRepository(BookRepository bookRepository) { this.bookRepository = bookRepository; } }  application.xml에 다음과 같이 작성함\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;beans xmlns=\u0026quot;http://www.springframework.org/schema/beans\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026quot;\u0026gt; \u0026lt;bean id=\u0026quot;bookService\u0026quot; class=\u0026quot;com.test.spring.core.applicationcontext.applicationcontext.BookService\u0026quot; scope=\u0026quot;singleton\u0026quot; autowire=\u0026quot;default\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;bookRepository\u0026quot; ref=\u0026quot;bookRepository\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026quot;bookRepository\u0026quot; class=\u0026quot;com.test.spring.core.applicationcontext.applicationcontext.BookRepository\u0026quot;/\u0026gt; \u0026lt;/beans\u0026gt;  DemoApplication.java\npublic class DemoApplication { public static void main(String[] args) { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\u0026quot;application.xml\u0026quot;); } }    Component-Scan 사용(Spring 2.5 부터 가능한 방법)\nclass 정보\n@Component public class BookRepository { }  @Service public class BookService { @Autowired BookRepository bookRepository; public void setBookRepository(BookRepository bookRepository) { this.bookRepository = bookRepository; } }  application.xml\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;beans xmlns=\u0026quot;http://www.springframework.org/schema/beans\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xmlns:context=\u0026quot;http://www.springframework.org/schema/context\u0026quot; xsi:schemaLocation=\u0026quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026quot;\u0026gt; \u0026lt;context:component-scan base-package=\u0026quot;com.test.spring.core.applicationcontext.applicationcontext\u0026quot;/\u0026gt; \u0026lt;/beans\u0026gt;  DemoApplication.java\npublic class DemoApplication { public static void main(String[] args) { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\u0026quot;application.xml\u0026quot;); } }  특정 패키지 이하의 모든 클래스 중에 @Component 애노테이션을 사용한 클래스를 빈으로 자동으로 등록 해 줌.\n  Java 설정\n빈 설정을 xml이 아닌 자바로 설정할 수 없을까 해서 등장한 방법.\nclass 정보\npublic class BookRepository { }  public class BookService { BookRepository bookRepository; public void setBookRepository(BookRepository bookRepository) { this.bookRepository = bookRepository; } }  ApplicationConfig.java\n@Configuration public class ApplicationConfig { @Bean public BookRepository bookRepository() { return new BookRepository(); } // method parameter로 주입받아서도 사용 가능 @Bean public BookService bookService() { BookService bookService = new BookService(); bookService.setBookRepository(bookRepository()); return bookService; } }  DemoApplication.java\npublic class DemoApplication { public static void main(String[] args) { ApplicationContext context = new AnnotationConfigApplicationContext(ApplicationContext.class); } }    @ComponentSacn 등장\nApplicaitonConfig에 일일이 등록해줘야하는 단점에 등장\nApplicationConfig.java\n@Configuration @ComponentScan(basePackageClasses = DemoApplication.class) ppublic class ApplicationConfig { }  @ComponentScan 이용시 @ComponentScan(basePackage = \u0026ldquo;com.도메인\u0026hellip;\u0026quot;) 보다 @ComponentScan(basePackageClasses = DemoApplication.class)을 사용하는 것이 타입 세잎하다. basePackageClasses는 해당 클래스가 있는 곳부터 scan하는 방식이다.\nDemoApplication.java\n@SpringBootAplication public class DemoApplication { public static void main(String[] args) { } }    ","id":1,"section":"posts","summary":"2. IoC 컨테이너 2부 : ApplicationContext와 다양한 빈 설정 방법 스프링 IoC 컨테이너의 역할 빈 인스턴스 생성 의존관계설정 빈 제공 ApplicationContext 크게 두가지로","tags":null,"title":"[Spring Core(스프링 프레임워크 핵심기술)] 03. IoC 컨테이너 2부 : ApplicationContext와 다양한 빈 설정 방법","uri":"https://chlalstjd430.github.io/2020/07/spring_core_03/","year":"2020"},{"content":"스프링 IoC 컨테이너와 빈 IoC(Inversion of Control) 의존 관계 주입(DI, Dependency Injection)이라고도 하며, 어떤 객체가 사용하는 의존 객체를 직접 만들어 사용하는게 아니라, 주입 받아 사용하는 방법을 말 함.\n1. 스프링 IoC 컨테이너   BeanFactory\n 스프링 IoC의 가장 최상위 인터페이스    애플리케이션 컴포넌트의 중앙 저장소\n  빈 설정 소스로 부터 빈 정의를 읽어들이고, 빈을 구성하고 제공한다\n  2. Bean   스프링 IoC 컨테이너가 관리 하는 객체\n 단순 클래스가 모두 빈이 아니라, @Repository, @Service 등 실제로 IoC 컨테이너가 관리하는 객체들을 빈이라고 한다.    의존성 주입을 하기 위해서는 빈이되야 한다.\n  Spring IoC 컨테이너에 등록된 빈의 장점\n 의존성 관리  TestServcie { private TestRepository repository = new TestRepository(); }  @Service TestService { @Autowired private TestRepository repository; }  두가지 코드 중에서 위의 경우에는 TestRepostiroy를 테스트해야 할 경우 해당 객체를 수정할 수 없다. 그러나 아래의 코드는 주입을 하기 때문에 수정이 가능하여 용이하다.\n  Scope\nScope에는 다음과 같이 2가지가 있다.\n  싱글톤(Spring IoC에서 관리하는 빈들은 기본적으로 싱글톤이다) : 하나의 객체 생성\n  프로포토타입 : 매번 다른 객체 생성\n    lifecycle interface\n    3. ApplicationContext  BeanFactory  메시지 소스 처리 기능(i18n) 이벤트 발행 기능 리소스 로딩 기능    ","id":2,"section":"posts","summary":"스프링 IoC 컨테이너와 빈 IoC(Inversion of Control) 의존 관계 주입(DI, Dependency Injection)이라고도 하며, 어떤 객체가 사용하는 의존 객체를 직접 만들어 사용하는게 아니라, 주","tags":null,"title":"[Spring Core(스프링 프레임워크 핵심기술)] 02. 스프링 IoC 컨테이너와 빈","uri":"https://chlalstjd430.github.io/2020/07/spring_core_02/","year":"2020"},{"content":"[Spring Core(스프링 프레임워크 핵심기술)] 01 - 내가 스프링 핵심기술을 공부하게 된 이유 스프링을 공부한지 1년이 다되간다, 스프링을 이용하여 다양한 프로젝트를 진행하였다. 누군가가 나에게 \u0026ldquo;스프링 할 줄 아나?\u0026rdquo; 라고 물어본다면 \u0026ldquo;그렇다\u0026quot;라고 자신있게(?) 대답할 수 있을 것 같다. 그러나 누군가가 나에게 \u0026ldquo;스프링을 잘 아나?\u0026rdquo; 라고 물어본다면 대답을 하지 못할 것이다.\n앞서 말한 이야기에서 사실 스프링을 잘 할줄 아는 것도 아니다. 다만, 할 수 있는 부분에 비해 아는 것이 현저히 적기에 그러한 예를 들었다. 현재 스프링으로 개발을 하지만 비교적 원론적인 개념들이 아직도 많이 부족하다 느끼고 학습할 내용이 많다. 이에 이를 공부해야겠다는 필요성을 느끼고 스프링을 더 알아보고자 학습 계획을 세웠다.\n물론 이 외에도 스프링에 대해 알아야할 것이 많다, 그러나 원론적인 부분을 먼저 알아야 추후 관련된 부분을 학습하는 것이 맞다고 생각한다. 그렇게 어떻게 공부할 것인지 생각해보았고, 가장 효율적이라고 생각하는 인터넷 강의를 채택하게 되었다. 인터넨 강의는 백기선님의 강의로 진행할 것이고 방학동안 꾸준히 공부하여 스프링에 대한 기술을 향상시킬 것이다.\n강의 계획 강의의 목차는 다음과 같다.\n 스프링 IOC 리소스 Validation 데이터 바인딩 SpEL 스프링 AOP NullSafety  강의는 총 23강의에 5시간 정도 걸린다.\n현재 해당 공부 외에도 공부하고 있는 것들이 많고 여러 프로젝트들을 진행하고있어서 많은 시간을 할애하지는 못할 것 같다. 그러나 꾸준히, 정확히 공부하여 빠르게 해당 내용들을 체화할 예정이다. 이에 하루에 1시간 정도 할애하여 일주일 안에 강의를 완강할 계획이다. 그러나 이는 너무 타이트할 일정일 수 있기에 일주일 안에 완강을 목표로 하되, 여러 변수들을 고려하여 일주일정도 더 기한을 줄 예정이다. 즉, 2주 정도의 기간안에 완강과 함께 블로그에 학습 내용들을 정리할 것이다.\n항상 몰랐던 부분을 학습하게 되는 것은 재밌는 것 같다. 어쩔수해야하는 공부가 아닌, 내 의지에 의한 공부는 정말 재미있다. 더 깊게 공부하여 완벽에 가까운(?) 스프링 개발자가 되야겠다!\n","id":3,"section":"posts","summary":"[Spring Core(스프링 프레임워크 핵심기술)] 01 - 내가 스프링 핵심기술을 공부하게 된 이유 스프링을 공부한지 1년이 다되간다, 스프링을 이용하여 다양한 프로젝트","tags":null,"title":"[Spring Core(스프링 프레임워크 핵심기술)] 01. 내가 스프링 핵심기술을 공부하게 된 이유","uri":"https://chlalstjd430.github.io/2020/06/spring_core_01/","year":"2020"},{"content":"[JAVA] - GC(Garbage Collection) GC(Garbage Collection)는 Java 프로세스가 동작하는 과정에서 불필요한 또는 더이상은 사용하지 않는 객체들을 메모리에서 제거함으로써, Java 프로세스가 한정된 메모리를 효율적으로 사용할 수 있게 해준다.\nstop the world\nGC 실행을 위해 JVM이 애플리케이션을 멈추는 것.\nGC 실행시 GC 실행을 위한 스레드를 제외하고 모두 멈춘다.\nGC 튜닝 은 이러한 stop the world 시간을 줄이는 것을 말한다.\nMark and Sweep\nGC 과정을 일컫는 단어.\n Mark : GC가 스택의 모든 변수 또는 Reachable 객체를 스캔하면서 각각 어떤 객체를 참조하고 있는지 찾는 과정(이 과정에서 stop the world 발생) Sweep : Mark되어 있지 않는 객체들을 힙에서 제거하는 과정  Minor GC \u0026amp; Major GC\nJVM의 Heap은 Young, Old, Perm 세 영역으로 나뉜다. Young영역에서 발생한 GC를 Minor GC, 나머지 두영역에서 발생한 GC를 Major GC라고 한다.\n  Young\n 새롭게 생성한 객체가 위치. 구조 : eden, survivor(2개) eden영역에 최초로 객체가 만들어지고, Survivor 영역을 통해서 Old 영역으로 이동    Old\n Young 영역에서 reachable 상태를 유지해 살아남은 객체가 복사된다. Young 영역보다 크게 할당하며, 크기가 큰 만큼 Young 영역보다 GC는 적게 발생한다. GC의 종류는 JAVA의 버전이 다양해짐에 따라 GC도 다양해졌다. 여기서는 CMS GC와 G1 GC 정도만 설명을 한다.   CMS GC - 속도는 빠르나, CPU를 더 많이 사용한다.\nInitial mark 단계에서 클래스 로더에서 가장 가까운 객체 중 살아 있는 객체만 찾는 것으로 끝낸다. 따라서, 멈추는 시간이 굉장히 짧다.\nConcurrent Mark 단계에서는 방금 살아있다고 확인한 객체에서 참조하고 있는 개체들을 따라가 확인한다.\nReamark 단게에서는 Concurrent Mark 단계에서 새로 추가되거나 참조가 끊긴 객체를 확인하다.\n마지막으로 Concurrent Sweep 단계에서 쓰레드를 정리하는 작업을 실행한다.\n  G1 GC\n바둑판의 각 영역에 객체를 할당하고 GC를 실행한다.\n해당 영역이 꽉 차면 다른 영역에서 객체를 할당하고 GC를 실행한다.\n즉, Young → Old 영역으로 이동하는 단계가 사라진 GC 방식\n      Perm(Method Area) : 클래스와 메소드 정보와 같이 자바 언어 레벨에서는 거의 사용되지 않는 영역이다.\n  더 자세한 사항은 아래 참고 주소를 확인하면 좋다.\n  참고\n Java Garbage Collection    ","id":4,"section":"posts","summary":"[JAVA] - GC(Garbage Collection) GC(Garbage Collection)는 Java 프로세스가 동작하는 과정에서 불필요한 또는 더이상은 사용하지 않는 객체들을 메모리에서 제거함으로써, Java 프로세스가 한","tags":null,"title":"[JAVA] - GC(Garbage Collection)","uri":"https://chlalstjd430.github.io/2020/06/gc/","year":"2020"},{"content":"[Python 기초] - 클래스 클래스의 개념  id() : 클래스에 의해 생성된 \u0026lsquo;객체\u0026rsquo;의 식별자를 반환하는 함수 \u0026lsquo;객체\u0026rsquo;는 \u0026lsquo;클래스\u0026rsquo;에 의해 생성된 실체  클래스 생성 및 선언 class Car :\r# 속성(변수)\rcount = 0 # 클래스 변수\r# 생성자\rdef __init__(self, color, speed) :\r# 인스턴스 변수\rself.color = color\rself.speed = speed\r# 클래스 변수\rCar.count += 1\r# 메소드\rdef getName(self) :\rreturn self.color\rdef getSpeed(self) :\rreturn self.speed\rdef upSpeed(self, value) :\rself.speed += value\rdef downSpeed(self, value) :\rself.speed -= value\rcar = Car('검정', 0)\rprint('%s의 현재 속도는 %d입니다.' %(car.getName(), car.getSpeed()))\rcar.color = \u0026quot;파랑\u0026quot;\rcar.speed = 5\rcar.upSpeed(30)\rprint('%s의 현재 속도는 %d입니다.' %(car.getName(), car.getSpeed()))\r 검정의 현재 속도는 0입니다.\r파랑의 현재 속도는 35입니다.\r 클래스의 상속 상속을 구현하는 문법 class SubClass(SuperClass) :\r# ~~\r 메서드 오버라이딩 구현 코드 ## 부모 클래스 ##\rclass Car :\rspeed = 0\rdef upSpeed(self, vlaue) :\rself.speed += value\rclass Sedan(Car) :\rdef upSpeed(self, value) :\rself.speed += value\rif self.speed \u0026gt; 150 :\rself.speed = 150\r 클래스 심화 클래스의 특별한 메소드  del() 메소드  소멸자, 생성자와 반대로 인스턴스 삭제할 때 자동 호출   repr() 메소드  인스턴스를 print() 문으로 출력할 때 실행   add() 메소드  인스턴스 사이에 덧셈 작업이 일어날 때 실행되는 메소드   비교 메소드  lt(), le(), gt(), ge(), eq(), ne() 순서대로 \u0026lt;. \u0026lt;=, \u0026gt;. \u0026gt;=, ==, !=    추상 메소드 class SuperClass :\rdef method(self) : #\rraise NotImplementedError()\rclass SubClass(SuperClass) :\rdef method(self) :\rprint('abstract method')\r ","id":5,"section":"posts","summary":"[Python 기초] - 클래스 클래스의 개념 id() : 클래스에 의해 생성된 \u0026lsquo;객체\u0026rsquo;의 식별자를 반환하는 함수 \u0026lsquo;객체\u0026rsquo;는 \u0026","tags":null,"title":"[Python 기초] - 클래스","uri":"https://chlalstjd430.github.io/2020/06/python_06_class/","year":"2020"},{"content":"[Python 기초] - 함수와 모듈 함수 기본 함수 만들기 def hello(name) : # 함수 선언\rreturn name +'님, 안녕하세요!'\rhello('홍길동') # 함수 호출\r pass 예약어  이름만 만들어 놓고 내용은 pass 예약어를 사용하여 비울 수 잇음  # 오류인 상황\rif True :\r# True일 때 아무런 할 일이 없다고 빈 줄로 둘 때 오류 발생\relse :\rprint('거짓')\r# 정상 작동\rif True :\rpass\relse :\rprint('거짓')\r 함수의 매개변수 전달  매개변수의 개수를 지정해 전달하는 방법  def para_func(v1, v2) :\rreturn v1 + v2\r 매개변수에 기본값을 설정해 놓고 전달하는 방법  def para_func(v1, v2 = 1)\rreturn v1 ** v2\r 매개변수의 개수를 지정하지 않고 전달하는 방법  def para_func(*para) :\rresult = 0\rfor num in para :\rresult += num\rreturn result\r  함수 호출할 때 딕셔너리의 형식의 매개변수를 키 = 값 형식으로 사용  def dic_func(**para) :\rfor k in para.keys() :\rprint('%s --\u0026gt; %d명입니다.' % (k, para[k]))\rdic_func(트와이스=9, 소녀시대=7, 걸스데이=4, 블랙핑크=4)\r 인수 이해하기 위치나 키워드로 인수 설정 def print_student_info(name, birth, major='CS', country='KOR') :\rprint('이름 :', name, ', 생년월일 : ', birth, ', 전공 : ', major, ', 국적 : ', country)\rprint_student_info('홍길동', '2020-06-09')\rprint_student_info('홍길동', '2020-06-09', 'SERVER') print_student_info(birth='2020-06-10', name='길동 홍')\r 출력 결과\n이름 : 홍길동 , 생년월일 : 2020-06-09 , 전공 : CS , 국적 : KOR\r이름 : 홍길동 , 생년월일 : 2020-06-09 , 전공 : SERVER , 국적 : KOR\r이름 : 길동 홍 , 생년월일 : 2020-06-10 , 전공 : CS , 국적 : KOR\r 키워드로만 호출하기 def concat(*args, sep='/'):\rreturn sep.join(args)\rconcat('a', 'b', 'c')\r'a/b/c'\rconcat('a', 'b', 'c', sep = '.')\r'a.b.c'\rconcat(sep='-', 'a','b', 'c')\r# SyntaxError\r# 개수가 정해져 있지 않은 인수는 함수 선언 시 가장 뒤쪽에 배치하여야 한다.\r 언패킹 인수 리스트 활용하기 args = 5, 10\rlist(range(*args))\r# [5, 6, 7, 8, 9]\r 모듈 모듈의 생성과 사용 Module1.py\ndef func1():\rprint('func1')\rdef func2():\rprint('func2')\r Module2.py\nimport Module1\rModule1.func1()\rModule2.func2()\r   모듈병을 생략하고 사용하고 싶을 때\n from 모듈명 import 함수1, 함수2 from 모듈명 import *  Module3.py\nfrom Modul1 import func1, func2\rfunc1()\rfunc2()\r   모듈의 종류  표준 모듈 : 파이썬에서 제공하는 모듈 사용자 정의 모듈 : 사용자가 직접 정의한 모듈 서드 파티 모듈 : 파이썬이 아닌 외부 회사나 단체에서 제공하는 모듈 모듈의 목록 확인 방법  모듈명.builtin_module_names dir(모듈명)    함수의 응용 패키지  모듈을 주제별로 분리할 때 사용   임포트 형식  from 패키지명.모듈명 import 함수명\r 내부 함수, lambda, map()  내부 함수  def outFunc(v1, v2) :\rdef inFunc(num1, num2) :\rreturn num1 + num2\rreturn inFunc(v1, v2)\rprint(outFunc(10,20))\r## 출력 결과 ##\r30\r outFunc() 함수 밖에서 호출하면 오류\nprint(inFunc(10,20)) # 불가능\r   람다 함수\n 쓰고 버리는 일시적인 함수로 함수가 생성된 곳에서만 필요 간단한 기능을 일반적인 함수와 같이 정의해두고 쓰는 것이 아닌 필요한 곳에 즉시 사용 후 버릴 수 있음 람다에는 return 문이 포함되어 있지 않으며 반환값을 만드는 표현식이 있음  g = lambda x: x**2\rprint(g(8))\r64\rf = lambda x ,y=7: x + y\rprint(f(3))\r10\rmyList = [1, 2, 3, 4, 5]\radd10 = lambda num : num + 10\rmyList = list(map(add10, myList))\rprint(myList)\r## 출력 결과 ##\r[11, 12, 13, 14, 15]\r# 두 리스트의 각 자릿수를 합쳐서 새로운 리스트로 만들기\rlist1 = [1, 2, 3, 4]\rlist2 = [10, 20, 30, 40]\rhapList = list(map(lambda n1,n2 : n1 + n2, list1, list2))\rprint(hapList)\r## 출력 결과 ##\r[11, 22, 33, 44]\r   제너레이터와 yield  yield 문 : 함수를 종결하지 않으면서 값을 계속 반환  def number_generator():\ryield 0\ryield 1\ryield 2\rfor i in number_generator():\rprint(i)\r ## 출력 결과 ##\r0\r1\r2\r ","id":6,"section":"posts","summary":"[Python 기초] - 함수와 모듈 함수 기본 함수 만들기 def hello(name) : # 함수 선언 return name +'님, 안녕하세요!' hello('홍길동') # 함수 호출 pass 예약어 이름만 만들어 놓고 내","tags":null,"title":"[Python 기초] - 함수와 모듈","uri":"https://chlalstjd430.github.io/2020/06/python_05_function/","year":"2020"},{"content":"[Python 기초] - 문자열의 개념 문자열의 개념 ss = '파이썬' * 3\r## 출력 결과 ##\r'파이썬파이썬파이썬'\r  문자열의 모든 글자 뒤에 $를 붙여서 출력하는 코드  ss = '파이썬짱!'\rsslen = len(ss)\rfor i in range(0, sslen) :\rprint(ss[i] + '$', end = '')\r 문자열 메소드 대, 소문자 변환  upper() : 소문자 → 대문자 lower() : 대문자 → 소문자 swapcase() : 대문자 ←→ 소문자 capitalize(0 : 첫문자를 대문자로 변환 title() 각 단어의 앞글자만 대문자로 변환  검색  s.count(\u0026lsquo;like\u0026rsquo;) : \u0026lsquo;like\u0026rsquo;라는 문자열이 발생한 횟수 리턴 s.find(\u0026lsquo;like\u0026rsquo;)  문자열 s에서 \u0026lsquo;like\u0026rsquo;의 오프셋 리턴 찾는 문자열 없을 경우 -1 리턴   s.find(\u0026lsquo;like\u0026rsquo;, 숫자) : 문자열 숫자 번 위치부터 검색 s.rfind(\u0026lsquo;like\u0026rsquo;) : find와 동일하나, 오른쪽부터 검색 s.index(\u0026lsquo;like\u0026rsquo;)  문자열 s에서 \u0026lsquo;like\u0026rsquo;의 오프셋 리턴 찾는 문자열이 없을 경우 예외 발생   s.rindex(\u0026lsquo;like\u0026rsquo;) : index와 같지만 오른쪽부터 검색 s.startswith(\u0026lsquo;i like\u0026rsquo;) : i like로 시작하는 문자열인가? bool 타입 리턴(True, False) s.endswith(\u0026lsquo;you\u0026rsquo;) : \u0026lsquo;you\u0026rsquo;로 끝나는 문자열인가? bool 타입 리턴(True, False) s.startswith(\u0026lsquo;i like\u0026rsquo;, 7) startswith을 7번쨰 문자열부터 검사 s.endswith(\u0026lsquo;you\u0026rsquo;, 7) endswith을 7번째 문자열부터 검사  문자열 편집/치환  s.strip() : 좌우 공백 삭제 s.rstrip() : 오른쪽 공백 삭제 s.lstrip() : 왼쪽 공백 삭제  ss = ' 파 이 썬 '\rss.strip()\rss.rstrip()\rss.lstrip()\r## 출력 결과 ##\r'파 이 썬'\r' 파 이 썬'\r'파 이 썬 '\r  s.strip(\u0026lsquo;\u0026lt;\u0026gt;\u0026rsquo;) : 앞뒤의 특정 문자 삭제, \u0026lsquo;\u0026lt;\u0026gt;\u0026rsquo; 삭제 s.replace(\u0026lsquo;파이썬\u0026rsquo;, \u0026lsquo;Python\u0026rsquo;) : \u0026lsquo;파이썬\u0026rsquo;을 \u0026lsquo;Python\u0026rsquo;으로 치환  문자열 분리/결합  s.split() : 공백으로 분리 s.splitlines() : 라인 단위로 분리 \u0026lsquo;:'.join(s) : \u0026lsquo;:\u0026rsquo; 문자로 결합 s.split(':\u0026rsquo;, 2) : \u0026lsquo;:\u0026rsquo; 문자로 2번만 분리 s.rsplit(':\u0026rsquo;, 1) : 오른쪽부터 한번만 분리  함수명에 대입 : map() 함수  map(함수명, 리스트명)  before = ['2019', '12, '31']\rafter = list(map(int, before))\rafter\r## 출력 결과 ##\r[2019, 12, 31]\r 문자열 정렬, 채우기  center() : 문자열 가운데 정렬 ljust() : 문자열 왼쪽 정렬 rjust() : 문자열 오른쪽 정렬 zfill() : 오른쪽 정렬, 왼쪽 빈 공간은 0으로 채움  문자열 구성 파악(bool type return)  isdigit() : 문자열이 숫자인지 아닌지 확인 isalpha() : 문자열이 문자(한글, 영어)인지 아닌지 확인 isalnum() : 글자와 숫자가 섞여있는지 아닌지 확인 islower() : 전체가 소문자로만 구성되었는지 아닌지 확인 isupper() : 전체가 대문자로만 구성되었는지 아닌지 확인 isspace() : 공백 문자로만 구성되었는지 아닌지를 확인  ","id":7,"section":"posts","summary":"[Python 기초] - 문자열의 개념 문자열의 개념 ss = '파이썬' * 3 ## 출력 결과 ## '파이썬파이썬파이썬' 문자열의 모든 글자 뒤에 $를 붙여서 출력하는 코드 ss = '파이썬","tags":null,"title":"[Python 기초] - 문자열의 개념","uri":"https://chlalstjd430.github.io/2020/06/python_04_string/","year":"2020"},{"content":"[Python 기초] - 제어문과 데이터 구조 데이터 정렬 : sorted() 함수  리스트  nums = 4, 2, 5, 7, 1, 3\rsorted(nums)\r[1, 2, 3, 4, 5, 7]\rsorted(nums, reverse = True)\r[7, 5 , 4, 3, 2, 1]\rnums\r(4, 2, 5, 7, 1, 3(\r  딕셔너리  programmer_dict = {'Python':5, 'C':2, 'C++':3, 'Java':4, 'Ruby':1}\rsorted(programmer_dict.keys())\rsorted(programmer_dict.values())\r 제어문과 데이터 타입 조합 A = ['blue', 'yellow', 'red']\rB = ['red', 'green', 'blue']\rpairs = []\rfor a in A :\rfor b in B :\rif a != b :\rpairs.append((a,b))\rpairs\r[('blue', 'red'), ('blue', 'green'), ... ]\rnew_pairs = [(a, b) for a in A for b in B if a != b] # (a, b) 소괄호를 안감싸면 컴파일 에러\r  세트 타입 구성  a = {x for x in 'abracadabra' if x not in 'abc'}\r{'d', 'r'}\r  딕셔너리 타입 구성  square_dic = {x: x**2 for x in (2, 4, 6)}\rsquare_dic\r{2: 4, 4: 16, 6: 36}\r  enumerate()  korean_foods_enum = enumerate(korean_foods)\rfor index, food in korean_foods_enums:\rprint(index, food)\r## 출력 결과 ##\r0 kimchi\r1 bibimbab\r2 tteok-bokki\r ","id":8,"section":"posts","summary":"[Python 기초] - 제어문과 데이터 구조 데이터 정렬 : sorted() 함수 리스트 nums = 4, 2, 5, 7, 1, 3 sorted(nums) [1, 2, 3, 4, 5, 7] sorted(nums, reverse = True) [7, 5 , 4, 3, 2, 1] nums (4, 2, 5, 7, 1, 3( 딕셔너리 programmer_dict = {'Python':5, 'C':2, 'C++':3, 'Java':4, 'Ruby':1}","tags":null,"title":"[Python 기초] - 제어문과 데이터 구조","uri":"https://chlalstjd430.github.io/2020/06/python_03_control/","year":"2020"},{"content":"[Python 기초] - 튜플,세트 그리고 딕셔너리 다양한 데이터 타입 컴퓨터 자원의 효율적 사용을 위해 상황에 맞는 데이터 구조를 선택해야 질 높은 프로그램을 개발할 수 있음\n 튜플 타입 : 값을 변경할 수 없음(←→ 리스트) 세트 타입 : 중복 데이터를 허용하지 않음 딕셔너리 타입 : 색인이 아닌 특정 키로 값을 불러올 수 있음  튜플 개념  immutable 열거 데이터의 집합 값을 변경할 수 있는 리스트 타입과 달리, 한 번 값이 정해지면 항목의 값을 변경할 수 없음  튜플 타입  \u0026lsquo;서로 다른 종류의 데이터 타입\u0026rsquo;으로 이루어진 항목들을 변수에 바로 풀어서 할당하거나 색인을 매길 때 사용  리스트 타입  \u0026lsquo;동일한 자료 타입\u0026rsquo;으로 이루어진 항목들을 리스트 내에서 순차적으로 추출할 때 사용  선언 및 사용  소괄호 기호(())로 감싸거나, 아예 감싸지 않는 방법으로 선언  card = 'red', 4, '다이아모든', True # 튜플 생성\rcard\r# ('red', 4, '다이아모늗', True) 출력\rcard[-1] = False # -\u0026gt; 불가능\r  빈 튜플 만들기  empty_tuple = ()\rempty_tuple2 = tuple()\r  항목이 하나 있는 튜플 생ㅇ성  one = ('하나')\rtype(one)\r# \u0026lt;class 'str'\u0026gt; 출력\rone_item = '하나',\rtype(one_item)\r# \u0026lt;class 'tuple'\u0026gt; 출력\r 튜플 패킹과 튜플 언패킹  튜플 패킹 : 문자열, 숫자, 논리 타입으로 이루어진 여러 개의 데이터가 하나의 튜플로 포장된 것 튜플 언패킹 : 튜플을 항목별로 각각 풀어서 변수에 저장하는 것  card = 'red', 4, '다이아몬드', True # 튜플 생성(패킹)\ra, b, c, d = card # 튜플 항목 개별 할당(언패킹)\ra # 'red' 출력\r 튜플 ↔ 리스트 card = 'red', 4, '다이아몬드', True\rcard_list = list(card)\rtype(card_list)\r\u0026lt;class 'list'\u0026gt;\r# ['red', 4, '다이아몬드', True]\rcard_tuple = tuple(card_list)\rtype(card_tuple)\r\u0026lt;class 'tuple'\u0026gt;\rcard_tuple\r# ('red', 4, '다이아몬드', True)\r 튜플은 append, index 삭제, 값 변경이 불가능하다.\n세트 개념 세트 타입은 데이터 중복을 허용하지 않고 순서가 없는 데이터 지합을 위한 데이터 타입\n선언 및 사용  쉼표 기호(,)로 구분된 항목을 중괄호 기호({})로 감싸는 것 \u0026lsquo;in\u0026rsquo; : 값이 있으면 Ture, 없으면 False 반환  languages = {'C++', 'Python', 'C', 'C', 'C++', 'Python'}\rlanguages\r# {'Python', 'C++', 'C'} 출력\r'Python' in languages\rTrue\r'R' in languages\rFalse\r  빈 세트 타입 생성  try_empty_set = {} # -\u0026gt; 이것은 딕셔너리 타입\rreal_empty_set = set() # -\u0026gt; 올바른 빈 세트 데이터 생성\r  사용 예제  a = set('abracadabra')\r# {'a', 'r', 'b', 'c', 'd'} 출력\rb = set('alacazam')\ra-b\r{'r', 'd', 'b'} # a와 b의 차집합\ra | b\r{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'} # a와 b의 합집합\ra \u0026amp; b\r{'a', 'c'} # a와 b의 교집합\ra^b\r{'r', 'd', 'b', 'm', 'z', 'l'} # a와 b의 여집합(합집합 - 교집합)\r 딕셔너리 개념  \u0026lsquo;딕셔너리 타입\u0026rsquo;은 전체 항목이 정렬되지 않은 키와 값의 쌍으로 구성된 데이터 모음 변경할 수 있는 데이터 타입 \u0026lsquo;키:값\u0026rsquo;의 형태로 표기하며 각 쌍은 쉼표 기호(,)로 구분하고 전체 집합은 중괄호 기호({})로 감사는 방식 딕셔너리에는 순서가 없어 생성한 순서대로 딕셔너리가 구성 중복된 키가 있을 경우 마지막에 있는 키를 적용  student1 = {'학번' : 1000, '이름' : '홍길동', '학번' : 2000}\r# {'학번' : 2000, '이름' : '홍길동'} 출력\r 선언 및 사용 programmer_dict = {'Python' : 5, 'C': 2, 'C++' : 3, 'JAVA' : 4}\rprogrammer_dict['Python']\r# 5 출력\r  값 변경 및 값 추가  programmer_dict['Python'] = 7\rprogrammer_dict['Python']\r# 7 출력\rprogrammer_dict['JvavScript'] = 1\r# {'Python' : 5, 'C': 2, 'C++' : 3, 'JAVA' : 4, 'JavaScript' : 1} 출력\r  키 값 확인 : 내장 함수 keys(), values 사용 반환 값은 dict_keys() 타입으로 반환되며 익숙한 리스트로 활용할 경우 lsit() 함수 활용  programmer_dict.keys()\rdict_keys(['Python', 'C', 'C++', 'Java', 'Ruby'])\rprogrammer_dict.values()\rdict_values([5, 2, 3, 4])\rlist(programmer_dict.keys())\r['Python', 'C', 'C++', 'Java', 'Ruby']\r  특정 키워드를 확인할 경우 \u0026lsquo;in\u0026rsquo; 사용  'Python' in programmer_dict\rTrue\r'R' not in programmer_dict\rTrue\r  특정 항목 삭제 : del / 전체 항목 삭제 : 내장 함수 clear()  del programmer_dict['Ruby']\rdel(programmer_dict['C++'], programmer_dict['C'])\rprogrammer_dict.clear()\r  없는 키를 찾을 때 \u0026lsquo;딕셔너리명[키]\u0026lsquo;를 사용하면 오류, 하지만 \u0026lsquo;딕셔너리.get(키)' 를 사용하면 아무것도 반환하지 않고 정상 실행 딕셔너리.items() 하면를 사용하면 튜플 형태로도 구할 수 있음  정렬 키로 정렬한 후 딕셔너리 추출\nimport operator # operator.itemgetter() 함수 사용을 위해 import\rtrainDic, trainList = {}, []\rtrainDic = {'Thomas' : '토마스', 'Edward' : '에드워드', 'Henry' : '헨리'}\rtrainList = sorted(trainDic.items(), key = operator.itemgetter(0))\r# 값으로 정렬을 원할시 0이아닌 1 입력\r 컴프리헨션  값이 순차적인 리스트를 한 줄로 만드는 간단한 방법 리스트 = [수식 for 항목 in range() if 조건식]  numList = [num for num in range(1, 6)]\rnumList # [1, 2, 3, 4, 5] 출력\rnumList = [num for num in range(1, 21) if num % 3 == 0]\rnumList # [3, 6, 9, 12, 15, 18] 출력\r 동시에 여러 리스트에 접근  zip() 함수를 사용해 동시에 여러 리스트에 접근  foods = ['떡볶이', '짜장면', '라면', '피자', '맥주', '치킨', '삼겹살']\rsides = ['오뎅', '단무지', '김치']\rfor food, side in zip(foods, sides) :\rprint(food, ' --\u0026gt; ', side)\r## 출력 결과 ##\r떡볶이 --\u0026gt; 오뎅\r짜장면 --\u0026gt; 단무지\r라면 --\u0026gt; 김치\r  두 리스트를 튜플이나 딕셔너리로 짝지을 때 zip() 함수 사용  tupList = list(zip(foods, sides))\rdic = dict(zip(foods, sides))\rtupList\rdic\r## 출력 결과 ##\r[('떡볶이', '오뎅'), ('짜장면', '단무지'), ('라면', '김치')]\r{'떡볶이': '오뎅', '짜장면': '단무지', '라면': '김치'}\r  얕은 복사의 방지  newList = oldList[:]\r ","id":9,"section":"posts","summary":"[Python 기초] - 튜플,세트 그리고 딕셔너리 다양한 데이터 타입 컴퓨터 자원의 효율적 사용을 위해 상황에 맞는 데이터 구조를 선택해야 질 높은 프로그램을 개발할 수 있음 튜플","tags":null,"title":"[Python 기초] - 튜플,세트 그리고 딕셔너리","uri":"https://chlalstjd430.github.io/2020/06/python_02_collections/","year":"2020"},{"content":"[Python 기초] - 리스트 리스트 기본  리스트 생성  리스트명 = [값1, 값2, 값3]\r  리스트의 색인  num_list = [3, 1, 5, 2]\r# 양수핼인 0 1 2 3\r# 음수색인 -4 -3 -2 -1\r  길이  len(num_list)\r# 4 출력\r  리스트 조작 함수   리스트 자르기  num_list = [3, 1, 5, 2]\rnum_list[1:3] # 1부터 2까지 자르기\r[1, 5]\rnum_list[:2] # 1까지 자르기\r[3, 1]\rnum_list[1:] # 1부터 자르기\r[1, 5, 2]\rnum_list[:] # 전체 복사\r[3, 1, 5, 2]\r  리스트의 덧셈/곱셈 연산  aa = [10, 20, 30]\rbb = [40, 50, 60]\raa + bb\raa * 3\r# 출력\r# [10, 20, 30, 40, 50, 60]\r# [10, 20, 30, 10, 20, 30, 10, 20, 30]\r  리스트의 항목 건너뛰며 추출  aa = [10, 20, 30, 40, 50, 60, 70]\raa[::2] # [10, 30, 50, 70]\raa[::-2] # [70, 50, 30, 10]\r  리스트 안에 리스트 넣기  aa = [10, 20, 30]\raa[1] = [200, 201]\raa\r[10, [200, 201], 30]\r  리스트 삭제  1. aa = []; # [] 출력\r2. aa = None; # 출력 없음\rex)\raa = [10, 20, 30, 40, 50]\raa[1:4] = []\r# [10, 50]\r  2차원 리스트  aa = [[1,2,3,4], [5,6,7,8], [9,10,11,12]]\r ","id":10,"section":"posts","summary":"[Python 기초] - 리스트 리스트 기본 리스트 생성 리스트명 = [값1, 값2, 값3] 리스트의 색인 num_list = [3, 1, 5, 2] # 양수핼인 0 1 2 3 # 음수색인 -4 -3 -2 -1 길이 len(num_list) # 4 출력","tags":null,"title":"[Python 기초] - 리스트","uri":"https://chlalstjd430.github.io/2020/06/python_01_list/","year":"2020"},{"content":"Observer pattern(옵저버 패턴) 이번에 학습할 디자인 패턴은 옵저버 패턴 입니다.\nObserver pattern(옵저버 패턴)이란? 위키에서는 다음과 같이 정의합니다.\n 옵서버 패턴(observer pattern)은 객체의 상태 변화를 관찰하는 관찰자들, 즉 옵저버들의 목록을 객체에 등록하여 상태 변화가 있을 때마다 메서드 등을 통해 객체가 직접 목록의 각 옵저버에게 통지하도록 하는 디자인 패턴이다. 주로 분산 이벤트 핸들링 시스템을 구현하는 데 사용된다. 발행/구독 모델로 알려져 있기도 하다.\n 예제와 함께 커맨드 패턴에 대해 자세히 알아보도록 하겠습니다.\n여러가지 방식으로 성적 출력하기 성적을 출력해주는 클래스가 다음과 같이 있다고 하자.\n  ScoreRecord 클래스: 점수를 저장/관리하는 클래스\n  DataSheetView 클래스: 점수를 목록형태로 출력하는 클래스\n  코드로 구현하면 다음과 같다.\npublic class Client {\rpublic static void main(String[] args) {\rScoreRecord scoreRecord = new ScoreRecord();\rDataSheetView dataSheetView = new DataSheetView(scoreRecord, 3);\rscoreRecord.setDataSheetView(dataSheetView);\rfor(int i = 1; i \u0026lt;= 5; i++){\rint score = i * 10;\rSystem.out.println(\u0026quot;Adding \u0026quot; + score);\rscoreRecord.addScore(score);\r}\r}\r}\rclass ScoreRecord {\rprivate List\u0026lt;Integer\u0026gt; scores = new ArrayList\u0026lt;\u0026gt;();\rprivate DataSheetView dataSheetView;\rpublic void setDataSheetView(DataSheetView dataSheetView){\rthis.dataSheetView = dataSheetView;\r}\rpublic void addScore(int score){\rthis.scores.add(score);\rdataSheetView.update();\r}\rpublic List\u0026lt;Integer\u0026gt; getScoredRecord(){\rreturn scores;\r}\r}\rclass DataSheetView {\rprivate ScoreRecord scoreRecord;\rprivate int viewCount;\rpublic DataSheetView(ScoreRecord scoreRecord, int viewCount) {\rthis.scoreRecord = scoreRecord;\rthis.viewCount = viewCount;\r}\rpublic void update(){\rList\u0026lt;Integer\u0026gt; record = scoreRecord.getScoredRecord();\rdisplayScore(record, viewCount);\r}\rpublic void displayScore(List\u0026lt;Integer\u0026gt; record, int viewCount){\rSystem.out.print(\u0026quot;List of \u0026quot; + viewCount + \u0026quot; entries: \u0026quot;);\rfor (int i = 0; i \u0026lt; viewCount \u0026amp;\u0026amp; i \u0026lt; record.size(); i++){\rSystem.out.println(record.get(i) + \u0026quot; \u0026quot;);\r}\rSystem.out.println();\r}\r}\r 해당 코드를 보고 다음과 같은 문제에 대해 고민해보자.\n  성적을 다른 방식으로 출력하고 싶다면 어떤 변경작업을 해야 하는가? 에를 들어 성적을 목록으로 출력하지 않고 최소/최대값만을 출력하려면?\n  성적을 동시에 여러 가지 형태로 출력하려면 어떤 변경 작업을 해야 하는가?\n  프로그램이 실행 시에 성적의 출력 대상이 변경되는 것을 지원한다면 어떤 변경 작업을 해야 하는가?\n  현재 코드에서 다음과 같은 작업을 할 경우, 뷰가 추가될때마다 ScoreRecord에 추가해줘야 하기 때문에 ScoreRecord가 지나치게 비대해지고, 이외에도 코드의 중복도 발생할 것이다.\n이에 성적 통보 대상이 변경되더라도 ScoreRecord 클래스를 그대로 재사용할 수 있도록 옵저버 패턴을 이용하여 클래스 구조를 바꿔보자.\n여러가지 방식으로 성적 출력하기(옵저버 패턴) 먼저 옵저버 패턴은\n위와 같은 클래스 구조로 이루어져야 한다.\n옵저버 패턴은 통보 대상 객체의 관리를 Subject 클래스와 Observer 인터페이스로 일반화한다. 그러면 데이터 변경을 통보하는 클래스(ConcreteSubject)는 통보 대상 클래스/객체ConcreteObserver)에 대한 의존성을 제거 할 수 있다. 결과적으로 옵저버 패턴은 통보 대상 클래스나 대상 객체의 변경에도 ConcreteSubject 클래스를 수정 없이 그대로 사용할 수 있도록 한다.\n옵저버 패턱을 적용하면 클래스 구조는 위와 같아집니다.\n그리고 코드는 다음과 같습니다.\ninterface Observer {\rabstract public void update();\r}\rabstract class Subject {\rprivate List\u0026lt;Observer\u0026gt; observers = new ArrayList\u0026lt;\u0026gt;();\rpublic void attach(Observer observer){\robservers.add(observer);\r}\rpublic void detach(Observer observer){\robservers.remove(observer);\r}\rpublic void notifyObservers(){\rfor (Observer o : observers) o.update();\r}\r}\rclass ScoreRecord extends Subject {\rprivate List\u0026lt;Integer\u0026gt; scores = new ArrayList\u0026lt;\u0026gt;();\rpublic void addScore(int score){\rthis.scores.add(score);\rnotifyObservers();\r}\rpublic List\u0026lt;Integer\u0026gt; getScoredRecord(){\rreturn scores;\r}\r}\rclass DataSheetView implements Observer {\rprivate ScoreRecord scoreRecord;\rprivate int viewCount;\rpublic DataSheetView(ScoreRecord scoreRecord, int viewCount) {\rthis.scoreRecord = scoreRecord;\rthis.viewCount = viewCount;\r}\rpublic void update(){\rList\u0026lt;Integer\u0026gt; record = scoreRecord.getScoredRecord();\rdisplayScore(record, viewCount);\r}\rpublic void displayScore(List\u0026lt;Integer\u0026gt; record, int viewCount){\rSystem.out.print(\u0026quot;List of \u0026quot; + viewCount + \u0026quot; entries: \u0026quot;);\rfor (int i = 0; i \u0026lt; viewCount \u0026amp;\u0026amp; i \u0026lt; record.size(); i++){\rSystem.out.println(record.get(i) + \u0026quot; \u0026quot;);\r}\rSystem.out.println();\r}\r}\rclass MinMaxView implements Observer {\rprivate ScoreRecord scoreRecord;\rpublic MinMaxView(ScoreRecord scoreRecord){\rthis.scoreRecord = scoreRecord;\r}\r@Override\rpublic void update() {\rList\u0026lt;Integer\u0026gt; record = scoreRecord.getScoredRecord();\rdisplayMinMax(record);\r}\rprivate void displayMinMax(List\u0026lt;Integer\u0026gt; record){\rint min = Collections.min(record, null);\rint max = Collections.max(record, null);\rSystem.out.println(\u0026quot;Min: \u0026quot; + min + \u0026quot; Max: \u0026quot; + max);\r}\r}\rpublic class Client {\rpublic static void main(String[] args) {\rScoreRecord scoreRecord = new ScoreRecord();\rDataSheetView dataSheetView3 = new DataSheetView(scoreRecord, 3);\rDataSheetView dataSheetView5 = new DataSheetView(scoreRecord, 5);\rMinMaxView minMaxView = new MinMaxView(scoreRecord);\rscoreRecord.attach(dataSheetView3);\rscoreRecord.attach(dataSheetView5);\rscoreRecord.attach(minMaxView);\rfor(int i = 1; i \u0026lt;= 5; i++){\rint score = i * 10;\rSystem.out.println(\u0026quot;Adding \u0026quot; + score);\rscoreRecord.addScore(score);\r}\r}\r}\r 참고\n JAVA 객체지향 디자인 패턴   ","id":11,"section":"posts","summary":"Observer pattern(옵저버 패턴) 이번에 학습할 디자인 패턴은 옵저버 패턴 입니다. Observer pattern(옵저버 패턴)이란? 위키에서는 다음과 같이 정의합니다.","tags":null,"title":"[DesignPattern] Observer pattern(옵저버 패턴)","uri":"https://chlalstjd430.github.io/2020/06/08_observer_pattern/","year":"2020"},{"content":"Command pattern(커맨드 패턴) 이번에 학습할 디자인 패턴은 커맨드 패턴 입니다.\nCommand pattern(커맨드 패턴)이란? 위키에서는 다음과 같이 정의합니다.\n 커맨드 패턴(Command pattern)이란 요청을 객체의 형태로 캡슐화하여 사용자가 보낸 요청을 나중에 이용할 수 있도록 매서드 이름, 매개변수 등 요청에 필요한 정보를 저장 또는 로깅, 취소할 수 있게 하는 패턴이다.\n  커맨드 패턴에는 명령(command), 수신자(receiver), 발동자(invoker), 클라이언트(client)의 네개의 용어가 항상 따른다. 커맨드 객체는 수신자 객체를 가지고 있으며, 수신자의 메서드를 호출하고, 이에 수신자는 자신에게 정의된 메서드를 수행한다. 커맨드 객체는 별도로 발동자 객체에 전달되어 명령을 발동하게 한다. 발동자 객체는 필요에 따라 명령 발동에 대한 기록을 남길 수 있다. 한 발동자 객체에 다수의 커맨드 객체가 전달될 수 있다. 클라이언트 객체는 발동자 객체와 하나 이상의 커맨드 객체를 보유한다. 클라이언트 객체는 어느 시점에서 어떤 명령을 수행할지를 결정한다. 명령을 수행하려면, 클라이언트 객체는 발동자 객체로 커맨드 객체를 전달한다.\n 예제와 함께 커맨드 패턴에 대해 자세히 알아보도록 하겠습니다.\n만능 버튼 만들기 우리가 만능 버튼을 만들어야한다는 문제에 앞서, 일반적으로 램프와 버튼 관계의 클래스를 만들면 다음과 같이 만들 수 있습니다.\n이와 같이 클래스를 만들었을 때, 다음과 같은 문제점을 고민해봅시다.\n  버튼이 눌렸을 때 램프를 켜는 대신에 다른 기능을 수행하기 위해서는 어떤 변경 작업을 해야 되는가? 예를 들어 버튼이 눌리면 알람을 시작시키려면?\n  버튼이 눌렸을 때 수행되는 기능을 프로그램이 동작할 때 결정하기 위해서는?\n  이러한 문제점을 해결하기 위해 커맨드 패턴을 이용해봅시다.\n커맨드 패턴에는 총 4가지의 역할이 존재합니다.\n Invoker   기능의 실행을 요청하는 호출자 클래스  Command    실행될 기능에 대한 인터페이스\n  실행될 기능을 execute 메세드로 표현\n  ConcreteCommand   실제로 실행되는 기능을 구현(Command 구현 클래스)  Receiver   ConcreteCommand에서 execute 메소드를 구현할 때 필요한 클래스  그렇다면 위에 클래스에 4가지 역할을 대입하면 다음과 같습니다.\n Invoker - Button Command ConcreteCommand - LampOnCommand, AlarmStartCommand Receiver - Lamp, Alarm  결론적으로 다음과 같은 클래스 구조가 나옵니다.\n다음과 같은 클래스 구조를 갖게되면, 동적으로 command를 설정함과 동시에 여러 기능들을 추가적으로 구현하는데 어렵지않게 됩니다.\n참고\n JAVA 객체지향 디자인 패턴   ","id":12,"section":"posts","summary":"Command pattern(커맨드 패턴) 이번에 학습할 디자인 패턴은 커맨드 패턴 입니다. Command pattern(커맨드 패턴)이란? 위키에서는 다음과 같이 정의합니다.","tags":null,"title":"[DesignPattern] Command pattern(커맨드 패턴)","uri":"https://chlalstjd430.github.io/2020/06/07_command_pattern/","year":"2020"},{"content":"Sigleton pattern(싱글톤 패턴) 이번에 학습할 디자인 패턴은 싱글톤 패턴 입니다.\nSigleton pattern(싱글톤 패턴)이란? 위키에서는 다음과 같이 정의합니다.\n 싱글턴 패턴(Singleton pattern)을 따르는 클래스는, 생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나이고 최초 생성 이후에 호출된 생성자는 최초의 생성자가 생성한 객체를 리턴한다. 이와 같은 디자인 유형을 싱글턴 패턴이라고 한다. 주로 공통된 객체를 여러개 생성해서 사용하는 DBCP(DataBase Connection Pool)와 같은 상황에서 많이 사용된다.\n Sigleton pattern(싱글톤 패턴) 구현 방법? 싱글톤을 구현하는 방법에는 Eager Initialization, Static Block Initialization, Lazy Initialization, Thread Safe Singleton, Bill Pugh Singleton Implementaion, Enum Singleton 등 다양한 방법이 있습니다. 이중 가장 널리 쓰이는 Bill Pugh Singleton Implementaion 으로 구현하는 방법을 소개해드리도록 하겠습니다.\npublic class Singleton {\rprivate Singleton(){}\rprivate static class SingletonHelper{\rprivate static final Singleton INSTANCE = new Singleton();\r}\rpublic static Singleton getInstance(){\rreturn SingletonHelper.INSTANCE;\r}\r}\r 해당 코드는 synchronized를 사용하지 않기 때문에 성능 저하와 멀티 스레드의 환경에서 모두 유용하여 널리 쓰입니다.\n간략하게 싱글톤 패턴에 대해 소개해드렸는데, 싱글톤 패턴의 경우 무작정 사용하기보다는 정말 필요한 상황에서만 사용해야 메모리 관리면에서도 효율적으로 관리할 수 있습니다. 이점 참고하셔서 효율적인 코드 작성하셨으면 좋겠습니다. 감사합니다.\n출처\n [생성 패턴] 싱글톤(Singleton) 패턴을 구현하는 6가지 방법  ","id":13,"section":"posts","summary":"Sigleton pattern(싱글톤 패턴) 이번에 학습할 디자인 패턴은 싱글톤 패턴 입니다. Sigleton pattern(싱글톤 패턴)이란? 위키에서는 다음과 같이 정의합니다.","tags":null,"title":"[DesignPattern] Sigleton pattern(싱글톤 패턴)","uri":"https://chlalstjd430.github.io/2020/06/06_sigleton_pattern/","year":"2020"},{"content":"Strategy pattern(전략 패턴) 이번에 학습할 디자인 패턴은 전략 패턴 입니다.\nStrategy pattern(전략 패턴)이란? 위키에서는 다음과 같이 정의합니다.\n 전략 패턴(strategy pattern) 또는 정책 패턴(policy pattern)은 실행 중에 알고리즘을 선택할 수 있게 하는 행위 소프트웨어 디자인 패턴이다.\n 예제를 보고 이해해봅시다.\n예제 - 로봇 만들기 우리는 공격과 이동 기능이 있는 TaekwonV, Atom 로봇을 만든다고 가정하자, 그렇다면 다음과 같은 클래스 구조를 생각할 수 있다.\n해당 클래스를 보며 다음과 같은 문제에 대해 생각해보자.\n  새로운 로봇을 만들어 기존의 공격 또는 이동 방법을 추가하거나 수정하려면 어떻게 할까? 예를 들어 새로웃 로봇(선가드)를 만들어 태권V의 미사일 공격 기능을 추가하려면?\n  기존 로봇의 공격 또는 이동 방법을 수정하려면 어떤 변경 작업을 해야하는가?\n  먼저 기존의 클래스 구조를 따라서 새로운 로븟을 만들려면\n다음과 같은 클래스를 추가하면 된다. 그러나 로봇이 추가될 때 마다 attack과 move 메소드를 수정해주어야 하고, 로봇들이 같은 기능을 할 경우 코드의 중복이 많이 생길 것이다.\n이에 우리는 전략 패턴을 이용해보자.\n예제 - 로봇 만들기(전략 패턴 이용)  Robot의 멤버로 MovingStrategy와 AttackStrategy가 멤버 변수가 사진에서 누락되었습니다.  기존의 클래스 구조와 비교를 하면 MovingStrategy, AttackStrategy와 같은 인터페이스를 만들고, 해당 클래스들을의 구체 클래스를 만드는 것을 확인하실 수 있습니다. 이후 Robot클래세 setter을 이용하여 move와 attack의 동작을 달리 할 수 있게 하였습니다.\n이를 통해 추후 각 로봇들이 추가됨에 따라 반복되는 기능은 쉽게 구현할 수 있고, 기능들을 동적으로 변경할 수 있게 되었습니다.\n참고\n JAVA 객체지향 디자인 패턴   ","id":14,"section":"posts","summary":"Strategy pattern(전략 패턴) 이번에 학습할 디자인 패턴은 전략 패턴 입니다. Strategy pattern(전략 패턴)이란? 위키에서는 다음과 같이 정의합니다. 전략 패","tags":null,"title":"[DesignPattern] Strategy pattern(전략 패턴)","uri":"https://chlalstjd430.github.io/2020/06/05_strategy_pattern/","year":"2020"},{"content":"Abstract factory pattern(추상 팩토리 패턴) 이번에 학습할 디자인 패턴은 추상 팩토리 패턴 입니다.\n추상 팩토리 패턴이란? 위키에서는 다음과 같이 정의합니다.\n 추상 팩토리 패턴(Abstract factory pattern)은 다양한 구성 요소 별로 \u0026lsquo;객체의 집합\u0026rsquo;을 생성해야 할 때 유용하다. 이 패턴을 사용하여 상황에 알맞은 객체를 생성할 수 있다.\n 문장으로 이해하는 것보다 정확한 예제로 이해해봅시다!\n엘리베이터 부품 업체 변경하기 다음은 LG와 현대 업체의 모터와 문을 지원하는 클래스들의 다이어그램입니다.\nMotor, Door Class의 핵심 메소드는 다음과 같습니다.\nclass Motor{\rpublic void move(Direction direction){\r// 1) 이미 이동 중이면 무시한다.\r// 2) 만약 문이 열려 있으면 문을 닫는다.\r// 3) 모터를 구동해서 이동시킨다.\r// 4) 모터의 상태를 이동중으로 설정한다.\r}\r}\rclass Door{\rpublic void open(){\r// 1) 이미 문이 열려있으면 무시한다.\r// 2) 문을 연다 -\u0026gt; 이 부분만 LG, 현대에서 달라짐\r// 3) 문의 상태를 닫힘으로 설정한다.\r}\r 이를 유념하고, 위의 클래스다이어그램이 구현된 코드들을 살펴 봅시다.\nenum DoorStatus { CLOSED, OPENED }\rabstract class Door {\rprivate DoorStatus doorStatus;\rpublic Door() {\rthis.doorStatus = DoorStatus.CLOSED;\r}\rpublic DoorStatus getDoorStatus() {\rreturn doorStatus;\r}\rpublic void close() {\rif(doorStatus == DoorStatus.CLOSED)\rreturn;\rdoorStatus = DoorStatus.CLOSED;\r}\rprotected abstract void doClose();\rpublic void open() {\rif(doorStatus == DoorStatus.OPENED)\rreturn;\rdoorStatus = DoorStatus.OPENED;\r}\rprotected abstract void doOpen();\r}\rclass LGDoor extends Door{\r@Override\rprotected void doClose() {\rSystem.out.println(\u0026quot;close LG Door\u0026quot;);\r}\r@Override\rprotected void doOpen() {\rSystem.out.println(\u0026quot;open LG Door\u0026quot;);\r}\r}\rclass HyundaiDoor extends Door{\r@Override\rprotected void doClose() {\rSystem.out.println(\u0026quot;close Hyundai Door\u0026quot;);\r}\r@Override\rprotected void doOpen() {\rSystem.out.println(\u0026quot;open Hyundai Door\u0026quot;);\r}\r}\r 먼저 Door와 관련된 클래스들은 템플릿 메소드 패턴이 적용된 것을 확인하실 수 있습니다.\n이후 모터와 도어 클래스에 팩토리 메서드를 적용해보겠습니다.\nenum Direction { UP, DOWN }\renum VendorID { LG, HYUNDAI }\rclass MotorFactory{\rpublic static Motor createMotor(VendorID vendorID){\rMotor motor = null;\rswitch (vendorID){\rcase LG:\rmotor = new LGMotor();\rbreak;\rcase HYUNDAI:\rmotor = new HyundaiMotor();\rbreak;\r}\rreturn motor;\r}\r}\rclass DoorFactory{\rpublic static Door createDoor(VendorID vendorID){\rDoor door = null;\rswitch (vendorID){\rcase HYUNDAI:\rdoor = new HyundaiDoor();\rbreak;\rcase LG:\rdoor = new LGDoor();\rbreak;\r}\rreturn door;\r}\r}\renum MotorStatus { MOVING, STOPPED }\rabstract class Motor {\rprivate MotorStatus motorStatus;\rprivate Door door;\rpublic Motor(){\rmotorStatus = MotorStatus.STOPPED;\r}\rpublic MotorStatus getMotorStatus(){\rreturn this.motorStatus;\r}\rpublic void setMotorStatus(MotorStatus motorStatus){\rthis.motorStatus = motorStatus;\r}\rpublic void move(Direction direction){\rMotorStatus motorStatus = getMotorStatus();\rif(motorStatus == motorStatus.MOVING){\rreturn;\r}\rdoor.close();\rmoveMotor(direction);\rsetMotorStatus(MotorStatus.MOVING);\r}\rprotected abstract void moveMotor(Direction direction);\rpublic void stop(){\rmotorStatus = MotorStatus.STOPPED;\r}\rpublic void setDoor(Door door){\rthis.door = door;\r}\r}\rclass LGMotor extends Motor{\r@Override\rprotected void moveMotor(Direction direction) {\rSystem.out.println(\u0026quot;move LG Motor \u0026quot; + direction);\r}\r}\rclass HyundaiMotor extends Motor{\r@Override\rprotected void moveMotor(Direction direction) {\rSystem.out.println(\u0026quot;move Hyundai Motor\u0026quot; + direction);\r}\r}\rpublic class Client {\rpublic static void main(String[] args) {\rDoor lgDoor = DoorFactory.createDoor(VendorID.LG);\rMotor lgMotor = MotorFactory.createMotor(VendorID.LG);\rlgMotor.setDoor(lgDoor);\rlgDoor.open();\rlgMotor.move(Direction.UP);\r}\r}\r 이전에 배웠던 패턴들을 이용해보았는데, 이를 통해 부품의 교체가 수월해 보입니다. 그러나 현재는 Door와 Motor의 부품만 필요로하는데, 그 외 여러가지 부품들이 필요한 경우 에는 어떻게 대응해야 할까요?\n예를 들어 총 8개의 부품이 추가된다면, 다음과 같이 8개의 Factory Class들을 만들어야 할 것입니다.\n이렇게 되면 부품이 생길 때마다 팩토리 클래스를 만들어야 해서 코드의 복잡도는 더 커질 것입니다. 이에 해결책으로 다음과 같은 방법을 정의하였습니다.\n위 다이어그램은 부품이 아니라 제조업체 별로 팩토리를 정의하였습니다.\n이를 소스코드로 보면 다음과 같습니다.\nabstract class ElevatorFactory{\rpublic abstract Motor createMotor();\rpublic abstract Door createDoor();\r}\rclass LGElevatorFactory extends ElevatorFactory{\r@Override\rpublic Motor createMotor() {\rreturn new LGMotor();\r}\r@Override\rpublic Door createDoor() {\rreturn new LGDoor();\r}\r}\rclass HyundaiElevatorFactory extends ElevatorFactory{\r@Override\rpublic Motor createMotor() {\rreturn new HyundaiMotor();\r}\r@Override\rpublic Door createDoor() {\rreturn new HyundaiDoor();\r}\r}\rpublic class Client {\rpublic static void main(String[] args) {\rElevatorFactory elevatorFactory = new LGElevatorFactory();\rDoor door = elevatorFactory.createDoor();\rMotor motor = elevatorFactory.createMotor();\rmotor.setDoor(door);\rdoor.open();\rmotor.move(Direction.UP);\r}\r}\r 부품별로 팩토리를 만드는 것이 아닌 제조사별로 팩토리 클래스를만들어 비교적 간겨한 코드가 작성되었습니다.\n추가적으로 삼성 엘리베이터가 다음과 같이 추가된다면 어떻게할까요?\n이는 다른 코드와 마찬가지로 다음과 같이 코드를 작성할 것입니다.\nclass SamsungElevatorFactory extends ElevatorFactory{\r@Override\rpublic Motor createMotor() {\rreturn new SamsungMotor();\r}\r@Override\rpublic Door createDoor() {\rreturn new SamsungDoor();\r}\r}\rclass SamsungDoor extends Door{\r@Override\rprotected void doClose() {\rSystem.out.println(\u0026quot;close Samsung Door\u0026quot;);\r}\r@Override\rprotected void doOpen() {\rSystem.out.println(\u0026quot;open Samsung Door\u0026quot;);\r}\r}\rclass SamsungMotor extends Motor{\r@Override\rprotected void moveMotor(Direction direction) {\rSystem.out.println(\u0026quot;moce Samsung Motor\u0026quot;);\r}\r}\rpublic class Client {\rpublic static void main(String[] args) {\rElevatorFactory elevatorFactory = new SamsungElevatorFactory();\rDoor door = elevatorFactory.createDoor();\rMotor motor = elevatorFactory.createMotor();\rmotor.setDoor(door);\rdoor.open();\rmotor.move(Direction.UP);\r}\r}\r 손 쉽게 다른 제조업체의 엘리베이터도 추가할 수 있습니다! 그러면 이제 이제까지 배웠던 디자인 패턴들을 적용하여 더 코드를 효율적이게 만들지 생각해보면 더 좋은 학습니다. 예를들어, Factory 클래스를 생성하는 부분을 팩토리 메소드 패턴을 적용하여 설계하자. 그리고 제조업체 별 팩토리는 1개만 필요하다면, 싱글톤 패턴을 적용해보면 보다 더 간결하고 명확한 다이어그램이 그려질 겁니다. 해당 코드는 오늘 다루지않겠지만 모두 시간이되면 고민해보고 적용해보시면 좋을 것 같습니다!\n참고\n JAVA 객체지향 디자인 패턴   ","id":15,"section":"posts","summary":"Abstract factory pattern(추상 팩토리 패턴) 이번에 학습할 디자인 패턴은 추상 팩토리 패턴 입니다. 추상 팩토리 패턴이란? 위키에서는 다음과 같이 정의합니다. 추상 팩","tags":null,"title":"[DesignPattern] Abstract factory pattern(추상 팩토리 패턴)","uri":"https://chlalstjd430.github.io/2020/06/04_abstact_factory_pattern/","year":"2020"},{"content":"RESTful API를 설계할 때 내가 만난 대부분은 주로 \u0026ldquo;수정\u0026rdquo; 기능에 대헤 PUT 을 사용하게 됩니다. 그러나 수정할 때 무조건 PUT 을 이용하는 것을 옳지 못한 방법입니다. 수정할 때는 PUT 말고 PATCH 가 있는데, 오늘 이 둘의 차이점을 간략하게 소개하고자 합니다.\nPUT  자원의 전체 수정, 자원내 모든 필드가 필요하다.\n PATCH  자원의 일부분 수정, 자원내 일부 필드가 필요하다.\n 예를 들어, 다음과 같은 User 정보가 있다고 가정해봅시다.\n{ name : \u0026quot;test_name\u0026quot; nickname : \u0026quot;test_nickname\u0026quot; email : \u0026quot;test@test.com\u0026quot; }  /users/{userId} URl에 PUT과 PATCH 로 다음과 같이 수정된 값을 요청해보면\n{ \u0026quot;nickname\u0026quot;: \u0026quot;test_nicknmae2\u0026quot; }  먼저 PUT의 경우에는\n{ name : null nickname : \u0026quot;test_nickname2\u0026quot; email : null }  PATCH는\n{ name : \u0026quot;test_name\u0026quot; nickname : \u0026quot;test_nickname2\u0026quot; email : \u0026quot;test@test.com\u0026quot; }  로 보내게됩니다. 위의 상황에서 PUT은 자원의 전체를 보내지않고 일부분만 보내게되면 나머지 데이터가 유실된채 null값이 들어가게 됩니다. 그렇기에 수정할 때 무조건적으로 PUT을 사용하는게 아닌, 적절하게 PUT과 PATCH를 이용하여 사용해야된다는 것을 알 수 있습니다.\n사실 너무 당연한 이야기로 들리시는 분들도 있지만, 의외로 모르시는 분들이 많아 포스팅을 간략하게 작성해보았습니다. 오해가 있을만한 정보가 있거나 궁금한게 있으시면 언제든지 댓글 남겨주세요🙋‍♂️\n","id":16,"section":"posts","summary":"RESTful API를 설계할 때 내가 만난 대부분은 주로 \u0026ldquo;수정\u0026rdquo; 기능에 대헤 PUT 을 사용하게 됩니다. 그러나 수정할 때 무조건 PUT 을 이용하는 것을 옳지","tags":null,"title":"[HTTP Method] PUT과 PATCH의 차이점","uri":"https://chlalstjd430.github.io/2020/06/put_vs_patch/","year":"2020"},{"content":"Factory method pattern(팩토리 메소드 패턴) 이번에 학습할 디자인 패턴은 \u0026ldquo;팩토리 메소드 패턴\u0026rdquo; 입니다.\n팩토리 메소드 메서드 패턴이란? 위키에서는 다음과 같이 설명합니다.\n Factory method는 부모(상위) 클래스에 알려지지 않은 구체 클래스를 생성하는 패턴이며. 자식(하위) 클래스가 어떤 객체를 생성할지를 결정하도록 하는 패턴이기도 하다. 부모(상위) 클래스 코드에 구체 클래스 이름을 감추기 위한 방법으로도 사용한다.\n 이번에도 역시나 예제로 자세히 살펴보도록 합시다.\n여러 방식의 엘리베이터 스케줄링 방법 지원하기(일반) 엘리베이터 제어 시스템에서 다양한 엘리베이터 스케줄링을 지원한다고 했을 때, 다음과 같은 구조의 클래스가 있다고 가정해봅시다.\n  ElevatorManager Class : 여러 엘리베이터 중에서 스케줄링에 따라서 하나의 엘리베이터를 선택하고 이동시킴\n  EleveatorController Class : 하나의 엘리베이터 이동을 제어하는 클래스\n  ThroughputScheduler Class : 처리량을 기준으로 스케줄링하는 클래스\n  코드로 표현하면, 다음과 같습니다.\nenum Direction {UP, DOW}\rclass ElevatorManager {\rprivate List\u0026lt;ElevatorController\u0026gt; controllers;\rprivate ThroughputScheduler scheduler;\rpublic ElevatorManager(int controllerCount){\rcontrollers = new ArrayList\u0026lt;ElevatorController\u0026gt;(controllerCount);\rfor(int i = 0; i \u0026lt; controllerCount; i++){\rElevatorController controller = new ElevatorController(i);\rcontrollers.add(controller);\r}\rscheduler = new ThroughputScheduler();\r}\rpublic void requestElevator(int destination, Direction direction){\rint selectedElevator = scheduler.selectElevator(this, destination, direction);\rcontrollers.get(selectedElevator).gotoFloor(destination);\r}\r}\rclass ElevatorController {\rprivate int id;\rprivate int curFloor;\rpublic ElevatorController(int id) {\rthis.id = id;\rcurFloor = 1;\r}\rpublic void gotoFloor(int destination){\rSystem.out.println(\u0026quot;Elevator [\u0026quot; + id + \u0026quot;] Floor: \u0026quot; + curFloor);\rcurFloor = destination;\rSystem.out.println(\u0026quot; ==\u0026gt; \u0026quot; + curFloor);\r}\r}\rclass ThroughputScheduler {\rpublic int selectElevator(ElevatorManager manager, int destination, Direction direction){\r// 실제 구현하지는 않음\rreturn 0;\r}\r}\rpublic class Client {\rpublic static void main(String[] args) {\rElevatorManager em = new ElevatorManager(1);\rem.requestElevator(4, Direction.UP);\r}\r}\r 먼저 코도를 잘 읽어가며 각 클래스들의 기능들을 자세히 파악해봅시다. 이후 다음과 문제점을 어떻게 해결할지 생각해봅시다.\n  🙋‍♂️문제점\n  현대 ElevatorManager는 ThroughputScheduler를 이용하고 있다. 즉 엘리베이터의 처리량을 최대화시키는 전략을 사용하고 있다. 만약 다른 스케쥴링 전략을 사용해야 한다면? 예를 들어 사용자의 대기시간을 최소화시키는 엘리베이터를 선택하는 전략을 사용해야 한다면?\n  스케쥴링 전략이 프로그램 실행 중에 변경을 해야 한다면? 즉, 동적 스케쥴링을 지원해야 한다면 어떻게 해야할까? 예를 들어 오전에는 대기시간 최소화 전략을 사용하고 오후에는 처리량 최대화 전략을 사용해야 한다면?\n    먼저 기존에 자주 사용하는 패턴으로 \u0026ldquo;Strategy Patter(전략 패턴)\u0026rdquo; 을 생각하기 쉽습니다. 그렇다면 해당 패턴으로 위와 같은 문제를 해결해봅시다!\n여러 방식의 엘리베이터 스케줄링 방법 지원하기(Strategy patter 적용) 스트래티지 패턴을 적용하면, 다음과 같이 클래스 구조가 나오게 됩니다.\n위의 다이어그램에서 ElevatorController가 표현되어있지 않지만, ElevatorManager와 연결되어있다고 생각하고 보면 된다.\n해당 구조를 보면 ElevatorSheduler를 구현한 클래스들이 생겨서, 위의 문제점을 해결할 수 있을 것으로 보입니다. 실제 코드를 봐볼까요?\ninterface ElevatorScheduler {\rpublic int selectElevator(ElevatorManager manager, int destination, Direction direction);\r}\rclass ThroughputScheduler implements ElevatorScheduler{\r@Override\rpublic int selectElevator(ElevatorManager manager, int destination, Direction direction){\r// 실제 구현하지는 않음\rreturn 0;\r}\r}\rclass ResponseTimeScheduler implements ElevatorScheduler {\r@Override\rpublic int selectElevator(ElevatorManager manager, int destination, Direction direction) {\r// 실제 구현하지는 않음\rreturn 1;\r}\r}\renum Direction {UP, DOW}\rclass ElevatorManager {\rprivate List\u0026lt;ElevatorController\u0026gt; controllers;\rpublic ElevatorManager(int controllerCount){\rcontrollers = new ArrayList\u0026lt;ElevatorController\u0026gt;(controllerCount);\rfor(int i = 0; i \u0026lt; controllerCount; i++){\rElevatorController controller = new ElevatorController(i);\rcontrollers.add(controller);\r}\r}\rpublic void requestElevator(int destination, Direction direction){\rElevatorScheduler scheduler;\rint hour = Calendar.getInstance().get(Calendar.HOUR_OF_DAY);\rif(hour \u0026lt; 12) {\rscheduler = new ResponseTimeScheduler();\r}\relse{\rscheduler = new ThroughputScheduler();\r}\rint selectedElevator = scheduler.selectElevator(this, destination, direction);\rcontrollers.get(selectedElevator).gotoFloor(destination);\r}\r}\r 확실히 이전 문제점을 해결한 것 같습니다. 그러나 ElevatorManager의 requestElevator method를 자세히 살펴보도록 하겠습니다. requestElevator()는 이미 선택된 전략을가지고 엘리베이터를 이동시키는 것이 해당 메소드의 책임입니다. 그런데 현재 코드에서는 전략까지 해당 메소드에서 선택하기 때문에 함수 설계 원칙에 어긋나게 됩니다.\nint hour = Calendar.getInstance().get(Calendar.HOUR_OF_DAY);\rif(hour \u0026lt; 12) {\rscheduler = new ResponseTimeScheduler();\r}\relse{\rscheduler = new ThroughputScheduler();\r}\r 위의 코드는 requestElevator에 있으면 옳은 방법은 아닙니다. 예를들어 현재 오전/오후에 나누어져 스케쥴러를 다르게 하지만, 특별한 공휴일, 평일, 주말마다 다르게 구현하기 위해서는 현재의 코드로는 표현하기 무리가 있어 보입니다. 그렇기에 전략을 선택하는 기능 을 분리하는게 좋아보입니다.\n여러 방식의 엘리베이터 스케줄링 방법 지원하기(Factory method pattern 적용) 팩토리 메소드 패턴을 이용하여 스케줄링 전략에 맞는 객체를 생성하는 코드를 별도로 정의하여봅시다. 그러면 다음과 같은 구조가 나오게 됩니다.\n기존의 클래스들에 SchedulerFactory가 추가된 것을 확인하실 수 있습니다. 해당 클래스에서는 전략들을 생성하는 알고리즘에 의해서 만들어진 Schedular를 반환하게끔 합니다. 즉, 스케줄러를 선택하는 행위는 SchedulerFactory가 하게 됩니다.\n이를 실제 코드로 살펴보도록 하겠습니다!\nenum Direction {UP, DOWN}\rclass ElevatorManager {\rprivate List\u0026lt;ElevatorController\u0026gt; controllers;\rprivate SchedulingStrategyID strategyID;\rpublic ElevatorManager(int controllerCount, SchedulingStrategyID strategyID){\rcontrollers = new ArrayList\u0026lt;ElevatorController\u0026gt;(controllerCount);\rfor(int i = 0; i \u0026lt; controllerCount; i++){\rElevatorController controller = new ElevatorController(i);\rcontrollers.add(controller);\r}\rthis.strategyID = strategyID;\r}\rpublic void setStrategyID(SchedulingStrategyID strategyID){\rthis.strategyID = strategyID;\r}\rpublic void requestElevator(int destination, Direction direction){\rElevatorScheduler scheduler = SchedulerFactory.getScheduler(strategyID);\rSystem.out.println(scheduler);\rint selectedElevator = scheduler.selectElevator(this, destination, direction);\rcontrollers.get(selectedElevator).gotoFloor(destination);\r}\r}\rclass ElevatorController {\rprivate int id;\rprivate int curFloor;\rpublic ElevatorController(int id) {\rthis.id = id;\rcurFloor = 1;\r}\rpublic void gotoFloor(int destination){\rSystem.out.println(\u0026quot;Elevator [\u0026quot; + id + \u0026quot;] Floor: \u0026quot; + curFloor);\rcurFloor = destination;\rSystem.out.println(\u0026quot; ==\u0026gt; \u0026quot; + curFloor);\r}\r}\renum SchedulingStrategyID {RESPONSE_TIME, THROUGHPUT, DYNAMIC}\rclass SchedulerFactory {\rpublic static ElevatorScheduler getScheduler(SchedulingStrategyID strategyID){\rElevatorScheduler scheduler = null;\rswitch (strategyID) {\rcase RESPONSE_TIME:\rscheduler = new ResponseTimeScheduler();\rbreak;\rcase THROUGHPUT:\rscheduler = new ThroughputScheduler();\rbreak;\rcase DYNAMIC: {\rint hour = Calendar.getInstance().get(Calendar.HOUR_OF_DAY);\rif(hour \u0026lt; 12) {\rscheduler = new ResponseTimeScheduler();\r}\relse{\rscheduler = new ThroughputScheduler();\r}\rbreak;\r}\r}\rreturn scheduler;\r}\r}\rinterface ElevatorScheduler {\rpublic int selectElevator(ElevatorManager manager, int destination, Direction direction);\r}\rclass ThroughputScheduler implements ElevatorScheduler{\r@Override\rpublic int selectElevator(ElevatorManager manager, int destination, Direction direction){\r// 실제 구현하지는 않음\rreturn 0;\r}\r}\rclass ResponseTimeScheduler implements ElevatorScheduler {\r@Override\rpublic int selectElevator(ElevatorManager manager, int destination, Direction direction) {\r// 실제 구현하지는 않음\rreturn 1;\r}\r}\rpublic class Client {\rpublic static void main(String[] args) {\rElevatorManager emWithResponseTimerScheduler = new ElevatorManager(2, SchedulingStrategyID.RESPONSE_TIME);\remWithResponseTimerScheduler.requestElevator(10, Direction.UP);\rElevatorManager emWithThroughputScheduler = new ElevatorManager(2, SchedulingStrategyID.RESPONSE_TIME);\remWithThroughputScheduler.requestElevator(10, Direction.UP);\rElevatorManager emWithDynamicScheduler = new ElevatorManager(2, SchedulingStrategyID.RESPONSE_TIME);\remWithDynamicScheduler.requestElevator(10, Direction.UP);\r}\r}\r SchedulerFactory Class를 보면 확실히 이전과 다르게 스케줄러를 선택하는 책임이 분리가 되는 것을 확인하실 수 있습니다.\n추가적으로 스케줄러는 지속적으로 사용되기 때문에 각각의 스케줄러를 싱글톤 패턴까지 적용하면 더 성능적으로 효율적인 구조가 될 수 있습니다. 그러나 오늘 이 시간에서는 팩토리 메소드 패턴을 설명하기 위한 시간이기 때문에, 생략하고 이 부분은 스스로 고민하시고 적용해보시면 좋을 것 같습니다:D\n더불어 팩토리 메소드 패턴은 상속을 이용하여 구현을 할 수도 있는데 간단하게만 설명하도록 하겠습니다.\n디자인 패턴을 구현하는데 절대적인 방법은 없습니다. 디자인 패턴은 다양한 방법으로 적용할 수 있기에 예제에 나온 방법만 생각하시지마시고 원론적인 부분을 이해하여 필요할 때 실제 프로젝트에 적용하며 학습하시면 좋을 것 같습니다.\n결과적으로 위의 과정을 통해서 Factory method pattern을 이용하면 객체의 생성 코드를 별도의 클래스/메소드로 분리함으로써 객체 생성의 변화를 대비하는데 굉장히 유용한 것을 알 수 있었습니다.\n참고\n JAVA 객체지향 디자인 패턴   ","id":17,"section":"posts","summary":"Factory method pattern(팩토리 메소드 패턴) 이번에 학습할 디자인 패턴은 \u0026ldquo;팩토리 메소드 패턴\u0026rdquo; 입니다. 팩토리 메소드 메서드 패턴이란","tags":null,"title":"[DesignPattern] Factory method pattern(팩토리 메소드 패턴)","uri":"https://chlalstjd430.github.io/2020/06/03_factory_method_pattern/","year":"2020"},{"content":"Template Method Pattern(템플릿 메소드 패턴) 이번에 학습할 디자인 패턴은 \u0026ldquo;템플릿 메소드 패턴\u0026rdquo; 입니다.\n템플릿 메서드 패턴이란?  알고리즘의 구조를 변경하지 않고 알고리즘의 특정 단계들을 다시 정의할 수 있게 해준다.\n 위의 내용은 위키에 나온 정의입니다. 해당 문장을 다시 표현하자면 \u0026ldquo;구현시 달라질 수 있는 메소드들을 구현클래스에서 선언 후 호출\u0026quot;하는 디자인 패턴입니다.\n백문이 불여일견, 같이 예제를 가지고 살펴보도록 합시다.\n엘레베이터 제어 시스템에서 모터를 구동시키는 기능(일반 ver) 엘레베이터 제어 시스템에서 도터를 구동시킬 떄 여러 회사의 모터를 지원하기 위해서는 어떻게 할까?\n먼저 다음과 같은 구조의 클래스가 있다고 생각해봅시다.\n HyundiaMotor Class : 모터를 제어하여 엘리베이터를 이동시키는 클래스가 Door Class : 문을 열거나 다는 기능을 제공하는 클래스  이를 코드로 표현하면 다음과 같습니다\nenum DoorStatus { CLOSED, OPENED }\renum MotorStatus { MOVING, STOPPED }\renum Direction { UP, DOWN }\rclass Door {\rprivate DoorStatus doorStatus;\rpublic Door() {\rthis.doorStatus = DoorStatus.CLOSED;\r}\rpublic DoorStatus getDoorStatus() {\rreturn doorStatus;\r}\rpublic void close() {\rdoorStatus = DoorStatus.CLOSED;\r}\rpublic void open() {\rdoorStatus = DoorStatus.OPENED;\r}\r}\rclass HyundaiMotor {\rprivate Door door;\rprivate MotorStatus motorStatus;\rpublic HyundaiMotor(Door door) {\rthis.door = door;\rthis.motorStatus = MotorStatus.STOPPED;\r}\rprivate void moveHyundaiMotor(Direction direction){\rSystem.out.println(\u0026quot;Hyundai Motor 구동\u0026quot;);\r}\rpublic MotorStatus getMotorStatus() {\rreturn motorStatus;\r}\rprivate void setMotorStatus(MotorStatus motorStatus){\rthis.motorStatus = motorStatus;\r}\rpublic void move(Direction direction){\rMotorStatus motorStatus = getMotorStatus();\rif(motorStatus == MotorStatus.MOVING)\rreturn;\rDoorStatus doorStatus = door.getDoorStatus();\rif(doorStatus == DoorStatus.OPENED)\rdoor.close();\rmoveHyundaiMotor(direction);\rsetMotorStatus(MotorStatus.MOVING);\r}\r}\r 위와 같은 코드를 가지고 실제 현대모터를 가지고 윗층으로 이동시키는 코드를 작성하면\npublic class Client {\rpublic static void main(String[] args) {\rDoor door = new Door();\rHyundaiMotor hyundaiMotor = new HyundaiMotor(door);\rhyundaiMotor.move(Direction.UP);\r}\r}\r 다음과 같이 구현할 수 있습니다.\n지금까지 현대 모터를 가지고 실행되는 엘리베이터를 만들었는데, 어떠한 상황이 생겨서 LG 모터를 사용해야 한다고 생각해봅시다. 어떻게 해야할까요?\n먼저 LG Moter라는 클래스를 다음과 같이 구현할 것입니다.\nclass LGMoter {\rprivate Door door;\rprivate MotorStatus motorStatus;\rpublic LGMoter(Door door) {\rthis.door = door;\rthis.motorStatus = MotorStatus.STOPPED;\r}\rprivate void moveLGMoter(Direction direction){\rSystem.out.println(\u0026quot;LG Motor 구동\u0026quot;);\r}\rpublic MotorStatus getMotorStatus() {\rreturn motorStatus;\r}\rprivate void setMotorStatus(MotorStatus motorStatus){\rthis.motorStatus = motorStatus;\r}\rpublic void move(Direction direction){\rMotorStatus motorStatus = getMotorStatus();\rif(motorStatus == MotorStatus.MOVING)\rreturn;\rDoorStatus doorStatus = door.getDoorStatus();\rif(doorStatus == DoorStatus.OPENED)\rdoor.close();\rmoveLGMoter(direction);\rsetMotorStatus(MotorStatus.MOVING);\r}\r}\r 이렇게 구현하면 LGMoter도 마찬가지로 사용가능하게 될겁니다. 그러나 코드를 보면 MoveLGMoter 메소드말고는 바뀐 부분이 없습니다. 이는 OCP 원칙에 위배됩니다. 그래서 다음과 같이 클래스 구조를 변경할 것입니다.\n이렇게 하면 OCP원칙을 지키며 모터를 상속만해주면 다양한 모터들을 구현할 수 있는 것으로 보입니다. 코드로 구현하면 다음과 같습니다.\nabstract class Motor {\rprotected Door door;\rprivate MotorStatus motorStatus;\rpublic Motor(Door door) {\rthis.door = door;\rmotorStatus = MotorStatus.STOPPED;\r}\rpublic MotorStatus getMotorStatus() {\rreturn motorStatus;\r}\rprotected void setMotorStatus(MotorStatus motorStatus) {\rthis.motorStatus = motorStatus;\r}\r}\rclass HyundaiMotor extends Motor {\rpublic HyundaiMotor(Door door) {\rsuper(door);\r}\rprivate void moveHyundaiMotor(Direction direction){\rSystem.out.println(\u0026quot;Hyundai Motor 구동\u0026quot;);\r}\rpublic void move(Direction direction){\rMotorStatus motorStatus = getMotorStatus();\rif(motorStatus == MotorStatus.MOVING)\rreturn;\rDoorStatus doorStatus = door.getDoorStatus();\rif(doorStatus == DoorStatus.OPENED)\rdoor.close();\rmoveHyundaiMotor(direction);\rsetMotorStatus(MotorStatus.MOVING);\r}\r}\rclass LGMoter extends Motor {\rpublic LGMoter(Door door) {\rsuper(door);\r}\rprivate void moveLGMoter(Direction direction){\rSystem.out.println(\u0026quot;LG Motor 구동\u0026quot;);\r}\rpublic void move(Direction direction){\rMotorStatus motorStatus = getMotorStatus();\rif(motorStatus == MotorStatus.MOVING)\rreturn;\rDoorStatus doorStatus = door.getDoorStatus();\rif(doorStatus == DoorStatus.OPENED)\rdoor.close();\rmoveLGMoter(direction);\rsetMotorStatus(MotorStatus.MOVING);\r}\r}\r 비교적 깔끔해진 코드를 볼 수있습니다. 그러나 자세히 move 메소드를 살펴보면 현대와 LG 모터 모두 똑같은 코드가 중복되는 부분이 보입니다. 지금 2개의 모터를 예제로 들었지만 이후 10개,100개의 모터와 호환이 되어야한다면 수 많은 코드가 중복되어 해당 로직이 변경된다고 하면 10번, 100번 넘게 코드를 수정해야하는 높은 유지보수 비용이 발생합니다. 그렇다면 어떻게 이를 대처할까요?\n엘레베이터 제어 시스템에서 모터를 구동시키는 기능(템플릿 메소드 패턴 적용 ver) 이러한 상황에서 템플릿 메소드 패턴을 활용하는 것을 살펴보도록 하겠습니다. 패턴을 적용하면 다음과 같은 구조가 나오게 됩니다.\n얼핏 보면 크게 달라진게 없어보이지만, Motor 추상 클래스에 move와 moveMotor 메소드가 추가된것을 확인하실 수 있습니다. 이를 코드를 통해 자세히 확인해봅시다.\nabstract class Motor {\rprivate Door door;\rprivate MotorStatus motorStatus;\rpublic Motor(Door door) {\rthis.door = door;\rmotorStatus = MotorStatus.STOPPED;\r}\rpublic MotorStatus getMotorStatus() {\rreturn motorStatus;\r}\rprivate void setMotorStatus(MotorStatus motorStatus) {\rthis.motorStatus = motorStatus;\r}\rpublic void move(Direction direction){\rMotorStatus motorStatus = getMotorStatus();\rif(motorStatus == MotorStatus.MOVING)\rreturn;\rDoorStatus doorStatus = door.getDoorStatus();\rif(doorStatus == DoorStatus.OPENED)\rdoor.close();\rmoveMotor(direction);\rsetMotorStatus(MotorStatus.MOVING);\r}\rprotected abstract void moveMotor(Direction direction);\r}\rclass HyundaiMotor extends Motor {\rpublic HyundaiMotor(Door door) {\rsuper(door);\r}\rpublic void moveMotor(Direction direction){\rSystem.out.println(\u0026quot;Hyundai Motor 구동\u0026quot;);\r}\r}\rclass LGMotor extends Motor {\rpublic LGMotor(Door door) {\rsuper(door);\r}\rpublic void moveMotor(Direction direction){\rSystem.out.println(\u0026quot;LG Motor 구동\u0026quot;);\r}\r}\r Motor 추상 클래스에 move메소드를 구현하고 moveMotor 추상 메소드를 활용하여 HyudaMotor와 LGMotor가 훨씬 간소해졌습니다. 뿐만 아니라 전체적인 코드량도 감소하였고, move의 로직이 변경될 떄 Motor의 move 메소드만 변경하면되서 유지보스 측면에서도 훨씬 좋아졌습니다.\n위와 같은 상황을 보았을 떄, 템플릿 메소드 패턴을 활용하면 전체적인 알고리즘을 구현하면서 상이한 부분은 하위 클래스에서 구현할 수 있도록 해 주는 디자인 패턴으로서 전체적인 알고리즘의 코드를 재사용하는데 유용하다는 것을 알 수 있었습니다.\n참고\n JAVA 객체지향 디자인 패턴   ","id":18,"section":"posts","summary":"Template Method Pattern(템플릿 메소드 패턴) 이번에 학습할 디자인 패턴은 \u0026ldquo;템플릿 메소드 패턴\u0026rdquo; 입니다. 템플릿 메서드 패턴이란? 알고","tags":null,"title":"[DesignPattern] Template Method Pattern(템플릿 메소드 패턴)","uri":"https://chlalstjd430.github.io/2020/05/02_templete_method_pattern/","year":"2020"},{"content":"코디미 상담 후기 - 백엔드 개발자를 꿈꾸는 초보 개발자에 대한 조언 최근 코덕이라는 이사이트를 애용하는데, 해당 사이트에서 코디미 라는 곳을 알게되었습니다. 코디미는 개발자 취업/커리어/이력서 등 다양한 고민을 상담해주는 곳인데, 평소 존경하던 우아한 형제 개발자 이동욱(a.k.a jojoldu)님이 1차적으로 무료로 상담을 해준다고해서 후다닥 신청했습니다.\n평소 백엔드 개발을 그 동안 진행해오면서 공부해야될 것이 너무 많고 알아야할 것도 많아서 너무 막막했는데, 그래서 고민이 술술(?) 나왔던 것 같습니다. 그렇게 은근한 기대를 하며 하루를 보내던 도중\n다음과 같은 메일을 받았고, 이후 동욱님에게 고민한 내용에 대한 답변도 받게되었습니다. 답변 내용은 굉장히 도움이 많이 되었고 저와 같은 초보 개발자분들에게 도움이 될만한 내용들이 충분히 담아져있었습니다. 이에 질문 했던 내용과 답변들을 공유하여 저와 같은 초보 개발자분들에게 도움을 드리고자 글을 작성합니다.\n질문 내용 사실 질문 내용이 엄청 구체적이지는 않은 것 같은데, 그래도 동욱님이 제 질문의 의도를 잘 이해주셔서 다행입니다..ㅎ. 무튼 제가 동욱님에게 질문을 간략하게 정리하면 다음과 같습니다.(정말 간략하게 정리했어요..대충한거 아님..ㅎ)\n  대기업SI 보다는 기술 기반의 서비스 기업에 취업하고 싶습니다. 해당하는 기업에 백엔드 개발자로 취업하기 위해서는 어떠한 준비를 하는게 좋을까요?\n  공부를 하다보면 학생으로서 접하기 힘든 다양한 현업 기술들을 듣게 됩니다. 이러한 부분을 반드시 학습해야하는지? 혹은 현재 공부하던 내용들에 대한 깊은 이해를 점검하는게 좋을지?\n  private repository들에 대한 어필을 할 수 있는 방법이 무엇이 있을까요?\n  기업에서 요구하는 신입 백엔드 개발자 능력은 어느 정도인가요?\n  위의 내용과 같이 크게 4가지로 나누어 질문을 드렸습니다.\n질문 답변 동욱님께서는 1,2,4번의 질문들을 묶어서 답변해주셨고, 이후 3번 질문에 대한 답변도 말씀해주셨습니다. 내용은 길지만 핵심만 간략하게 설명드리도록 하겠습니다.\n질문 1,2,4\n  요즘 모든 기업들은 코딩 테스트 를 진행한다. 지금부터 꾸준하게 코딩 테스트 를 준비하는 것을 추천한다.\n  본인만의 학습 방법을 찾아야한다.\n  스프링으로 백엔드 개발 공부를 한다고, 회사에 가서 스프링으로 백엔드를 할 거라는 보장은 없다. 회사에서 \u0026ldquo;전 스프링만 해서 프론트는 하고 싶지 않아요.\u0026quot;, \u0026ldquo;전 스프링만 해서 장고는 몰라요.\u0026quot; 라는 답변을 하면 그것이 과연 신입으로서 좋은 자세일까?\n  즉, 새로운 무언가를 배울 때, 빠르게 학습할 수 있는 본인만의 학습 방법 을 찾는게 중요하다.\n    1~2개의 기술만 하더라도 이에 대해 깊게 파고자 하는 습관을 들이는게 중요\n 많은 기술을 간단하게 사용하는 것은 전혀 도움이 되지 않는다. 그것보다는 프로젝트를 진행하면서 많은 문제 들을 직면하고 단순히 해결하는 것만이 아니라 \u0026ldquo;왜 발생했는지?\u0026rdquo;, \u0026ldquo;왜 해결됐는지?\u0026rdquo;, \u0026ldquo;이 기술이 어떠한 구조인지?\u0026quot; 등을 상세하게 파악하는게 중요하다.    먼저 배운것과 역량은 다르다\n 현업의 기술들을 학생으로서 익힌다하여도 책에 있는 예제, 간단한 듀토리얼 정도를 구현하는 것에 대해 전부일텐데, 누구나 시작하면 도달 할 수 있는 정도의 레벨만 가진 분을 연봉 4천,5천을 주며 뽑아야할 이유가 있는지?    신입 개발자가 당장 실무에서 쓰는 기술을 알아야 채용이 되는 것은 아니라는 예\n  \r신입기준으로는 당장 쓸 구체적인 응용기술을 아는 것도 당연히 선택을 받는데 도움이 됩니다.\r실무자들이 면접을 볼때 같이 나눌수 있는 이야기가 많아지기 때문입니다.\r특히 신입이라도 당장 와서 일할수 있는 사람을 찾는 조직에서는 실무기술을 가급적 많이 아는 사람을 선호할듯합니다.\r그런데 실무 기술을 써본 경험이 있어도 그 기술에 대해 자세히 설명할수 없다면 오히려 경험 안했다고 이야기하는 것보다 더 부정적인 영향을 미칠수 있습니다.\r예를 들면 Java로 DB를 쓰는 개발을 해봤다고했는데 그게 MyBatis를 썼는지 JPA를 썼는지도 모르는 경우입니다.\r반면 잠깐 써보고 아직 깊이 모르는 기술이라도 구체적인 이야기를 체계적으로 할 수 있다면 더 긍적적인 요인이 됩니다.\r예를 들어 MyBatis를 처음 썼는데 어떤 상황이 어려웠고, 알고보니 MyBatis의 어떤 특성 때문이였고, 이를 어떻게 해결했는지 등에 대한 구체적인 이야기를 하는 사람이면, '이 사람은 쓰는 기술에 대해서 제대로 파악을 하려고 했구나'를 느낄수 있습니다.\r그런 사람이면 MyBatis를 당장 안 쓰고 JPA를 쓰는 프로젝트에라도 바로 적응할수 있겠구나 하는 느낌을 줍니다.\r신입 개발자를 채용할때는 현재 할 수 있는 일이 얼마나 되는지를 넘어서 앞으로 얼마나 발전가능성이 있는지에 더 중점을 둬야된다고 생각합니다.\r면접관 입장에서는 자신이 잘 아는 기술을 단편적으로 물어보는것에 그치지 않고 사람이 가진 학습 능력, 학습 의지 등을 파악해야하는데, 당연히 쉬운 일은 아닙니다.\r지원자 입장에서는 성장가능성을 표현할수 있는 방법은 여러가지일 것 같습니다.\r위와 같이 실무에서 쓰는 이미 잘 알고 있고, 그걸 학습해온 과정을 잘 설명하는 것도 하나의 방법입니다.\r학교에서 한 팀 프로젝트라도 남 다르게 한 면이 있다면 실무기술을 잘 몰라도 충분히 앞으로 성장 가능성을 보여줄수 있다고 생각합니다.\r코딩 테스트에서 문제를 센스있게 파악한다던지, 유창하고 거침없이 코딩을 할 수 있는것도 자신을 잘 드러낼수 있는 방법입니다.\r글을 쓰다보니 '신입개발자로 지원할 때는 자신이 앞으로 빠른 속도로 발전할수 있다는 가능성을 보여주는 것이 중요한데 실무에서 쓰는 기술을 일부 아는 것은 그 방법 중의 하나이다. 그러나 유일한 방법은 아니다.' 정도로 제 생각은 정리가되네요.\r글을 쓰다보니 몇년전의 어느 인턴 지원자의 면접이 기억납니다.\rLinux 커널에 관심이 많은 학생이였는데, 사실 제가 인턴의 업무로 염두에 두었던 분야는 그쪽은 아니였습니다.\r코딩 테스트도 제가 계획한 둔 인턴 과제에서는 쓰지 않을 C++로 하기도했습니다.\r당시에 엄격한 기준으로 채점을 하는 시스템을 이용해서 코딩 테스트를 했는데, 그 시스템의 판정으로는 그 학생은 문제를 통과하지 못했습니다.\r그렇지만 거의 답에 근접한 방식으로 코딩을 했고, 무엇보다 유창하고 거침없이 코딩을 하는 모습이 인상적이였습니다.\r하나의 방법이 잘 안되자 그 다음 생각나는 아이디어를 바로 빠르게 타이핑해나갔습니다.\r저는 그 학생을 합격시키고, 연관된 업무가 있을만한 다른 프로젝트 쪽에 추천을 드렸습니다.\r인턴을 거쳐서 그 학생은 최종 입사를 했습니다.\r그런데 처음 그 신입사원이 했던 분야는 그 학생이 깊게 팠던 Linux 커널등과 관련된 분야는 아니였습니다.\rJava 웹개발과 JavaScript와 Angular.js로 FE개발까지 했던것으로 알고 있습니다.\r그때의 인턴은 몇년이 지나서 Linux 커널에 코드 기여를하고 Deview 2018에 [대형 컨테이너 클러스터에서의 고가용성](https://deview.kr/2018/schedule/268) 라는 발표를 하기도했습니다.\r그 발표를 두고 어떤 분들은 DEVIEW 2018의 최고의 발표라고도 말씀을 하셨듯습니다.\r  백엔드 개발자가 참고할만한 좋은 글 추천  질문 3\n 남들에게 공개하지 못하는 코드는 어필할 방법은 없다. 어느 면접관이든 코드에 더 관심을 갖기 때문이다. 그렇기에 이전 프로젝트보다 훨씬 좋은 퀄리티로 본인만의 사이드 프로젝트를 public하게 진행하는 것이 좋을 것 같다.  그 외\n  문제를 해결해 나가는 과정을 블로그 에 정리하여라.\n  최근 회사의 추세는 인턴을 뽑아 괜찮은 분들을 정규직 전환을 시키는 형태로 가고 있다. 막학기에 준비하는 것보다 지금부터(현재 3학년) 내년 인턴 합격을 준비하는 것이 좋을 것이다.\n  위에 간략하게 답변을 정리해보았는데, 사실 제가 간략하게 정리해서 그렇지 더 좋은 말씀들이 많았습니다. 그러면 이렇게 좋은 이야기를 저는 어떻게 행동으로 옮길 수 있을까요? 이에 대하여 많은 고민을 하게 됩니다. 그리고 다음과 같은 계획을 세우게 됩니다.\n앞으로 나는  WHY 에 집중하는 개발자가 될 것입니다.   사실 이는 어찌보면 당연한 부분이다. 내가 jvm에서 동작하는 언어를 선택하였다면, 왜? 선택하였는지 이유를 말할 수 있어야한다. 만약 실제 기업 면접에서 \u0026ldquo;OOO을 사용하셨는데, 왜 사용하셨는지 말씀해주실 수 있나요?\u0026quot; 라고 물어보았을 떄, 단순하게 \u0026ldquo;그냥..많이 하길래\u0026rdquo; 라는 두루뭉실한 말은 이유가 될 수 없습니다. 앞으로 개발하는데 있어서 무언가를 선택 하고 사용할 때 왜 내가 선택하고, 사용했는지 당당히 말할 수 있도록 해야겠습니다.  -\n꾸준한 알고리즘 공부를 진행할 것입니다.    사실 이 부분은 대다수가 인지하고 있을거라 생각합니다. IT기업 대부분이 코딩 테스트를 지향하고 있고, 실제로 인적성으로만 걸렀던 몇몇 대기업들도 코딩 테스트로 전환되고 있는 추세다.\n  이를 위해서 나는 6월 중순(현재 학교 재학 + 프로젝트를 동시에 3개 진행중이라 시간적인 여유가 없다..)부터 구체적으로 알고리즘 공부 계획을 세워 꾸준하게 역량을 키우도록 할 것입니다.\n  블로그 활동 을 꾸준하게 할 것입니다.   블로그는 남에게 나를 어필할 수 있는 좋은 수단인 것 같습니다. 앞으로 내가 문제를 직면했을 때, 어떻게 해결해나가는 과정을 추후 면접자분들에게도 어필 할 수 있도록 블로그 글을 작성할 것입니다. (목표는 이동욱님 블로그..ㅋ)  넓은 범위의 역량 을 습득할 것입니다.   여기서 넓은 범위란 무작정 많은 기술을 공부하고 습득할 것이라는 말이 아닙니다! 제가 말한 넓은 범위란 너무 백엔드 개발에 국한된 공부가 아닌 인접한 공부(프론트, 디비 등)를 말씀드린 것입니다!  제가 성장함에 필요한 조건(?)들을 나열해보았습니다. 앞으로 개발 공부를 진행하는 동안 다음과 같은 조건을 필히 지켜가며 공부하다보면 현업에서도 인정받고 저 또한 누군가에게 귀감이 되는 사람이 될거라 생각합니다.\n그럼 이 글을 읽으시는 모든 개발자분들 모두 꾸준한 성장을 이루어 원하는 결과를 얻길 바라며 글을 마치겠습니다! 모두 화이팅입니다 :D\n","id":19,"section":"posts","summary":"코디미 상담 후기 - 백엔드 개발자를 꿈꾸는 초보 개발자에 대한 조언 최근 코덕이라는 이사이트를 애용하는데, 해당 사이트에서 코디미 라는 곳을 알게되었습니다. 코디","tags":null,"title":"코디미상담 후기 - 백엔드 개발자를 꿈꾸는 초보 개발자에 대한 조언","uri":"https://chlalstjd430.github.io/2020/05/%EC%A0%95%EB%B3%B4_002/","year":"2020"},{"content":"AWS EC2를 이용하여 Spring Boot 배포하기(3) 안녕하세요! 오늘은 지난 포스팅에 이어서 서버에서 Spring Boot를 배포하는 과정을 안내해드리도록 하겠습니다. 우리는 github 레포지토리가 존재한다는 가정하에 진행하겠습니다.\n1. 호스트 네임 변경하기 EC2 서버에 접속하면, \u0026ldquo;ubuntu@ip - ip주소\u0026quot;가 등장하는데 ip주소만 봤을 때, 어떠한 서비스인지 알 수 없으니 호스트 네임을 변경해주도록 합시다.\n먼저,\n sudo vim /etc/cloud/cloud.cfg\n 라는 명령어를 이용하여 cloud.cfg를 열어줍니다. 이후 방향키를 내려가며 \u0026ldquo;preserve_hostname: false\u0026quot;을 true로 변경해줍니다.\n 참고 : vi 에디터 사용법  이후\n sudo hostnamectl set-hostname \u0026ldquo;호스트이름\u0026rdquo;\n 명령어를 이용해 호스트이름을 설정해주고 \u0026ldquo;reboot\u0026rdquo; 명령어를 이용해 서버를 재시작해주시면 다음과 같이 정상적으로 호스트이름이 설정된 것을 확인하실 수 있습니다.\n2. Java 8 설치 먼저 서버에 Java 8을 설치해주어야한다(나는 배포 할 프로젝트가 8버전이다)\n Ubuntu에서 Java 8 설치 글을 참고해주세요!   3. MySQL 설치 이후 MySQL도 설치해 봅시다.\n Ubuntu에서 MySQL 설치 글을 참고해주세요!  3. git clone 하기 EC2에는 기본적으로 git이 설치가 되어있습니다, 그렇기에 바로 git clone을 시도해줍니다.\n git clone 본인 repository\n 🙋‍♂️주의 : Permission denied(publickey)가 나오게 되면 해당 블로그 글을 참고해 키를 등록해주세요\n이렇게 하게 되면 root안에 방금 clone한 폴더가 등장합니다.\n이후\n dir\n 명령어를 사용해 clone한 폴더가 생겼는지 확인하고,\n cd 폴더명 // 현재 위치를 [폴더명]으로 이동 sudo chmod 777 ./gradlew // ./gradlew에게 권한을 부여 sudo ./gradlew build // gradle build  명령어를 순차적으로 실행하고, jar파일의 이름을 찾아\n $ java –jar [이름].jar \u0026amp;\n 명령어를 실행하면 서버에 배포가 됩니다.\n지금까지 AWS EC2에 Spring Boot 배포하는 것을 소개해드렸는데, 사실 제 블로그 글에 부족한게 많습니다. 사실 추후에 RDS를 사용하여 배포하는 것을 보여드리기 위해 지금은 중간중간 생략한 과정도 많아 그냥 참고용으로만 봐주시면 감사하겠습니다. 추가적으로 궁금하신 사항들은 저에게 물어보셔도되고 훌륭한 다른 포스팅들을 검색하셔도 됩니다.\n추후 RDS를 이용하는 법에 대해서도 간단히 소개해드릴 예정이니 그때 뵙겠습니다. 그럼 20000!!\n참고 문헌\n 스프링 부트와 AWS로 혼자 구현하는 웹 서비스  ","id":20,"section":"posts","summary":"AWS EC2를 이용하여 Spring Boot 배포하기(3) 안녕하세요! 오늘은 지난 포스팅에 이어서 서버에서 Spring Boot를 배포하는 과정을 안내해드리도록 하겠습니다. 우리는 github","tags":null,"title":"AWS EC2를 이용하여 Spring Boot 배포하기(3)","uri":"https://chlalstjd430.github.io/2020/05/aws_ec2_03/","year":"2020"},{"content":"AWS EC2를 이용하여 Spring Boot 배포하기(2) - AWS EC2 서버 접속 오늘은 AWS EC2 서버에 접속하는 과정을 소개해드리도록 하겠습니다. 먼저 시작하기 전에 해당 글은 윈도우 를 이용하여 접속하는 방법을 안내해드리는 점 참고해주세요!\n1. putty 다운로드 및 키 발급 윈도우에서는 Mac과 같이 ssh 접속하기에 불편한 점이 많아 별도의 클라이언트를 설치해줍니다.\n1. putty 사이트에서 다운로드 후 putty.exe,puttygen.exe 모두 다운로드하였으면, puttygen.exe 부터 실행시켜줍니다. 이후 Load를 클릭합니다. 2. 이전 AWS 발급한 Pem 키가 저장되어있는 곳을 찾아 클릭해줍시다. 그러면 다음과 같이 키가 발급되었다는 팝업창이 나옵니다.\n3. 이후 Save private Key 를 클릭해 안전한 장소에 발급된 키를 저장해줍니다. 2. putty를 이용하여 AWS EC2 서버 접속 1. 먼저 AWS에서 인스턴스와 연결한 탄력적 ip를 알아옵니다. 그리고 다음 사진과 같이 Host Name을 설정해줍니다.(자신의 탄력적 ip를 적으시면 됩니다) 주의 : 이전에 AWS 보안그룹에 22포트는 내 IP에서만 접근이 가능하도록 설정하였습니다. 설정한 IP의 장소가 맞는지 확인해주세요!\n2. 이후 왼쪽 카테고리의 Connection - SSH - Auth로 이동하여 이전에 발급한 ppk를 Browse..를 클릭하여 불러옵니다. 주의 : pem키를 찾을 때 모든 파일에서 찾기를 하셔야 pem키가 보입니다.\n3. ppk를 잘 불러왔으면, 다시 왼쪽 카테고리에서 제일 위에 있는 Session 으로 이동합니다. 이후 Saved Sessions 에 본인의 서비스명을 입력하고 Save 해줍시다. 이후 저장한 세션을 선택 후 Open 해줍시다! 3. AWS EC2 접속 open 해주면 보안 알림창이 처음에 나오는데 그냥 \u0026lsquo;예\u0026rsquo;를 눌러주시면 됩니다. 그러면 이후 다음과 같은화면이 나오며 접속이 완료됩니다!\n그럼 다음 포스팅에서 본격적으로 AWS EC2 서버에 Spring Boot를 배포하는 작업을 보여드리겠습니다. 다음 포스팅에서 봐용~!👐\n참고 문헌\n 스프링 부트와 AWS로 혼자 구현하는 웹 서비스  ","id":21,"section":"posts","summary":"AWS EC2를 이용하여 Spring Boot 배포하기(2) - AWS EC2 서버 접속 오늘은 AWS EC2 서버에 접속하는 과정을 소개해드리도록 하겠습니다. 먼저 시작하기 전에 해당 글은 윈도우 를 이","tags":null,"title":"AWS EC2를 이용하여 Spring Boot 배포하기(2)","uri":"https://chlalstjd430.github.io/2020/05/aws_ec2_02/","year":"2020"},{"content":"AWS EC2를 이용하여 Spring Boot 배포하기(1) 저는 지금까지 AWS EC2를 이용하여 여러번 서버를 배포해보았었는데요. 이번에 그 과정들을 간단하게 블로그에 담고자 글을 작성합니다.\n먼저 시작하기 전에 제가 배포하려는 서비스는 다음과 같습니다.\n 실제 운영할 서비스는 아니고 간단한 토이 프로젝트의 느낌이다. 나는 빠르게 프로젝트를 배포하여야한다. 나는 현재 돈이 없다..(ㅜㅜ)  이러한 조건의 서비스를 배포하기 위해서 PAAS의 Heroku도 생각했지만, 예전에 Heroku를 사용했을 떄, 서버 region이 외국에 있고 Cold Start 문제가 있어 서비스를 운영하는데 어려움을 많이 느꼇습니다. 그렇기에 AWS에서 제공해주는 프리 티어를 이용하여 간단하게 EC2 서버에 서비스를 배포할 계획을 하였습니다. 그러면 시작해보도록 하겠습니다!\n 본 글은 AWS에 회원가입 모두 완료되었다는 가정하에 진행됩니다.\n EC2 인스턴스 생성하기  1. 인스턴스 시작 먼저 인스턴스를 만들어주기 위해 EC2 대시보드로 이동합시다!\n이동하게 되면 위와 같은 화면을 마주하게 되는데요~, 여기서 화면 중앙의 인스턴스 시작 버튼을 눌러줍시다.\n2. 단계 1: Amazon Machine Image(AMI) 선택 AWS EC2에서는 Amazaon Linux, Ubunto, SUSE 등 다양한 OS를 제공하고 있습니다. 저는 이중에서 \u0026ldquo;Ubuntu Server 18.04 LTS (HVM), SSD Volume Type\u0026rdquo; 를 선택하겠습니다.\n🤷‍♂️ Why?\n  OS는 Window와 Linux가 대표적인데, 보안적인 부분이나 비용적인 부분에서 Window보다 좋기 때문에 대체적으로 서버는 Linux를 이용합니다.\n  그렇다면 Linux 기반의 OS에도 여러가지가 있는데, 왜 Ubunto인가?\n 저는 EC2는 프리티어로만 사용할 예정이고 실제 Linux에 대해 전반적으로 지식이 많은게 아닌 초보자이기 때문에, 쉽게 접할 수 있는 Ubuntu를 선택하였습니다.    Ubuntu는 2년바다 크게 업데이트가 진행된다, 그래서 최근 20.4버전이 나와있다. 그러나 최신 버전이라고 무조건 좋다는 법은 없다. 출시된지 아직 한달도 안되었기 떄문에 그 동안 검증된 18.04 버전을 선택하겠다.\n  사실 내가 사용하려는 수준에서는 이 모든게 크게 상관없을 듯 하다(?)\n  어찌됐든 AMI른 선택해주었다면 다음 단계로 넘어가보자.\n3. 단계 2: 인스턴스 유형 선택 여기서는 t2.micro를 선택하시면 됩니다~\n🤷‍♂️ Why?\n  앞서 말했다시피 현재 배포할 서비스는 지속적으로 관리할 서비스가 아닙니다. 잘된다면 서비스를 계속 운영할 수 있겠지만 현재 상황에서는 그러한 계획이 없기 떄문에, 무료로 제공되는 \u0026ldquo;프리티어\u0026quot;를 이용할 것입니다. 그렇기에 선택의 여지가 없습니다..\n(돈 없는 학식은 웁니다 ㅜㅜ)\n   참고  해당 유형에 대해 간략하게 설명드리면 \u0026ldquo;T시리즈\u0026quot;라고 불리는 유형이다. 이 서비스는 크레딧 이라는 일종의 CPU를 사용할 수 있는 포인트 개념이 있습니다. 관련된 내용은 해당 블로그를 참고하시면 좋을 것 같습니다. T2 instance 특징은 무엇인가요?    4. 단계 3: 인스턴스 세부 정보 구성 해당 사항은 추가적으로 건드리지 않고 그대로 진행하겠습니다!\n🤷‍♂️ Why?\n  현재 한대의 서버를 가지고 간단한 프로젝트를 배포하기 위해서이니, 별다른 설정을 하지않겠습니다.\n  추가적으로 해당 관련 정보를 수정하기 위해서는 추가적인 공부가 필요할 것 같아 당장 EC2를 이용하기 위해서는 그대로 넘어가도록하겠습니다.\n  5. 단계 4: 스토리지 추가 해당 스토리지의 크기를 30으로 설정해줍시다!\n🤷‍♂️ Why?\n 프리 티어에서는 최대 30GB의 스토리지를 사용할 수 있기 떄문에 우리는 최~대한 이를 활용하기 위해서 최대한으로 설정해줍시다!  6. 단계 5: 태그 추가 태그는 웹 콘솔에서 표기될 태그인 Name 태그를 등록합니다.\n(태그 추가 클릭 - 키에 Name입력 - 값에 본인의 서비스를 나타낼 수 있는 값을 입력)\n🤷‍♂️ Why?\n 여러 인스턴스가 있을 경우 이를 태그별로 구분하기 위해 본인의 서비스를 나타낼 수 있는 값으로 등록을합니다.  7. 단계 6: 보안 그룹 구성 보안 그룹은 사진과 같이 규칙을 추가하겠습니다.\n🤷‍♂️ Why?\n  22포트\n  22포트의 경우는 AWS EC2에 터미널로 접속할 떄를 이야기합니다. 해당 포트는 내 IP에서만 접속하게끔 설정을 하였는데요, 이유는 pem키가 없으면 접속이 불가능하나 pem키가 노출되었을 때 서버에서 비트 코인 채굴 서버로 이용될 수 있기 떄문입니다! 그러므로 내 IP로설정하고 장소가 이동될 떄 마다 내 IP를 다시 받아 이용하시는게 보안적으로 좋습니다 :D\n  말도 안 되는 과금의 추억. 요금 폭탄\n    80,443 포트\n http,https 통신을 위해 기본적으로 추가해줍니다~.    8. 단계 7: 인스턴스 시작 검토   해당 단계에서는 그동안 저희가 설정했던 부분들이 일괄적으로 나오게 됩니다. 이상없는지 확인해주고 시작하기 버튼을 클릭합시다!\n  이후 새 키 페어 생성 을 설정하고(기존 키 페어가 없다는 가정하에 진행하겠습니다.) 키 페어 이름을 서비스와 연관지어 짓고, 키 페어 다운로드를 클릭합니다. 이후 키 페어를 안전한 위치에 저장해줍니다.\n  위 과정이 완료되었으면 인스턴스 시작을 클릭합니다!\n  다음과 같은 화면이 나오면 다시 EC2 대시보드로 이동해봅시다.\n9. 인스턴스 생성 확인 짜잔-! 인스턴스 상태가 초록불과 함께 running이라 나와있으면 해당 인스턴스가 잘 실행되고 있음을 뜻합니다.(인스턴스가 생성되고 실행되는 과정까지 시간이 소요될 수 있습니다.)\n잠깐! 저희가 EC2 서버를 실제 접속하기 전에 해야할 일이 있습니다!\n10. 탄력적 IP 할당 인스턴스는 하나의 서버이기 떄문에 IP가 존재합니다. 인스턴스 생성시 항상 새 IP를 할당받고, 같은 인스턴스를 중지하고 다시 시작할 떄도 새 IP가 할당됩니다. 그렇게 되면 매번 접속해야 하는 IP가 변경되어 PC에서 매번 접속시 IP 주소를 확인해야하는 번거로움이 있습니다. 그렇기에 고정 IP를 가지게 해야하는데요, 우리는 이를 위해서 탄력적 IP를 할당합시다.\n1. 먼저 탄력적 IP 메뉴를 클릭합니다. 2. 탄력적 IP 주소 할당 을 클릭합니다. 3. 다음 화면에서 할당을 클릭합니다. 4. 탄력적 IP를 할당받으신걸 확인하실 수 있습니다. 그러면 이전에 저희가 만든 인스턴스와 탄력적 IP를 연결해보도록 하겠습니다! 먼저 퍼블릭 IPv4 주소 밑의 IP를 클릭합시다. 5. 이후 그대로 탄력적 IP 주소 연결 을 클릭합니다. 6. 이후 이전에 만든 인스턴스와 프라이빗 IP 주소를 설정합니다. 처음 AWS EC2 이용하시는 분은 그냥 그대로 설정하시고 연결하시면 됩니다. 7. 아래와 같이 나오게되면, 탄력적 IP가 해당 인스턴스와 연결되었음을 알 수 있습니다. 실제로 EC2 인스턴스를 확인하면 탄력적 IP가 연결된것도 확인하실 수 있습니다!\n지금까지 EC2 인스턴스 생성과 탄력적 IP 주소 연결까지의 과정을 소개해드렸습니다. 다음 포스팅에는 본격적으로 AWS EC2에 접속하는 방법과 서버에 Spring Boot를 배포하는 과정을 소개해드릴게요. 그럼 다음 포스팅떄 뵙겠습니다 :D\n참고 문헌\n 스프링 부트와 AWS로 혼자 구현하는 웹 서비스  ","id":22,"section":"posts","summary":"AWS EC2를 이용하여 Spring Boot 배포하기(1) 저는 지금까지 AWS EC2를 이용하여 여러번 서버를 배포해보았었는데요. 이번에 그 과정들을 간단하게 블로그에 담고자 글을","tags":null,"title":"AWS EC2를 이용하여 Spring Boot 배포하기(1)","uri":"https://chlalstjd430.github.io/2020/05/aws_ec2_01/","year":"2020"},{"content":"DecoratorPattern(데코레이터 패턴) 데코레인터 패턴이란?  객체의 결합 을 통해 기능을 동적으로 유연하게 확장 할 수 있게 해주는 패턴\n 위의 한 문장으로 정확히 무엇인지 정확히 이해하기 힘듭니다, 아래의 내용을 통해 데코레이터 패턴을 살펴봅시다!\n도로 표시 방법 조합하기(데코레이터 패턴을 모를 떄 ver) 도로가 있을 떄 차선을 표시해야할 떄 우리는 어떻게 클래스를 만들까?\n도로가 있을 떄 차선을 표시하기 위해 기본적으로 2가지 클래스를 만들어보았습니다!\n RodaDisplay Class : 기본 도로 표시 기능을 제공하는 클래스 RoadDIsplayWithLane Class : 기본 도로 표시에 추가적으로 차선을 표시하는 클래스  이 둘을 코드로 표현하면 다음과 같습니다~\npublic class Client {\rpublic static void main(String[] args) {\rSystem.out.println(\u0026quot;첫번째 draw\u0026quot;);\rRoadDisplay roadDisplay = new RoadDisplay();\rroadDisplay.draw();\rSystem.out.println(\u0026quot;\\n두번째 draw\u0026quot;);\rRoadDisplay roadDisplayWithLane = new RoadDisplayWithLane();\rroadDisplayWithLane.draw();\r}\r}\rclass RoadDisplay{\rpublic void draw(){\rSystem.out.println(\u0026quot;도로 기본 표시\u0026quot;);\r}\r}\rclass RoadDisplayWithLane extends RoadDisplay{\rpublic void draw(){\rsuper.draw();\rdrawLane();\r}\rprivate void drawLane(){\rSystem.out.println(\u0026quot;차선 표시\u0026quot;);\r}\r}\r 위의 코드 중 main을 보면 \u0026ldquo;draw()\u0026ldquo;라는 메소드를 사용하여 기능을 통일 시켜주었습니다. 그래서 결과를 보면\n첫번째 draw\r도로 기본 표시\r두번째 draw\r도로 기본 표시\r차선 표시\r 다음과 같이 출력이 됩니다. 동일한 \u0026ldquo;draw()\u0026ldquo;메소드를 수행했지만 다른 출력값이 나오는 것을 확인할 수 있습니다.\n기능만 봐서는 잘 작동하는 것 같은데,,과연 해당 코드에 문제점이 없을까요?🤔\n문제점이 있는지 확인하기 위해 다음과 같은 사항을 체크해봅시다!\n  또 다른 추가적인 도로 표시 기능을 구현하고 싶다면 어떻게 해야 하는가?(도로 표시에 교통량도 표시하고싶다면..!?)🚖🚖🚖\n  뿐만아니라 여러가지 추가 기능의 조합하여 제공하고 싶다면 어떻게 해야 할까요? 예를 들어 기본 도로 표시에 차선 표시 기능과 교통량 표시 기능을 함께 제공하고 싶다면요! 🏞 + 🚖🚖🚖\n  위의 사항들을 다음과 같이 시도해봅시다!\n추가적으로 RoadDisplay를 상속받는 RoadDisplayWithTraffic 클래스를 구현하는거죠!! 즉, 코드를 보면 다음과 같습니다!\npublic class Client {\rpublic static void main(String[] args) {\rSystem.out.println(\u0026quot;첫번째 draw\u0026quot;);\rRoadDisplay roadDisplay = new RoadDisplay();\rroadDisplay.draw();\rSystem.out.println(\u0026quot;\\n두번째 draw\u0026quot;);\rRoadDisplay roadDisplayWithLane = new RoadDisplayWithLane();\rroadDisplayWithLane.draw();\rSystem.out.println(\u0026quot;\\n세번째 draw\u0026quot;);\rRoadDisplay roadDisplayWithTraffic = new RoadDisplayWithTraffic();\rroadDisplayWithTraffic.draw();\r}\r}\rclass RoadDisplay{\rpublic void draw(){\rSystem.out.println(\u0026quot;도로 기본 표시\u0026quot;);\r}\r}\rclass RoadDisplayWithLane extends RoadDisplay{\rpublic void draw(){\rsuper.draw();\rdrawLane();\r}\rprivate void drawLane(){\rSystem.out.println(\u0026quot;차선 표시\u0026quot;);\r}\r}\rclass RoadDisplayWithTraffic extends RoadDisplay{\rpublic void draw(){\rsuper.draw();\rdrawTraffic();\r}\rprivate void drawTraffic(){\rSystem.out.println(\u0026quot;교통량 표시\u0026quot;);\r}\r}\r 이 코드의 실행 결과도\n첫번째 draw\r도로 기본 표시\r두번째 draw\r도로 기본 표시\r차선 표시\r세번째 draw\r도로 기본 표시\r교통량 표시\r 로 잘 수행이됩니다. 그렇다면 이와 같은 방식으로 기능들을 조합하여 사용하자는 두번째 사항 에 부합되도록 하려면 어떻게할까요?\n위와 같은 표처럼 많은 기능을 구현하기 위해 우리는 다음과 같이 코드를 작성해야할지 모릅니다..\nclass RoadDisplay{\rpublic void draw(){\rSystem.out.println(\u0026quot;도로 기본 표시\u0026quot;);\r}\r}\rclass RoadDisplayWithLane extends RoadDisplay{\rpublic void draw(){\rsuper.draw();\rdrawLane();\r}\rprivate void drawLane(){\rSystem.out.println(\u0026quot;차선 표시\u0026quot;);\r}\r}\rclass RoadDisplayWithTraffic extends RoadDisplay{\rpublic void draw(){\rsuper.draw();\rdrawTraffic();\r}\rprivate void drawTraffic(){\rSystem.out.println(\u0026quot;교통량 표시\u0026quot;);\r}\r}\rclass RoadDisplayWithCrossing extends RoadDisplay{\rpublic void draw(){\rsuper.draw();\rdrawCrossing();\r}\rprivate void drawCrossing(){\rSystem.out.println(\u0026quot;교차료 표시\u0026quot;);\r}\r}\rclass RoadDisplayWithLaneTraffic extends RoadDisplay{\rpublic void draw(){\rsuper.draw();\rdrawLane();\rdrawTraffic();\r}\rprivate void drawLane(){\rSystem.out.println(\u0026quot;차선 표시\u0026quot;);\r}\rprivate void drawTraffic(){\rSystem.out.println(\u0026quot;교통량 표시\u0026quot;);\r}\r}\rclass RoadDisplayWithLaneCrossing extends RoadDisplay{\rpublic void draw(){\rsuper.draw();\rdrawLane();\rdrawCrossing();\r}\rprivate void drawLane(){\rSystem.out.println(\u0026quot;차선 표시\u0026quot;);\r}\rprivate void drawCrossing(){\rSystem.out.println(\u0026quot;교차료 표시\u0026quot;);\r}\r}\r.\r.\r.\r.\r.\r 위의 코드를 보면 무언가 문제가 있다고 느껴지시지 않나요? 위의 코드를 보면 중복된 코드들이 많이 보입니다. \u0026ldquo;차선 표시\u0026quot;를 print해주는 문장만 벌써 3개 등장했습니다.. 그러면 기능들이 추가될 떄마다 중복된 코드는\u0026hellip;.\n맞습니다..기능이 추가될 떄마다 우리는 불필요한 하드 코딩을 하게 됩니다.\n그러면 데코레이터 패턴을 적용하면 어떻게 해결될까요!?\n데코레이터 패턴 적용 ver 다음은 데코레이터 패턴을 적용한 후의 클래스 다이어그램입니다.\n훨씬 간결해진 구조 보이시나요!? 기존에 기능들을 조합하기 위해 조합되는 기능만큼 클래스들을 생성했는데, 데코리에터 패턴을 이용하면 고유한 기능들 개수만큼만 클래스를 생성해주시면 됩니다! 그러면 코드를 볼까요?\npublic class Client {\rpublic static void main(String[] args) {\rDisplay roadWithLaneAndTraffic = new TrafficDecorator(\rnew LaneDecorator(\rnew CrossingDecorator(\rnew RoadDisplay()\r)\r)\r);\rSystem.out.println(\u0026quot;--- draw 호출 ---\u0026quot;);\rroadWithLaneAndTraffic.draw();\r}\r}\rabstract class Display{\rpublic abstract void draw();\r}\rclass RoadDisplay extends Display{\r@Override\rpublic void draw() {\rSystem.out.println(\u0026quot;도로 기본 표시\u0026quot;);\r}\r}\rclass DisplayDecorator extends Display{\rprivate Display decorateDisplay;\rpublic DisplayDecorator(Display decorateDisplay){\rthis.decorateDisplay = decorateDisplay;\r}\r@Override\rpublic void draw() {\rdecorateDisplay.draw();\r}\r}\rclass LaneDecorator extends DisplayDecorator{\rpublic LaneDecorator(Display decorateDisplay){\rsuper(decorateDisplay);\r}\r@Override\rpublic void draw() {\rsuper.draw();\rdrawLane();\r}\rprivate void drawLane(){\rSystem.out.println(\u0026quot;\\t차선 표시\u0026quot;);\r}\r}\rclass CrossingDecorator extends DisplayDecorator{\rpublic CrossingDecorator(Display decorateDisplay){\rsuper(decorateDisplay);\r}\r@Override\rpublic void draw() {\rsuper.draw();\rdrawCrossing();\r}\rprivate void drawCrossing(){\rSystem.out.println(\u0026quot;\\t횡단보도 표시\u0026quot;);\r}\r}\rclass TrafficDecorator extends DisplayDecorator{\rpublic TrafficDecorator(Display decorateDisplay){\rsuper(decorateDisplay);\r}\r@Override\rpublic void draw() {\rsuper.draw();\rdrawTraffic();\r}\rprivate void drawTraffic(){\rSystem.out.println(\u0026quot;\\t교통량 표시\u0026quot;);\r}\r}\r 수행결과\n--- draw 호출 ---\r도로 기본 표시\r횡단보도 표시\r차선 표시\r교통량 표시\r main안의 코드들을 살펴봅시다! 예전에 해당 기능을 구현하기 위해서는 새로 클래스를 만들어서 구현했는데, 데코레이터 페턴이 적용된 현재는 생성자 DisplayDecorator 클래스를 상속받는 클래스들의 생성자에 구현하고자 하는 기능들을 추가하면 간단하게 구현됩니다. 즉, 새로운 클래스 구현이 아닌 생성자에 필요한 기능을 담는 것으로 기능의 조합이 가능해집니다!\n이로써 우리는 앞으로 데코레이터 패턴을 이용하여 기본 기능에 추가될 수 있는 많은 수의 부가 기능에 대해서 다양한 조합을 동적으로 구현할 수 있습니다~!\n참고\n JAVA 객체지향 디자인 패턴   ","id":23,"section":"posts","summary":"DecoratorPattern(데코레이터 패턴) 데코레인터 패턴이란? 객체의 결합 을 통해 기능을 동적으로 유연하게 확장 할 수 있게 해주는 패턴 위의 한 문장","tags":null,"title":"[DesignPattern] Decorator Pattern(데코레이터 패턴)","uri":"https://chlalstjd430.github.io/2020/05/01_decorator_pattern/","year":"2020"},{"content":"문제링크 사용언어  c++  주의사항   방금그곡 서비스에서는 음악 제목, 재생이 시작되고 끝난 시각, 악보를 제공한다.\n  네오가 기억한 멜로디와 악보에 사용되는 음은 C, C#, D, D#, E, F, F#, G, G#, A, A#, B 12개이다.\n  각 음은 1분에 1개씩 재생된다. 음악은 반드시 처음부터 재생되며 음악 길이보다 재생된 시간이 길 때는 음악이 끊김 없이 처음부터 반복해서 재생된다. 음악 길이보다 재생된 시간이 짧을 때는 처음부터 재생 시간만큼만 재생된다.\n  음악이 00:00를 넘겨서까지 재생되는 일은 없다.\n  조건이 일치하는 음악이 여러 개일 때에는 라디오에서 재생된 시간이 제일 긴 음악 제목을 반환한다. 재생된 시간도 같을 경우 먼저 입력된 음악 제목을 반환한다.\n  조건이 일치하는 음악이 없을 때에는 (None)을 반환한다.\n  문제풀이 처음 문제를 풀때 \u0026lsquo;#\u0026lsquo;을 고려하지못하여서, 마지막에 m과 melody를 비교하기 힘들었다, 이후 처음부터 멜로디들의 코드를 \u0026ldquo;C, C#, D, D#, E, F, F#, G, G#, A, A#, B \u0026ldquo;로 구별하여 vector에 담아 비교하니 쉽게 구현할 수 있었다. 다만 문제를 어떻게 풀지 생각하는건 쉬웠는데..실제로 구현해보니 시간이 너..무 오래걸렸다..\n문제풀이 방식은 다음과 같다.\n  musicinfos의 string 정보를 \u0026lsquo;,\u0026lsquo;로 split하여 곡 정보를 받아온다.\n  이후 시작시간과 끝시간을 이용하여 총 재생시간을 구한다.\n  음악 정보의 멜로디를 비교하기 전에 총 재생시간이 이전에 조건이 일치했던 음악이 있는지와 그 음악의 재생시간보다 큰지 비교한다.\n  이후 해당 음악정보가 조건이 일치한지 검색한다.\n  조건에 일치하면 answer에 곡 제목을 담아준다.\n  여기서 melody들을 그냥 string으로 비교하는 것보다 코드별로 분리하는 함수를 만들어서 코드들을 순서대로 vector에 담아 비교하는 것이 더 쉽다.\n코드를 보면 다음과 같다.\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; // 4 6 7 8 9 12 15 18 19 vector\u0026lt;string\u0026gt; splitChar(string str, char ch){ vector\u0026lt;string\u0026gt; v; int ind = 0; for(int i = 0; i \u0026lt; str.size(); i++){ if(str[i] == ch){ v.push_back(str.substr(ind, i - ind)); ind = i + 1; } } v.push_back(str.substr(ind, str.size()-1)); return v; } bool searchMelody(vector\u0026lt;string\u0026gt; m, vector\u0026lt;string\u0026gt; melody){ bool result = true; for(int i = 0; i \u0026lt; melody.size(); i++){ if(melody[i] != m[0]) continue; int k = i; for(int j = 0; j \u0026lt; m.size(); j++){ if(melody[k] != m[j]) { result = false; break; } k++; } if(result) { return result; } result = true; } return false; } vector\u0026lt;string\u0026gt; findMelodyCode(string melody){ vector\u0026lt;string\u0026gt; melodyCode; for(int j = 0; j \u0026lt; melody.size() - 1; j++){ string code = \u0026quot;\u0026quot;; code += melody[j]; if(melody[j+1] == '#'){ code += melody[j+1]; j++; } melodyCode.push_back(code); } if(melody[melody.size() - 1] != '#'){ string code = \u0026quot;\u0026quot;; code += melody[melody.size() - 1]; melodyCode.push_back(code); } return melodyCode; } string solution(string m, vector\u0026lt;string\u0026gt; musicinfos) { string answer = \u0026quot;(None)\u0026quot;; int currentTime = 0; for(int i = 0; i \u0026lt; musicinfos.size(); i++){ vector\u0026lt;string\u0026gt; musicinfo = splitChar(musicinfos[i], ','); vector\u0026lt;string\u0026gt; startTime = splitChar(musicinfo[0], ':'); vector\u0026lt;string\u0026gt; endTime = splitChar(musicinfo[1], ':'); int sumTime = (stoi(endTime[0]) - stoi(startTime[0]))*60 + (stoi(endTime[1]) - stoi(startTime[1])); if(currentTime \u0026gt; sumTime) continue; if(currentTime == sumTime){ if(answer != \u0026quot;(None)\u0026quot;) continue; } vector\u0026lt;string\u0026gt; melodyCode = findMelodyCode(musicinfo[3]); vector\u0026lt;string\u0026gt; melody; for(int j = 0; j \u0026lt; sumTime; j++){ int ind = j%melodyCode.size(); melody.push_back(melodyCode[ind]); } if(searchMelody(findMelodyCode(m), melody)){ answer = musicinfo[2]; currentTime = sumTime; } } return answer; }  ","id":24,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 방금그곡 서비스에서는 음악 제목, 재생이 시작되고 끝난 시각, 악보를 제공한다. 네오가 기억한 멜로디와 악보에 사용되는 음은 C, C#, D,","tags":null,"title":"프로그래머스 - [3차] 방금그곡","uri":"https://chlalstjd430.github.io/2020/04/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_022/","year":"2020"},{"content":"문제링크 사용언어  c++  주의사항   비트마스킹을 이용하여 풀 수 있는 문제이다. 기본적인 비트연산자에 대하여 숙지하여야한다.\n dfs로도 풀 수 있긴하다.    관계 데이터베이스에서 릴레이션(Relation)의 튜플(Tuple)을 유일하게 식별할 수 있는 속성(Attribute) 또는 속성의 집합 중, 다음 두 성질을 만족하는 것을 후보 키(Candidate Key)라고 한다.\n  유일성(uniqueness) : 릴레이션에 있는 모든 튜플에 대해 유일하게 식별되어야 한다.\n  최소성(minimality) : 유일성을 가진 키를 구성하는 속성(Attribute) 중 하나라도 제외하는 경우 유일성이 깨지는 것을 의미한다. 즉, 릴레이션의 모든 튜플을 유일하게 식별하는 데 꼭 필요한 속성들로만 구성되어야 한다.\n    문제풀이 해당 문제를 비트마스킹으로 푸는 코드를 이해하는데 오래걸렸다..애초에 비트연산자를 안쓴지 오래되어 까먹은 부분도 있고, 이러한 문제유형을 접해본게 처음인지라 나에게는 많이 어려웠다.\n해당 문제를 비트마스킹으로 풀기 전에 이론적으로 내가 생각한 부분은 이렇다.\n  colum개수만큼 for문을 진행하면서 colum의 개수중 i개를 조합한다.\n  이후 조합된 colum이 후보키가 될 수 있는지 확인한다.\n  이렇게 선출된 후보키들중 다른 후보키에 포함되는 경우 다른 후보키를 후보키에서 제외한다.\n 예시) \u0026ldquo;이름\u0026quot;이라는 칼럼자체가 후보키가 될 수있으면 {\u0026ldquo;이름\u0026rdquo;,\u0026ldquo;학번\u0026rdquo;},{\u0026ldquo;이름\u0026rdquo;,\u0026ldquo;전공\u0026rdquo;} 등 \u0026ldquo;이름\u0026quot;이 들어간 후보키는 최소성에 어긋난다.    위와 같이 과정을 생각하고 막상 코드를 구현하려했더니 dfs밖에 생각이 나지 않았다. 그래서 코드를 구현하다보니 내가 많이 복잡하게 구현한다는 느낌을 받아 검색을 통해 비트마스킹을 이용하여 문제를 풀 수 있다는 것을 알게되었다. 비트마스킹을 이용하여 문제를 푸는게 처음이라 코드를 이해하고 적용하는데 오래걸렸다. 코드는 다음과 같다.\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int countBits(int n){ int ret = 0; while(n){ if(n \u0026amp; 1) ret++; n = n \u0026gt;\u0026gt; 1; } return ret; } bool cmp(int a, int b){ a = countBits(a); b = countBits(b); return a \u0026lt; b; } bool check(vector\u0026lt;vector\u0026lt;string\u0026gt; \u0026gt; relation , int rowSize, int colSize, int subset){ // 예시) relation, 6, 4, 1(= 0001) // subset의 값에 있는 같은 자리에 대헤서 후보키가 될 수 있는지 검사한다. for(int i = 0; i \u0026lt; rowSize - 1; i++){ for(int j = i + 1; j \u0026lt; rowSize; j++){ bool isSame = true; for(int k = 0; k \u0026lt; colSize; k++){ if ((subset \u0026amp; 1 \u0026lt;\u0026lt; k) == 0) continue; // subset의 자리에 없는 colum은 지나친다. // 한 row에 값잍 틀린게 있으면(즉, 후보키가 될 수 있으면) isSame에 flase를 주고 해당 row에서 다음 row를 검사한다. // 예시로 subset = 3(0011) 일 때, 검색하는 row의 3번째자리나 4번째자리에 값중 하나만 달라도 후보키가 될 수 있다. if (relation[i][k] != relation[j][k]) { isSame = false; break; } } if (isSame) return false; // 해당 row의 값이 같으면 후보키가 될 수 없다. } } return true; } int solution(vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; relation) { int answer = 0; int rowSize = relation.size(); int colSize = relation[0].size(); vector\u0026lt;int\u0026gt; candidates; // colSize로 표현할 수 있는 비트개수만큼 for문 진행 for(int i = 1; i \u0026lt; (1 \u0026lt;\u0026lt; colSize); i++){ // 후보키가 될 수 있는지 여부를 탐색 if(check(relation, rowSize, colSize, i)) candidates.push_back(i); } // colum의 개수가 작은 순서대로 정렬 sort(candidates.begin(), candidates.end(), cmp); while(!candidates.empty()){ // sort된 후보키중 가장 작은 후보키를 답으로 제출 int n = candidates[0]; candidates.erase(candidates.begin()); answer++; // 이후 해당 후보키가 포함된 후보키들은 답에서 제외 for(int i = 0; i \u0026lt; candidates.size(); i++){ if((n \u0026amp; candidates[i]) == n){ candidates.erase(candidates.begin() + i); i = -1; } } } return answer; }  ","id":25,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 비트마스킹을 이용하여 풀 수 있는 문제이다. 기본적인 비트연산자에 대하여 숙지하여야한다. dfs로도 풀 수 있긴하다. 관계 데이터","tags":null,"title":"프로그래머스 - 후보키","uri":"https://chlalstjd430.github.io/2020/04/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_021/","year":"2020"},{"content":"문제링크 사용언어  c++  주의사항  최솟값이 8보다 크면 -1을 return 합니다.  문제풀이  해당 문제는 DP로 풀지못하여 DFS를 활용하였습니다. Count가 9이상이면 -1을 리턴하기때문에 N은 최대 9번 연속으로 나열될 수 있습니다. 코드는 다음과 같습니다.  #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int minNum = 9; void dfs(int count, int number, int current, int target) { if(count \u0026gt; 8) return; if(current == target){ minNum = min(minNum, count); } int tmp = 0; for(int i = 0; i \u0026lt; 8 - count; i++){ tmp = tmp*10 + number; dfs(count + 1 + i, number, current + tmp, target); dfs(count + 1 + i, number, current / tmp, target); dfs(count + 1 + i, number, current * tmp, target); dfs(count + 1 + i, number, current - tmp, target); } } int solution(int N, int number) { int answer = 0; dfs(0, N, 0, number); if(minNum \u0026gt;= 9) answer = -1; else answer = minNum; return answer; }  ","id":26,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 최솟값이 8보다 크면 -1을 return 합니다. 문제풀이 해당 문제는 DP로 풀지못하여 DFS를 활용하였습니다. Count가 9이상이면","tags":null,"title":"프로그래머스 - N으로 표현","uri":"https://chlalstjd430.github.io/2020/04/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_020/","year":"2020"},{"content":"문제링크 사용언어  c++  주의사항  double형으로 값들을 계산할 경우 부동소수점에 유의해야 한다.  문제풀이 해당 문제를 풀기위한 순서는 다음과 같다.\n lines를 ' ' 단위로 1차적으로 split한다.   마지막 단어인 \u0026rsquo;s\u0026rsquo;는 빼준다.   1번에의하여 split된 시간값을 \u0026lsquo;:\u0026rsquo; 단위로 다시한번 split해준다.\n  2번에의하여 split된 값들을 이용하여 시작시간과 종료시간을 구하여 값을 저장한다.\n   시작 시간을 구할 떄, 0.001초에 해당하는 값은 더해주어야한다.(처리시간은 시작시간과 끝시간을 포함)  각각 로그들의 시작시간과 종료시간별로 1초가 지난 값들 안에 다른 로그들이 범위에 들어있는지 확인하여 최대 처리량을 구한다.  #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; double abs(double num){ if(num \u0026gt; 0) return num; return -num; } vector\u0026lt;string\u0026gt; splitByChar(string str, char ch){ vector\u0026lt;string\u0026gt; result; int ind = 0; for(int i = 0; i \u0026lt; str.size(); i++){ if(str[i] == ch){ result.push_back(str.substr(ind, i - ind)); ind = i + 1; } } result.push_back(str.substr(ind, str.size() - ind )); return result; } int solution(vector\u0026lt;string\u0026gt; lines) { int answer = 0; int size = lines.size(); vector\u0026lt;long\u0026gt; startTime; vector\u0026lt;long\u0026gt; endTime; for(int i = 0; i \u0026lt; size; i++){ vector\u0026lt;string\u0026gt; line = splitByChar(lines[i], ' '); vector\u0026lt;string\u0026gt; time = splitByChar(line[1], ':'); long d = (long)(stoi(time[0])*60*60*1000 + stoi(time[1])*60*1000 + stod(time[2])*1000); startTime.push_back(d - stod(line[2])*1000 + 1); endTime.push_back(d); } for(int i = 0; i\u0026lt; size; i++){ long s = startTime[i]; long e = endTime[i]; int tmp1 = 0; int tmp2 = 0; for(int j = 0; j \u0026lt; size; j++){ long cs = startTime[j]; long ce = endTime[j]; if(s \u0026lt;= ce \u0026amp;\u0026amp; s + 999 \u0026gt;= cs) tmp1++; if(e \u0026lt;= ce \u0026amp;\u0026amp; e + 999 \u0026gt;= cs) tmp2++; } answer = max(answer, max(tmp1,tmp2)); } return answer; }  ","id":27,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 double형으로 값들을 계산할 경우 부동소수점에 유의해야 한다. 문제풀이 해당 문제를 풀기위한 순서는 다음과 같다. lines","tags":null,"title":"프로그래머스 - [1차] 추석 트래픽","uri":"https://chlalstjd430.github.io/2020/04/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_019/","year":"2020"},{"content":"문제링크 사용언어  c++  주의사항   입력으로 판의 높이 m, 폭 n과 판의 배치 정보 board가 들어온다.\n  2 ≦ n, m ≦ 30\n  board는 길이 n인 문자열 m개의 배열로 주어진다. 블록을 나타내는 문자는 대문자 A에서 Z가 사용된다.\n 문제를 풀때 이 부분을 놓치면 9번 TC를 통과하지 못하게 된다.    문제풀이 해당 문제를 풀기 위해서 문제를 이해하고 어떻게 해야 문제를 풀 수 있을지 생각해보았다.\n  2x2블록들을 찾는다.\n  1번에서 찾은 블록들을 빈 블록 처리를 해준다.\n  블록들을 아래로 떨어트려 준다.\n  1~3 과정을 2x2블록을 찾지 못할 떄까지 진행한다.\n  2x2블록을 찾지 못하였으면 비어있는 블록들의 개수를 세준다.\n  위의 과정을 거치면 우리는 답을 구할 수 있다는 것을 알 수 있다. 그러면 코드로 구현해보자.\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; vector\u0026lt;string\u0026gt; friendsBoard; int nx[] = {0, 0, 1, 1}; int ny[] = {0, 1, 0, 1}; int answer = 0; // 블록을 아래로 떨어트리는 함수 void pushBoard(){ int w = friendsBoard[0].size(); int h = friendsBoard.size(); for(int i = h - 1; i \u0026gt;= 0; i--){ for(int j = w - 1; j \u0026gt;= 0; j--){ if(friendsBoard[i][j] != 'x') continue; int ind = -1; for(int k = i; k \u0026gt;= 0; k--){ if(friendsBoard[k][j] != 'x') { ind = k; break; } } if(ind == -1) continue; int cur = i; for(int k = ind; k \u0026gt;= 0; k--){ if(cur \u0026lt; 0) break; friendsBoard[cur][j] = friendsBoard[k][j]; friendsBoard[k][j] = 'x'; cur--; } } } } // 2x2 블록을 찾는 함수 bool findFriends(){ vector\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; boardLocation; int w = friendsBoard[0].size(); int h = friendsBoard.size(); for(int i = 0; i \u0026lt; h; i++){ for(int j = 0; j \u0026lt; w; j++){ bool find[4] = {false, }; char v = friendsBoard[i][j]; if(v == 'x') continue; for(int k = 0; k \u0026lt; 4; k++){ int x = i + nx[k]; int y = j + ny[k]; if(0 \u0026gt; x || 0 \u0026gt; y || x \u0026gt;= h || y \u0026gt;= w ) break; if(v == friendsBoard[x][y]){ find[k] = true; continue; } break; } if(find[0] \u0026amp;\u0026amp; find[1] \u0026amp;\u0026amp; find[2] \u0026amp;\u0026amp; find[3]){ for(int k = 0; k \u0026lt; 4; k++){ boardLocation.push_back(make_pair(i + nx[k], j + ny[k])); } find[0] = find[1] = find[2] = find[3] = false; } } } for(int i = 0; i \u0026lt; boardLocation.size(); i++){ int x = boardLocation[i].first; int y = boardLocation[i].second; friendsBoard[x][y] = 'x'; } if(boardLocation.size() == 0){ return false; } return true; } // 비어있는 블락을 찾는 함수 void findAnswer(){ int w = friendsBoard[0].size(); int h = friendsBoard.size(); for(int i = 0; i \u0026lt; h; i++){ for(int j = 0; j \u0026lt; w; j++){ if(friendsBoard[i][j] == 'x') answer++; } } } int solution(int m, int n, vector\u0026lt;string\u0026gt; board) { friendsBoard = board; bool find = true; findFriends(); while(find){ pushBoard(); find = findFriends(); } findAnswer(); return answer; }  ","id":28,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 입력으로 판의 높이 m, 폭 n과 판의 배치 정보 board가 들어온다. 2 ≦ n, m ≦ 30 board는 길이 n인 문자열 m개의 배열로 주어진","tags":null,"title":"프로그래머스 - [1차] 프렌즈4블록","uri":"https://chlalstjd430.github.io/2020/03/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_018/","year":"2020"},{"content":"문제링크 사용언어  c++  주의사항   문자열의 길이 : 1,000,000이하의 자연수\n  문자열은 모두 소문자로 이루어져 있습니다.\n  문제풀이 처음에 for문을 계속 돌려줘가며 탐색하는 방식으로 문제를 풀었다. 그러나 이 방식은 효율성 테스트를 통과하지 못하였고 다른 방법을 모색하였다. 이를 해결하기 위한 좋은 방법으로는 stack 자료구조를 활용하는 방법이다. 과정은 다음과 같다.\n  첫 글자는 무조건 stack에 담는다.\n  이후 두번째 글자부터 for문을 진행한다.\n  for문을 진행하면서 stack의 top에 있는 글자와 현재 글자가 같다면 stack을 pop 시켜준다.\n  같지 않다면 stack에 push해준다.\n  위와 같은 과정을 계속 진행하며 stack이 비어있다면 answer를 1로 변환해준다.\n  위 과정에서 stack에 top을 가르키기 전에 stack이 비어있는지 확인하여 비어있다면 비교하지 않고 해당 값을 push 해줘야한다. 코드를 보면 다음과 같다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;stack\u0026gt; using namespace std; int solution(string s) { int answer = 0; stack\u0026lt;char\u0026gt; st; st.push(s[0]); for(int i = 1; i \u0026lt; s.size(); i++){ if(st.empty()){ st.push(s[i]); continue; } if(st.top() == s[i]){ st.pop(); continue; } st.push(s[i]); } if(st.empty()) answer = 1; return answer; }  ","id":29,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 문자열의 길이 : 1,000,000이하의 자연수 문자열은 모두 소문자로 이루어져 있습니다. 문제풀이 처음에 for문을 계속 돌려","tags":null,"title":"프로그래머스 - 짝지어 제거하기","uri":"https://chlalstjd430.github.io/2020/03/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_017/","year":"2020"},{"content":"문제링크 사용언어  c++  주의사항   행의 개수 N : 100,000 이하의 자연수\n  열의 개수는 4개이고, 땅(land)은 2차원 배열로 주어집니다.\n  점수 : 100 이하의 자연수\n  문제풀이 처음 문제를 풀 때는 재귀로 문제에 접그하였더니 예제는 통과하였지만, 실행을 하니 모두 실패가 나왔다. 그래서 DP로 접근하여 문제를 풀기로 했다. 문제 풀이 과정은 다음과 같다.\n  행의 두번째 줄부터 열을 차례대로 검사한다.\n  해당칸은 이전 행에서 열이 같잊않은 칸들 중 가장 큰수를 더한값이 된다. 즉, n = n + max(n-1)(열이 같지 않은 칸 중 가장 큰 값) 이라는 점화식이 이용된다.\n  마지막 행까지 검사가 끝나면 마지막 행에서 가장 큰 값을 찾아 답을 구한다.\n  이를 코드로 표현하면 다음과 같습니다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int landW; int landH; int answer; void dfs(int x, int y, int sum, vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; land){ if(x \u0026gt;= landH || y \u0026gt;= landW){ return; } sum += land[x][y]; answer = max(answer, sum); for(int i = 0; i \u0026lt; landW; i++){ if(i == y) continue; dfs(x+1, i, sum, land); } } int solution(vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; land) { answer = 0; landH = land.size(); landW = land[0].size(); for(int i = 0; i \u0026lt; landH; i++){ for(int j = 0; j \u0026lt; landW; j++){ dfs(i,j,0, land); } } return answer; }  ","id":30,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 행의 개수 N : 100,000 이하의 자연수 열의 개수는 4개이고, 땅(land)은 2차원 배열로 주어집니다. 점수 : 100 이하의 자연수 문제풀이","tags":null,"title":"프로그래머스 - 땅따먹기","uri":"https://chlalstjd430.github.io/2020/03/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_016/","year":"2020"},{"content":"문제링크 사용언어  c++  주의사항   조건 1. n의 다음 큰 숫자는 n보다 큰 자연수 입니다.\n  조건 2. n의 다음 큰 숫자와 n은 2진수로 변환했을 때 1의 갯수가 같습니다.\n  조건 3. n의 다음 큰 숫자는 조건 1, 2를 만족하는 수 중 가장 작은 수 입니다.\n  문제풀이 문제의 조건에 맞게 문제의 풀이 과정은 다음과 같이 진행하였다.\n  n을 2진법으로 변환한데 1의 갯수를 센다.\n  n+1 부터 1000000까지 차례대로 2진법 변환을 하며 1의 갯수를 센다.\n  2번 과정을 반복하다 n의 2진법의 1의 갯수와 같은게 있으면 answer에 값을 저장하고 끝낸다.\n  위 과정을 코드로 표현하면 다음과 같습니다.\nusing namespace std; int cntN(int n){ int cnt = 0; while(n \u0026gt; 1){ if(n%2 == 1) cnt++; n /= 2; } return cnt; } int solution(int n) { int answer = 0; int current = cntN(n); for(int i = n+1; i \u0026lt; 1000001; i++){ if(current == cntN(i)){ answer = i; break; } } return answer; }  ","id":31,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 조건 1. n의 다음 큰 숫자는 n보다 큰 자연수 입니다. 조건 2. n의 다음 큰 숫자와 n은 2진수로 변환했을 때 1의 갯수가 같습니다. 조건 3.","tags":null,"title":"프로그래머스 - 다음 큰 숫자","uri":"https://chlalstjd430.github.io/2020/03/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_015/","year":"2020"},{"content":"문제링크 사용언어  c++  주의사항  DP를 적용하여 문제를 풀지않으면 시간 초과가 된다.  문제풀이  array[N][N] = (array[N-1][N], array[N][N-1], array[N-1][N-1]) 중 가장 작은 값 + 1\n 위의 점화식을 이용하여 문제를 풀면된다. 다만, 맨 윗줄과 맨 왼쪽줄을 제외하고 검사를 하기 때문에 해당 부분에 1값이 있는지 확인해줘야한다. 코드를 보면 다음과 같다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; bool visited[1002][1002]; void dfs(int x, int y){ } int solution(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; board) { int answer = 0; int h = board.size(); int w = board[0].size(); // 검사를 1,1부터 시작하기 때문에, 맨윗줄과 왼쪽줄에 1값이 있는지 검사한다. for(int i = 0; i \u0026lt; h; i++){ if(board[i][0] == 1) { answer = 1; break; } } for(int i = 0; i \u0026lt; w; i++){ if(board[0][i] == 1) { answer = 1; break; } } // DP를 이용하여 최대 넓이를 구한다. for(int i = 1; i \u0026lt; h; i++){ for(int j = 1; j \u0026lt; w; j++){ if(board[i][j] == 0) continue; // 진행하는 값이 0이라면 패스한다. board[i][j] = min(board[i-1][j-1], min(board[i-1][j],board[i][j-1])) + 1; // DP answer = max(board[i][j]*board[i][j], answer); // answer에 최대 넓이 값을 비교한다. } } return answer; }  ","id":32,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 DP를 적용하여 문제를 풀지않으면 시간 초과가 된다. 문제풀이 array[N][N] = (array[N-1][N], array[N][N-1], array[N-1][N-1]) 중 가장 작은 값 + 1 위의 점화식을 이용하여 문제를 풀면된다","tags":null,"title":"프로그래머스 - 가장 큰 정사각형 찾기","uri":"https://chlalstjd430.github.io/2020/03/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_014/","year":"2020"},{"content":"문제링크 사용언어  c++  주의사항   카펫의 테두리는 브라운이고, 테두리를 제외한 부분은 빨간색이다. 이 조건을 통해 두가지 공식이 나온다.\n  넓이*높이 = brown + red\n  (넓이 - 2)(높이 - 2) = red\n -2인 이유는, 높이의 경우 전체 높이에서 맨 위,아래 칸(테두리)을 뺀 값이고, 넓이의 경우 맨 왼쪽,오른쪽 칸(테두리)을 뺀 값이기 때문이다.      문제풀이 위 조건을 통해 넓이와 높이는 최소 3부터 시작되는 것을 알 수 있다. 그리하여 높이를 3부터 시작하여 차례대로 탐색하여 위 공식에 부합되는 값들을 구하면 된다. 코드는 다음과 같다.\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; solution(int brown, int red) { vector\u0026lt;int\u0026gt; answer; int sum = brown + red; for(int i = 3; i \u0026lt; sum; i++ ){ if(sum % i == 0){ int height = i; int weight = sum/height; if((height - 2)*(weight - 2) == red){ answer.push_back(weight); answer.push_back(height); break; } } } return answer; }  ","id":33,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 카펫의 테두리는 브라운이고, 테두리를 제외한 부분은 빨간색이다. 이 조건을 통해 두가지 공식이 나온다. 넓이*높이 = brown + red (넓이","tags":null,"title":"프로그래머스 - 카펫","uri":"https://chlalstjd430.github.io/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_013/","year":"2020"},{"content":" C++  적용 알고리즘   브루트 포스\n  DFS\n  주의사항  크기가 양수인 부분수열 중에서 그 수열의 원소를 다 더한 값이 S가 되는 경우의 수  문제풀이  해당 문제는 중복되지 않는 수열 조합의 합의 문제로 볼 수 있다. 그래서 재귀를 통해 문제를 풀었는데 틀렸다고 나왔다..첫 코드는 다음과 같다.  #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int N, S; int cnt; vector\u0026lt;int\u0026gt; v; void solution(int ind, int sum) { if (N \u0026lt;= ind) { return; } if (sum == S) { cnt++; } solution(ind + 1, sum + v[ind]); solution(ind + 1, sum); } int main() { cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; for (int i = 0; i \u0026lt; N; i++) { int tmp; cin \u0026gt;\u0026gt; tmp; v.push_back(tmp); } v.push_back(0); solution(0, 0); cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; }  왜 틀렸는지 이유를 보았더니, S가 0일때 중복해서 cnt값이 증가되는 것을 알수있다. 즉, 그래서 해당 부분을 수정하여 다시 작성하였다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int N, S; int cnt; vector\u0026lt;int\u0026gt; v; void solution(int ind, int sum) { if (N \u0026lt;= ind) { return; } if (sum + v[ind] == S) { cnt++; } solution(ind + 1, sum + v[ind]); solution(ind + 1, sum); } int main() { cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; for (int i = 0; i \u0026lt; N; i++) { int tmp; cin \u0026gt;\u0026gt; tmp; v.push_back(tmp); } v.push_back(0); solution(0, 0); cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; }  sum과 S를 비교하는 if문에서 sum 대신에 sum + v[ind]를 비교하며 앞서 틀렸던 오류를 해결하였다. 현재 sum이 아닌 다음 sum값을 미리 비교하므로 어떠한 수도 조합하지 않았을 때 비교하는 경우는 없을 것이다.\n","id":34,"section":"posts","summary":"C++ 적용 알고리즘 브루트 포스 DFS 주의사항 크기가 양수인 부분수열 중에서 그 수열의 원소를 다 더한 값이 S가 되는 경우의 수 문제풀이 해당 문제는 중복되지 않는 수열 조합의","tags":["브루트 포스트"],"title":"백준 1182 - 부분수열의 합","uri":"https://chlalstjd430.github.io/2020/02/%EB%B0%B1%EC%A4%801182/","year":"2020"},{"content":"문제링크 사용언어  c++  주의사항   stock에 있는 밀가루는 오늘(0일 이후)부터 사용됩니다.\n  stock과 k는 2 이상 100,000 이하입니다.\n  dates의 각 원소는 1 이상 k 이하입니다.\n  supplies의 각 원소는 1 이상 1,000 이하입니다.\n  dates와 supplies의 길이는 1 이상 20,000 이하입니다.\n  k일 째에는 밀가루가 충분히 공급되기 때문에 k-1일에 사용할 수량까지만 확보하면 됩니다.\n  dates에 들어있는 날짜는 오름차순 정렬되어 있습니다.\n  dates에 들어있는 날짜에 공급되는 밀가루는 작업 시작 전 새벽에 공급되는 것을 기준으로 합니다. 예를 들어 9일째에 밀가루가 바닥나더라도, 10일째에 공급받으면 10일째에는 공장을 운영할 수 있습니다. 밀가루가 바닥나는 경우는 주어지지 않습니다.\n  문제풀이 해당 문제는 우선순위 큐를 이용하여 풀 수 있다. 우선순위 큐를 통해 stock이 k값을 넘어갈때까지 자신이 공급받을 수 있는 밀가루를 공급받으면 된다. 이를 코드로 표현하면 다음과 같다.\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; int solution(int stock, vector\u0026lt;int\u0026gt; dates, vector\u0026lt;int\u0026gt; supplies, int k) { int answer = 0; priority_queue\u0026lt;int\u0026gt; pq; int before_stock = 0; int search_index = 0; // stock이 k를 이상일떄까지 while(stock \u0026lt; k){ int dates_size = dates.size(); // 필요한 supplies를 공급받기 위해 반복문 수행 for(int i = search_index; i \u0026lt; dates_size; i++){ // supplies를 받을 수 있는 날짜의 supplies를 pq에 저장 if(before_stock \u0026lt;= dates[i] \u0026amp;\u0026amp; dates[i] \u0026lt;= stock){ search_index = i + 1; // 저장한 날짜의 인덱스 값 저장(추후 마지막으로 저장된 인덱스 값부터만 for문) pq.push(supplies[i]); } } before_stock = stock; // 이전 stock에 현재 stock을 저장 stock += pq.top(); // 현재 stock에 pq중 가장 많은 값을 저장 pq.pop(); // 사용한 supplies값을 pop answer++; // answer 추가 } return answer; }  ","id":35,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 stock에 있는 밀가루는 오늘(0일 이후)부터 사용됩니다. stock과 k는 2 이상 100,000 이하입니다. dates의 각 원소는 1","tags":null,"title":"프로그래머스 - 라면 공장","uri":"https://chlalstjd430.github.io/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_012/","year":"2020"},{"content":"문제링크 사용언어  c++  주의사항   숫자는 1~9까지만 존재한다\n  동일한 숫자는 없다\n  문제풀이 일단 문제에서 답이될 수는 123~987에서 0을 포함하거나, 동일한 숫자가 있는 경우를 제외한 모든 숫자가 처음에 답이 될 수 있다. 이후 baceball에 담겨있는 숫자와 스트라이크,볼 정보를 통해 숫자들을 다 비교하며 답이 될 수 없는 수는 완전히 제외 하다보면 답이 될 수있는 수의 개수를 구할 수 있다.\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int solution(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; baseball) { int answer = 0; int baseball_size = baseball.size(); vector\u0026lt;string\u0026gt; answers; // 가능한 모든 경우의 수 추가 for(int i = 123; i \u0026lt;= 987; i++){ string number = to_string(i); // 숫자에 0이 들어가있거나 동일한 숫자가 들어있으면 추가X if(number[1] == '0' || number[2] == '0' || number[0] == number[1] || number[1] == number[2] || number[0] == number[2]){ continue; } answers.push_back(number); } // baseball에 담긴 for(int i = 0; i \u0026lt; baseball_size; i++){ string number = to_string(baseball[i][0]); int answers_size = answers.size(); for(int j = answers.size() - 1; j \u0026gt;= 0; j--){ int strike = 0; int ball = 0; string check = answers[j]; for(int k = 0; k \u0026lt; 3; k++){ if(number[k] == check[k]){ strike++; } if(number[k] == check[(k+1)%3] || number[k] == check[(k+2)%3]){ ball++; } } if(baseball[i][1] == strike \u0026amp;\u0026amp; baseball[i][2] == ball) continue; answers.erase(answers.begin() + j); } } answer = answers.size(); return answer; }  ","id":36,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 숫자는 1~9까지만 존재한다 동일한 숫자는 없다 문제풀이 일단 문제에서 답이될 수는 123~987에서 0을 포함하거나, 동일한 숫","tags":null,"title":"프로그래머스 - 숫자 야구","uri":"https://chlalstjd430.github.io/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_011/","year":"2020"},{"content":"문제링크 사용언어  c++  주의사항  서로 다른 옷의 조합의 수를 구하는 공식을 생각해보자.  문제풀이 처음에 공식을 생각하지 않은 채, 재귀로 조합으로 경우의 수를 구하여 시간초과가 났다. 이에 다른 풀이법이 있을 것을 예상하고 일정한 공식을 찾아보았다.\n 옷의 종류가 얼굴, 상의, 하의 인 경우\n   (얼굴 개수 + 1)(상의 개수 + 1)(하의 개수 + 1) - 1 이다\n 여시서 (+ 1)은 해당 옷을 입지않은 경우고, 마지막에 있는 (-1)은 전체 옷을 아무것도 안입을 떄이다.    즉, 해당 공식을 코드로 표현하면 다음과 같다.\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;map\u0026gt; using namespace std; int solution(vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; clothes) { int answer = 1; map\u0026lt;string, int\u0026gt; m; vector\u0026lt;string\u0026gt; order; // 중보되는 옷을 구한다 int clothes_size = clothes.size(); for (int i = 0; i \u0026lt; clothes_size; i++) { if (m[clothes[i][1]] == 0) { m[clothes[i][1]]++; order.push_back(clothes[i][1]); continue; } m[clothes[i][1]]++; } // 공식 수행 for (int i = 0; i \u0026lt; order.size(); i++) { answer = answer * (m[order[i]] + 1); } answer -= 1; return answer; }  ","id":37,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 서로 다른 옷의 조합의 수를 구하는 공식을 생각해보자. 문제풀이 처음에 공식을 생각하지 않은 채, 재귀로 조합으로 경우의 수를 구하여 시","tags":null,"title":"프로그래머스 - 위장","uri":"https://chlalstjd430.github.io/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_010/","year":"2020"},{"content":"문제링크 사용언어  c++  주의사항  종이접기를 진행할 떄마다 생기는 규칙을 찾아야한다.  문제풀이 문제의 예제만으로는 규칙을 찾기 어려워 n=4일 떄 값을 직접 구해보아 규칙을 찾기로 하였다. n=4일 떄 값을 구하니 규칙이 보이기 시작하였다, 내가 세운 규칙은 다음과 같다.\n n = 1, 0\n  n = 2, 0 0 1\n  n = 3, 001 0 011\n  n = 4, 0010011 0 0011011\n 위 규칙을 해석하면 다음과 같다.\n  종이를 접었을 때 나오는 결과의 가운데는 항상 0(\u0026lsquo;V\u0026rsquo;)이다.\n  n = n-1 +'0\u0026rsquo; + (n-1의 가운데가 1인 값) 이다.\n 즉, 가운제를 기준으로 왼쪽은 이전에 접었던 결과와 같고, 오른쪽은 이전에 접었던 결과에서 가운데만 1(\u0026lsquo;ㅅ\u0026rsquo;)인 값이다.    위의 규칙을 코드로 작성하면 다음과 같다.\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; solution(int n) { vector\u0026lt;int\u0026gt; answer; if(n == 1) { answer.push_back(0); return answer; } if(n == 2){ answer.push_back(0); answer.push_back(0); answer.push_back(1); return answer; } string result = \u0026quot;001\u0026quot;; for(int i = 3; i \u0026lt;= n; i++){ string tmp = result; string tmp2 = result; tmp2[result.size()/2] = '1'; result = tmp + '0' + tmp2; } int result_size = result.size(); for(int i = 0; i \u0026lt; result_size; i++){ answer.push_back(result[i] - '0'); } return answer; }  ","id":38,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 종이접기를 진행할 떄마다 생기는 규칙을 찾아야한다. 문제풀이 문제의 예제만으로는 규칙을 찾기 어려워 n=4일 떄 값을 직접 구해보아","tags":null,"title":"프로그래머스 - 종이접기","uri":"https://chlalstjd430.github.io/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_009/","year":"2020"},{"content":"문제링크 사용언어  c++  주의사항   어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다.\n 조합하여 가장 큰 수가 아닌 숫자 순서를 유지하며 k개의 수를 제거하는 것을 의미한다.    문제풀이 처음 문제를 풀 떄 조합을 하여 가장 큰수 인줄 알았지만, 숫자 순서를 유지한채 k개의 수를 제거하는 문제였다. 문제를 풀기 위해 어떻게 해야 가장 큰수를 구할지 생각해보았다. 먼저, answer의 길이 = (number의 길이 - k) 이다. 그러므로 answer의 길이 를 number의 길이 - k 만큼 보장한다는 전제하여 앞에서부터 가장 큰 수를 선택하면 된다. 해당 과정을 단계별로 설명하면 다음과 같다.\n  0 부터 number.size - (number.size() - k) 까지 중에 가장 큰 수 선택하여 answer에 추가\n  k를 1만큼 감소\n  1,2 과정을 number.size() - k가 0이 될 때까지 혹은 answer의 길이가 초기의 number의 길이 - k 와 같을 때까지 진행한다.\n  이후 answer의 길이가 초기의 number의 길이 - k 와 같지 않다면 이전에 저장한 큰 수의 인덱스부터 number의 끝까지 answer의 뒤에 추가해준다.\n  이를 코드로 표현하면\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; string solution(string number, int k) { string answer = \u0026quot;\u0026quot;; int number_size = number.size(); int value = -1; int value_ind; int kk = k; int default_last = number_size - k; k= number_size - k; for(int i = 0; i \u0026lt;= (number_size - k); i++){ if(answer.size() == default_last) break; if(k == 0) { break; } int tmp = number[i] - '0'; if(value \u0026lt; tmp){ value = tmp; value_ind = i; } if(i == (number_size - k)){ i = value_ind; value = -1; --k; answer += number[value_ind]; } } answer += number.substr(value_ind+1); return answer; }  ","id":39,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다. 조합하여 가장 큰 수가 아닌 숫자 순서를 유지하며 k개의","tags":null,"title":"프로그래머스 - 큰 수 만들기","uri":"https://chlalstjd430.github.io/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_008/","year":"2020"},{"content":"문제링크 사용언어  c++  주의사항  1,2,4 숫자가 반복 진행 되므로 3진법을 구하는 방법과 비슷하게 진행하면 된다.  문제풀이   124 나라에서는 10진법 124 수로 표현되는 과정을 보자.\n 3으로 몫을 계속해서 나누고 나머지가 0일 떄 몫을 -1 한다.    11(10진법)일 때 11/3 = 3 ... 2 3/3 = 1 -1 ... 0 // 나머지가 0이므로 몫을 -1한다. 나머지들을 밑에서부터 나열하면 02가 된다. 9(10진법) 9/3 = 3 - 1 ... 0 2/3 = 0 ... 2 나머지들을 밑에서부터 나열하면 20가 된다.  여기서 0을 4라고 생각하면 답은 순서대로 42, 24가 된다.\n그러면 위와 같은 식을 코드로 구현해보자.\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; string solution(int n) { string answer = \u0026quot;\u0026quot;; char num[3] = {'4', '1', '2'}; // 나머지를 인덱스로하는 실제값 while(true){ if(n == 0){ break; } else{ int tmp = n%3; answer = num[tmp] + answer; n /= 3; if(tmp == 0) n--; } } return answer; }  위 코드와 과정을 이해하였다면 어떠한 진법 변환 문제도 적용할 수 있을 것이다 :D\n","id":40,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 1,2,4 숫자가 반복 진행 되므로 3진법을 구하는 방법과 비슷하게 진행하면 된다. 문제풀이 124 나라에서는 10진법 124 수로 표현되는 과정을 보","tags":null,"title":"프로그래머스 - 124 나라의 숫자","uri":"https://chlalstjd430.github.io/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_007/","year":"2020"},{"content":"Chapter 09 - 단위 테스트  사실 단위 테스트는 한 챕터로 설명하기에 부족한면이 없지않아 있다. 해당 챕터는 추후에 정리할 \u0026ldquo;자바와 JUnit을 활용한 실용주의 단위 테스트\u0026rdquo;라는 책을 가지고 정리해가며 공부할 때 더 다뤄볼 예정이다. 그러므로 해당 챕터는 생략하겠다.\n","id":41,"section":"posts","summary":"Chapter 09 - 단위 테스트 사실 단위 테스트는 한 챕터로 설명하기에 부족한면이 없지않아 있다. 해당 챕터는 추후에 정리할 \u0026ldquo;자바와 JUnit을 활용한 실용주","tags":["클린코드"],"title":"Chapter 09 - 단위 테스트","uri":"https://chlalstjd430.github.io/2020/02/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C_009/","year":"2020"},{"content":"알고리즘 문제를 풀면서 어떠한 문제를 풀 때 어떠한 알고리즘을 적용해야하는 특징이 보이는 경우가 있다. 그래서 그러한 특징들이 보일 떄 마다 정리하려고 한다.\n알고리즘 특징 1. DFS(깊이 우선 탐색) vs BFS(넓이 우선 탐색)\nDFS/BFS는 그래프 문제의 대표적인 알고리즘이라 많은 사람들이 많이들 접해봤을 거라 생각한다. 사실 DFS로만 BFS로만 문제를 풀어야하는 경우는 거의 없다. 왠만하면 두 알고리즘 적용이 다 가능하다. 그래서 필자같은 경우에도 특별하게 메모리 초과가 날 것 같지않으면 DFS가 편해 DFS로 문제를 거의 푼다.\n  DFS\n  재귀or스택을 이용하여 구현한다.\n 나는 주로 재귀를 통해 구현한다.      BFS\n  큐를 이용하여 구현한다.\n  나는 주로 최단 경로를 탐색할 떄 많이 적용한다.\n 가중치 없는 그래프의 최단 경로문제는 BFS로만 접근해야 한다고 한다.      2. Dynamic Programming(다이나믹 프로그래밍)\n일정한 규칙을 가지고 결과를 도출하는 문제들은 거의 DP이다. 사실 DP에서 점화식 만 구하면 어지간하면 답을 구하지만 처음 보는 문제의 점화식을 구하기는 절대 쉽지 않다. 그래서 내가 느끼기엔 더 많은 문제를 계속해서 풀어봐야 하는 것 같다.\n3. Greedy Algorithm(탐욕 알고리즘)\n코딩 테스트 및 여러가지 알고리즘 문제에서 대표적인 알고리즘이다. 해당 문제를 풀기 위해서는 정렬,자료구조 개념이 있으면 좋을 것 같다.\n3. Kruskal Algorithm(크루스칼 알고리즘)\n보통 최소 신장 트리의 구현(MST) 방법으로 채택되는 알고리즘이다.즉, 가장 적은 비용으로 모든 노드를 연결하기 위해 사용되는 알고리즘이다. 크루스칼 알고리즘에서는 Union-Finde(합집합 찾기) 를 사용한다.\n4. Dijkstra Algorithm(다익스트라 알고리즘)\n하나의 정점에서 다른 모든 정점까지의 최단 경로 를 구하는 문제에 사용된다. 보통 우선순위 큐(Priority Queue)를 활용해서 문제를 푼다.\n5. Floyd Warshall Algorithm(플로이드 와샬 알고리즘)\n다익스트라는 하나의 정점에서 다른 모든 정점이라면, 플로이드 와샬은 모든 정점에서 다른 모든 정점의 최단 경로 를 구하는 문제에 사용된다.\n6. Topological Sorting(위상 정렬)\n7. Strongly Connected Component(강한 결합 요소)\n","id":42,"section":"posts","summary":"알고리즘 문제를 풀면서 어떠한 문제를 풀 때 어떠한 알고리즘을 적용해야하는 특징이 보이는 경우가 있다. 그래서 그러한 특징들이 보일 떄 마다 정리하려고 한다. 알고리","tags":["알고리즘"],"title":"알고리즘 특징정리","uri":"https://chlalstjd430.github.io/2020/02/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%ED%8A%B9%EC%A7%95%EC%A0%95%EB%A6%AC/","year":"2020"},{"content":"문제링크 사용언어  c++  주의사항   문제의 제한사항을 주의깊게 보자\n  제한사항\n  전체 학생의 수는 2명 이상 30명 이하입니다.\n  체육복을 도난당한 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다.\n  여벌의 체육복을 가져온 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다.\n  여벌 체육복이 있는 학생만 다른 학생에게 체육복을 빌려줄 수 있습니다.\n  여벌 체육복을 가져온 학생이 체육복을 도난당했을 수 있습니다. 이때 이 학생은 체육복을 하나만 도난당했다고 가정하며, 남은 체육복이 하나이기에 다른 학생에게는 체육복을 빌려줄 수 없습니다.(이 제한사항이 중요한 것 같다)\n      문제풀이 처음 문제를 풀었을 때 제한사항 중 마지막 부분을 읽지 못하고 문제를 풀어 답이 틀렸다고 나왔다, 이후 어떤점이 문제가 있었는지 알기 위해 문제를 다시 읽어보았고 제한사항에서 놓친 부분이 있다는 것을 알게되어서 코드를 수정하고 제출하여 정답을 맞았다.\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int solution(int n, vector\u0026lt;int\u0026gt; lost, vector\u0026lt;int\u0026gt; reserve) { int answer = 0; vector\u0026lt;int\u0026gt; v(n+2,1); // 0~n+1까지 체육복 개수를 1로 초기화 // 체육복을 잃어버린 학생의 체육복 개수 1 감소 int lostSize = lost.size(); for(int i = 0; i \u0026lt; lostSize; i++){ v[lost[i]]--; } // 여분의 체육복을 가진 학생의 체육복 개수 1 증가 int reserveSize = reserve.size(); for(int i = 0; i \u0026lt; reserveSize; i++){ int ind = reserve[i]; v[ind]++; } for(int i = 0; i \u0026lt; reserveSize; i++){ int ind = reserve[i]; // 제한사항 마지막 부분에 해당하는 학생은 넘어간다. if(v[ind] \u0026lt; 2) continue; // 체육복은 앞에 있는 학생 먼저 나눠주고 앞에 학생이 체육복이 있다면 뒤에 학생을 확인한다. if(v[ind-1] == 0) v[ind-1]++; else if(v[ind+1] == 0) v[ind+1]++; } // 체육복을 가지고 있는 학생 수만큼 answer를 증가시킨다 for(int i = 1; i \u0026lt;= n; i++){ if(v[i] != 0) { answer++; } } return answer; }  ","id":43,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 문제의 제한사항을 주의깊게 보자 제한사항 전체 학생의 수는 2명 이상 30명 이하입니다. 체육복을 도난당한 학생의 수는 1명 이상 n명","tags":null,"title":"프로그래머스 - 체육복","uri":"https://chlalstjd430.github.io/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_006/","year":"2020"},{"content":" C++  적용 알고리즘   그리디 알고리즘\n  정렬\n  주의사항  재귀를 통해 순열을 구하여 정답을 찾았지만 메모리 초과가 나왔다.  문제풀이 초기에 순열을 통해 문제를 풀었지만 메모리 초과가 나와 다른 방법을 찾아보았다. 그 결과 30의 배수가 되기 위해서 두 가지 조건을 가져야 한다는 것을 알게 되었다.\n  마지막 일의 자리는 무조건 0이 되어야 한다.\n  마지막 숫자를 제외한 나머지 숫자들의 합은 3의 배수이다.\n  #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; vector\u0026lt;char\u0026gt; v; bool cmp(char c1, char c2) { return c1 \u0026gt; c2; } int main() { string str = \u0026quot;\u0026quot;; string answer = \u0026quot;\u0026quot;; int sum = 0; cin \u0026gt;\u0026gt; str; int strSize = str.size(); for (int i = 0; i \u0026lt; strSize; i++) { v.push_back(str[i]); } // 큰 숫자대로 정렬 sort(v.begin(), v.end(), cmp); // 마지막 숫자가 0이 아니면 30의 배수가 될 수 없다. if (v[strSize - 1] != '0') { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; return 0; } // 모든 수의 합을 구한다. for (int i = 0; i \u0026lt; strSize; i++) { sum += v[i] - '0'; answer += v[i]; } if (sum % 3 == 0) { cout \u0026lt;\u0026lt; answer \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; } }  ","id":44,"section":"posts","summary":"C++ 적용 알고리즘 그리디 알고리즘 정렬 주의사항 재귀를 통해 순열을 구하여 정답을 찾았지만 메모리 초과가 나왔다. 문제풀이 초기에 순열을 통해 문제를 풀었지만 메모리","tags":["그리디 알고리즘"],"title":"백준 10610 - 30","uri":"https://chlalstjd430.github.io/2020/02/%EB%B0%B1%EC%A4%8010610/","year":"2020"},{"content":"JWT(JSON Web Token)  프로젝트를 진행 중 모바일에서 로그인 API를 제공해야 될 일이 생겼다. 기존에 웹에서 프로젝트를 할 때는 session 정보를 이용하여 로그인 기능을 제공하였는데 모바일 환경에서 JWT를 이용하여 로그인 API를 제공한다는 것을 알게되고 실제 프로젝트에 적용해봤다. 프로젝트가 끝난 이후 JWT에 대헤서 다시 한번 상기시키고 문서로 개념을 정리해보려고 한다.\n1. JWT란?  JWT란 JSON Web Token의 약자로 Json 포맷을 이용하여 Claim(사용자 정보나 데이터 속성 등을 의미) 정보를 디지털 서명 하고 이후 비밀 서명 키로 검증하는 Web Token입니다.\n   두 개체에서 JSON 객체를 이용해 Self-contained 방식으로 정보를 안전한게 전달\n  JWT는 토큰 자체에 정보를 가지고 있다.\n  회원 인증, 정보 전달에 주로 사용\n  위의 말도 어렵다면 쉽게 정보를 가진 토큰을 통한 인증을 위해 사용된다고 이해하면 좋다.\n2. JWT 구조 JWT는 Header, Payload, Signature 로 3부분으로 JSON 형태를 Base64로 인코딩하여 이루져있다.\n  Header\n  토큰의 첫번째 파트이다.\n  전형적으로 2가지 파트로(alg 와 typ)으로 구성되어있다.\n  alg : 알고리즘 방식을 지정하며, 서명(Signature) 및 토큰 검증에 사용\n  typ : 토큰의 타입\n      Payload\n  토큰의 두번째 파트이고 Claim 정보를 담고있다. Claim은 총 3가지 파트로 나누어진다.\n  Claim\n  Registered claims(등록된 클레임)\n토큰 정보를 표현하기 위해 이미 정해진 종류의 데이트들이다. 모두 선택적으로 작성이 가능하며 사용할 것을 권장한다. 또한 JWT를 간결하게 위해 key는 모두 3글자이다.\n  iss : 토큰 발급자(issuer)\n  sub : 토큰 제목(subject)\n  aud : 토큰 대상자(audience)\n  exp : 토큰 만료 시간(expiration), NumericDate 형식으로 되어 있어야 함 ex) 1480849147370\n  nbf : 토큰 활성 날짜(not before), 이 날이 지나기 전의 토큰은 활성화되지 않음\n  iat : 토큰 발급 시간(issued at), 토큰 발급 이후의 경과 시간을 알 수 있음\n  jti : JWT 토큰 식별자(JWT ID), 중복 방지를 위해 사용하며 일회성 토큰(Access Token) 등에 사용\n  토큰\n    Public claims(공개 클레임)\n충돌 방지를 위해 공개된 클레임이다. 보통 URI형식으로 짓는다.\n  Private claims(비공개 클레임)\n서버와 클라이언트간에 협의된 클레임 이름이다.\n    Payload의 예제로는 다음과 같습니다.\n{ // 실제 프로젝트에 적용한 AccessToken 예제 \u0026quot;sub\u0026quot;: \u0026quot;AccessToken\u0026quot;, \u0026quot;iat\u0026quot;: 1581231911, \u0026quot;exp\u0026quot;: 1581232271, \u0026quot;uid\u0026quot;: \u0026quot;21\u0026quot; }    Verify Signature\nSignature(서명)은 토큰을 인코딩하거나 유효성 검증을 할 때 사용하는 고유한 암호화 코드이다. Signature는 Header와 Payload의 값을 인코딩(BASE64)하고, 이코딩한 값을 비밀 키를 이용해 Header에 정의한 알고리즘으로 해싱을 하고, 이 값을 BASE64로 인코딩하여 생산한다.\nHMACSHA256( base64UrlEncode(header) + \u0026quot;.\u0026quot; + base64UrlEncode(payload), your-256-bit-secret    3. JWT 장점과 단점 장점\n  JWT는 발급 후 토큰 검증만 하면 되기 때문에 저장소가 필요없다.\n  세션 정보를 유지할 필요가 없어, 로드밸런싱 환경에서 유리하다.\n  토큰 기반으로 하는 다른 인증 시스템에 접근이 가능하다.\n  정보를 가지고 있어 별도의 쿼리문을 줄일 수 있다.\n  단점\n  JWT는 한 번 발급되면 유효기간이 지나기 전까지 정보들을 탈취할 수 있다.\n Access Token과 Refresh Token을 이용해 피해를 줄일 수 있다.    payload 정보가 제한적이다.\n JWT는 서명에 의해 변조되지 않음을 보장할 순 있지만 데이터를 다른 사람이 볼 수 있으므로 Header나 Payload에 private한 정보는 넣지 않을 것을 권장합니다.    4. Access Token \u0026amp; Refresh Token 앞서 말한 JWT의 단점 중에 토큰을 탈취 당할 경우 보안에 취약하다는 단점이 있었다. 토큰의 유효기간은 길 수록 토큰이 탈취 당했을 떄 보안에 취약하게 된다. 그렇다고 토큰의 유효기간이 짧아지면 새 토큰을 발급받기 위해 로그인을 자주 시도해야 되게 된다. 이러한 문제점에서 해결 대안으로 나온 것이 Access Token과 Refresh Token 이다. 이 개념은 OAuth에서 나왔는데 이는 추후에 공부해도록 하겠다.\nAccess Token과 Refresh Token 모두 JWT 형태입니다. 로그인 완료되었을 떄 유효기간이 짧은 Access Token과 비교적 유효기간이 긴 Refresh Token을 발행합니다. Refresh Token은 Access Token의 유효기간이 만료되었을 떄 새로 Token을 발급해주는 열쇠가 됩니다.\n에를 들어보면\n  가정) Refresh Token은 유효기간이 2주, Access Token은 유효기간이 1시간이다.\n  사용자는 로그인을 하여 Refresh,Access Token을 받는다\n  사용자는 API 요청을 하다가 1시간이 지나면 Access Token이 만료된다.\n  Refresh Token의 유효기간이 지나지 않았다면 새롭게 Access Token을 발급받는다.\n  Refresh Token은 2주가 지나면 유효기간이 만료된다.\n  사용자는 새로 로그인을 한다.\n  위와 같은 과정을 통해 기존에 유효기간이 길 수록 보안에 취약한 Access Token으 단점을 보완하고, 유효기간을 줄일 경우 로그인을 자주 시도해야 된다는 단점을 Refresh Token으로 보완한 것을 알 수 있습니다.\n  위의 예시를 조금더 자세하게 그림으로 설명하면 다음과 같습니다.\n 여기서 9~11번은 무조건적인 상황은 아니다. 클라이언트에서 Access Token의 Payload를 통해 유효기간을 알기 떄문에 API 요청전에 토큰이 만료되면 클라이언트에서 토큰 재발급을 요청할수있다.  결론적으로 Refresh Token을 통해 Access Token을 단독적으로 사용했을 때보다 보안에 좋아졌다는 점을 알 수 있다. 그러나 Access Token이 만료될 떄마다 새롭게 발급받기 위해 HTTP 요청이 많아진다는 단점이 있습니다.\n5. 마무리 이번 문서를 통해 JWT를 다시 정리하며 개념을 확고히 잡은 것 같습니다. 혹여나 잘못된 정보가 있으면 언제든지 댓글 달아주시면 감사하겠습니다. 다음 JWT 예제 포스팅에서 뵙도록 하겠습니다 :D\n참고 자료\n  https://jwt.io/introduction\n  https://mangkyu.tistory.com/56\n  https://elfinlas.github.io/2018/08/12/whatisjwt-01/\n  https://brownbears.tistory.com/440\n  ","id":45,"section":"posts","summary":"JWT(JSON Web Token) 프로젝트를 진행 중 모바일에서 로그인 API를 제공해야 될 일이 생겼다. 기존에 웹에서 프로젝트를 할 때는 session 정보를 이용하여 로그인 기능을 제공하였는데 모바","tags":["JWT"],"title":"JWT(1) - JWT(JSON Web Token)란 무엇인가?","uri":"https://chlalstjd430.github.io/2020/02/%EA%B3%B5%EB%B6%80_jwt/","year":"2020"},{"content":"Spring Webflux  최근 교내 커뮤니티 동아리 유어슈에서 Spring Webflux를 이용하여 프로젝트를 하였다. 사실 기존 동아리 스펙이 webflux로 정해져서 어쩔수 없이 새로운 프로젝트에 사용하여서 webflux가 왜 필요한지? 어떠한 장점이 있는지? 등 이해도가 부족하다는 생각이 들었다. 그래서 앞으로 webflux를 정리하고 reactive programming을 이해하하는 과정을 문서로 담아 정리하려고 한다.\n연관된 나의 글  리엑티브 프로그래밍이란?  Spring Webflux란? reactive-stack 웹 프레임워크인 Spring Webflux는 Spring 5버전부터 추가되었다. Webflux는 non-blocking을 지향하고 Reactive Streams back pressure을 지원한다. 그리고 Sprinb MVC와 Spring Webflux는 같이 사용할 수 있다.\nSpring 웹 요청을 처리하는 방식\n 요청 매핑    웹 요청을 어느 핸들러에게 보낼지 결정\n  URL, 헤더\n  @RequestMapping\n  요청 바인딩    핸들러에 전달할 웹 요청 준비\n  웹 URL, 헤더, 쿠키, 바디 등\n  핸들러(controller) 실행   전달 받은 요청 정보를 이용해 로직을 수행하고 결과를 리턴  핸들러 결과 처리(응답 생성)   핸들러의 리턴 값으로 웹 응답 생성  @RestController public class MyController { @GetMapping(\u0026quot;/hello/{name}\u0026quot;) // 1. 요청 매핑 String hello(@PathVariable String name){ // 2. 요청 바인딩 return \u0026quot;Hello! \u0026quot; + name; // 3,4. 해들러 실행 후 결과 처리 } }  함수형 WebFlux가 웹 요청을 처리하는 방식\n 요청 매핑   RouterFunction  요청 바인딩  -HandlerFUnction\n핸들러 실행  -HandlerFUnction\n핸들러 결과 처리(응답 생성)  -HandlerFUnction\nspring webflux를 사용하는 이유   비동기-논블럭킹 리엑티브 개발에 사용\n  효율적으로 등장하는 고성능 웹 애플리케이션 개발\n  서비스간 호출이 많은 마이크로서비스 아키텍처에 적합\n  새로운 방식으로 개발해보고 싶은 호기심 충족\n 발표자 토비님께서는 이를 권장하지 않는다 하셨다.    thread pool hell 발생을 저하\n 일반적으로 spring은 멀티 스레드 기반으로 동작하고, 만약 blocking IO로 진행된다면 준비된 스레드보다 더 많은 요청이 들어올 경우 thread pool hell이 발생합니다. 하지만 webflux를 사용할 경우 비동기 non-blocking IO로 서버의 코어 갯수만큼 스레드가 할당되어 사용되기 때문에, thread pool hell이 발생을 줄일 수 있습니다.    검증된 JVM과 방대한 자바 생태계를 이용할 수 있는 장점이 있습니다.\n  webflux 작동원리 지원 웹 서버/컨테이너  Sel  참고자료\n 스프링캠프 강의 - 토비  20.02.07 아직 작성이 완료되지 않은 문서입니다 :D ","id":46,"section":"posts","summary":"Spring Webflux 최근 교내 커뮤니티 동아리 유어슈에서 Spring Webflux를 이용하여 프로젝트를 하였다. 사실 기존 동아리 스펙이 webflux로 정해져서 어쩔수 없이 새로운","tags":["spring webflux"],"title":"리액티브","uri":"https://chlalstjd430.github.io/2020/02/%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_webflux/","year":"2020"},{"content":"문제링크 사용언어  c++  주의사항   대각선이 지나가는 단위 정사각형의 개수를 구하는 수학적인 공식\n  h + w - (h와w의 최대공약수)\n  사실 왜 이러한 공식이 나오는 지 이해는 못하였다.\n    answer의 자료형이 괜히 long long이 아니다.\n  문제풀이 h와 w의 최대공약수를 구하고 공식을 적용하면 문제가 나온다. 사실 공식을 알지 못하는 상태에서 다른사람들은 어떻게 문제를 풀었는지\u0026hellip;정말 대단하다.\nusing namespace std; long long solution(int w,int h) { long long answer = 1; // 최대 공약수 구하기 int gdc = 0; long long sum = (long long)w * (long long)h; int minNum = (w \u0026gt; h) ? h : w; for(int i = minNum; i \u0026gt;= i; i--){ if(w%i ==0 \u0026amp;\u0026amp; h%i == 0){ gdc = i; break; } } // 공식 적용 answer = (long long)(sum- (w+h-gdc)); return answer; }  ","id":47,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 대각선이 지나가는 단위 정사각형의 개수를 구하는 수학적인 공식 h + w - (h와w의 최대공약수) 사실 왜 이러한 공식이 나오는 지 이해","tags":null,"title":"프로그래머스 - 멀쩡한 사각형","uri":"https://chlalstjd430.github.io/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_005/","year":"2020"},{"content":" C++  적용 알고리즘   그리디 알고리즘\n  정렬\n  문제풀이  k개의 로프를 사용하여 중량이 w인 물체를 들어올릴 때, 각각의 로프에는 모두 고르게 w/k 만큼의 중량이 걸리게 된다.\n 위의 문항을 잘 이해했다면 쉽게 문제를 풀 수 있다. w/k 만큼의 중량은 가장 적은 중량을 들어올리는 로프의 중량보다 클수 없다. 그러므로 가장 작은 중량을 들어올리는 로프부터 차례대로 보다 큰 중량을 들어올리는 로프들을 함께 사용하여 가장 많은 중량을 올리는 게 답이 될 수 있다. 말이 어려울 수 있는데 코드를 보며 이해해보도록 하자.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main() { int tc = 0; int maxWeight = 0; // 들어올릴수 있는 가장 큰 중량의 값을 저장하는 변수 vector\u0026lt;int\u0026gt; lope; // 로프의 중량을 담는다 cin \u0026gt;\u0026gt; tc; for (int i = 0; i \u0026lt; tc; i++) { int weight; cin \u0026gt;\u0026gt; weight; lope.push_back(weight); } // 중량이 적은 순서대로 정렬한다. sort(lope.begin(), lope.end()); // i번째 로프 부터 i+1~tc의 로프를 함께 이용하여 들어올리는 중량의 값을 구하여 더 큰 중량의 값을 저장한다. for (int i = 0; i \u0026lt; tc; i++) { maxWeight = max(maxWeight, lope[i] * (tc - i)); } cout \u0026lt;\u0026lt; maxWeight \u0026lt;\u0026lt; endl; }  ","id":48,"section":"posts","summary":"C++ 적용 알고리즘 그리디 알고리즘 정렬 문제풀이 k개의 로프를 사용하여 중량이 w인 물체를 들어올릴 때, 각각의 로프에는 모두 고르게 w/k 만큼의 중량이 걸리게 된다. 위","tags":["그리디 알고리즘"],"title":"백준 2217 - 로프","uri":"https://chlalstjd430.github.io/2020/02/%EB%B0%B1%EC%A4%802217/","year":"2020"},{"content":" C++  적용 알고리즘   그리디 알고리즘\n  정렬\n  주의사항  문제의 주어진 조건을 잘 파악하고 경우의 수를 나누어야 한다.  문제풀이  문제의 내용과 조건을 보면 3가지의 경우에 한해서 답을 구할 수있다.    가장 싼 세트 가격으로 구매했을 경우\n  가장 싼 세트 가격과 가장 싼 낱개 가격으로 구매했을 경우\n  가장 싼 낱개 가격으로 구매했을 경우\n   가장 싼 세트 가격과 낱개 가격은 sort를 통해 쉽게 구할 수 있다.  #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; bool compare(pair\u0026lt;int, int\u0026gt; p1, pair\u0026lt;int, int\u0026gt; p2) { return p1.second \u0026lt; p2.second; } int main() { int N, M; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; vector\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; brand; int minMoney = 987654321; for (int i = 0; i \u0026lt; M; i++) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; brand.push_back(make_pair(a, b)); } // 1. 모든 기타줄을 세트로만 구매했을 때 sort(brand.begin(), brand.end()); int setPrice = brand[0].first; // 가장 저렴한 세트의 가격 int setCnt = N / 6; // 세트로 나눠지는 개수 int piece = N % 6; // 세트로 나눠지고 남는 낱개 개수 minMoney = (piece == 0) ? setCnt * setPrice : (setCnt + 1)*setPrice; // 세트 개수로 나누어졌을 때 // 2. 세트 + 낱개로 구매했을 때 sort(brand.begin(), brand.end(), compare); minMoney = min(minMoney, setPrice*setCnt + piece * brand[0].second); // 3. 모든 기타줄을 낱개로만 구매했을 때 minMoney = min(minMoney, brand[0].second*N); cout \u0026lt;\u0026lt; minMoney \u0026lt;\u0026lt; endl; }  ","id":49,"section":"posts","summary":"C++ 적용 알고리즘 그리디 알고리즘 정렬 주의사항 문제의 주어진 조건을 잘 파악하고 경우의 수를 나누어야 한다. 문제풀이 문제의 내용과 조건을 보면 3가지의 경우에 한해","tags":["그리디 알고리즘"],"title":"백준 1049 - 기타줄","uri":"https://chlalstjd430.github.io/2020/02/%EB%B0%B1%EC%A4%801049/","year":"2020"},{"content":"Chapter 08 - 경계  외부에서 사용하느 코드 또한 우리 내부코드와 \u0026ldquo;깨끗하게\u0026rdquo; 통합시켜야 한다.\n1. 서드파티 코드 사용하기    서드파티란?\n  Map같은 경우 가급적이면 Wrapping을 하여 사용하자.\n 공개된 API에서 인자로 받거나 리턴하지 마라.    2. 경계를 탐험하고 공부하기    서드파티를 사용할 때 우리가 사용할 코드에 대헤서는 충분히 테스트 할 필요가 있다.\n  테스트는 값어치를 한다.\n  메인 로직에 영향을 주지 않으며 서드파티 코드를 이해할 수 있다.\n  이러한 테스트는 새 버전으로 이전에 도움을 준다.\n    3. 아직 존재하지 않는 코드 사용하기    아직 개발되지 않은 모듈이 필요한데, 기능은 커녕 인터페이스조차 구현되지 않은 경우가 있다.\n 필요한 인터페이스를 만들어 활용하자(임시)    결론    서드파티를 이용할 때 내부코드와 \u0026ldquo;깨끗하게\u0026rdquo; 통합시키자\n  서드파티 코드를 충분히 테스트하며 연습하자.\n  ","id":50,"section":"posts","summary":"Chapter 08 - 경계 외부에서 사용하느 코드 또한 우리 내부코드와 \u0026ldquo;깨끗하게\u0026rdquo; 통합시켜야 한다. 1. 서드파티 코드 사용하기 서드파티란? Map","tags":["클린코드"],"title":"Chapter 08 - 경계","uri":"https://chlalstjd430.github.io/2020/02/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C_008/","year":"2020"},{"content":"문제링크 사용언어  c++  주의사항   큐와 우선순위 큐의 개념에 알고있어야 한다.\n 우선순위 큐는 항상 값이 높은 것을 앞으로 보낸다.    문제풀이 언뜻 보면 굉장히 쉬워보였는데, 정작 문제를 풀지 못하였다. 우선순위 큐를 활용해서 어찌저찌해서 풀 수 있을 것 같은데 방법이 생각이 안났다.\n문제는 큐 와 우선순위 큐 를 이용하면 간단하게 풀 수 있었다. 코드의 주석을 통해 설명하겠다.\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int solution(vector\u0026lt;int\u0026gt; priorities, int location) { int answer = 0; // 큐와 우선순위 큐를 적절히 활용하는게 이번 풀이의 핵심이다. queue\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; q; priority_queue\u0026lt;int\u0026gt; pq; // 큐에는 인덱스와 우선순위 정보를 차례대로, 우선순위 큐에는 우선순위 정보만을 담는다. for(int i = 0; i \u0026lt; priorities.size(); i++){ q.push(make_pair(i, priorities[i])); pq.push(priorities[i]); } int index = 1; while(!q.empty()){ // 현재 큐의 우선순위 값과 우선순위 큐의 값이 일치하다면 if(q.front().second == pq.top()){ // 현재 큐의 인덱스 정보와 찾고자하는 인덱스 정보가 일치할 경우 index값을 answer에 저장하고 while문을 종료한다. if(location == q.front().first){ answer = index; break; } // 그렇지 않은 경우 index를 증가시켜주고, q와 pq를 pop시켜준다. else{ index++; q.pop(); pq.pop(); } } // 현재 큐의 우선순위 값과 우선순위 큐의 값이 불일치하다면 현재 큐의 우선순위보다 더 높은게 뒤에 있다는 소리이므로 현재 큐의 값들을 뒤로 빼준다. else{ q.push(q.front()); q.pop(); } } return answer; }  ","id":51,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 큐와 우선순위 큐의 개념에 알고있어야 한다. 우선순위 큐는 항상 값이 높은 것을 앞으로 보낸다. 문제풀이 언뜻 보면 굉장히 쉬워보였는데","tags":null,"title":"프로그래머스 - 프린터","uri":"https://chlalstjd430.github.io/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_004/","year":"2020"},{"content":" C++  적용 알고리즘   그리디 알고리즘\n  정렬\n  주의사항   처음 문제 풀 때 재귀를 통해 풀었으나 시간초과가 날 뿐더러 답도 틀렸었다..\n 답은 왜 틀렸는지 의문이다.    문제풀이 해당 문제는 다음과 같은 과정을 거치면 풀 수 있다.\n 회의가 끝나는 시간으로 정렬한다.(회의 끝나 시간이 작은게 앞으로)    끝나는 시간이 서로 같을 경우에는 회의의 시작시간으로 정렬한다.\n 위와 같이 정렬하는 이유는 회의 시작시간과 끝나는 시간이 같은 값이 있을 경우 더 많은 회의를 잡을 수 있기 때문이다.     가장 회의가 빨리 끝나는 회의가 첫 회의가 된다. 첫 회의의 끝나는 시간을 저장한다.\n  이후 for문을 돌리며 끝나는 회의시간 이후에 시작되는 회의시간을 차례대로 저장하며 count를 센다.\n  코드 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; vector\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; room; bool compare(pair\u0026lt;int, int\u0026gt; \u0026amp;p1, pair\u0026lt;int, int\u0026gt; \u0026amp;p2) { if (p1.second == p2.second) { return p1.first \u0026lt; p2.first; } return p1.second \u0026lt; p2.second; } int main() { int tc; cin \u0026gt;\u0026gt; tc; for (int i = 0; i \u0026lt; tc; i++) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; room.push_back(make_pair(a, b)); } sort(room.begin(), room.end(), compare); int cnt = 0; int end = 0; for (int i = 0; i \u0026lt; tc; i++) { if (end \u0026lt;= room[i].first) { end = room[i].second; cnt++; } } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; }  ","id":52,"section":"posts","summary":"C++ 적용 알고리즘 그리디 알고리즘 정렬 주의사항 처음 문제 풀 때 재귀를 통해 풀었으나 시간초과가 날 뿐더러 답도 틀렸었다.. 답은 왜 틀렸는지 의문이다. 문제풀이 해당","tags":["그리디 알고리즘"],"title":"백준 1931 - 회의실 배정","uri":"https://chlalstjd430.github.io/2020/02/%EB%B0%B1%EC%A4%801931/","year":"2020"},{"content":"Study TODO 리스트  이것도 공부하고 싶고, 저것도 공부하고 싶고 공부하고 싶은 내용들이 너무 많다\u0026hellip; 그래서 Study todo 리스트를 만들어보았다. 단기간 내에 모든 것을 하기 힘들겠지만 너무 조급해하지않고 차근차근 하나씩 공부해볼 예정이다.\n1. Spring\n  spring의 내부적인 개념\n  spring webflux\n  유어슈 프로젝트 코드 공부\n  reactive stream method 정리\n    spring batch\n  2. CI/CD\n 프로젝트에 적용해보기  3. Multi-Module 공부\n Multi-Module에 대하여 학습하고 프로젝트에 적용해보고 싶다.  4. Clean code\n 클린코드 정리중  5. DB 공부\n  MySQL\n 효율적인 ERM 작성을 위한 공부    6. HTTP 완벽 가이드(책) 공부\n 추후에 스터디를 열어볼까 생각중..  7. 알고리즘 공부\n 스터디 진행중(01.01 ~ 02.29)  8. 코틀린 공부\n  유어슈 프로젝트 때 코틀린으로 개발을 하였는데, 자바가 주언어여서 아직 서투르다..\n  yapp에서 스터디 예정\n  9. 도커 공부\n 생활코딩  10. AWS 공부\n  생활코딩\n  프리티어 버전으로 약간 경험보긴 했지만 정말 약간이라 더 학습이 필요하다.\n  11. TDD\n yapp에서 스터디 예정  12. 운영체제\n 학교 수업을 통해 공부할 예정  ","id":53,"section":"posts","summary":"Study TODO 리스트 이것도 공부하고 싶고, 저것도 공부하고 싶고 공부하고 싶은 내용들이 너무 많다\u0026hellip; 그래서 Study todo 리스트를 만들어보았다. 단기간 내에 모든 것","tags":["계획"],"title":"2020 학습하고 싶은 공부","uri":"https://chlalstjd430.github.io/2020/02/2020%EA%B3%84%ED%9A%8D_002/","year":"2020"},{"content":"Chapter 07 - 에러 핸들링  1. 리턴 코드 대신에 Exception을 사용하자!  기존에 flag를 이용하여 에러 코드를 리턴하거나 호출하는 측에서 예외처리를 하였다. 이런 방식은 예외처리를 잊어버리기 쉽고 로직을 헷갈리게 한다.\n// Bad public class DeviceController { ... public void sendShutDown() { DeviceHandle handle = getHandle(DEV1); // Check the state of the device if (handle != DeviceHandle.INVALID) { // Save the device status to the record field retrieveDeviceRecord(handle); // If not suspended, shut down if (record.getStatus() != DEVICE_SUSPENDED) { pauseDevice(handle); clearDeviceWorkQueue(handle); closeDevice(handle); } else { logger.log(\u0026quot;Device suspended. Unable to shut down\u0026quot;); } } else { logger.log(\u0026quot;Invalid handle for: \u0026quot; + DEV1.toString()); } } ... } // Good public class DeviceController { ... public void sendShutDown() { try { tryToShutDown(); } catch (DeviceShutDownError e) { logger.log(e); } } private void tryToShutDown() throws DeviceShutDownError { DeviceHandle handle = getHandle(DEV1); DeviceRecord record = retrieveDeviceRecord(handle); pauseDevice(handle); clearDeviceWorkQueue(handle); closeDevice(handle); } private DeviceHandle getHandle(DeviceID id) { ... throw new DeviceShutDownError(\u0026quot;Invalid handle for: \u0026quot; + id.toString()); ... } ... }  2. Try-Catch-Finally문을 먼저 쓰자    이로써 \u0026ldquo;Scrope 정의\u0026quot;가 가능하다.\n  ▽ 잘못된 input을 넣을 경우 StorageException을 제대로 던지는지 확인하는 테스트 코드\n  // Step 1: StorageException을 던지지 않으므로 이 테스트는 실패한다. @Test(expected = StorageException.class) public void retrieveSectionShouldThrowOnInvalidFileName() { sectionStore.retrieveSection(\u0026quot;invalid - file\u0026quot;); } public List\u0026lt;RecordedGrip\u0026gt; retrieveSection(String sectionName) { // dummy return until we have a real implementation return new ArrayList\u0026lt;RecordedGrip\u0026gt;(); } // Step 2: 이제 테스트는 통과한다. public List\u0026lt;RecordedGrip\u0026gt; retrieveSection(String sectionName) { try { FileInputStream stream = new FileInputStream(sectionName) } catch (Exception e) { throw new StorageException(\u0026quot;retrieval error\u0026quot;, e); } return new ArrayList\u0026lt;RecordedGrip\u0026gt;(); } // Step 3: Exception의 범위를 FileNotFoundException으로 줄여 정확히 어떤 Exception이 발생한지 체크하자. public List\u0026lt;RecordedGrip\u0026gt; retrieveSection(String sectionName) { try { FileInputStream stream = new FileInputStream(sectionName); stream.close(); } catch (FileNotFoundException e) { throw new StorageException(\u0026quot;retrieval error\u0026quot;, e); } return new ArrayList\u0026lt;RecordedGrip\u0026gt;(); }  3. Unchecked Exception을 사용하자    Unchecked Exception과 Checked Exception에 대하여 설명을 잘해준 블로그\n  상위 레벨 메소드에서 하위 레벨 메소드의 디테일에 대해 알아야 하기 때문에 캡슐화 또한 깨진다.\n  4. Exceptions로 문맥을 제공하자    예외가 발생한 이유와 좀 더 구체적인 Exception 타입을 제공하자.\n  catch문의 내용이 비슷하다면 하나로 묶어서 사용하자.\n  5. NULL을 리턴하지 말자    null을 리턴하고 싶은 생각이 들면 Special Case object를 리턴하자.\n Null Object Patter    서드파트 라이브러리 에서 null을 리턴할 가능성이 있다면 Exception을 던지거나 Special Case object를 리턴하자.\n  // Bad List\u0026lt;Employee\u0026gt; employees = getEmployees(); if (employees != null) { for(Employee e : employees) { totalPay += e.getPay(); } } // Good List\u0026lt;Employee\u0026gt; employees = getEmployees(); for(Employee e : employees) { totalPay += e.getPay(); } public List\u0026lt;Employee\u0026gt; getEmployees() { if( .. there are no employees .. ) return Collections.emptyList(); } }  6. NULL을 넘기지 말자    null을 메서드로 넘기는 것 또한 나쁘다\n  가장 이성적인 해법은 null을 파라미터로 받지 못하게 하는 것이다.\n  결론    예외처리는 가급적 Exception을 통해 처리를 해주는 것이 코드를 간결하게 한다.\n  null을 리턴하지도 넘기지도 말자.\n  출저 : https://github.com/Yooii-Studios/Clean-Code\n출저 : Clean Code 클린 코드 : 애자일 소프트웨어 장인 정신\n","id":54,"section":"posts","summary":"Chapter 07 - 에러 핸들링 1. 리턴 코드 대신에 Exception을 사용하자! 기존에 flag를 이용하여 에러 코드를 리턴하거나 호출하는 측에서 예외처리를 하였다. 이","tags":["클린코드"],"title":"Chapter 07 - 에러 핸들링","uri":"https://chlalstjd430.github.io/2020/02/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C_007/","year":"2020"},{"content":"문제링크 사용언어  c++  주의사항  문자열은 제일 앞부터 정해진 길이만큼 잘라야 합니다.  문제풀이 문제풀이를 위해서 다음과 같은 과정을 거치게 됩니다.\n  문자열을 자를 단위는 \u0026ldquo;1 ~ (문자열 길이/2)\u0026quot; 입니다.\n  문자열 단위별로 제공되는 문자열을 압축해봅니다.\n  \u0026ldquo;문자열 총 길이 - (문자열 총 길이 / 문자열 자를 단위) * 문자열 자를 단위\u0026rdquo; 만큼은 압축에 포함되지 않기 때문에 별도 추가합니다.\n  이전에 가장 짧았던 문자열과 길이를 비교합니다.\n  #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int solution(string s) { int len = s.length(); int answer = len; // i = 문자열을 자를 단위 for(int i = 1; i \u0026lt;= (len/2); i++){ string result = \u0026quot;\u0026quot;; string tmp = s.substr(0, i); // 처음 비교해야 될 문자열 int cnt = 1; // 압축이 없을 경우 1 // 자를 문자열 단위만큼 이동하며 비교 for(int j = i; j \u0026lt;= len; j+=i){ // 현재 압축이 있다면 if(tmp == s.substr(j, i)){ cnt++; } // 현재 압축이 없다면 else{ // 지금까지 압축이 없었을 경우 if(cnt == 1){ result += tmp; } // 지금까지 압축이 있었을 경우 else{ result += (to_string(cnt) + tmp); } tmp = s.substr(j, i); cnt = 1; } } result += s.substr((len/i) * i); // 문자열을 자르는 단위에 포함 안되는 문자열 추가 answer = min(answer, (int)result.length()); } return answer; }  ","id":55,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 문자열은 제일 앞부터 정해진 길이만큼 잘라야 합니다. 문제풀이 문제풀이를 위해서 다음과 같은 과정을 거치게 됩니다. 문자열을 자를 단","tags":null,"title":"프로그래머스 - 문자열 압축","uri":"https://chlalstjd430.github.io/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_003/","year":"2020"},{"content":" C++  적용 알고리즘  그리디 알고리즘  문제풀이 다음과 같은 과정을 거쳐 문제를 풀었습니다.\n  재귀를 통해 순열을 구한다.\n  해당 순열이 부등호를 충족시키는지 검사한다. (부등호를 충족시킬 경우 해당 값을 저장한다.)\n  저장된 순열 값들을 정렬 후 가장 작은 값과 큰 값을 출력한다.\n  위의 세 과정을 거치면 문제의 답을 쉽게 구할 수 있습니다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; char Inequality[11]; bool visited[11]; vector\u0026lt;char\u0026gt; num; vector\u0026lt;string\u0026gt; answer; int tc; // 3. Inequality에 저장되어있는 부등호에 맞게 비교되는 수열인지 확인 bool isPossible() { for (int i = 0; i \u0026lt; tc; i++) { if (Inequality[i] == '\u0026gt;') { if (!(num[i] - '0' \u0026gt; num[i+1] - '0')) return false; } else if(Inequality[i] == '\u0026lt;'){ if (!(num[i] - '0' \u0026lt; num[i+1] - '0')) return false; } } return true; } // 1. 순열을 만드는 재귀 함수 void dfs(int index) { // Inequality의 index값이 tc와 같아질 경우 부등호에 맞는지 검증 if (index == tc) { if (isPossible()) { string tmp = \u0026quot;\u0026quot;; int size = num.size(); for (int i = 0; i \u0026lt; size; i++) { tmp += num[i]; } answer.push_back(tmp); } return; } for (int i = 0; i \u0026lt; 10; i++) { if (visited[i]) continue; visited[i] = true; num.push_back(i + '0'); dfs(index+1); visited[i] = false; num.pop_back(); } } int main() { cin \u0026gt;\u0026gt; tc; for (int i = 0; i \u0026lt; tc; i++) { char a; cin \u0026gt;\u0026gt; a; Inequality[i] = a; } dfs(-1); // 매개변수는 dfs를 실행했을 때 dfs(0)부터 시작할수 있도록 -1값을 준다. // 3. 정렬 후 정답 출력 sort(answer.begin(), answer.end()); cout \u0026lt;\u0026lt; answer[answer.size() - 1] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; answer[0] \u0026lt;\u0026lt; endl; }  ","id":56,"section":"posts","summary":"C++ 적용 알고리즘 그리디 알고리즘 문제풀이 다음과 같은 과정을 거쳐 문제를 풀었습니다. 재귀를 통해 순열을 구한다. 해당 순열이 부등호를 충족시키는지 검사한다. (","tags":["그리디 알고리즘"],"title":"백준 2529 - 부등호","uri":"https://chlalstjd430.github.io/2020/02/%EB%B0%B1%EC%A4%802529/","year":"2020"},{"content":"Chapter 06 - 객체와 자료구조  1. 자료 추상화   목록 6-1 구체적인 Point 클래스  public class Point { public double x; public double y; }   목록 6-2 추상적인 Point 클래스  public interface Point { double getX(); double getY(); void setCartesian(double x, double y); double getR(); double getTheta(); void setPolar(double r, double theta); }  목록 6-1같은 경우 내부 구졸르 노출하고. 목록 6-2는 구현을 완전히 숨긴다. 구현을 완전히 감추기 위해서는 추상화 가 필요하다. set,get 메서드로 변수를 다룬다고 클래스가 아니라, 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스다.\n2. 자료/객체 비대칭   객체 는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 제공한다.\n  자료 구조 는 자료를 그대로 공개하며 별다른 함수는 제공하지 않는다.\n  두 정의는 본질적으로 상반되며 두 개념은 사실상 정반대이다.\n 목록 6-5 절차적인 도형 (Procedural Shape)  public class Square { public Point topLeft; public double side; } public class Rectangle { public Point topLeft; public double height; public double width; } public class Circle { public Point center; public double radius; } public class Geometry { public final double PI = 3.141592653589793; public double area(Object shape) throws NoSuchShapeException { if (shape instanceof Square) { Square s = (Square)shape; return s.side * s.side; } else if (shape instanceof Rectangle) { Rectangle r = (Rectangle)shape; return r.height * r.width; } else if (shape instanceof Circle) { Circle c = (Circle)shape; return PI * c.radius * c.radius; } throw new NoSuchShapeException(); } }  객체 지향 프로그래머가 위 코드를 보면 의아해 할 것이다. 하지만 Geometry 클래스에 둘레 길이를 구하기 위해서 perimeter() 함수를 추가하고 싶을 경우 도형 클래스는 아무 영향도 받지 않는다. 반대로 새 도형을 추가하고 싶다면 Geometry 클래스에 속한 함수를 모두 고쳐야 한다. 그래서 두 조건은 완전히 정반대라고 할 수 있다.\n 목록 6-6 다형적인 도형 (Polymorphic Shape)  public class Square implements Shape { private Point topLeft; private double side; public double area() { return side * side; } } public class Rectangle implements Shape { private Point topLeft; private double height; private double width; public double area() { return height * width; } } public class Circle implements Shape { private Point center; private double radius; public final double PI = 3.141592653589793; public double area() { return PI * radius * radius; } }  이번에는 목록 6-6을 살펴보자. 객체 지향적인 도형 클래스다. 새 도형을 추가해서 기존 함수에 아무런 영향을 미치지 않는다. 반면 새 함수를 추가하고 싶다면 도형 클래스 전부를 고쳐야 한다.\n즉, 객체 지향 코드에서 어려운 변경은 절차적인 코드에서 쉬우며, 절차적인 코드에서 어려운 변경은 객체 지향 코드에서 쉽다. 그러므로 상황에 맞게 클래스 \u0026amp; 객체 지향 기법을 사용하거나, 절차적인 코드와 자료 구조를 적절하게 사용하는 것이 좋다.\n3. 디미터 법칩  모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙이다. 좀 더 정확히 표현하자면, 디미터 법칙은 \u0026ldquo;클래스 C의 메서드 f는 다음과 같은 객체의 메서드만 호출해야 한다\u0026rdquo; 고 주장한다.\n  클래스 C\n  f가 생성한 객체\n  int f(){ Module module = new Modele(); module.메서드() }   f 인수로 넘어온 객체  int f(Module module){ module.메서드() }   C 인스턴스 변수에 저장된 객체  class C { private Module module; ... int f(){ module.메서드(); } }  하지만 위 객체에서 허용된 메서드가 반환하는 객체의 메서드는 호출하면 안 된다.\n 기차 충돌  final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();  위와 같은 코드는 일반적으로 조잡하다 여겨지므로 가능하면 피하자.\n  잡종 구조\n 절반은 객체 절반은 자료 구조인 잡종 구조는 가급적이면 지양하자. 이는 어중간한 설계처럼 보인다.    자료 전달 객체(DTO)\n  결론    클래스를 만들 때 가급적이면 추상화 과정을 거쳐 만드는 것이 더 바람직한 클래스 설계라고 생각이 든다.\n  무조건 객체가 옳은 것은 아니다. 상황에 맞게 객체나 자료 구조를 사용하여야 한다.\n  출저 : https://github.com/Yooii-Studios/Clean-Code\n출저 : Clean Code 클린 코드 : 애자일 소프트웨어 장인 정신\n","id":57,"section":"posts","summary":"Chapter 06 - 객체와 자료구조 1. 자료 추상화 목록 6-1 구체적인 Point 클래스 public class Point { public double x; public double y; } 목록 6-2 추상적인 Point 클래스 public interface Point { double getX(); double getY(); void setCartesian(double x, double y); double getR(); double getTheta(); void setPolar(double r, double","tags":["클린코드"],"title":"Chapter 06 - 객체와 자료구조","uri":"https://chlalstjd430.github.io/2020/02/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C_006/","year":"2020"},{"content":"문제링크 사용언어  c++  문제유형  힙/우선순위 큐  주의 사항   vector를 가지고 sort후 문제를 풀었더니 효율성에서 통과하지 못하였다. 이는 우선순위 큐를 선언하여 문제를 해결하였다.\n  단순 vector를 가지고 실행한 결과   priority_queue를 가지고 실행한 결과     문제풀이 #include \u0026lt;string\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int k; int cnt; priority_queue\u0026lt;int\u0026gt; pq; bool compare (int a, int b){ return a \u0026gt; b; } bool check_scoville(){ int top = -pq.top(); bool result = true; if(top \u0026lt; k) result = false; return result; } int solution(vector\u0026lt;int\u0026gt; scoville, int K) { int answer = 0; // 전역변수 초기화 k = K; cnt = 0; for(int i = 0; i \u0026lt; scoville.size(); i++){ pq.push(-scoville[i]); // priority_queue는 별도 설정이 없으면 가장 큰 값이 top에 있기 때문에 -를 붙여 값들을 저장한다. } while(true){ int size = pq.size(); // 모든 값들이 K를 넘거나, 1개 밖에 값이 안남은 경우 if(check_scoville() || size == 1 ){ break; } // 기존에 가장 스코빌 지수가 적은 2개를 삭제하고 섞은 음식의 스코빌 지수를 저장 int a = -pq.top(); // 가장 스코빌 지수가 적은 값, 저장할 때 -를 붙여 저장하였기 때문에 꺼낼 때 다시 -기호를 붙여 양수의 값을 받아온다. pq.pop(); int b = -pq.top(); // 두번째로 스코빌 지수가 적은 값 pq.pop(); int c = a + b*2; // 섞은 음식의 스코빌 지수를 저장 pq.push(-c); cnt++; // 한번 섞었으므로 cnt가 1증가 } // 모든 스코빌 지수가 K보다 클 경우 if(check_scoville()){ answer = cnt; } // 그렇지 못할 경우(스코빌 지수가 한개 남았을 때) else answer = -1; return answer; }  ","id":58,"section":"posts","summary":"문제링크 사용언어 c++ 문제유형 힙/우선순위 큐 주의 사항 vector를 가지고 sort후 문제를 풀었더니 효율성에서 통과하지 못하였다. 이는 우선순위 큐를 선언","tags":null,"title":"프로그래머스 - 더 맵게","uri":"https://chlalstjd430.github.io/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_002/","year":"2020"},{"content":"문제링크 사용언어  c++  문제유형   dfs/bfs\n  그래프\n  주의 사항   전역 변수를 사용할 경우 함수 내에 초기화 코드를 꼭 작성하자\n 제출하면 답이 틀리려서 30분넘게 씨름했는데..solution 함수 위에 다음과 같은 주석이 있었다\u0026hellip;   // 전역 변수를 정의할 경우 함수 내에 초기화 코드를 꼭 작성해주세요.\n   문제풀이 해당 문제에서는 DFS 혹은 BFS를 이용하여 풀 수 있는 문제이다. 나는 DFS를 선택하여 문제를 풀어보았다.\n#include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; vec; bool visited[102][102]; int M, N; int dx[] = {-1, 0, 0, 1}; int dy[] = {0, -1, 1, 0}; int area; void dfs(int x, int y, int color){ visited[x][y] = true; area++; for(int i = 0; i \u0026lt; 4; i++){ int mx = x + dx[i]; int ny = y + dy[i]; if(0 \u0026gt; mx || mx \u0026gt; M-1 || 0 \u0026gt; ny || ny \u0026gt; N-1) continue; if(!visited[mx][ny] \u0026amp;\u0026amp; vec[mx][ny] == color){ dfs(mx,ny,color); } } } // 전역 변수를 정의할 경우 함수 내에 초기화 코드를 꼭 작성해주세요. vector\u0026lt;int\u0026gt; solution(int m, int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; picture) { int number_of_area = 0; int max_size_of_one_area = 0; // 전역변수 초기화 area = 0; M = m; N = n; vec = picture; // visited 2차원 배열을 초기화 안해서 계속 틀렸었다..아마 해당 문제에서는 전역변수 설정시 자동으로 false 설정이 안되나보다. for(int i = 0; i \u0026lt; m; i++){ for(int j = 0; j \u0026lt; n; j++){ visited[i][j] = false; } } for(int i = 0; i \u0026lt; m; i++){ for(int j = 0; j \u0026lt; n; j++){ if(!visited[i][j] \u0026amp;\u0026amp; vec[i][j] \u0026gt; 0){ area = 0; dfs(i, j, vec[i][j]); number_of_area++; max_size_of_one_area = max(area, max_size_of_one_area); } } } vector\u0026lt;int\u0026gt; answer(2); answer[0] = number_of_area; answer[1] = max_size_of_one_area; return answer; }  ","id":59,"section":"posts","summary":"문제링크 사용언어 c++ 문제유형 dfs/bfs 그래프 주의 사항 전역 변수를 사용할 경우 함수 내에 초기화 코드를 꼭 작성하자 제출하면 답이 틀리려서 30분넘게 씨름했는데..so","tags":null,"title":"프로그래머스 - 카카오 프렌즈 컬러링북","uri":"https://chlalstjd430.github.io/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_001/","year":"2020"},{"content":" C++  적용 알고리즘  KMP 알고리즘  문제풀이 문제에서는 것은 단순 문자열 비교 알고리즘이 아니라 KMP나 라빈 카프 같은 효율적인 알고리즘을 요구합니다. 그러므로 저는 KMP 알고리즘을 이용하여 문제를 풀어보았습니다.\n코드는 다음과 같습니다. 설명은 주석으로 진행하겠습니다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; // vector를 사용하기 위해 선언 #include \u0026lt;string.h\u0026gt; // strlen을 사용하기 위해 선언 using namespace std; vector\u0026lt;int\u0026gt; place; // 문제에서 요구하는 답(겹치는 문자열의 개수, 위치)를 저장하기 위해 전역변수로 선언 // pattern(찾고자 하는 문자열)에 대하여 table을 만드는 함수 vector\u0026lt;int\u0026gt; makeTable(char *pattern) { int patternSize = strlen(pattern); vector\u0026lt;int\u0026gt; table(patternSize, 0); // pattern의 길이만큼 만들어줍니다. // table을 만드는 과정 int j = 0; for (int i = 1; i \u0026lt; patternSize; i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; pattern[i] != pattern[j]) { j = table[j - 1]; } if (pattern[i] == pattern[j]) { table[i] = ++j; // pattern i와 j의 값이 일치할 경우 table에 기록합니다. } } return table; } // parent(기존의 문자열)과 pattern(찾고자 하는 문자열)을 가지고 kmp 알고리즘을 수행합니다. void kmp(char *parent, char *pattern) { vector\u0026lt;int\u0026gt; table = makeTable(pattern); int parentSize = strlen(parent); int patternSize = strlen(pattern); int j = 0; for (int i = 0; i \u0026lt; parentSize; i++) { // parent와 pattern을 비교하기 때문에 parent길이만큼 확인 while (j \u0026gt; 0 \u0026amp;\u0026amp; parent[i] != pattern[j]) { j = table[j - 1]; } if (parent[i] == pattern[j]) { // j가 pattern의 길이-1과 같은 경우 if (j == patternSize - 1) { j = table[j]; place.push_back(i - patternSize + 2); // place vector에 인데스 저장 } // 길이가 같이 않을 경우 else { j++; } } } } int main() { char parent[1000002] = {}; char pattern[1000002] = {}; cin.getline(parent, 1000002); cin.getline(pattern, 1000002); kmp(parent, pattern); int size = place.size(); cout \u0026lt;\u0026lt; size \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; size; i++) { cout \u0026lt;\u0026lt; place[i] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }  ","id":60,"section":"posts","summary":"C++ 적용 알고리즘 KMP 알고리즘 문제풀이 문제에서는 것은 단순 문자열 비교 알고리즘이 아니라 KMP나 라빈 카프 같은 효율적인 알고리즘을 요구합니다. 그러므로 저는 KMP","tags":["KMP 알고리즘"],"title":"백준 1786 - 찾기","uri":"https://chlalstjd430.github.io/2020/02/%EB%B0%B1%EC%A4%801786/","year":"2020"},{"content":"Chapter 05 - 형식 맞추기  질서정연하고 깔끔하며, 일관적인 코드를 본다면 사람들에게 전문가가 짰다는 인상을 심어줄 수 있다. 반대로, 코드가 어수선해 보인다면 프로젝트 전반적으로 무성의한 태도로 작성했다고 생각할 것이다.\n1. 형식을 맞추는 목적  코드 형식은 의사소통의 일환이며 오늘 구현한 코드의 스타일과 가독성 수준은 용이성과 확장성에 지속적인 영향을 준다.\n 코드는 사라져도 스타일과 규율은 사라지지 않는다!\n 2. 적절한 행 길이를 유지하라(코드의 세로 길이)  코드의 줄이 길어질 수록 코드를 이해하기 어렵기 때문에 코드의 줄을 200줄 내외로 정하여 개발하는 것이 좋다. 물론 이것이 반드시 지켜져야 될 엄격한 규칙은 아니지만 확실히 코드의 줄이 작을 수록 보기좋다.\n  신문 기사처럼 작성하라\n 신문 기사는 최상단에 표제, 첫 문단에는 요약된 기사 내용, 그리고 내려갈수록 세세한 내용 들이 등장한다. 코드 또한 이와 마찬가지로 소스파일 이름(표제) 은 간단하면서도 설명이 가능하게 지어 이름만 보고도 올바른 모듈을 살펴보고 있는지를 판단 할 수 있도록 한다. 소스파일의 첫 부분(요약 내용) 은 고차원 개념과 알고리즘을 설명한다. 아래로 내려갈수록 의도를 세세하게 묘사하며, 마지막에는 가장 저차원 함수(getter,setter같은)와 세부 내역이 나오게 한다.    개념은 빈 행으로 분리하여라\n  코드의 각 줄은 수식이나 절을 나타내고, 여러 줄의 묶음은 완결된 생각 하나를 표현한다. 생각 사이에는 빈 행을 넣어 분리하자.\n  같은 코드에 대헤서 빈 행을 다르게 표현한 코드를 보자.\n  // 빈 행을 넣지 않을 경우 package fitnesse.wikitext.widgets; import java.util.regex.*; public class BoldWidget extends ParentWidget { public static final String REGEXP = \u0026quot;'''.+?'''\u0026quot;; private static final Pattern pattern = Pattern.compile(\u0026quot;'''(.+?)'''\u0026quot;, Pattern.MULTILINE + Pattern.DOTALL); public BoldWidget(ParentWidget parent, String text) throws Exception { super(parent); Matcher match = pattern.matcher(text); match.find(); addChildWidgets(match.group(1));} public String render() throws Exception { StringBuffer html = new StringBuffer(\u0026quot;\u0026lt;b\u0026gt;\u0026quot;); html.append(childHtml()).append(\u0026quot;\u0026lt;/b\u0026gt;\u0026quot;); return html.toString(); } }  // 빈 행을 넣을 경우 package fitnesse.wikitext.widgets; import java.util.regex.*; public class BoldWidget extends ParentWidget { public static final String REGEXP = \u0026quot;'''.+?'''\u0026quot;; private static final Pattern pattern = Pattern.compile(\u0026quot;'''(.+?)'''\u0026quot;, Pattern.MULTILINE + Pattern.DOTALL ); public BoldWidget(ParentWidget parent, String text) throws Exception { super(parent); Matcher match = pattern.matcher(text); match.find(); addChildWidgets(match.group(1)); } public String render() throws Exception { StringBuffer html = new StringBuffer(\u0026quot;\u0026lt;b\u0026gt;\u0026quot;); html.append(childHtml()).append(\u0026quot;\u0026lt;/b\u0026gt;\u0026quot;); return html.toString(); } }    세로 밀집도\n  줄바꿈이 개념을 분리한다면, 세로 밀집도는 연관성을 의미한다. 즉, 서로 밀집한 코드 행은 세로로 가까이 놓여야 한다.\n  같은 코드에 대헤서 세로 밀집도를 다르게 표현한 코드를 보자.\n  // 의미없는 주석으로 변수를 떨어뜨려 놓아서 한눈에 파악이 잘 안된다. public class ReporterConfig { /** * The class name of the reporter listener */ private String m_className; /** * The properties of the reporter listener */ private List\u0026lt;Property\u0026gt; m_properties = new ArrayList\u0026lt;Property\u0026gt;(); public void addProperty(Property property) { m_properties.add(property); }  // 의미 없는 주석을 제거함으로써 코드가 한눈에 들어온다. // 변수 2개에 메소드가 1개인 클래스라는 사실이 드러난다. public class ReporterConfig { private String m_className; private List\u0026lt;Property\u0026gt; m_properties = new ArrayList\u0026lt;Property\u0026gt;(); public void addProperty(Property property) { m_properties.add(property); }    수직거리\n  서로 밀접한 개념은 세로로 가까이 둬야 한다. 타당한 근거가 없다면 서로 밀접한 개념은 한 파일에 속해야 마땅하다. 같은 파일에 속할 정도로 밀접한 두 개념은 세로 거리로 연관성(한 개념을 이해하는데 다른 개념이 중요한 정도)을 표현한다.\n  변수 선언\n 우리가 만든 함수는 매우 짧으므로(chapter03 참고)변수는 사용하는 위치에 최대한 가까이 선언한다.  // InputStream이 함수 맨 처음에 선언 되어있다. private static void readPreferences() { InputStream is = null; try { is = new FileInputStream(getPreferencesFile()); setPreferences(new Properties(getPreferences())); getPreferences().load(is); } catch (IOException e) { try { if (is != null) is.close(); } catch (IOException e1) { } } }  // 모두들 알다시피 루프 제어 변수는 Test each처럼 루프 문 내부에 선언 public int countTestCases() { int count = 0; for (Test each : tests) count += each.countTestCases(); return count; }  // 드물지만, 긴 함수에서는 블록 상단 또는 루프 직전에 변수를 선언 할 수도 있다. ... for (XmlTest test : m_suite.getTests()) { TestRunner tr = m_runnerFactory.newTestRunner(this, test); tr.addListener(m_textReporter); m_testRunners.add(tr); invoker = tr.getInvoker(); for (ITestNGMethod m : tr.getBeforeSuiteMethods()) { beforeSuiteMethods.put(m.getMethod(), m); } for (ITestNGMethod m : tr.getAfterSuiteMethods()) { afterSuiteMethods.put(m.getMethod(), m); } } ...    인스턴스 변수\n 인스턴스 변수는 클래스 맨 처음에 선언한다.(자바의 경우)    종속 함수\n  한 함수가 다른 함수를 호출한다면(종속 함수) 두 함수는 세로로 가까이 배치한다. 일반적으로 함수 호출 종속성은 아래방향으로 유지하므로, 호출되는 함수를 호출하는 함수보다 뒤에 배치한다.\n  아래의 코드에서 makeResponse 함수에서 getPageNameOrDefault 함수를 호출하기 때문에 더 위에 작성되었다.\n  public class WikiPageResponder implements SecureResponder { protected WikiPage page; protected PageData pageData; protected String pageTitle; protected Request request; protected PageCrawler crawler; public Response makeResponse(FitNesseContext context, Request request) throws Exception { String pageName = getPageNameOrDefault(request, \u0026quot;FrontPage\u0026quot;); loadPage(pageName, context); if (page == null) return notFoundResponse(context, request); else return makePageResponse(context); } private String getPageNameOrDefault(Request request, String defaultPageName) { String pageName = request.getResource(); if (StringUtil.isBlank(pageName)) pageName = defaultPageName; return pageName; } ...      3. 가로 형식 맞추기  보통 행은 80자에서 120자까지로 제한한다.\n  가로 공백과 밀집도\n 가로로는 공백을 사용해 밀접/느슨한 개념을 표현한다  private void measureLine(String line) { lineCount++; // 흔히 볼 수 있는 코드인데, 할당 연산자 좌우로 공백을 주어 왼쪽,오른쪽 요소가 확실하게 구분된다. int lineSize = line.length(); totalChars += lineSize; // 반면 함수이름과 괄호 사이에는 공백을 없앰으로써 함수와 인수의 밀접함을 보여준다 // 괄호 안의 인수끼리는 쉼표 뒤의 공백을 통해 인수가 별개라는 사실을 보여준다. lineWidthHistogram.addLine(lineSize, lineCount); recordWidestLine(lineSize); }   연산자의 우선순위를 강조하기 위해서도 공백을 사용한다.    들여쓰기\n 짧은 함수여도 들여쓰기는 가독성을 위해 사용하자.  public CommentWidget(ParentWidget parent, String text){super(parent, text);} public CommentWidget(ParentWidget parent, String text){ super(parent, text); } 위의 코드보다 아래의 코드가 훨씬 보기 좋다.    4. 팀 규칙  팀에 속해있다면 가장 우선시 되어야 할 규칙은 팀 규칙이다.\n5. 책의 저자가 사용하는 규칙이 드러나는 코드  public class CodeAnalyzer implements JavaFileAnalysis { private int lineCount; private int maxLineWidth; private int widestLineNumber; private LineWidthHistogram lineWidthHistogram; private int totalChars; public CodeAnalyzer() { lineWidthHistogram = new LineWidthHistogram(); } public static List\u0026lt;File\u0026gt; findJavaFiles(File parentDirectory) { List\u0026lt;File\u0026gt; files = new ArrayList\u0026lt;File\u0026gt;(); findJavaFiles(parentDirectory, files); return files; } private static void findJavaFiles(File parentDirectory, List\u0026lt;File\u0026gt; files) { for (File file : parentDirectory.listFiles()) { if (file.getName().endsWith(\u0026quot;.java\u0026quot;)) files.add(file); else if (file.isDirectory()) findJavaFiles(file, files); } } public void analyzeFile(File javaFile) throws Exception { BufferedReader br = new BufferedReader(new FileReader(javaFile)); String line; while ((line = br.readLine()) != null) measureLine(line); } private void measureLine(String line) { lineCount++; int lineSize = line.length(); totalChars += lineSize; lineWidthHistogram.addLine(lineSize, lineCount); recordWidestLine(lineSize); } private void recordWidestLine(int lineSize) { if (lineSize \u0026gt; maxLineWidth) { maxLineWidth = lineSize; widestLineNumber = lineCount; } } public int getLineCount() { return lineCount; } public int getMaxLineWidth() { return maxLineWidth; } public int getWidestLineNumber() { return widestLineNumber; } public LineWidthHistogram getLineWidthHistogram() { return lineWidthHistogram; } public double getMeanLineWidth() { return (double)totalChars/lineCount; } public int getMedianLineWidth() { Integer[] sortedWidths = getSortedWidths(); int cumulativeLineCount = 0; for (int width : sortedWidths) { cumulativeLineCount += lineCountForWidth(width); if (cumulativeLineCount \u0026gt; lineCount/2) return width; } throw new Error(\u0026quot;Cannot get here\u0026quot;); } private int lineCountForWidth(int width) { return lineWidthHistogram.getLinesforWidth(width).size(); } private Integer[] getSortedWidths() { Set\u0026lt;Integer\u0026gt; widths = lineWidthHistogram.getWidths(); Integer[] sortedWidths = (widths.toArray(new Integer[0])); Arrays.sort(sortedWidths); return sortedWidths; } }  결론    코드를 작성할 때 가로/세로 규칙을 적용해가며 작성하자.\n  내가 당장 쉽게 짜는 코드보다 모두가 쉽게 볼 수있는 코드를 작성하자.\n  출저 : https://github.com/Yooii-Studios/Clean-Code\n출저 : Clean Code 클린 코드 : 애자일 소프트웨어 장인 정신\n","id":61,"section":"posts","summary":"Chapter 05 - 형식 맞추기 질서정연하고 깔끔하며, 일관적인 코드를 본다면 사람들에게 전문가가 짰다는 인상을 심어줄 수 있다. 반대로, 코드가 어수선해 보인다면 프로젝트","tags":["클린코드"],"title":"Chapter 05 - 형식 맞추기","uri":"https://chlalstjd430.github.io/2020/01/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C_005/","year":"2020"},{"content":"백준 문제 바로가기 사용 언어  C++  적용 알고리즘  위상 정렬 알고리즘  문제풀이 해당 문제에서 요구하는 것은 2가지이다.\n1. 모든 사람들이 만나는 시간 2. 1분도 쉬지 않고 달려야 하는 도로의 수 - 즉, 1번 요구사항에서 나온 시간에 딱 맞게 도착했을 때 거쳐간 도로의 수  2번째 요구사항이 나같은 경우 이해하기 힘들었는데, 쉽게 설명하자면 1번 요구사항에서 나온 시간만큼 걸려서 도착 도시에 도착했을 때, 시작 도시부터 거쳐간 도로의 개수를 구하면 된다. 해당 문제는 역추적 방식을 이용하면 문제를 쉽게 풀 수 있다.\n 먼저 지도 정보를 담을 클래스를 만들어주자.  class Edge { public: int node; int time; Edge(int node, int time) { this-\u0026gt;node = node; this-\u0026gt;time = time; } };  이후 위상 정렬 알고리즘을 사용하기 위한 변수들을 선언해준다.  int n; int start, goal; int inDegree[MAX]; int result[MAX], visited[MAX]; vector\u0026lt;Edge\u0026gt; map[MAX]; vector\u0026lt;Edge\u0026gt; reverseMap[MAX];   여기서 reverseMap이라는게 나온데 이는 visted배열과 함께 이후 역추적 때 사용하기 위해 선언한 것이다.  위상 정렬 함수를 선언해준다.  void topologySort() { queue\u0026lt;int\u0026gt; q; q.push(start); while (!q.empty()) { int current = q.front(); q.pop(); int mapSize = map[current].size(); for (int i = 0; i \u0026lt; mapSize; i++) { Edge next = Edge(map[current][i].node, map[current][i].time); int totalTime = next.time + result[current]; if (result[next.node] \u0026lt;= totalTime) { result[next.node] = totalTime; } if (--inDegree[next.node] == 0) { q.push(next.node); } } } cout \u0026lt;\u0026lt; result[goal] \u0026lt;\u0026lt; endl; }  역추적을 위한 함수를 선언해준다.  void traceBack() { queue\u0026lt;int\u0026gt; q; int count = 0; q.push(goal); while (!q.empty()) { int front = q.front(); q.pop(); int reverseMapSize = reverseMap[front].size(); for (int i = 0; i \u0026lt; size i++) { Edge next = Edge(reverseMap[front][i].node, reverseMap[front][i].time); if (result[front] - result[next.node] == next.time) { if (visited[next.node] == 0) { q.push(next.node); visited[next.node] = 1; } } } } cout \u0026lt;\u0026lt; count; }    이 함수안에서는 queue에 goal을 넣고 시작해서 시작점이 아닌 도착점에서 시작한다.\n  for문 안에 if조건문이 중요한 부분이다. 이미 result를 구했으므로 result 배열을 통해서 현재 도시까지의 거리 - 현재-1 도시까지의 거리 의 값이 다음 찾을 도시의 time정보랑 값이 같다면 해당 도로는 이전 거쳐가는 도로가 확실함으로 count를 증가시킨다.\n  이후 해동 도시를 queue에 다시 담지 않도록 방문 처리를 해준다음, queue에 담는다.\n  코드 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;algorithm\u0026gt; #define MAX 10002 using namespace std; class Edge { public: int node; int time; Edge(int node, int time) { this-\u0026gt;node = node; this-\u0026gt;time = time; } }; int n, start, goal; int inDegree[MAX], result[MAX], visited[MAX]; vector\u0026lt;Edge\u0026gt; map[MAX]; vector\u0026lt;Edge\u0026gt; reverseMap[MAX]; void topologySort() { queue\u0026lt;int\u0026gt; q; q.push(start); while (!q.empty()) { int current = q.front(); q.pop(); int mapSize = map[current].size(); for (int i = 0; i \u0026lt; mapSize; i++) { Edge next = Edge(map[current][i].node, map[current][i].time); int totalTime = next.time + result[current]; if (result[next.node] \u0026lt;= totalTime) { result[next.node] = totalTime; } if (--inDegree[next.node] == 0) { q.push(next.node); } } } cout \u0026lt;\u0026lt; result[goal] \u0026lt;\u0026lt; endl; } void traceBack() { queue\u0026lt;int\u0026gt; q; int count = 0; q.push(goal); while (!q.empty()) { int front = q.front(); q.pop(); int reverseMapSize = reverseMap[front].size(); for (int i = 0; i \u0026lt; size i++) { Edge next = Edge(reverseMap[front][i].node, reverseMap[front][i].time); if (result[front] - result[next.node] == next.time) { count++; if (visited[next.node] == 0) { q.push(next.node); visited[next.node] = 1; } } } } cout \u0026lt;\u0026lt; count; } int main() { int m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; m; i++) { int x, node, time; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; node \u0026gt;\u0026gt; time; map[x].push_back(Edge(node, time)); reverseMap[node].push_back(Edge(x, time)); inDegree[node]++; } cin \u0026gt;\u0026gt; start \u0026gt;\u0026gt; goal; topologySort(); traceBack(); }  ","id":62,"section":"posts","summary":"백준 문제 바로가기 사용 언어 C++ 적용 알고리즘 위상 정렬 알고리즘 문제풀이 해당 문제에서 요구하는 것은 2가지이다. 1. 모든 사람들이 만나는 시간 2. 1분도 쉬지 않고 달","tags":["위상 정렬 알고리즘"],"title":"백준 1948 - 임계경로","uri":"https://chlalstjd430.github.io/2020/01/%EB%B0%B1%EC%A4%801948/","year":"2020"},{"content":"Chapter 04 - 주석   나쁜 코드에 주석을 달지 마라. 새로 짜라. - 브라이언 W.커니핸, P.J.플라우거\n 1. 불필요한 주석을 없애자.    주석은 코드로 의도를 표현하지 못하여 실패를 만회하기 위해 사용하는 것이다. 즉, 주석은 언제나 실패를 의미한다.\n  오래된 코드일수록 코드를 유지보수해도 주석을 유지보수하는 경우는 거의 없다.\n  2. 주석 대신 코드로 의도를 표현하라!  // 직원에게 복지 혜택을 받을 자격이 있는지 검사한다. if ((emplotee.flags \u0026amp; HOURLY_FLAG) \u0026amp;\u0026amp; (employee.age \u0026gt; 65)  위 코드를 주석을 제거하고 함수 이름만으로 표현하면\nif (employee.isEligibleForFullBenefits())  다음과 같은 코드가 된다. 훨씬 보기 좋지 않은가?\n3. 필요한 주석    법적인 주석 : 소스 파일 첫머리에 들어가는 저작권 정보와 소유권 정보 등\n // Copyright (C) 2003, 2004, 2005 by Object Montor, Inc. All right reserved. // GNU General Public License\n   정보를 제공하는 주석\n// kk:mm:ss EEE, MMM dd, yyyy 형식이다. Pattern timeMatcher = Pattern.compile(\u0026quot;\\\\d*:\\\\d*\\\\d* \\\\w*, \\\\w*, \\\\d*, \\\\d*\u0026quot;);    의도를 설명하는 주석\n// 스레드를 대량 생성하는 방법으로 어떻게든 경쟁 조건을 만들려 시도한다. for (int i = 0; i \u0026gt; 2500; i++) { WidgetBuilderThread widgetBuilderThread = new WidgetBuilderThread(widgetBuilder, text, parent, failFlag); Thread thread = new Thread(widgetBuilderThread); thread.start(); }    결과를 경고하는 주석\n// 여유 시간이 충분하지 않다면 실행하지 마십시오. public void _testWithReallyBigFile() { ... }    중요성을 강조하는 주석\nString listItemContent = match.group(3).trim(); // 여기서 trim은 정말 중요하다. trim 함수는 문자열에서 시작 공백을 제거한다. // 문자열에 시작 공백이 있으면 다른 문자열로 인식되기 때문이다. new ListItemWidget(this, listItemContent, this.level + 1); return buildList(text.substring(match.end()));    공개 API에서 Javadocs\n 설명이 잘 된 공개 API는 참으로 유용하고 만족스럽다. 공개 API를 구현한다면 반드시 훌륭한 Javadocs 작성을 추천한다. 하지만 여느 주석과 마찬가지로 Javadocs 역시 독자를 오도하거나, 잘못 위치하거나, 그릇된 정보를 전달할 가능성이 존재하는 것 역시 잊으면 안 된다.    4. 나쁜 주석    주절거리는 주석(특별한 이유없이 달리는 주석)\n  같은 이야기를 중복하는 주석\n  오해의 여지가 있는 주석\n  의무적으로 다는 주석\n 모든 함수에 Javadocs를 달거나 모든 변수에 주석을 달아야 한다는 규칙은 어리석기 그지없다. 이런 주석은 코드를 복잡하게 만들며, 거짓말을 퍼뜨리고, 혼동과 무질서를 초래한다. 아래와 같은 주석은 아무 가치도 없다.  /** * * @param title CD 제목 * @param author CD 저자 * @param tracks CD 트랙 숫자 * @param durationInMinutes CD 길이(단위: 분) */ public void addCD(String title, String author, int tracks, int durationInMinutes) { CD cd = new CD(); cd.title = title; cd.author = author; cd.tracks = tracks; cd.duration = durationInMinutes; cdList.add(cd); }    소스 코드 관리 시스템이 해주는 것들\n  저자를 표시하는 주석\n  이력(기록)을 표시하는 주석\n  주석으로 처리한 코드\n 소스 코드 관리 시스템은 우리의 지난 코드들을 보관해준다.      위치를 표시하는 주석\n  닫는 괄호에 다는 주석\n  전역 정보(소스 코드 전체적으로 다는 주석)\n 주석은 반드시 근처에 있는 코드에 한해서만 기술하자.    비공개 코드에서 Javadocs\n 공개 API에서는 Javadocs가 유용하지만 공개하지 않을 코드이면 Javadocs는 쓸모가 없다.    결론    좋은 주석의 예시로 TODO 주석 같은게 있었지만, 이는 현재 다른 툴로 충분히 다룰수 있으므로 제외하였다.\n  사실 나쁜 주석으로 여러 예시들을 나열 했는데, 좋은 주석 예제들을 자세히보고 그 외의 주석들은 안다는게 편할듯 하다.\n  예전에야 주석이 잘 짜여져야 보기 편하다 했지만, 확실히 불필요한 주석은 가독성을 저해하고 유지보수가 되면서 왜곡된 정보들이 노출되는 것 같다. 앞으로 주석은 가급적 지양하고 함수명과 변수명을 통해 내 의도가 드러나도록 만들도록 해야겠다.\n  출저 : https://github.com/Yooii-Studios/Clean-Code\n출저 : Clean Code 클린 코드 : 애자일 소프트웨어 장인 정신\n","id":63,"section":"posts","summary":"Chapter 04 - 주석 나쁜 코드에 주석을 달지 마라. 새로 짜라. - 브라이언 W.커니핸, P.J.플라우거 1. 불필요한 주석을 없애자. 주석은 코드로 의도를 표현하지 못하여","tags":["클린코드"],"title":"Chapter 04 - 주석","uri":"https://chlalstjd430.github.io/2020/01/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C_004/","year":"2020"},{"content":"Chapter 03 - 함수  이번 시간에는 clean한 함수를 만드는 방법에 공부하였다. 어떻게 해야 좋은 함수를 만들 수 있는지 같이 확인 해 보자. 1. 함수는 작을수록(분리될수록) 좋다.   다음은 코드의 예시다, 위의 코드보다 아래 코드처럼 5줄 이내로 줄여서 사용할 것을 권장한다.  public static String renderPageWithSetupsAndTeardowns( PageData pageData, boolean isSuite) throws Exception { boolean isTestPage = pageData.hasAttribute(\u0026quot;Test\u0026quot;); if (isTestPage) { WikiPage testPage = pageData.getWikiPage(); StringBuffer newPageContent = new StringBuffer(); includeSetupPages(testPage, newPageContent, isSuite); newPageContent.append(pageData.getContent()); includeTeardownPages(testPage, newPageContent, isSuite); pageData.setContent(newPageContent.toString()); } return pageData.getHtml(); }  public static String renderPageWithSetupsAndTeardowns( PageData pageData, boolean isSuite) throws Exception { if (isTestPage(pageData)) includeSetupAndTeardownPages(pageData, isSuite); return pageData.getHtml(); }    에네르기파를 자제하자\n 우리는 간혹 if~else 문으로 depth가 3단계 넘어가는 경우도 보게된다. 그러한 코드는 가독성 뿐만 아니라 상당히 비효율적인 코드이다.    2. 함수는 하나의 기능만!   함수는 한 가지 기능만 해야한다. 한가지 함수내에서 기능들을 여러가지 나눌 수 있다면 그 함수는 하나가 아닌 여러작업을 하는 함수이다.  3. 함수 당 추상화 수준은 하나로    한 함수 내에서 추상화 수준은 섞이지 않고 동일해야 된다.\n  내려가기 규칙(위에서 아래로 코드 읽기)\n 함수 추상화 부분이 한번에 한단계씩 낮아지는 것이 가장 이상적이다.    4. switch는 댜형적 객체를 생성하는 코드 안에서만 사용을 권장한다.    물론 불가피한 상황에서는 적절히 이용할 수 있다.\n  switch를 abstract factory에 숨겨 다형적 코드를 생성하는 예\n  public abstract class Employee { public abstract boolean isPayday(); public abstract Money calculatePay(); public abstract void deliverPay(Money pay); } public interface EmployeeFactory { public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType; } public class EmployeeFactoryImpl implements EmployeeFactory { public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType { switch (r.type) { case COMMISSIONED: return new CommissionedEmployee(r) ; case HOURLY: return new HourlyEmployee(r); case SALARIED: return new SalariedEmploye(r); default: throw new InvalidEmployeeType(r.type); } } }  5. 함수 인수  함수에서 이상적인 인수 개수는 0개(무항). 인수는 코드 이해에 방해가 되는 요소이므로 최선은 0개이고, 차선은 1개뿐인 경우이다. 출력인수(함수의 반환 값이 아닌 입력 인수로 결과를 받는 경우)는 이해하기 어려우므로 왠만하면 쓰지 않는 것이 좋겠다.\n  많이 쓰이는 단항 형식\n  인수에 질문을 던지는 경우\n boolean fileExists(“MyFile”);    인수를 뭔가로 변환해 결과를 변환하는 경우\n InputStream fileOpen(“MyFile”);    이벤트 함수일 경우 (이 경우에는 이벤트라는 사실이 코드에 명확하게 드러나야 한다.)\n    플래그 인수\n bool값을 넘기는 것 자체가 함수의 기능이 하나가 아닌 것을 입증하게 된다. 즉, 플래그 인수는 쓰지말자.    단항 함수\n  단항 함수는 함수와 인수가 동사/명사 쌍을 이루어야 한다.\n writeField(name);    함수이름에 키워드(인수 이름)을 추가하면 인수 순서를 기억할 필요가 없다.\n assertExpectedEqualsActual(expected, actual);      다항 함수\n  단항 함수보다 한번에 알아보기 힘들다. 이항 함수의 경우에는 무조건적으로 지양해야 할 대상은 아니지만 가능하면 단항 함수로 변경하여 사용하자.\n  결론적으로 매개변수가 많아질수록 코드의 이해도는 떨어질 것이다.\n  많은 매개변수를 전달해야 할 때 클래스로 변수를 넘길수는 없는지 생각해보자.\n  때로는 String format 같은 인수 개수가 가변적인 경우도 필요하다.\n    6. 부수 효과를 일으키지 말자!  부수효과는 함수에서 한 가지 역할만 하겠다고 약속하고 거짓말을 하는 셈이다.\n7. 명령과 조회를 분리하라  함수는 객체 상태를 변겅하거나, 객체 정보를 반환하거나 둘 중 하나다. 둘 다 수행해서는 안된다.\n\u0026lt;br?\n8. 오류코드보다 예외를 사용하자  try/catch 를 사용하면 코드가 훨씬 간결해진다.\n if/else 로 정상 작동과 오류 처리 작동을 뒤섞는 구조는 정말 보기 안좋다. 그러므로 try/catch 로 예외 처리를 진행하자.  // 보기 안좋은 if/else로 정상/오류 작동 처리 if (deletePage(page) == E_OK) { if (registry.deleteReference(page.name) == E_OK) { if (configKeys.deleteKey(page.name.makeKey()) == E_OK) { logger.log(\u0026quot;page deleted\u0026quot;); } else { logger.log(\u0026quot;configKey not deleted\u0026quot;); } } else { logger.log(\u0026quot;deleteReference from registry failed\u0026quot;); } } else { logger.log(\u0026quot;delete failed\u0026quot;); return E_ERROR; }  // try/catch를 사용한 예외 처리 public void delete(Page page) { try { deletePageAndAllReferences(page); } catch (Exception e) { logError(e); } } private void deletePageAndAllReferences(Page page) throws Exception { deletePage(page); registry.deleteReference(page.name); configKeys.deleteKey(page.name.makeKey()); } private void logError(Exception e) { logger.log(e.getMessage()); }  9. 코드의 중복은 없애자   중복은 모든 소프트웨어에서 악의 근원이다. 중복된 코드는 하나의 함수로 만들어 재사용하자.  10. 구조적 프로그래밍  다익스크라의 구조적 프로그래밍의 원칙을 따르자면 모든 함수와 함수 내 모든 블록에 입구와 출구가 하나여야 된다. 즉, 함수는 return문이 하나여야 되며, 루프 안에서 break나 continue를 사용해선 안된며 goto는 절대로, 절대로 사용하지 말자. 함수가 클 경우에만 상당 이익을 제공하므로, 함수를 작게 만든다면 오히려 여러차례 사용하는 것이 함수의 의도를 표현하기 쉬워진다.\n그런데 구조적 프로그래밍의 목표와 규율은 공감하지만 함수가 작다면 위 규칙은 별 이익을 제공하지 못한다. 함수가 아주 클 때만 상당한 이익을 제공한다. 그러므로 함수를 작게 만든다면 간혹 return, break, continue를 사용해도 괜찮다. 오히려 때로는 단일 입/출구 규칙보다 의도를 표현하기 쉬워진다.\n결론    이 문서에서 다루지는 않았지만 chapter02 - 의미있는 이름에서 함수명을 짓는 방법도 나와있으니 참고하면 좋을 것 같다.\n  처음부터 완벽히 위의 10개의 규칙들을 적용하며 함수를 만들면 좋지만, 사람이다보니 처음부터 완벽할수는 없다. 차근차근 습관을 길들이도록 하자.\n  출저 : https://github.com/Yooii-Studios/Clean-Code\n출저 : Clean Code 클린 코드 : 애자일 소프트웨어 장인 정신\n","id":64,"section":"posts","summary":"Chapter 03 - 함수 이번 시간에는 clean한 함수를 만드는 방법에 공부하였다. 어떻게 해야 좋은 함수를 만들 수 있는지 같이 확인 해 보자. 1. 함수는 작을수록(분리될수록","tags":["클린코드"],"title":"Chapter 03 - 함수","uri":"https://chlalstjd430.github.io/2020/01/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C_003/","year":"2020"},{"content":"백준 문제 바로가기 사용 언어  C++  적용 알고리즘  다익스트라 알고리즘  문제풀이 이 문제는 얼핏 보면 단순 다익스트라 알고리즘을 한번 적용하여 풀 수 있는 문제로 보인다. 그러나 문제를 잘 들여다 보면 다음과 같은 문구를 확인할 수 있다.\n 세준이는 한번 이동했던 정점은 물론, 한번 이동했던 간선도 다시 이동할 수 있다. 하지만 반드시 최단 경로로 이동해야 한다는 사실에 주의하라. 1번 정점에서 N번 정점으로 이동할 때, 주어진 두 정점을 반드시 거치면서 최단 경로로 이동하는 프로그램을 작성하시오.\n 이 문구를 통해 우리는 반드시 주어진 두 정점을 거쳐 1부터 N번의 정점으로 이동하여야 한다. 위 문제를 해결하기 위해서 반드시 거쳐야 할 두 정점을 a,b라고 가정해보면 다음과 같은 과정이 나온다.\n1. a-\u0026gt;b로 이동하는 과정\n  1 -\u0026gt; a -\u0026gt; b -\u0026gt; N\n  dijkstra(1-\u0026gt;a) + dijkstra(a-\u0026gt;b) + dijkstra(b-\u0026gt;N)\n  2. b-\u0026gt;a로 이동하는 과정\n  1 -\u0026gt; b -\u0026gt; a -\u0026gt; N\n  dijkstra(1-\u0026gt;b) + dijkstra(b-\u0026gt;a) + dijkstra(a -\u0026gt; N)\n  총 2가지의 과정 중 적은 과정을 택하여 값으로 출력하면 된다. 그리하여 작성된 코드를 보면 다음과 같다.\n코드 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; const int INF = 1000000; // 과정을 진행할 때 INF가 3번 더해지는 경우가 있으니 이를 고려하여 INF값을 설정하여야 한다. const int MAX = 10000; int N, E; vector\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; graph[MAX]; int visited[MAX]; void dijkstra(int start) { visited[start] = 0; priority_queue\u0026lt;pair\u0026lt;int,int\u0026gt; \u0026gt; pq; pq.push(make_pair(0, start)); while (!pq.empty()) { int current = pq.top().second; int distance = -pq.top().first; pq.pop(); int size = graph[current].size(); for(int i = 0; i \u0026lt; size; i++){ int next = graph[current][i].first; int nextDistance = distance + graph[current][i].second; if (nextDistance \u0026lt; visited[next]) { visited[next] = nextDistance; pq.push(make_pair(-nextDistance, next)); } } } } // 초기화 void init() { fill(\u0026amp;visited[0], \u0026amp;visited[MAX - 1], INF); } // 다익스트라 알고리즘 실행 후 원하는 경로가 있는지 확인 int isINF(int goal) { if (visited[goal] == INF) return INF; else return visited[goal]; } int isPossible(int a, int b, int c, int d) { init(); dijkstra(a); int a_b = isINF(b); init(); dijkstra(b); int b_c = isINF(c); init(); dijkstra(c); int c_d = isINF(d); // 3개의 경로 중 하나라도 경로가 없으면 두 정점을 거쳐서 1부터 N까지 갈 수 없으므로 INF값을 리턴 if (a_b == INF || b_c == INF || c_d == INF) return INF; // 3개의 경로 모두 값이 있으면 합계 리턴 return a_b + b_c + c_d; } int main() { cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; E; int a, b, c; int start, goal; for (int i = 0; i \u0026lt; E; i++) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; // 무방향 그래프이므로 a에서 b로 가는 것과 b에서 a로 가는 것 둘다 받아야 한다. graph[a].push_back(make_pair(b, c)); graph[b].push_back(make_pair(a, c)); } cin \u0026gt;\u0026gt; start \u0026gt;\u0026gt; goal; int one = isPossible(1, start, goal, N); int two = isPossible(1, goal, start, N); int result = min(one, two); // 두가지 과정 모두 경로가 없으면 -1 리턴 cout \u0026lt;\u0026lt; (result \u0026gt;= INF ? -1 : result); }  ","id":65,"section":"posts","summary":"백준 문제 바로가기 사용 언어 C++ 적용 알고리즘 다익스트라 알고리즘 문제풀이 이 문제는 얼핏 보면 단순 다익스트라 알고리즘을 한번 적용하여 풀 수 있는 문제로 보인다. 그","tags":["다익스트라 알고리즘"],"title":"백준 1504 - 특정한 최단 경로","uri":"https://chlalstjd430.github.io/2020/01/%EB%B0%B1%EC%A4%801504/","year":"2020"},{"content":"Chapter 02 - 의미있는 이름  1. 의도가 담긴 이름을 짓자    변수명/메서드명을 통해서 역할을 추정할 수 있도록 이름을 짓자.\n  별도의 주석이 필요 없을 정도로 명확하게 이름을 짓자.\n  예시\n  int d; (X) -\u0026gt; int elapsedTimeInDays; public void getThem(){ ... } (x) -\u0026gt; public void getFlaggedCells(){ ... } (o)  2. 그릇된 정보를 피하자.    중의적인 의미를 피하자.\n  개발자에게 특수한 의미를 가지는 단어(Collection - list 등)는 실제 컨테이너가 해당 타입이 아닌 경우 변수명에 넣지 말자.\n  예시\n  String[] customerList; (x) -\u0026gt; List\u0026lt;String\u0026gt; customerList; (o)  3. 불용어(noise word)를 사용하지 말자.    클래스 이름에 Manager, Processor, Data, Info 같은 불용어를 붙이지 말자.\n  예시\n  Class StudentInfo{ ... } (x) -\u0026gt; Class Student{ ... } (o)  4. 발음하기 쉬운 이름을 사용하자.    숫자를 혼용하지 말자.\n  우리가 아는 단어 위주로 사용하자.\n  5. 검색하기 쉬운 이름을 사용하자.    상수는 static final과 같이 정희하여 사용하자.\n  변수의 이름은 변수의 범위에 비례하여 길어진다.\n  6. 클래스/메서드   변수\n 변수명에 해당 변수의 타입등을 적지말자.    클래스\n 명사 혹은 명사구(Custemer, Student)를 사용하고 동사는 사용하지 말자.    메서드\n  동사 혹은 동사구(updatePayment, deleteAccount)하자.\n  접근자는 get, 변경자는 set, 조건자는 is로 시작하자. (should, has 도 가능)\n  생성자를 오버로드할 경우 정적 팩토리 메서드를 사용하고 해당 생성자를 private로 선언한다.\n 예시  Complex fulcrumPoint = new Complex(23.0); (x) Complex fulcrumPoint = Complex.FromRealNumber(23.0); (o)      7. 함부로 이름을 줄이지 말자. GS (x) -\u0026gt; GasStation (o)  결론    사실 위의 내용 말고 \u0026quot; -를 사용하자\u0026rdquo;, \u0026ldquo;-를 하지말자\u0026rdquo; 라는 내용이 더 있다. 하지만 근본적인 내용들은 위의 내용과 겹칠 뿐더러 오히려 더 나열하면 헷갈릴 것 같아 정리 내용에서 제외하였다.\n  결론적으로 이름을 성의있게 지어야 한다는 것을 알게 되었다. 나 역시도 어느정도 성의 있게 지켜가며 이름을 지었지만 이번 공부를 통해 더 명확하게 이름을 지을 수 있을 것 같다.\n  출저 : https://github.com/Yooii-Studios/Clean-Code\n출저 : Clean Code 클린 코드 : 애자일 소프트웨어 장인 정신\n","id":66,"section":"posts","summary":"Chapter 02 - 의미있는 이름 1. 의도가 담긴 이름을 짓자 변수명/메서드명을 통해서 역할을 추정할 수 있도록 이름을 짓자. 별도의 주석이 필요 없을 정도로 명확하게 이름을 짓자","tags":["클린코드"],"title":"Chapter 02 - 의미있는 이름","uri":"https://chlalstjd430.github.io/2020/01/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C_002/","year":"2020"},{"content":"01.21부로 클린 코드에 대하여 요약한 게시글을 보고 나만의 후기를 남길 예정이다.\n책은 우선시 되는 다른 공부가 어느정도 정리되면 그 때 읽어볼 예정이다.\nChapter 01 - 깨끗한 코드  1. 나쁜 코드  우리는 종종 당장의 문제를 해결하기 위해 나쁜 코드(가독성,효율성,등 여러면에서)를 작성하고는 한다. 이러한 코드들은 당장의 문제를 해결해 줄 뿐이지 추후 결과적으로는 우리에게 최악의 상황을 초래한다. 그렇기 때문에 초기에 나쁜 코드가 아닌 클린한 코드를 작성하는 것이 중요하다.\n2. 보이스카우트 규칙   \u0026ldquo;Leave the campground cleaner than you found it.\u0026rdquo;\n 위 문구는 보이스카우트에서 인용된 문구이다. 이 말을 우리(프로그래머)의 언어로 받아 들이면 다음과 같다.\n \u0026ldquo;눈 앞에 더러운 코드가 보이면 조금이라도(변수명,if문 한줄) 개선하여라\u0026rdquo;\n 한번에 모든걸 하려면 어렵다. 그러나 조금씩이라도 변화를 지속하다보면 그것이 습관이되고 결국에는 근본적인 문제점 또한 해결 될 것이다.\n3. 같이 읽어보면 좋은 책  클린 코드에서는 이 책이 Agile Sorfware Development의 프리퀄이라고 말하였다. 추후에 해당 책도 읽어보면 좋을 듯 하다.\n결론    깨끗한 코드를 만들기 위해서 무작정 당장의 문제 해결에 집중하지 말고 장기적인 관점에서 코드를 작성하다.\n  보이스카우트 규칙에 따라 많이는 아니더라도 조금씩이라도 코드를 고쳐나가자.\n  Agile Sorfware Development을 시간이 되면 읽어보자.\n  출저 : https://github.com/Yooii-Studios/Clean-Code\n출저 : Clean Code 클린 코드 : 애자일 소프트웨어 장인 정신\n","id":67,"section":"posts","summary":"01.21부로 클린 코드에 대하여 요약한 게시글을 보고 나만의 후기를 남길 예정이다. 책은 우선시 되는 다른 공부가 어느정도 정리되면 그 때 읽어볼 예정이다. Chapter 01 -","tags":["클린코드"],"title":"Chapter 01 - 깨끗한 코드","uri":"https://chlalstjd430.github.io/2020/01/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C_001/","year":"2020"},{"content":"백준 문제 바로가기 사용 언어  C++  적용 알고리즘  다이나믹 프로그래밍  문제풀이   포도주 잔을 선택하면 그 잔에 들어있는 포도주는 모두 마셔야 하고, 마신 후에는 원래 위치에 다시 놓아야 한다. 연속으로 놓여 있는 3잔을 모두 마실 수는 없다.   문제의 조건 중 위 두가지 조건으로 보아 일정한 규칙을 세울 수 있다.\n포도주를 마실때 총 3가지 조건으로 나누어지게 된다.\n첫번째 포도주인 경우\n 현재까지의 포도주 양 = 현재 포도주 양 + 이전까지의 포도주 양\n 두번째 포도주인 경우\n 현재까지의 포도주 양 = 현재 포도주 양 + 이전 포도주 양 + 현재-3까지의 포도주 양\n 세번째 포도주인 경우(건너띄는 포도주)\n 현재까지의 포도주 양 = 이전까지의 포도주 양\n 이를 통해 다음과 같은 코드가 나오게 되었다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; long long int podo[10002]; long long int dp[10002]; int main() { int n; long long int maxPodo; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; podo[i]; } if (n == 1) { cout \u0026lt;\u0026lt; podo[1]; return 0; } else if (n == 2) { cout \u0026lt;\u0026lt; max(podo[1], (podo[1] + podo[2])); return 0; } dp[1] = podo[1]; dp[2] = dp[1] + podo[2]; maxPodo = dp[2]; for (int i = 3; i \u0026lt;= n; i++) { dp[i] = max(podo[i] + dp[i - 2], max((podo[i] + podo[i - 1] + dp[i - 3]), dp[i-1]) ); maxPodo = max(maxPodo, dp[i]); } cout \u0026lt;\u0026lt; maxPodo; }  ","id":68,"section":"posts","summary":"백준 문제 바로가기 사용 언어 C++ 적용 알고리즘 다이나믹 프로그래밍 문제풀이 포도주 잔을 선택하면 그 잔에 들어있는 포도주는 모두 마셔야 하고, 마신 후에는 원래 위치에","tags":["다이나믹 프로그래밍"],"title":"백준 2156 - 포도주 시식","uri":"https://chlalstjd430.github.io/2020/01/%EB%B0%B1%EC%A4%802156/","year":"2020"},{"content":"","id":69,"section":"posts","summary":"","tags":["다이나믹 프로그래밍"],"title":"백준 9465 - 스티커","uri":"https://chlalstjd430.github.io/2020/01/%EB%B0%B1%EC%A4%809465/","year":"2020"},{"content":"","id":70,"section":"posts","summary":"","tags":["다이나믹 프로그래밍"],"title":"백준 2579 - 계단 오르기","uri":"https://chlalstjd430.github.io/2020/01/%EB%B0%B1%EC%A4%802579/","year":"2020"},{"content":"","id":71,"section":"posts","summary":"","tags":["다이나믹 프로그래밍"],"title":"백준 1149 - RGB거리","uri":"https://chlalstjd430.github.io/2020/01/%EB%B0%B1%EC%A4%801149/","year":"2020"},{"content":"백준 문제 바로가기  C++  적용 알고리즘  최소 스패닝 트리 합집합 찾기  문제풀이 일반적으로 난이도가 쉬운 최소 스패닝 트리 문제를 풀 때, 가중치 값 기준으로 정렬 후 크르스칼 알고리즘을 적용하면 문제를 쉽게 풀 수 있습니다. 그러나 해당 문제는 가중치 값 기준으로 정렬할 때 다른 문제와 다르다는 것을 느낄 수 있습니다.\n먼저 정렬을 위해서 문제 중 이 한 문장을 잘 이해할 필요가 있겠습니다\n 두 행성 A(xA, yA, zA)와 B(xB, yB, zB)를 터널로 연결할 때 드는 비용은 min(|xA-xB|, |yA-yB|, |zA-zB|)이다.\n 이 문장을 통해 최종적으로 x,y,z 값을 각각 기준으로 정렬후 모든 값들을 vector에 넣어 정렬한 뒤 크루스칼 알고리즘을 적용하면 답이 나올 것을 예상할수 있었습니다.\n먼저 Planet 클래스와, Planet 클래스를 x,y,z 값으로 정렬 후 담아줄수 있는 Edge 클래스를 생성합니다.\n//행성 정보를 담아줄 Planet 클래스 class Planet { public: int node[3]; int index; Planet(int x, int y, int z, int index) { node[0] = x; node[1] = y; node[2] = z; this-\u0026gt;index = index; } }; //Planet Class를 x,y,z기준으로 각각 sort를 위해 만들어줍니다. bool cmpX (Planet \u0026amp;planet, Planet \u0026amp;planet2) { return planet.node[0] \u0026lt; planet2.node[0]; } bool cmpY(Planet \u0026amp;planet, Planet \u0026amp;planet2) { return planet.node[1] \u0026lt; planet2.node[1]; } bool cmpZ(Planet \u0026amp;planet, Planet \u0026amp;planet2) { return planet.node[2] \u0026lt; planet2.node[2]; } //sort이후 가중치 정보를 담아줄 Edge 클래스를 만들어줍니다. class Edge { public: int x, y; int value; Edge(int x, int y, int value) { this-\u0026gt;x = x; this-\u0026gt;y = y; this-\u0026gt;value = value; } bool operator \u0026lt;(Edge \u0026amp;edge) { return this-\u0026gt;value \u0026lt; edge.value; } };  이후 앞서 말씀드린 것처럼 x,y,z 기준으로 Plaent Class를 정렬 후 Edge Class에 담아 최종적으로 Edge Class를 정렬 후 크루스칼 알고리즘을 적용하면 결과가 나옵니다.\n//정렬 과정 sort(planet.begin(), planet.end(), cmpX); for (int i = 0; i \u0026lt; N - 1; i++) { edge.push_back(Edge(planet[i].index, planet[i + 1].index, abs(planet[i].node[0] - planet[i + 1].node[0]))); } sort(planet.begin(), planet.end(), cmpY); for (int i = 0; i \u0026lt; N - 1; i++) { edge.push_back(Edge(planet[i].index, planet[i + 1].index, abs(planet[i].node[1] - planet[i + 1].node[1]))); } sort(planet.begin(), planet.end(), cmpZ); for (int i = 0; i \u0026lt; N - 1; i++) { edge.push_back(Edge(planet[i].index, planet[i + 1].index, abs(planet[i].node[2] - planet[i + 1].node[2]))); } sort(edge.begin(), edge.end());  최종코드 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; class Planet { public: int node[3]; int index; Planet(int x, int y, int z, int index) { node[0] = x; node[1] = y; node[2] = z; this-\u0026gt;index = index; } }; bool cmpX (Planet \u0026amp;planet, Planet \u0026amp;planet2) { return planet.node[0] \u0026lt; planet2.node[0]; } bool cmpY(Planet \u0026amp;planet, Planet \u0026amp;planet2) { return planet.node[1] \u0026lt; planet2.node[1]; } bool cmpZ(Planet \u0026amp;planet, Planet \u0026amp;planet2) { return planet.node[2] \u0026lt; planet2.node[2]; } class Edge { public: int x, y; int value; Edge(int x, int y, int value) { this-\u0026gt;x = x; this-\u0026gt;y = y; this-\u0026gt;value = value; } bool operator \u0026lt;(Edge \u0026amp;edge) { return this-\u0026gt;value \u0026lt; edge.value; } }; int getParent(int parent[], int x) { if (parent[x] == x) return x; return getParent(parent, parent[x]); } void unionParent(int parent[], int x, int y) { x = getParent(parent, x); y = getParent(parent, y); if (x \u0026gt; y) parent[x] = y; else parent[y] = x; } bool findParent(int parent[], int x, int y) { x = getParent(parent, x); y = getParent(parent, y); if (x == y) return true; return false; } int dist[100002]; vector\u0026lt;Planet\u0026gt; planet; vector\u0026lt;Edge\u0026gt; edge; int main() { int N; int x, y, z; int sum = 0; cin \u0026gt;\u0026gt; N; for (int i = 0; i \u0026lt; N; i++) { cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; z; planet.push_back(Planet(x, y, z, i)); } for (int i = 0; i \u0026lt;= N; i++) { dist[i] = i; } sort(planet.begin(), planet.end(), cmpX); for (int i = 0; i \u0026lt; N - 1; i++) { edge.push_back(Edge(planet[i].index, planet[i + 1].index, abs(planet[i].node[0] - planet[i + 1].node[0]))); } sort(planet.begin(), planet.end(), cmpY); for (int i = 0; i \u0026lt; N - 1; i++) { edge.push_back(Edge(planet[i].index, planet[i + 1].index, abs(planet[i].node[1] - planet[i + 1].node[1]))); } sort(planet.begin(), planet.end(), cmpZ); for (int i = 0; i \u0026lt; N - 1; i++) { edge.push_back(Edge(planet[i].index, planet[i + 1].index, abs(planet[i].node[2] - planet[i + 1].node[2]))); } sort(edge.begin(), edge.end()); for (int i = 0; i \u0026lt; edge.size(); i++) { if (!(findParent(dist, edge[i].x, edge[i].y))) { sum += edge[i].value; unionParent(dist, edge[i].x, edge[i].y); } } cout \u0026lt;\u0026lt; sum; }  추가적인 질문사항 있으시면 언제든지 댓글 달아주시면 감사하겠습니다😊\n","id":72,"section":"posts","summary":"백준 문제 바로가기 C++ 적용 알고리즘 최소 스패닝 트리 합집합 찾기 문제풀이 일반적으로 난이도가 쉬운 최소 스패닝 트리 문제를 풀 때, 가중치 값 기준으로 정렬 후 크르스칼","tags":["최소 스패닝 트리"],"title":"백준 2887 - 행성터널","uri":"https://chlalstjd430.github.io/2020/01/%EB%B0%B1%EC%A4%802887/","year":"2020"},{"content":"","id":73,"section":"posts","summary":"","tags":["이진 트리 알고리즘"],"title":"백준 1991 - 트리 순회","uri":"https://chlalstjd430.github.io/2020/01/%EB%B0%B1%EC%A4%801991/","year":"2020"},{"content":"IT 동아리 정보  업데이트 날짜 : 20 - 07 - 02\n1. YAPP   6-7월 / 12-1월\n  기획자 / 디자이너 / 개발자가 협업하는 환경\n  2. NEXTERS   5월 / 11월\n  별도의 기획자가 없고, 디자이너/개발자가 협업하는 환경\n  3. SOPT   3월 / 9월\n  추가적으로 학습하는 기간이 주어지고 하나의 주제를 학습하고 프로젝트를 시행한다.\n  새로운 분야를 배워보고싶으신 분들 추천\n  4. 프로그라피   2-3월 / 8월\n  주위에 정보가 없습니다\u0026hellip;\n  5. Mash-Up   3월 / 8-9월\n  각 직군별 스터디/모임이 존재하고, 학습하는 시간도 있다.\n  최종적으로 전체가 프로젝트를 진행하는 환경\n  6. DEPROMEET   2월 / 9월\n  주위에 정보가 없습니다\u0026hellip;\n  7. 멋쟁이사자처럼   2월\n  하나의 언어 및 프레임워크를 가르쳐주는 환경(루비 온 레일즈)에서 최근 파이썬으로 바꼈다고 한다.)\n  8. DDD   6 ~ 9 월\n  직장인 9 : 학생 1 의 비율로 진행된다는 특징.\n  위에 적힌 날짜는 대략적인 날짜이며 상황에 맞게 모든 동아리들이 모집 시즌이 변경되니 참고해주세요~.\n그 외 IT 활동  1. S/W 마에스트로(1월 중순 - 2월 중순)  정부에서 진행하는 IT 최고의 대외활동  2. 우아한 테크코스(10월 ~ 11월)  우아한형제에서 진햏하는 인턴십  3. 우아한 테크캠프(5월)   우아한형제에서 진행하는 캠프, 1,2기는 서버직군, 3기는 프론트 직군 캠프를 진행한다고 한다.\n  지인피셜로 합격자중 절반이 우아한 형제에 입사했다는..\n  4. 스마일 게이트 서버캠프(11월)   방학기간 내에 다양한 학습과 프로젝트를 진행하는 캠프\n  대학생들 추천\n  5. 42SEOUL   정부 제공\n  비전공/전공 상관 없이 2년동안 지원금을 받으며 프로그래밍을 공부하는 환경\n  6. SSAFY(삼성 청년 소프트웨어 아카데미)  삼성에서 주관하여 알고리즘,프로젝트를 진행한다.  7. Slipp 스터디(6-7월/12-1월)  전문적인 분들이 이끌어주느 IT 스터디  ","id":74,"section":"posts","summary":"IT 동아리 정보 업데이트 날짜 : 20 - 07 - 02 1. YAPP 6-7월 / 12-1월 기획자 / 디자이너 / 개발자가 협업하는 환경 2. NEXTERS 5월 / 11월 별도의 기획자가 없고, 디자이","tags":["IT 정보","IT 동아리"],"title":"IT 동아리 정보","uri":"https://chlalstjd430.github.io/2020/01/%EC%A0%95%EB%B3%B4_001/","year":"2020"},{"content":"2020년 학업 계획  20-07-02 업데이트\n1. IT동아리\u0026lt;\n  YOURSSU 활동중(19.11.01~ )\n  YAPP\n  지원중(1.18 면접)\n  최종 합격(1.22)\n    NEXTERS\n 최종 합격(6월)    2. S/W 마에스트로\n  1월 중순~말 서류 접수\n  서류 준비중(1.22~)\n  코딩 데스트 1,2차 통과\n  최종 면접 탈락\u0026hellip;(5월)\n 가장 준비를 많이하고 기대했던 활동이라 상심이 컷다\u0026hellip;      3. 클린코드 공부\n   블로그 읽기    Clean Code 책 읽기    클린코드 정리중\n  4. Spring Framework 더 자유롭게 다루기\n   프로젝트 하면서 필요한 부분 학습    인프런 강의    Spring Core 강의 듣는 중(7월)\n  Spring Boot 강의 듣는 중(7월)\n    5. JPA/DB 공부\n   프로젝트 하면서 필요한 부분 학습    인프런 강의    초반에 강의를 들었으나 더욱 심도있는 공부가 필요함\n  queryDSL 공부해야할 듯(7월)\n    6. 학점 4.0  평균 학점 3.5이상 유지하기\n 1학기 학점 : 4.13(7월)    7. 여름/겨울에 인턴활동\n  S/W마에스트로 활동중이라면 겨울에라도 지원하기\n  프로그래머스 여름 인턴쉽 지원\n 딜리셔스(신상마켓) 최종 면접 탈락(6월)    네오위즈 인턴십 지원\n  서류 합\n  코딩 테스트 탈락(5월)\n 600점 만점 중 560점이어서 코테는 무조건 통과라고 생각했는데\u0026hellip;단톡방 사람들 보니 580 이상부터 합격했다고 한다\u0026hellip;.진짜 너무하네 ㅜㅜ        8. 꾸준한 알고리즘 공부\n  스터디 활동 (01/01 ~ 02.28 진행중)\n  github\n  9. 프로젝트 실제 런칭 해보기\n  TEAMPLAY 런칭!\n  안드로이드 런칭 완료\n  그러나 미흡한 부분이 많아 사실 런칭했다하기도 부끄러움\u0026hellip;\n    10. 꾸준한 블로그 포스팅\n  최소 1일 1포스팅\n 7월 피드백 : 1일 1포스팅까지는 무리지만 나름 꾸준하게 글은 작성 중    11. S/W 관련 공모전 나가보기\n 국방 데이터 공모전 준비  12. ACM 도전\n  교내 입상이라도..\n 현재 상황에 힘들 듯 ㅜㅜ    13. AWS 공부\n  6월 : RDS, S3, EC2, CodeDeploy 사용\n  심도있는 공부가 필요하다\n  14. 교내 멘토 활동 지원해보기\n 공고가 안 뜬다 ㅜㅜ(7월)  15. 깃에 1일 1커밋\n 이 부분은 무조건적인 커밋은 아님, 하루도 빠짐없이 공부는 하고 있다. 다만, 커밋을 올리지 않는 날이 있을 뿐(개인적인 공부나, gitlab사용중일 때)  16. 삼성 SW 역량 테스트(A형) 취득\n 일단 알고리즘 공부좀 다시\u0026hellip;(7월)  17. TDD로 개발하기!\n 이 부분 정말 안지켜지고 있다 ㅜㅜ\u0026hellip;,외부 강의라도 들을까 생각중..(7월)  ","id":75,"section":"posts","summary":"2020년 학업 계획 20-07-02 업데이트 1. IT동아리\u0026lt; YOURSSU 활동중(19.11.01~ ) YAPP 지원중(1.18 면접) 최종 합격(1.22) NEXTERS 최종 합격(6월)","tags":["계획"],"title":"2020 학업 계획","uri":"https://chlalstjd430.github.io/2020/01/2020%EA%B3%84%ED%9A%8D_001/","year":"2020"},{"content":"","id":76,"section":"posts","summary":"","tags":["리액티브 프로그래밍"],"title":"Reactive Programming이란?","uri":"https://chlalstjd430.github.io/2020/01/%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_reactive_programming/","year":"2020"},{"content":"","id":77,"section":"posts","summary":"","tags":["크루스칼 알고리즘"],"title":"백준6497 - 전력난","uri":"https://chlalstjd430.github.io/2020/01/%EB%B0%B1%EC%A4%806497/","year":"2020"}],"tags":[{"title":"IT 동아리","uri":"https://chlalstjd430.github.io/tags/it-%EB%8F%99%EC%95%84%EB%A6%AC/"},{"title":"IT 정보","uri":"https://chlalstjd430.github.io/tags/it-%EC%A0%95%EB%B3%B4/"},{"title":"JWT","uri":"https://chlalstjd430.github.io/tags/jwt/"},{"title":"KMP 알고리즘","uri":"https://chlalstjd430.github.io/tags/kmp-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"title":"spring webflux","uri":"https://chlalstjd430.github.io/tags/spring-webflux/"},{"title":"계획","uri":"https://chlalstjd430.github.io/tags/%EA%B3%84%ED%9A%8D/"},{"title":"그리디 알고리즘","uri":"https://chlalstjd430.github.io/tags/%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"title":"다이나믹 프로그래밍","uri":"https://chlalstjd430.github.io/tags/%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"},{"title":"다익스트라 알고리즘","uri":"https://chlalstjd430.github.io/tags/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"title":"리액티브 프로그래밍","uri":"https://chlalstjd430.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"},{"title":"브루트 포스트","uri":"https://chlalstjd430.github.io/tags/%EB%B8%8C%EB%A3%A8%ED%8A%B8-%ED%8F%AC%EC%8A%A4%ED%8A%B8/"},{"title":"알고리즘","uri":"https://chlalstjd430.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"title":"위상 정렬 알고리즘","uri":"https://chlalstjd430.github.io/tags/%EC%9C%84%EC%83%81-%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"title":"이진 트리 알고리즘","uri":"https://chlalstjd430.github.io/tags/%EC%9D%B4%EC%A7%84-%ED%8A%B8%EB%A6%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"title":"최소 스패닝 트리","uri":"https://chlalstjd430.github.io/tags/%EC%B5%9C%EC%86%8C-%EC%8A%A4%ED%8C%A8%EB%8B%9D-%ED%8A%B8%EB%A6%AC/"},{"title":"크루스칼 알고리즘","uri":"https://chlalstjd430.github.io/tags/%ED%81%AC%EB%A3%A8%EC%8A%A4%EC%B9%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"title":"클린코드","uri":"https://chlalstjd430.github.io/tags/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C/"}]}