{"categories":[{"title":"2020 계획","uri":"https://chlalstjd430.github.io/categories/2020-%EA%B3%84%ED%9A%8D/"},{"title":"IT 정보","uri":"https://chlalstjd430.github.io/categories/it-%EC%A0%95%EB%B3%B4/"},{"title":"리액티브 프로그래밍","uri":"https://chlalstjd430.github.io/categories/%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"},{"title":"백준 문제풀이","uri":"https://chlalstjd430.github.io/categories/%EB%B0%B1%EC%A4%80-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/"},{"title":"스터디","uri":"https://chlalstjd430.github.io/categories/%EC%8A%A4%ED%84%B0%EB%94%94/"},{"title":"클린코드","uri":"https://chlalstjd430.github.io/categories/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C/"},{"title":"프로그래머스 문제풀이","uri":"https://chlalstjd430.github.io/categories/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/"}],"posts":[{"content":" 문제링크 \n사용언어  c++  \n\n주의사항  문제의 제한사항을 주의깊게 보자\n 제한사항\n 전체 학생의 수는 2명 이상 30명 이하입니다.\n 체육복을 도난당한 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다.\n 여벌의 체육복을 가져온 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다.\n 여벌 체육복이 있는 학생만 다른 학생에게 체육복을 빌려줄 수 있습니다.\n 여벌 체육복을 가져온 학생이 체육복을 도난당했을 수 있습니다. 이때 이 학생은 체육복을 하나만 도난당했다고 가정하며, 남은 체육복이 하나이기에 다른 학생에게는 체육복을 빌려줄 수 없습니다.(이 제한사항이 중요한 것 같다)\n   \n문제풀이 처음 문제를 풀었을 때 제한사항 중 마지막 부분을 읽지 못하고 문제를 풀어 답이 틀렸다고 나왔다, 이후 어떤점이 문제가 있었는지 알기 위해 문제를 다시 읽어보았고 제한사항에서 놓친 부분이 있다는 것을 알게되어서 코드를 수정하고 제출하여 정답을 맞았다.\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int solution(int n, vector\u0026lt;int\u0026gt; lost, vector\u0026lt;int\u0026gt; reserve) { int answer = 0; vector\u0026lt;int\u0026gt; v(n+2,1); // 0~n+1까지 체육복 개수를 1로 초기화 // 체육복을 잃어버린 학생의 체육복 개수 1 감소 int lostSize = lost.size(); for(int i = 0; i \u0026lt; lostSize; i++){ v[lost[i]]--; } // 여분의 체육복을 가진 학생의 체육복 개수 1 증가 int reserveSize = reserve.size(); for(int i = 0; i \u0026lt; reserveSize; i++){ int ind = reserve[i]; v[ind]++; } for(int i = 0; i \u0026lt; reserveSize; i++){ int ind = reserve[i]; // 제한사항 마지막 부분에 해당하는 학생은 넘어간다. if(v[ind] \u0026lt; 2) continue; // 체육복은 앞에 있는 학생 먼저 나눠주고 앞에 학생이 체육복이 있다면 뒤에 학생을 확인한다. if(v[ind-1] == 0) v[ind-1]++; else if(v[ind+1] == 0) v[ind+1]++; } // 체육복을 가지고 있는 학생 수만큼 answer를 증가시킨다 for(int i = 1; i \u0026lt;= n; i++){ if(v[i] != 0) { answer++; } } return answer; }  ","id":0,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 문제의 제한사항을 주의깊게 보자 제한사항 전체 학생의 수는 2명 이상 30명 이하입니다. 체육복을 도난당한 학생의 수는 1명 이상 n명","tags":null,"title":"프로그래머스 - 체육복","uri":"https://chlalstjd430.github.io/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_006/","year":"2020"},{"content":" \n백준 문제 바로가기 \n사용 언어  C++  적용 알고리즘  그리디 알고리즘\n 정렬\n  주의사항  재귀를 통해 순열을 구하여 정답을 찾았지만 메모리 초과가 나왔다.  문제풀이 초기에 순열을 통해 문제를 풀었지만 메모리 초과가 나와 다른 방법을 찾아보았다. 그 결과 30의 배수가 되기 위해서 두 가지 조건을 가져야 한다는 것을 알게 되었다.\n 마지막 일의 자리는 무조건 0이 되어야 한다.\n 마지막 숫자를 제외한 나머지 숫자들의 합은 3의 배수이다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; vector\u0026lt;char\u0026gt; v; bool cmp(char c1, char c2) { return c1 \u0026gt; c2; } int main() { string str = \u0026quot;\u0026quot;; string answer = \u0026quot;\u0026quot;; int sum = 0; cin \u0026gt;\u0026gt; str; int strSize = str.size(); for (int i = 0; i \u0026lt; strSize; i++) { v.push_back(str[i]); } // 큰 숫자대로 정렬 sort(v.begin(), v.end(), cmp); // 마지막 숫자가 0이 아니면 30의 배수가 될 수 없다. if (v[strSize - 1] != '0') { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; return 0; } // 모든 수의 합을 구한다. for (int i = 0; i \u0026lt; strSize; i++) { sum += v[i] - '0'; answer += v[i]; } if (sum % 3 == 0) { cout \u0026lt;\u0026lt; answer \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; } }   ","id":1,"section":"posts","summary":"백준 문제 바로가기 사용 언어 C++ 적용 알고리즘 그리디 알고리즘 정렬 주의사항 재귀를 통해 순열을 구하여 정답을 찾았지만 메모리 초과가 나왔다. 문제풀이 초기에 순열을","tags":["그리디 알고리즘"],"title":"백준 10610 - 30","uri":"https://chlalstjd430.github.io/2020/02/%EB%B0%B1%EC%A4%8010610/","year":"2020"},{"content":" JWT(JSON Web Token) 프로젝트를 진행 중 모바일에서 로그인 API를 제공해야 될 일이 생겼다. 기존에 웹에서 프로젝트를 할 때는 session 정보를 이용하여 로그인 기능을 제공하였는데 모바일 환경에서 JWT를 이용하여 로그인 API를 제공한다는 것을 알게되고 실제 프로젝트에 적용해봤다. 프로젝트가 끝난 이후 JWT에 대헤서 다시 한번 상기시키고 문서로 개념을 정리해보려고 한다.\n\n1. JWT란?  JWT란 JSON Web Token의 약자로 Json 포맷을 이용하여 Claim(사용자 정보나 데이터 속성 등을 의미) 정보를 디지털 서명 하고 이후 비밀 서명 키로 검증하는 Web Token입니다.\n  두 개체에서 JSON 객체를 이용해 Self-contained 방식으로 정보를 안전한게 전달\n JWT는 토큰 자체에 정보를 가지고 있다.\n 회원 인증, 정보 전달에 주로 사용\n  위의 말도 어렵다면 쉽게 정보를 가진 토큰을 통한 인증을 위해 사용된다고 이해하면 좋다.\n\n2. JWT 구조 JWT는 Header, Payload, Signature 로 3부분으로 JSON 형태를 Base64로 인코딩하여 이루져있다.\n Header\n 토큰의 첫번째 파트이다.\n 전형적으로 2가지 파트로(alg 와 typ)으로 구성되어있다.\n alg : 알고리즘 방식을 지정하며, 서명(Signature) 및 토큰 검증에 사용\n typ : 토큰의 타입\n  Payload\n 토큰의 두번째 파트이고 Claim 정보를 담고있다. Claim은 총 3가지 파트로 나누어진다.\n Claim\n Registered claims(등록된 클레임)\n  토큰 정보를 표현하기 위해 이미 정해진 종류의 데이트들이다. 모두 선택적으로 작성이 가능하며 사용할 것을 권장한다. 또한 JWT를 간결하게 위해 key는 모두 3글자이다.\n- iss : 토큰 발급자(issuer) - sub : 토큰 제목(subject) - aud : 토큰 대상자(audience) - exp : 토큰 만료 시간(expiration), NumericDate 형식으로 되어 있어야 함 ex) 1480849147370 - nbf : 토큰 활성 날짜(not before), 이 날이 지나기 전의 토큰은 활성화되지 않음 - iat : 토큰 발급 시간(issued at), 토큰 발급 이후의 경과 시간을 알 수 있음 - jti : JWT 토큰 식별자(JWT ID), 중복 방지를 위해 사용하며 일회성 토큰(Access Token) 등에 사용   토큰\n Public claims(공개 클레임)\n  충돌 방지를 위해 공개된 클레임이다. 보통 URI형식으로 짓는다.\n Private claims(비공개 클레임)  서버와 클라이언트간에 협의된 클레임 이름이다.\n  Payload의 예제로는 다음과 같습니다.\n{ // 실제 프로젝트에 적용한 AccessToken 예제 \u0026quot;sub\u0026quot;: \u0026quot;AccessToken\u0026quot;, \u0026quot;iat\u0026quot;: 1581231911, \u0026quot;exp\u0026quot;: 1581232271, \u0026quot;uid\u0026quot;: \u0026quot;21\u0026quot; }   Verify Signature  Signature(서명)은 토큰을 인코딩하거나 유효성 검증을 할 때 사용하는 고유한 암호화 코드이다. Signature는 Header와 Payload의 값을 인코딩(BASE64)하고, 이코딩한 값을 비밀 키를 이용해 Header에 정의한 알고리즘으로 해싱을 하고, 이 값을 BASE64로 인코딩하여 생산한다.\nHMACSHA256( base64UrlEncode(header) + \u0026quot;.\u0026quot; + base64UrlEncode(payload), your-256-bit-secret  \n3. JWT 장점과 단점 장점\n JWT는 발급 후 토큰 검증만 하면 되기 때문에 저장소가 필요없다.\n 세션 정보를 유지할 필요가 없어, 로드밸런싱 환경에서 유리하다.\n 토큰 기반으로 하는 다른 인증 시스템에 접근이 가능하다.\n 정보를 가지고 있어 별도의 쿼리문을 줄일 수 있다.\n  단점\n JWT는 한 번 발급되면 유효기간이 지나기 전까지 정보들을 탈취할 수 있다.\n Access Token과 Refresh Token을 이용해 피해를 줄일 수 있다.  payload 정보가 제한적이다.\n JWT는 서명에 의해 변조되지 않음을 보장할 순 있지만 데이터를 다른 사람이 볼 수 있으므로 Header나 Payload에 private한 정보는 넣지 않을 것을 권장합니다.   \n4. Access Token \u0026amp; Refresh Token 앞서 말한 JWT의 단점 중에 토큰을 탈취 당할 경우 보안에 취약하다는 단점이 있었다. 토큰의 유효기간은 길 수록 토큰이 탈취 당했을 떄 보안에 취약하게 된다. 그렇다고 토큰의 유효기간이 짧아지면 새 토큰을 발급받기 위해 로그인을 자주 시도해야 되게 된다. 이러한 문제점에서 해결 대안으로 나온 것이 Access Token과 Refresh Token 이다. 이 개념은 OAuth에서 나왔는데 이는 추후에 공부해도록 하겠다.\nAccess Token과 Refresh Token 모두 JWT 형태입니다. 로그인 완료되었을 떄 유효기간이 짧은 Access Token과 비교적 유효기간이 긴 Refresh Token을 발행합니다. Refresh Token은 Access Token의 유효기간이 만료되었을 떄 새로 Token을 발급해주는 열쇠가 됩니다.\n에를 들어보면\n 가정) Refresh Token은 유효기간이 2주, Access Token은 유효기간이 1시간이다.\n 사용자는 로그인을 하여 Refresh,Access Token을 받는다\n 사용자는 API 요청을 하다가 1시간이 지나면 Access Token이 만료된다.\n Refresh Token의 유효기간이 지나지 않았다면 새롭게 Access Token을 발급받는다.\n Refresh Token은 2주가 지나면 유효기간이 만료된다.\n 사용자는 새로 로그인을 한다.\n   위와 같은 과정을 통해 기존에 유효기간이 길 수록 보안에 취약한 Access Token으 단점을 보완하고, 유효기간을 줄일 경우 로그인을 자주 시도해야 된다는 단점을 Refresh Token으로 보완한 것을 알 수 있습니다.\n위의 예시를 조금더 자세하게 그림으로 설명하면 다음과 같습니다.\n 여기서 9~11번은 무조건적인 상황은 아니다. 클라이언트에서 Access Token의 Payload를 통해 유효기간을 알기 떄문에 API 요청전에 토큰이 만료되면 클라이언트에서 토큰 재발급을 요청할수있다.  결론적으로 Refresh Token을 통해 Access Token을 단독적으로 사용했을 때보다 보안에 좋아졌다는 점을 알 수 있다. 그러나 Access Token이 만료될 떄마다 새롭게 발급받기 위해 HTTP 요청이 많아진다는 단점이 있습니다.\n\n5. 마무리 이번 문서를 통해 JWT를 다시 정리하며 개념을 확고히 잡은 것 같습니다. 혹여나 잘못된 정보가 있으면 언제든지 댓글 달아주시면 감사하겠습니다. 다음 JWT 예제 포스팅에서 뵙도록 하겠습니다 :D\n\n참고 자료\n https://jwt.io/introduction\n https://mangkyu.tistory.com/56\n https://elfinlas.github.io/2018/08/12/whatisjwt-01/\n https://brownbears.tistory.com/440\n  ","id":2,"section":"posts","summary":"JWT(JSON Web Token) 프로젝트를 진행 중 모바일에서 로그인 API를 제공해야 될 일이 생겼다. 기존에 웹에서 프로젝트를 할 때는 session 정보를 이용하여 로그인 기능을 제공하였는데 모바","tags":["JWT"],"title":"JWT(1) - JWT(JSON Web Token)란 무엇인가?","uri":"https://chlalstjd430.github.io/2020/02/%EA%B3%B5%EB%B6%80_jwt/","year":"2020"},{"content":" Spring Webflux 최근 교내 커뮤니티 동아리 유어슈에서 Spring Webflux를 이용하여 프로젝트를 하였다. 사실 기존 동아리 스펙이 webflux로 정해져있어서 어쩔수 없이 새로운 프로젝트에 사용하여서 webflux가 왜 필요한지? 어떠한 장점이 있는지? 등 이해도가 부족하다는 생각이 들었다. 그래서 앞으로 webflux를 정리하고 reactive programming을 이해하하는 과정을 문서로 담아 정리하려고 한다.\n연관된 나의 글  리엑티브 프로그래밍이란?  spring webflux를 사용하는 이유  비동기-논블럭킹 리엑티브 개발에 사용\n 효율적으로 등장하는 고성능 웹 애플리케이션 개발\n 서비스간 호출이 많은 마이크로서비스 아키텍처에 적합\n 새로운 방식으로 개발해보고 싶은 호기심 충족\n 발표자 토비님께서는 이를 권장하지 않는다 하셨다.  일반적으로 spring은 멀티 스레드 기반으로 동작하고, 만약 blocking IO로 진행된다면 준비된 스레드보다 더 많은 요청이 들어올 경우 thread pool hell이 발생합니다. 하지만 webflux를 사용할 경우 비동기 non-blocking IO로 서버의 코어 갯수만큼 스레드가 할당되어 사용되기 때문에, thread pool hell이 발생을 줄일 수 있습니다.\n 검증된 JVM과 방대한 자바 생태계를 이용할 수 있는 장점이 있습니다.   webflux 작동원리 ** 토비님 강의 듣고 정리하기 **\n지원 웹 서버/컨테이너  Sel  20.02.07 아직 작성이 완료되지 않은 문서입니다 :D ","id":3,"section":"posts","summary":"Spring Webflux 최근 교내 커뮤니티 동아리 유어슈에서 Spring Webflux를 이용하여 프로젝트를 하였다. 사실 기존 동아리 스펙이 webflux로 정해져있어서 어쩔수 없이 새","tags":["spring webflux"],"title":"리액티브","uri":"https://chlalstjd430.github.io/2020/02/%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_webflux/","year":"2020"},{"content":" 문제링크 \n사용언어  c++  \n\n주의사항  대각선이 지나가는 단위 정사각형의 개수를 구하는 수학적인 공식\n h + w - (h와w의 최대공약수)\n 사실 왜 이러한 공식이 나오는 지 이해는 못하였다.\n  answer의 자료형이 괜히 long long이 아니다.\n  \n문제풀이 h와 w의 최대공약수를 구하고 공식을 적용하면 문제가 나온다. 사실 공식을 알지 못하는 상태에서 다른사람들은 어떻게 문제를 풀었는지\u0026hellip;정말 대단하다.\nusing namespace std; long long solution(int w,int h) { long long answer = 1; // 최대 공약수 구하기 int gdc = 0; long long sum = (long long)w * (long long)h; int minNum = (w \u0026gt; h) ? h : w; for(int i = minNum; i \u0026gt;= i; i--){ if(w%i ==0 \u0026amp;\u0026amp; h%i == 0){ gdc = i; break; } } // 공식 적용 answer = (long long)(sum- (w+h-gdc)); return answer; }  ","id":4,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 대각선이 지나가는 단위 정사각형의 개수를 구하는 수학적인 공식 h + w - (h와w의 최대공약수) 사실 왜 이러한 공식이 나오는 지 이해","tags":null,"title":"프로그래머스 - 멀쩡한 사각형","uri":"https://chlalstjd430.github.io/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_005/","year":"2020"},{"content":" \n백준 문제 바로가기 \n사용 언어  C++  적용 알고리즘  그리디 알고리즘\n 정렬\n  문제풀이  k개의 로프를 사용하여 중량이 w인 물체를 들어올릴 때, 각각의 로프에는 모두 고르게 w/k 만큼의 중량이 걸리게 된다.\n 위의 문항을 잘 이해했다면 쉽게 문제를 풀 수 있다. w/k 만큼의 중량은 가장 적은 중량을 들어올리는 로프의 중량보다 클수 없다. 그러므로 가장 작은 중량을 들어올리는 로프부터 차례대로 보다 큰 중량을 들어올리는 로프들을 함께 사용하여 가장 많은 중량을 올리는 게 답이 될 수 있다. 말이 어려울 수 있는데 코드를 보며 이해해보도록 하자.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main() { int tc = 0; int maxWeight = 0; // 들어올릴수 있는 가장 큰 중량의 값을 저장하는 변수 vector\u0026lt;int\u0026gt; lope; // 로프의 중량을 담는다 cin \u0026gt;\u0026gt; tc; for (int i = 0; i \u0026lt; tc; i++) { int weight; cin \u0026gt;\u0026gt; weight; lope.push_back(weight); } // 중량이 적은 순서대로 정렬한다. sort(lope.begin(), lope.end()); // i번째 로프 부터 i+1~tc의 로프를 함께 이용하여 들어올리는 중량의 값을 구하여 더 큰 중량의 값을 저장한다. for (int i = 0; i \u0026lt; tc; i++) { maxWeight = max(maxWeight, lope[i] * (tc - i)); } cout \u0026lt;\u0026lt; maxWeight \u0026lt;\u0026lt; endl; }  ","id":5,"section":"posts","summary":"백준 문제 바로가기 사용 언어 C++ 적용 알고리즘 그리디 알고리즘 정렬 문제풀이 k개의 로프를 사용하여 중량이 w인 물체를 들어올릴 때, 각각의 로프에는 모두 고르게 w/k 만","tags":["그리디 알고리즘"],"title":"백준 2217 - 로프","uri":"https://chlalstjd430.github.io/2020/02/%EB%B0%B1%EC%A4%802217/","year":"2020"},{"content":" \n백준 문제 바로가기 \n사용 언어  C++  적용 알고리즘  그리디 알고리즘\n 정렬\n  주의사항  문제의 주어진 조건을 잘 파악하고 경우의 수를 나누어야 한다.  문제풀이  문제의 내용과 조건을 보면 3가지의 경우에 한해서 답을 구할 수있다.   가장 싼 세트 가격으로 구매했을 경우\n 가장 싼 세트 가격과 가장 싼 낱개 가격으로 구매했을 경우\n 가장 싼 낱개 가격으로 구매했을 경우\n   가장 싼 세트 가격과 낱개 가격은 sort를 통해 쉽게 구할 수 있다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; bool compare(pair\u0026lt;int, int\u0026gt; p1, pair\u0026lt;int, int\u0026gt; p2) { return p1.second \u0026lt; p2.second; } int main() { int N, M; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; vector\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; brand; int minMoney = 987654321; for (int i = 0; i \u0026lt; M; i++) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; brand.push_back(make_pair(a, b)); } // 1. 모든 기타줄을 세트로만 구매했을 때 sort(brand.begin(), brand.end()); int setPrice = brand[0].first; // 가장 저렴한 세트의 가격 int setCnt = N / 6; // 세트로 나눠지는 개수 int piece = N % 6; // 세트로 나눠지고 남는 낱개 개수 minMoney = (piece == 0) ? setCnt * setPrice : (setCnt + 1)*setPrice; // 세트 개수로 나누어졌을 때 // 2. 세트 + 낱개로 구매했을 때 sort(brand.begin(), brand.end(), compare); minMoney = min(minMoney, setPrice*setCnt + piece * brand[0].second); // 3. 모든 기타줄을 낱개로만 구매했을 때 minMoney = min(minMoney, brand[0].second*N); cout \u0026lt;\u0026lt; minMoney \u0026lt;\u0026lt; endl; }   ","id":6,"section":"posts","summary":"백준 문제 바로가기 사용 언어 C++ 적용 알고리즘 그리디 알고리즘 정렬 주의사항 문제의 주어진 조건을 잘 파악하고 경우의 수를 나누어야 한다. 문제풀이 문제의 내용과 조건","tags":["그리디 알고리즘"],"title":"백준 1049 - 기타줄","uri":"https://chlalstjd430.github.io/2020/02/%EB%B0%B1%EC%A4%801049/","year":"2020"},{"content":" Chapter 08 - 경계 외부에서 사용하느 코드 또한 우리 내부코드와 \u0026ldquo;깨끗하게\u0026rdquo; 통합시켜야 한다.\n\n1. 서드파티 코드 사용하기  서드파티란?\n Map같은 경우 가급적이면 Wrapping을 하여 사용하자.\n 공개된 API에서 인자로 받거나 리턴하지 마라.   \n2. 경계를 탐험하고 공부하기  서드파티를 사용할 때 우리가 사용할 코드에 대헤서는 충분히 테스트 할 필요가 있다.\n 테스트는 값어치를 한다.\n 메인 로직에 영향을 주지 않으며 서드파티 코드를 이해할 수 있다.\n 이러한 테스트는 새 버전으로 이전에 도움을 준다.\n   \n3. 아직 존재하지 않는 코드 사용하기  아직 개발되지 않은 모듈이 필요한데, 기능은 커녕 인터페이스조차 구현되지 않은 경우가 있다.\n 필요한 인터페이스를 만들어 활용하자(임시)   \n결론  서드파티를 이용할 때 내부코드와 \u0026ldquo;깨끗하게\u0026rdquo; 통합시키자\n 서드파티 코드를 충분히 테스트하며 연습하자.\n  ","id":7,"section":"posts","summary":"Chapter 08 - 경계 외부에서 사용하느 코드 또한 우리 내부코드와 \u0026ldquo;깨끗하게\u0026rdquo; 통합시켜야 한다. 1. 서드파티 코드 사용하기 서드파티란? Map","tags":["클린코드"],"title":"Chapter 08 - 경계","uri":"https://chlalstjd430.github.io/2020/02/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C_008/","year":"2020"},{"content":" 문제링크 \n사용언어  c++  \n\n주의사항  큐와 우선순위 큐의 개념에 알고있어야 한다.\n 우선순위 큐는 항상 값이 높은 것을 앞으로 보낸다.   \n문제풀이 언뜻 보면 굉장히 쉬워보였는데, 정작 문제를 풀지 못하였다. 우선순위 큐를 활용해서 어찌저찌해서 풀 수 있을 것 같은데 방법이 생각이 안났다.\n문제는 큐 와 우선순위 큐 를 이용하면 간단하게 풀 수 있었다. 코드의 주석을 통해 설명하겠다.\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int solution(vector\u0026lt;int\u0026gt; priorities, int location) { int answer = 0; // 큐와 우선순위 큐를 적절히 활용하는게 이번 풀이의 핵심이다. queue\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; q; priority_queue\u0026lt;int\u0026gt; pq; // 큐에는 인덱스와 우선순위 정보를 차례대로, 우선순위 큐에는 우선순위 정보만을 담는다. for(int i = 0; i \u0026lt; priorities.size(); i++){ q.push(make_pair(i, priorities[i])); pq.push(priorities[i]); } int index = 1; while(!q.empty()){ // 현재 큐의 우선순위 값과 우선순위 큐의 값이 일치하다면 if(q.front().second == pq.top()){ // 현재 큐의 인덱스 정보와 찾고자하는 인덱스 정보가 일치할 경우 index값을 answer에 저장하고 while문을 종료한다. if(location == q.front().first){ answer = index; break; } // 그렇지 않은 경우 index를 증가시켜주고, q와 pq를 pop시켜준다. else{ index++; q.pop(); pq.pop(); } } // 현재 큐의 우선순위 값과 우선순위 큐의 값이 불일치하다면 현재 큐의 우선순위보다 더 높은게 뒤에 있다는 소리이므로 현재 큐의 값들을 뒤로 빼준다. else{ q.push(q.front()); q.pop(); } } return answer; }  ","id":8,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 큐와 우선순위 큐의 개념에 알고있어야 한다. 우선순위 큐는 항상 값이 높은 것을 앞으로 보낸다. 문제풀이 언뜻 보면 굉장히 쉬워보였는데","tags":null,"title":"프로그래머스 - 프린터","uri":"https://chlalstjd430.github.io/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_004/","year":"2020"},{"content":" \n백준 문제 바로가기 \n사용 언어  C++  적용 알고리즘  그리디 알고리즘\n 정렬\n  주의사항  처음 문제 풀 때 재귀를 통해 풀었으나 시간초과가 날 뿐더러 답도 틀렸었다..\n 답은 왜 틀렸는지 의문이다.   문제풀이 해당 문제는 다음과 같은 과정을 거치면 풀 수 있다.\n 회의가 끝나는 시간으로 정렬한다.(회의 끝나 시간이 작은게 앞으로)   끝나는 시간이 서로 같을 경우에는 회의의 시작시간으로 정렬한다.\n 위와 같이 정렬하는 이유는 회의 시작시간과 끝나는 시간이 같은 값이 있을 경우 더 많은 회의를 잡을 수 있기 때문이다.    가장 회의가 빨리 끝나는 회의가 첫 회의가 된다. 첫 회의의 끝나는 시간을 저장한다.\n 이후 for문을 돌리며 끝나는 회의시간 이후에 시작되는 회의시간을 차례대로 저장하며 count를 센다.\n  코드 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; vector\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; room; bool compare(pair\u0026lt;int, int\u0026gt; \u0026amp;p1, pair\u0026lt;int, int\u0026gt; \u0026amp;p2) { if (p1.second == p2.second) { return p1.first \u0026lt; p2.first; } return p1.second \u0026lt; p2.second; } int main() { int tc; cin \u0026gt;\u0026gt; tc; for (int i = 0; i \u0026lt; tc; i++) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; room.push_back(make_pair(a, b)); } sort(room.begin(), room.end(), compare); int cnt = 0; int end = 0; for (int i = 0; i \u0026lt; tc; i++) { if (end \u0026lt;= room[i].first) { end = room[i].second; cnt++; } } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; }  ","id":9,"section":"posts","summary":"백준 문제 바로가기 사용 언어 C++ 적용 알고리즘 그리디 알고리즘 정렬 주의사항 처음 문제 풀 때 재귀를 통해 풀었으나 시간초과가 날 뿐더러 답도 틀렸었다.. 답은 왜 틀렸는","tags":["그리디 알고리즘"],"title":"백준 1931 - 회의실 배정","uri":"https://chlalstjd430.github.io/2020/02/%EB%B0%B1%EC%A4%801931/","year":"2020"},{"content":" Study TODO 리스트 이것도 공부하고 싶고, 저것도 공부하고 싶고 공부하고 싶은 내용들이 너무 많다\u0026hellip; 그래서 Study todo 리스트를 만들어보았다. 단기간 내에 모든 것을 하기 힘들겠지만 너무 조급해하지않고 차근차근 하나씩 공부해볼 예정이다.\n1. Spring\n spring의 내부적인 개념\n spring webflux\n 유어슈 프로젝트 코드 공부\n reactive stream method 정리\n  spring batch\n  2. CI/CD\n 프로젝트에 적용해보기  3. Multi-Module 공부\n Multi-Module에 대하여 학습하고 프로젝트에 적용해보고 싶다.  4. Clean code\n 클린코드 정리중  5. DB 공부\n MySQL\n 효율적인 ERM 작성을 위한 공부   6. HTTP 완벽 가이드(책) 공부\n 추후에 스터디를 열어볼까 생각중..  7. 알고리즘 공부\n 스터디 진행중(01.01 ~ 02.29)  8. 코틀린 공부\n 유어슈 프로젝트 때 코틀린으로 개발을 하였는데, 자바가 주언어여서 아직 서투르다..\n yapp에서 스터디 예정\n  9. 도커 공부\n 생활코딩  10. AWS 공부\n 생활코딩\n 프리티어 버전으로 약간 경험보긴 했지만 정말 약간이라 더 학습이 필요하다.\n  11. TDD\n yapp에서 스터디 예정  12. 운영체제\n 학교 수업을 통해 공부할 예정  ","id":10,"section":"posts","summary":"Study TODO 리스트 이것도 공부하고 싶고, 저것도 공부하고 싶고 공부하고 싶은 내용들이 너무 많다\u0026hellip; 그래서 Study todo 리스트를 만들어보았다. 단기간 내에 모든 것","tags":["계획"],"title":"2020 학습하고 싶은 공부","uri":"https://chlalstjd430.github.io/2020/02/2020%EA%B3%84%ED%9A%8D_002/","year":"2020"},{"content":" Chapter 07 - 에러 핸들링 \n1. 리턴 코드 대신에 Exception을 사용하자! 기존에 flag를 이용하여 에러 코드를 리턴하거나 호출하는 측에서 예외처리를 하였다. 이런 방식은 예외처리를 잊어버리기 쉽고 로직을 헷갈리게 한다.\n\n// Bad public class DeviceController { ... public void sendShutDown() { DeviceHandle handle = getHandle(DEV1); // Check the state of the device if (handle != DeviceHandle.INVALID) { // Save the device status to the record field retrieveDeviceRecord(handle); // If not suspended, shut down if (record.getStatus() != DEVICE_SUSPENDED) { pauseDevice(handle); clearDeviceWorkQueue(handle); closeDevice(handle); } else { logger.log(\u0026quot;Device suspended. Unable to shut down\u0026quot;); } } else { logger.log(\u0026quot;Invalid handle for: \u0026quot; + DEV1.toString()); } } ... } // Good public class DeviceController { ... public void sendShutDown() { try { tryToShutDown(); } catch (DeviceShutDownError e) { logger.log(e); } } private void tryToShutDown() throws DeviceShutDownError { DeviceHandle handle = getHandle(DEV1); DeviceRecord record = retrieveDeviceRecord(handle); pauseDevice(handle); clearDeviceWorkQueue(handle); closeDevice(handle); } private DeviceHandle getHandle(DeviceID id) { ... throw new DeviceShutDownError(\u0026quot;Invalid handle for: \u0026quot; + id.toString()); ... } ... }  \n2. Try-Catch-Finally문을 먼저 쓰자  이로써 \u0026ldquo;Scrope 정의\u0026rdquo;가 가능하다.\n ▽ 잘못된 input을 넣을 경우 StorageException을 제대로 던지는지 확인하는 테스트 코드\n// Step 1: StorageException을 던지지 않으므로 이 테스트는 실패한다. @Test(expected = StorageException.class) public void retrieveSectionShouldThrowOnInvalidFileName() { sectionStore.retrieveSection(\u0026quot;invalid - file\u0026quot;); } public List\u0026lt;RecordedGrip\u0026gt; retrieveSection(String sectionName) { // dummy return until we have a real implementation return new ArrayList\u0026lt;RecordedGrip\u0026gt;(); } // Step 2: 이제 테스트는 통과한다. public List\u0026lt;RecordedGrip\u0026gt; retrieveSection(String sectionName) { try { FileInputStream stream = new FileInputStream(sectionName) } catch (Exception e) { throw new StorageException(\u0026quot;retrieval error\u0026quot;, e); } return new ArrayList\u0026lt;RecordedGrip\u0026gt;(); } // Step 3: Exception의 범위를 FileNotFoundException으로 줄여 정확히 어떤 Exception이 발생한지 체크하자. public List\u0026lt;RecordedGrip\u0026gt; retrieveSection(String sectionName) { try { FileInputStream stream = new FileInputStream(sectionName); stream.close(); } catch (FileNotFoundException e) { throw new StorageException(\u0026quot;retrieval error\u0026quot;, e); } return new ArrayList\u0026lt;RecordedGrip\u0026gt;(); }   \n3. Unchecked Exception을 사용하자  Unchecked Exception과 Checked Exception에 대하여 설명을 잘해준 블로그\n 상위 레벨 메소드에서 하위 레벨 메소드의 디테일에 대해 알아야 하기 때문에 캡슐화 또한 깨진다.\n  \n4. Exceptions로 문맥을 제공하자  예외가 발생한 이유와 좀 더 구체적인 Exception 타입을 제공하자.\n catch문의 내용이 비슷하다면 하나로 묶어서 사용하자.\n  \n5. NULL을 리턴하지 말자  null을 리턴하고 싶은 생각이 들면 Special Case object를 리턴하자.\n Null Object Patter  서드파트 라이브러리 에서 null을 리턴할 가능성이 있다면 Exception을 던지거나 Special Case object를 리턴하자.\n// Bad List\u0026lt;Employee\u0026gt; employees = getEmployees(); if (employees != null) { for(Employee e : employees) { totalPay += e.getPay(); } } // Good List\u0026lt;Employee\u0026gt; employees = getEmployees(); for(Employee e : employees) { totalPay += e.getPay(); } public List\u0026lt;Employee\u0026gt; getEmployees() { if( .. there are no employees .. ) return Collections.emptyList(); } }   \n6. NULL을 넘기지 말자  null을 메서드로 넘기는 것 또한 나쁘다\n 가장 이성적인 해법은 null을 파라미터로 받지 못하게 하는 것이다.\n  \n결론  예외처리는 가급적 Exception을 통해 처리를 해주는 것이 코드를 간결하게 한다.\n null을 리턴하지도 넘기지도 말자.\n  \n출저 : https://github.com/Yooii-Studios/Clean-Code\n출저 : Clean Code 클린 코드 : 애자일 소프트웨어 장인 정신\n","id":11,"section":"posts","summary":"Chapter 07 - 에러 핸들링 1. 리턴 코드 대신에 Exception을 사용하자! 기존에 flag를 이용하여 에러 코드를 리턴하거나 호출하는 측에서 예외처리를 하였다. 이","tags":["클린코드"],"title":"Chapter 07 - 에러 핸들링","uri":"https://chlalstjd430.github.io/2020/02/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C_007/","year":"2020"},{"content":" 문제링크 \n사용언어  c++  주의사항  문자열은 제일 앞부터 정해진 길이만큼 잘라야 합니다.  \n문제풀이 문제풀이를 위해서 다음과 같은 과정을 거치게 됩니다.\n 문자열을 자를 단위는 \u0026ldquo;1 ~ (문자열 길이/2)\u0026rdquo; 입니다.\n 문자열 단위별로 제공되는 문자열을 압축해봅니다.\n \u0026ldquo;문자열 총 길이 - (문자열 총 길이 / 문자열 자를 단위) * 문자열 자를 단위\u0026rdquo; 만큼은 압축에 포함되지 않기 때문에 별도 추가합니다.\n 이전에 가장 짧았던 문자열과 길이를 비교합니다.\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int solution(string s) { int len = s.length(); int answer = len; // i = 문자열을 자를 단위 for(int i = 1; i \u0026lt;= (len/2); i++){ string result = \u0026quot;\u0026quot;; string tmp = s.substr(0, i); // 처음 비교해야 될 문자열 int cnt = 1; // 압축이 없을 경우 1 // 자를 문자열 단위만큼 이동하며 비교 for(int j = i; j \u0026lt;= len; j+=i){ // 현재 압축이 있다면 if(tmp == s.substr(j, i)){ cnt++; } // 현재 압축이 없다면 else{ // 지금까지 압축이 없었을 경우 if(cnt == 1){ result += tmp; } // 지금까지 압축이 있었을 경우 else{ result += (to_string(cnt) + tmp); } tmp = s.substr(j, i); cnt = 1; } } result += s.substr((len/i) * i); // 문자열을 자르는 단위에 포함 안되는 문자열 추가 answer = min(answer, (int)result.length()); } return answer; }   ","id":12,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 문자열은 제일 앞부터 정해진 길이만큼 잘라야 합니다. 문제풀이 문제풀이를 위해서 다음과 같은 과정을 거치게 됩니다. 문자열을 자를 단","tags":null,"title":"프로그래머스 - 문자열 압축","uri":"https://chlalstjd430.github.io/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_003/","year":"2020"},{"content":" \n백준 문제 바로가기 \n사용 언어  C++  적용 알고리즘  그리디 알고리즘  문제풀이 다음과 같은 과정을 거쳐 문제를 풀었습니다.\n 재귀를 통해 순열을 구한다.\n 해당 순열이 부등호를 충족시키는지 검사한다. (부등호를 충족시킬 경우 해당 값을 저장한다.)\n 저장된 순열 값들을 정렬 후 가장 작은 값과 큰 값을 출력한다.\n  위의 세 과정을 거치면 문제의 답을 쉽게 구할 수 있습니다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; char Inequality[11]; bool visited[11]; vector\u0026lt;char\u0026gt; num; vector\u0026lt;string\u0026gt; answer; int tc; // 3. Inequality에 저장되어있는 부등호에 맞게 비교되는 수열인지 확인 bool isPossible() { for (int i = 0; i \u0026lt; tc; i++) { if (Inequality[i] == '\u0026gt;') { if (!(num[i] - '0' \u0026gt; num[i+1] - '0')) return false; } else if(Inequality[i] == '\u0026lt;'){ if (!(num[i] - '0' \u0026lt; num[i+1] - '0')) return false; } } return true; } // 1. 순열을 만드는 재귀 함수 void dfs(int index) { // Inequality의 index값이 tc와 같아질 경우 부등호에 맞는지 검증 if (index == tc) { if (isPossible()) { string tmp = \u0026quot;\u0026quot;; int size = num.size(); for (int i = 0; i \u0026lt; size; i++) { tmp += num[i]; } answer.push_back(tmp); } return; } for (int i = 0; i \u0026lt; 10; i++) { if (visited[i]) continue; visited[i] = true; num.push_back(i + '0'); dfs(index+1); visited[i] = false; num.pop_back(); } } int main() { cin \u0026gt;\u0026gt; tc; for (int i = 0; i \u0026lt; tc; i++) { char a; cin \u0026gt;\u0026gt; a; Inequality[i] = a; } dfs(-1); // 매개변수는 dfs를 실행했을 때 dfs(0)부터 시작할수 있도록 -1값을 준다. // 3. 정렬 후 정답 출력 sort(answer.begin(), answer.end()); cout \u0026lt;\u0026lt; answer[answer.size() - 1] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; answer[0] \u0026lt;\u0026lt; endl; }  ","id":13,"section":"posts","summary":"백준 문제 바로가기 사용 언어 C++ 적용 알고리즘 그리디 알고리즘 문제풀이 다음과 같은 과정을 거쳐 문제를 풀었습니다. 재귀를 통해 순열을 구한다. 해당 순열이 부등호를","tags":["그리디 알고리즘"],"title":"백준 2529 - 부등호","uri":"https://chlalstjd430.github.io/2020/02/%EB%B0%B1%EC%A4%802529/","year":"2020"},{"content":" Chapter 06 - 객체와 자료구조 \n1. 자료 추상화  목록 6-1 구체적인 Point 클래스\npublic class Point { public double x; public double y; }  목록 6-2 추상적인 Point 클래스\npublic interface Point { double getX(); double getY(); void setCartesian(double x, double y); double getR(); double getTheta(); void setPolar(double r, double theta); }   목록 6-1같은 경우 내부 구졸르 노출하고. 목록 6-2는 구현을 완전히 숨긴다. 구현을 완전히 감추기 위해서는 추상화 가 필요하다. set,get 메서드로 변수를 다룬다고 클래스가 아니라, 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스다.\n\n2. 자료/객체 비대칭  객체 는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 제공한다.\n 자료 구조 는 자료를 그대로 공개하며 별다른 함수는 제공하지 않는다.\n  두 정의는 본질적으로 상반되며 두 개념은 사실상 정반대이다.\n 목록 6-5 절차적인 도형 (Procedural Shape)\npublic class Square { public Point topLeft; public double side; } public class Rectangle { public Point topLeft; public double height; public double width; } public class Circle { public Point center; public double radius; } public class Geometry { public final double PI = 3.141592653589793; public double area(Object shape) throws NoSuchShapeException { if (shape instanceof Square) { Square s = (Square)shape; return s.side * s.side; } else if (shape instanceof Rectangle) { Rectangle r = (Rectangle)shape; return r.height * r.width; } else if (shape instanceof Circle) { Circle c = (Circle)shape; return PI * c.radius * c.radius; } throw new NoSuchShapeException(); } }   객체 지향 프로그래머가 위 코드를 보면 의아해 할 것이다. 하지만 Geometry 클래스에 둘레 길이를 구하기 위해서 perimeter() 함수를 추가하고 싶을 경우 도형 클래스는 아무 영향도 받지 않는다. 반대로 새 도형을 추가하고 싶다면 Geometry 클래스에 속한 함수를 모두 고쳐야 한다. 그래서 두 조건은 완전히 정반대라고 할 수 있다.\n 목록 6-6 다형적인 도형 (Polymorphic Shape)\npublic class Square implements Shape { private Point topLeft; private double side; public double area() { return side * side; } } public class Rectangle implements Shape { private Point topLeft; private double height; private double width; public double area() { return height * width; } } public class Circle implements Shape { private Point center; private double radius; public final double PI = 3.141592653589793; public double area() { return PI * radius * radius; } }   이번에는 목록 6-6을 살펴보자. 객체 지향적인 도형 클래스다. 새 도형을 추가해서 기존 함수에 아무런 영향을 미치지 않는다. 반면 새 함수를 추가하고 싶다면 도형 클래스 전부를 고쳐야 한다.\n즉, 객체 지향 코드에서 어려운 변경은 절차적인 코드에서 쉬우며, 절차적인 코드에서 어려운 변경은 객체 지향 코드에서 쉽다. 그러므로 상황에 맞게 클래스 \u0026amp; 객체 지향 기법을 사용하거나, 절차적인 코드와 자료 구조를 적절하게 사용하는 것이 좋다.\n\n3. 디미터 법칩 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙이다. 좀 더 정확히 표현하자면, 디미터 법칙은 \u0026ldquo;클래스 C의 메서드 f는 다음과 같은 객체의 메서드만 호출해야 한다\u0026rdquo; 고 주장한다.\n 클래스 C\n f가 생성한 객체\nint f(){ Module module = new Modele(); module.메서드() }  f 인수로 넘어온 객체\nint f(Module module){ module.메서드() }  C 인스턴스 변수에 저장된 객체\nclass C { private Module module; ... int f(){ module.메서드(); } }   하지만 위 객체에서 허용된 메서드가 반환하는 객체의 메서드는 호출하면 안 된다.\n 기차 충돌\nfinal String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();   위와 같은 코드는 일반적으로 조잡하다 여겨지므로 가능하면 피하자.\n 잡종 구조\n 절반은 객체 절반은 자료 구조인 잡종 구조는 가급적이면 지양하자. 이는 어중간한 설계처럼 보인다.  자료 전달 객체(DTO)\n  \n결론  클래스를 만들 때 가급적이면 추상화 과정을 거쳐 만드는 것이 더 바람직한 클래스 설계라고 생각이 든다.\n 무조건 객체가 옳은 것은 아니다. 상황에 맞게 객체나 자료 구조를 사용하여야 한다.\n  \n출저 : https://github.com/Yooii-Studios/Clean-Code\n출저 : Clean Code 클린 코드 : 애자일 소프트웨어 장인 정신\n","id":14,"section":"posts","summary":"Chapter 06 - 객체와 자료구조 1. 자료 추상화 목록 6-1 구체적인 Point 클래스 public class Point { public double x; public double y; } 목록 6-2 추상적인 Point 클래스 public interface Point { double getX(); double getY(); void setCartesian(double x, double y); double getR(); double getTheta(); void setPolar(double r, double","tags":["클린코드"],"title":"Chapter 06 - 객체와 자료구조","uri":"https://chlalstjd430.github.io/2020/02/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C_006/","year":"2020"},{"content":" 문제링크 \n사용언어  c++  \n문제유형  힙/우선순위 큐  \n주의 사항  vector를 가지고 sort후 문제를 풀었더니 효율성에서 통과하지 못하였다. 이는 우선순위 큐를 선언하여 문제를 해결하였다.\n 단순 vector를 가지고 실행한 결과  priority_queue를 가지고 실행한 결과    \n문제풀이 #include \u0026lt;string\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int k; int cnt; priority_queue\u0026lt;int\u0026gt; pq; bool compare (int a, int b){ return a \u0026gt; b; } bool check_scoville(){ int top = -pq.top(); bool result = true; if(top \u0026lt; k) result = false; return result; } int solution(vector\u0026lt;int\u0026gt; scoville, int K) { int answer = 0; // 전역변수 초기화 k = K; cnt = 0; for(int i = 0; i \u0026lt; scoville.size(); i++){ pq.push(-scoville[i]); // priority_queue는 별도 설정이 없으면 가장 큰 값이 top에 있기 때문에 -를 붙여 값들을 저장한다. } while(true){ int size = pq.size(); // 모든 값들이 K를 넘거나, 1개 밖에 값이 안남은 경우 if(check_scoville() || size == 1 ){ break; } // 기존에 가장 스코빌 지수가 적은 2개를 삭제하고 섞은 음식의 스코빌 지수를 저장 int a = -pq.top(); // 가장 스코빌 지수가 적은 값, 저장할 때 -를 붙여 저장하였기 때문에 꺼낼 때 다시 -기호를 붙여 양수의 값을 받아온다. pq.pop(); int b = -pq.top(); // 두번째로 스코빌 지수가 적은 값 pq.pop(); int c = a + b*2; // 섞은 음식의 스코빌 지수를 저장 pq.push(-c); cnt++; // 한번 섞었으므로 cnt가 1증가 } // 모든 스코빌 지수가 K보다 클 경우 if(check_scoville()){ answer = cnt; } // 그렇지 못할 경우(스코빌 지수가 한개 남았을 때) else answer = -1; return answer; }  ","id":15,"section":"posts","summary":"문제링크 사용언어 c++ 문제유형 힙/우선순위 큐 주의 사항 vector를 가지고 sort후 문제를 풀었더니 효율성에서 통과하지 못하였다. 이는 우선순위 큐를 선언","tags":null,"title":"프로그래머스 - 더 맵게","uri":"https://chlalstjd430.github.io/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_002/","year":"2020"},{"content":" 문제링크 \n사용언어  c++  \n문제유형  dfs/bfs\n 그래프\n  \n주의 사항  전역 변수를 사용할 경우 함수 내에 초기화 코드를 꼭 작성하자\n 제출하면 답이 틀리려서 30분넘게 씨름했는데..solution 함수 위에 다음과 같은 주석이 있었다\u0026hellip;    // 전역 변수를 정의할 경우 함수 내에 초기화 코드를 꼭 작성해주세요.\n \n문제풀이 해당 문제에서는 DFS 혹은 BFS를 이용하여 풀 수 있는 문제이다. 나는 DFS를 선택하여 문제를 풀어보았다.\n#include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; vec; bool visited[102][102]; int M, N; int dx[] = {-1, 0, 0, 1}; int dy[] = {0, -1, 1, 0}; int area; void dfs(int x, int y, int color){ visited[x][y] = true; area++; for(int i = 0; i \u0026lt; 4; i++){ int mx = x + dx[i]; int ny = y + dy[i]; if(0 \u0026gt; mx || mx \u0026gt; M-1 || 0 \u0026gt; ny || ny \u0026gt; N-1) continue; if(!visited[mx][ny] \u0026amp;\u0026amp; vec[mx][ny] == color){ dfs(mx,ny,color); } } } // 전역 변수를 정의할 경우 함수 내에 초기화 코드를 꼭 작성해주세요. vector\u0026lt;int\u0026gt; solution(int m, int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; picture) { int number_of_area = 0; int max_size_of_one_area = 0; // 전역변수 초기화 area = 0; M = m; N = n; vec = picture; // visited 2차원 배열을 초기화 안해서 계속 틀렸었다..아마 해당 문제에서는 전역변수 설정시 자동으로 false 설정이 안되나보다. for(int i = 0; i \u0026lt; m; i++){ for(int j = 0; j \u0026lt; n; j++){ visited[i][j] = false; } } for(int i = 0; i \u0026lt; m; i++){ for(int j = 0; j \u0026lt; n; j++){ if(!visited[i][j] \u0026amp;\u0026amp; vec[i][j] \u0026gt; 0){ area = 0; dfs(i, j, vec[i][j]); number_of_area++; max_size_of_one_area = max(area, max_size_of_one_area); } } } vector\u0026lt;int\u0026gt; answer(2); answer[0] = number_of_area; answer[1] = max_size_of_one_area; return answer; }  \n","id":16,"section":"posts","summary":"문제링크 사용언어 c++ 문제유형 dfs/bfs 그래프 주의 사항 전역 변수를 사용할 경우 함수 내에 초기화 코드를 꼭 작성하자 제출하면 답이 틀리려서 30분넘게 씨름했는데..so","tags":null,"title":"프로그래머스 - 카카오 프렌즈 컬러링북","uri":"https://chlalstjd430.github.io/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_001/","year":"2020"},{"content":" \n백준 문제 바로가기 \n사용 언어  C++  적용 알고리즘  KMP 알고리즘  문제풀이 문제에서는 것은 단순 문자열 비교 알고리즘이 아니라 KMP나 라빈 카프 같은 효율적인 알고리즘을 요구합니다. 그러므로 저는 KMP 알고리즘을 이용하여 문제를 풀어보았습니다.\n코드는 다음과 같습니다. 설명은 주석으로 진행하겠습니다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; // vector를 사용하기 위해 선언 #include \u0026lt;string.h\u0026gt; // strlen을 사용하기 위해 선언 using namespace std; vector\u0026lt;int\u0026gt; place; // 문제에서 요구하는 답(겹치는 문자열의 개수, 위치)를 저장하기 위해 전역변수로 선언 // pattern(찾고자 하는 문자열)에 대하여 table을 만드는 함수 vector\u0026lt;int\u0026gt; makeTable(char *pattern) { int patternSize = strlen(pattern); vector\u0026lt;int\u0026gt; table(patternSize, 0); // pattern의 길이만큼 만들어줍니다. // table을 만드는 과정 int j = 0; for (int i = 1; i \u0026lt; patternSize; i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; pattern[i] != pattern[j]) { j = table[j - 1]; } if (pattern[i] == pattern[j]) { table[i] = ++j; // pattern i와 j의 값이 일치할 경우 table에 기록합니다. } } return table; } // parent(기존의 문자열)과 pattern(찾고자 하는 문자열)을 가지고 kmp 알고리즘을 수행합니다. void kmp(char *parent, char *pattern) { vector\u0026lt;int\u0026gt; table = makeTable(pattern); int parentSize = strlen(parent); int patternSize = strlen(pattern); int j = 0; for (int i = 0; i \u0026lt; parentSize; i++) { // parent와 pattern을 비교하기 때문에 parent길이만큼 확인 while (j \u0026gt; 0 \u0026amp;\u0026amp; parent[i] != pattern[j]) { j = table[j - 1]; } if (parent[i] == pattern[j]) { // j가 pattern의 길이-1과 같은 경우 if (j == patternSize - 1) { j = table[j]; place.push_back(i - patternSize + 2); // place vector에 인데스 저장 } // 길이가 같이 않을 경우 else { j++; } } } } int main() { char parent[1000002] = {}; char pattern[1000002] = {}; cin.getline(parent, 1000002); cin.getline(pattern, 1000002); kmp(parent, pattern); int size = place.size(); cout \u0026lt;\u0026lt; size \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; size; i++) { cout \u0026lt;\u0026lt; place[i] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }  ","id":17,"section":"posts","summary":"백준 문제 바로가기 사용 언어 C++ 적용 알고리즘 KMP 알고리즘 문제풀이 문제에서는 것은 단순 문자열 비교 알고리즘이 아니라 KMP나 라빈 카프 같은 효율적인 알고리즘을 요","tags":["KMP 알고리즘"],"title":"백준 1786 - 찾기","uri":"https://chlalstjd430.github.io/2020/02/%EB%B0%B1%EC%A4%801786/","year":"2020"},{"content":" Chapter 05 - 형식 맞추기 질서정연하고 깔끔하며, 일관적인 코드를 본다면 사람들에게 전문가가 짰다는 인상을 심어줄 수 있다. 반대로, 코드가 어수선해 보인다면 프로젝트 전반적으로 무성의한 태도로 작성했다고 생각할 것이다.\n\n1. 형식을 맞추는 목적 코드 형식은 의사소통의 일환이며 오늘 구현한 코드의 스타일과 가독성 수준은 용이성과 확장성에 지속적인 영향을 준다.\n 코드는 사라져도 스타일과 규율은 사라지지 않는다!\n \n2. 적절한 행 길이를 유지하라(코드의 세로 길이) 코드의 줄이 길어질 수록 코드를 이해하기 어렵기 때문에 코드의 줄을 200줄 내외로 정하여 개발하는 것이 좋다. 물론 이것이 반드시 지켜져야 될 엄격한 규칙은 아니지만 확실히 코드의 줄이 작을 수록 보기좋다.\n 신문 기사처럼 작성하라\n 신문 기사는 최상단에 표제, 첫 문단에는 요약된 기사 내용, 그리고 내려갈수록 세세한 내용 들이 등장한다. 코드 또한 이와 마찬가지로 소스파일 이름(표제) 은 간단하면서도 설명이 가능하게 지어 이름만 보고도 올바른 모듈을 살펴보고 있는지를 판단 할 수 있도록 한다. 소스파일의 첫 부분(요약 내용) 은 고차원 개념과 알고리즘을 설명한다. 아래로 내려갈수록 의도를 세세하게 묘사하며, 마지막에는 가장 저차원 함수(getter,setter같은)와 세부 내역이 나오게 한다.  개념은 빈 행으로 분리하여라\n 코드의 각 줄은 수식이나 절을 나타내고, 여러 줄의 묶음은 완결된 생각 하나를 표현한다. 생각 사이에는 빈 행을 넣어 분리하자.\n 같은 코드에 대헤서 빈 행을 다르게 표현한 코드를 보자.\n// 빈 행을 넣지 않을 경우 package fitnesse.wikitext.widgets; import java.util.regex.*; public class BoldWidget extends ParentWidget { public static final String REGEXP = \u0026quot;'''.+?'''\u0026quot;; private static final Pattern pattern = Pattern.compile(\u0026quot;'''(.+?)'''\u0026quot;, Pattern.MULTILINE + Pattern.DOTALL); public BoldWidget(ParentWidget parent, String text) throws Exception { super(parent); Matcher match = pattern.matcher(text); match.find(); addChildWidgets(match.group(1));} public String render() throws Exception { StringBuffer html = new StringBuffer(\u0026quot;\u0026lt;b\u0026gt;\u0026quot;); html.append(childHtml()).append(\u0026quot;\u0026lt;/b\u0026gt;\u0026quot;); return html.toString(); } }  // 빈 행을 넣을 경우 package fitnesse.wikitext.widgets; import java.util.regex.*; public class BoldWidget extends ParentWidget { public static final String REGEXP = \u0026quot;'''.+?'''\u0026quot;; private static final Pattern pattern = Pattern.compile(\u0026quot;'''(.+?)'''\u0026quot;, Pattern.MULTILINE + Pattern.DOTALL ); public BoldWidget(ParentWidget parent, String text) throws Exception { super(parent); Matcher match = pattern.matcher(text); match.find(); addChildWidgets(match.group(1)); } public String render() throws Exception { StringBuffer html = new StringBuffer(\u0026quot;\u0026lt;b\u0026gt;\u0026quot;); html.append(childHtml()).append(\u0026quot;\u0026lt;/b\u0026gt;\u0026quot;); return html.toString(); } }   세로 밀집도\n 줄바꿈이 개념을 분리한다면, 세로 밀집도는 연관성을 의미한다. 즉, 서로 밀집한 코드 행은 세로로 가까이 놓여야 한다.\n 같은 코드에 대헤서 세로 밀집도를 다르게 표현한 코드를 보자.\n// 의미없는 주석으로 변수를 떨어뜨려 놓아서 한눈에 파악이 잘 안된다. public class ReporterConfig { /** * The class name of the reporter listener */ private String m_className; /** * The properties of the reporter listener */ private List\u0026lt;Property\u0026gt; m_properties = new ArrayList\u0026lt;Property\u0026gt;(); public void addProperty(Property property) { m_properties.add(property); }  // 의미 없는 주석을 제거함으로써 코드가 한눈에 들어온다. // 변수 2개에 메소드가 1개인 클래스라는 사실이 드러난다. public class ReporterConfig { private String m_className; private List\u0026lt;Property\u0026gt; m_properties = new ArrayList\u0026lt;Property\u0026gt;(); public void addProperty(Property property) { m_properties.add(property); }   수직거리\n 서로 밀접한 개념은 세로로 가까이 둬야 한다. 타당한 근거가 없다면 서로 밀접한 개념은 한 파일에 속해야 마땅하다. 같은 파일에 속할 정도로 밀접한 두 개념은 세로 거리로 연관성(한 개념을 이해하는데 다른 개념이 중요한 정도)을 표현한다.\n 변수 선언\n 우리가 만든 함수는 매우 짧으므로(chapter03 참고)변수는 사용하는 위치에 최대한 가까이 선언한다.\n// InputStream이 함수 맨 처음에 선언 되어있다. private static void readPreferences() { InputStream is = null; try { is = new FileInputStream(getPreferencesFile()); setPreferences(new Properties(getPreferences())); getPreferences().load(is); } catch (IOException e) { try { if (is != null) is.close(); } catch (IOException e1) { } } }  // 모두들 알다시피 루프 제어 변수는 Test each처럼 루프 문 내부에 선언 public int countTestCases() { int count = 0; for (Test each : tests) count += each.countTestCases(); return count; }  // 드물지만, 긴 함수에서는 블록 상단 또는 루프 직전에 변수를 선언 할 수도 있다. ... for (XmlTest test : m_suite.getTests()) { TestRunner tr = m_runnerFactory.newTestRunner(this, test); tr.addListener(m_textReporter); m_testRunners.add(tr); invoker = tr.getInvoker(); for (ITestNGMethod m : tr.getBeforeSuiteMethods()) { beforeSuiteMethods.put(m.getMethod(), m); } for (ITestNGMethod m : tr.getAfterSuiteMethods()) { afterSuiteMethods.put(m.getMethod(), m); } } ...  인스턴스 변수\n 인스턴스 변수는 클래스 맨 처음에 선언한다.(자바의 경우)\n 종속 함수\n 한 함수가 다른 함수를 호출한다면(종속 함수) 두 함수는 세로로 가까이 배치한다. 일반적으로 함수 호출 종속성은 아래방향으로 유지하므로, 호출되는 함수를 호출하는 함수보다 뒤에 배치한다.\n 아래의 코드에서 makeResponse 함수에서 getPageNameOrDefault 함수를 호출하기 때문에 더 위에 작성되었다.\npublic class WikiPageResponder implements SecureResponder { protected WikiPage page; protected PageData pageData; protected String pageTitle; protected Request request; protected PageCrawler crawler; public Response makeResponse(FitNesseContext context, Request request) throws Exception { String pageName = getPageNameOrDefault(request, \u0026quot;FrontPage\u0026quot;); loadPage(pageName, context); if (page == null) return notFoundResponse(context, request); else return makePageResponse(context); } private String getPageNameOrDefault(Request request, String defaultPageName) { String pageName = request.getResource(); if (StringUtil.isBlank(pageName)) pageName = defaultPageName; return pageName; } ...    \n3. 가로 형식 맞추기 보통 행은 80자에서 120자까지로 제한한다.\n 가로 공백과 밀집도\n 가로로는 공백을 사용해 밀접/느슨한 개념을 표현한다\nprivate void measureLine(String line) { lineCount++; // 흔히 볼 수 있는 코드인데, 할당 연산자 좌우로 공백을 주어 왼쪽,오른쪽 요소가 확실하게 구분된다. int lineSize = line.length(); totalChars += lineSize; // 반면 함수이름과 괄호 사이에는 공백을 없앰으로써 함수와 인수의 밀접함을 보여준다 // 괄호 안의 인수끼리는 쉼표 뒤의 공백을 통해 인수가 별개라는 사실을 보여준다. lineWidthHistogram.addLine(lineSize, lineCount); recordWidestLine(lineSize); }  연산자의 우선순위를 강조하기 위해서도 공백을 사용한다.\n  들여쓰기\n 짧은 함수여도 들여쓰기는 가독성을 위해 사용하자.\npublic CommentWidget(ParentWidget parent, String text){super(parent, text);} public CommentWidget(ParentWidget parent, String text){ super(parent, text); } 위의 코드보다 아래의 코드가 훨씬 보기 좋다.    \n4. 팀 규칙 팀에 속해있다면 가장 우선시 되어야 할 규칙은 팀 규칙이다.\n\n5. 책의 저자가 사용하는 규칙이 드러나는 코드 public class CodeAnalyzer implements JavaFileAnalysis { private int lineCount; private int maxLineWidth; private int widestLineNumber; private LineWidthHistogram lineWidthHistogram; private int totalChars; public CodeAnalyzer() { lineWidthHistogram = new LineWidthHistogram(); } public static List\u0026lt;File\u0026gt; findJavaFiles(File parentDirectory) { List\u0026lt;File\u0026gt; files = new ArrayList\u0026lt;File\u0026gt;(); findJavaFiles(parentDirectory, files); return files; } private static void findJavaFiles(File parentDirectory, List\u0026lt;File\u0026gt; files) { for (File file : parentDirectory.listFiles()) { if (file.getName().endsWith(\u0026quot;.java\u0026quot;)) files.add(file); else if (file.isDirectory()) findJavaFiles(file, files); } } public void analyzeFile(File javaFile) throws Exception { BufferedReader br = new BufferedReader(new FileReader(javaFile)); String line; while ((line = br.readLine()) != null) measureLine(line); } private void measureLine(String line) { lineCount++; int lineSize = line.length(); totalChars += lineSize; lineWidthHistogram.addLine(lineSize, lineCount); recordWidestLine(lineSize); } private void recordWidestLine(int lineSize) { if (lineSize \u0026gt; maxLineWidth) { maxLineWidth = lineSize; widestLineNumber = lineCount; } } public int getLineCount() { return lineCount; } public int getMaxLineWidth() { return maxLineWidth; } public int getWidestLineNumber() { return widestLineNumber; } public LineWidthHistogram getLineWidthHistogram() { return lineWidthHistogram; } public double getMeanLineWidth() { return (double)totalChars/lineCount; } public int getMedianLineWidth() { Integer[] sortedWidths = getSortedWidths(); int cumulativeLineCount = 0; for (int width : sortedWidths) { cumulativeLineCount += lineCountForWidth(width); if (cumulativeLineCount \u0026gt; lineCount/2) return width; } throw new Error(\u0026quot;Cannot get here\u0026quot;); } private int lineCountForWidth(int width) { return lineWidthHistogram.getLinesforWidth(width).size(); } private Integer[] getSortedWidths() { Set\u0026lt;Integer\u0026gt; widths = lineWidthHistogram.getWidths(); Integer[] sortedWidths = (widths.toArray(new Integer[0])); Arrays.sort(sortedWidths); return sortedWidths; } }  \n결론  코드를 작성할 때 가로/세로 규칙을 적용해가며 작성하자.\n 내가 당장 쉽게 짜는 코드보다 모두가 쉽게 볼 수있는 코드를 작성하자.\n  \n출저 : https://github.com/Yooii-Studios/Clean-Code\n출저 : Clean Code 클린 코드 : 애자일 소프트웨어 장인 정신\n","id":18,"section":"posts","summary":"Chapter 05 - 형식 맞추기 질서정연하고 깔끔하며, 일관적인 코드를 본다면 사람들에게 전문가가 짰다는 인상을 심어줄 수 있다. 반대로, 코드가 어수선해 보인다면 프로젝트","tags":["클린코드"],"title":"Chapter 05 - 형식 맞추기","uri":"https://chlalstjd430.github.io/2020/01/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C_005/","year":"2020"},{"content":" 백준 문제 바로가기 \n사용 언어  C++  적용 알고리즘  위상 정렬 알고리즘  문제풀이 해당 문제에서 요구하는 것은 2가지이다.\n1. 모든 사람들이 만나는 시간 2. 1분도 쉬지 않고 달려야 하는 도로의 수 - 즉, 1번 요구사항에서 나온 시간에 딱 맞게 도착했을 때 거쳐간 도로의 수  2번째 요구사항이 나같은 경우 이해하기 힘들었는데, 쉽게 설명하자면 1번 요구사항에서 나온 시간만큼 걸려서 도착 도시에 도착했을 때, 시작 도시부터 거쳐간 도로의 개수를 구하면 된다. 해당 문제는 역추적 방식을 이용하면 문제를 쉽게 풀 수 있다.\n 먼저 지도 정보를 담을 클래스를 만들어주자.\nclass Edge { public: int node; int time; Edge(int node, int time) { this-\u0026gt;node = node; this-\u0026gt;time = time; } };  이후 위상 정렬 알고리즘을 사용하기 위한 변수들을 선언해준다.\nint n; int start, goal; int inDegree[MAX]; int result[MAX], visited[MAX]; vector\u0026lt;Edge\u0026gt; map[MAX]; vector\u0026lt;Edge\u0026gt; reverseMap[MAX];    여기서 reverseMap이라는게 나온데 이는 visted배열과 함께 이후 역추적 때 사용하기 위해 선언한 것이다.   위상 정렬 함수를 선언해준다.\nvoid topologySort() { queue\u0026lt;int\u0026gt; q; q.push(start); while (!q.empty()) { int current = q.front(); q.pop(); int mapSize = map[current].size(); for (int i = 0; i \u0026lt; mapSize; i++) { Edge next = Edge(map[current][i].node, map[current][i].time); int totalTime = next.time + result[current]; if (result[next.node] \u0026lt;= totalTime) { result[next.node] = totalTime; } if (--inDegree[next.node] == 0) { q.push(next.node); } } } cout \u0026lt;\u0026lt; result[goal] \u0026lt;\u0026lt; endl; }  역추적을 위한 함수를 선언해준다.\nvoid traceBack() { queue\u0026lt;int\u0026gt; q; int count = 0; q.push(goal); while (!q.empty()) { int front = q.front(); q.pop(); int reverseMapSize = reverseMap[front].size(); for (int i = 0; i \u0026lt; size i++) { Edge next = Edge(reverseMap[front][i].node, reverseMap[front][i].time); if (result[front] - result[next.node] == next.time) { if (visited[next.node] == 0) { q.push(next.node); visited[next.node] = 1; } } } } cout \u0026lt;\u0026lt; count; }    이 함수안에서는 queue에 goal을 넣고 시작해서 시작점이 아닌 도착점에서 시작한다.\n for문 안에 if조건문이 중요한 부분이다. 이미 result를 구했으므로 result 배열을 통해서 현재 도시까지의 거리 - 현재-1 도시까지의 거리 의 값이 다음 찾을 도시의 time정보랑 값이 같다면 해당 도로는 이전 거쳐가는 도로가 확실함으로 count를 증가시킨다.\n 이후 해동 도시를 queue에 다시 담지 않도록 방문 처리를 해준다음, queue에 담는다.\n  코드 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;algorithm\u0026gt; #define MAX 10002 using namespace std; class Edge { public: int node; int time; Edge(int node, int time) { this-\u0026gt;node = node; this-\u0026gt;time = time; } }; int n, start, goal; int inDegree[MAX], result[MAX], visited[MAX]; vector\u0026lt;Edge\u0026gt; map[MAX]; vector\u0026lt;Edge\u0026gt; reverseMap[MAX]; void topologySort() { queue\u0026lt;int\u0026gt; q; q.push(start); while (!q.empty()) { int current = q.front(); q.pop(); int mapSize = map[current].size(); for (int i = 0; i \u0026lt; mapSize; i++) { Edge next = Edge(map[current][i].node, map[current][i].time); int totalTime = next.time + result[current]; if (result[next.node] \u0026lt;= totalTime) { result[next.node] = totalTime; } if (--inDegree[next.node] == 0) { q.push(next.node); } } } cout \u0026lt;\u0026lt; result[goal] \u0026lt;\u0026lt; endl; } void traceBack() { queue\u0026lt;int\u0026gt; q; int count = 0; q.push(goal); while (!q.empty()) { int front = q.front(); q.pop(); int reverseMapSize = reverseMap[front].size(); for (int i = 0; i \u0026lt; size i++) { Edge next = Edge(reverseMap[front][i].node, reverseMap[front][i].time); if (result[front] - result[next.node] == next.time) { count++; if (visited[next.node] == 0) { q.push(next.node); visited[next.node] = 1; } } } } cout \u0026lt;\u0026lt; count; } int main() { int m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; m; i++) { int x, node, time; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; node \u0026gt;\u0026gt; time; map[x].push_back(Edge(node, time)); reverseMap[node].push_back(Edge(x, time)); inDegree[node]++; } cin \u0026gt;\u0026gt; start \u0026gt;\u0026gt; goal; topologySort(); traceBack(); }  ","id":19,"section":"posts","summary":"백준 문제 바로가기 사용 언어 C++ 적용 알고리즘 위상 정렬 알고리즘 문제풀이 해당 문제에서 요구하는 것은 2가지이다. 1. 모든 사람들이 만나는 시간 2. 1분도 쉬지 않고 달","tags":["위상 정렬 알고리즘"],"title":"백준 1948 - 임계경로","uri":"https://chlalstjd430.github.io/2020/01/%EB%B0%B1%EC%A4%801948/","year":"2020"},{"content":" Chapter 04 - 주석  나쁜 코드에 주석을 달지 마라. 새로 짜라. - 브라이언 W.커니핸, P.J.플라우거\n \n1. 불필요한 주석을 없애자.  주석은 코드로 의도를 표현하지 못하여 실패를 만회하기 위해 사용하는 것이다. 즉, 주석은 언제나 실패를 의미한다.\n 오래된 코드일수록 코드를 유지보수해도 주석을 유지보수하는 경우는 거의 없다.\n  \n2. 주석 대신 코드로 의도를 표현하라! // 직원에게 복지 혜택을 받을 자격이 있는지 검사한다. if ((emplotee.flags \u0026amp; HOURLY_FLAG) \u0026amp;\u0026amp; (employee.age \u0026gt; 65)  위 코드를 주석을 제거하고 함수 이름만으로 표현하면\nif (employee.isEligibleForFullBenefits())  다음과 같은 코드가 된다. 훨씬 보기 좋지 않은가?\n\n3. 필요한 주석  법적인 주석 : 소스 파일 첫머리에 들어가는 저작권 정보와 소유권 정보 등   // Copyright \u0026copy; 2003, 2004, 2005 by Object Montor, Inc. All right reserved. // GNU General Public License\n  정보를 제공하는 주석\n// kk:mm:ss EEE, MMM dd, yyyy 형식이다. Pattern timeMatcher = Pattern.compile(\u0026quot;\\\\d*:\\\\d*\\\\d* \\\\w*, \\\\w*, \\\\d*, \\\\d*\u0026quot;);  의도를 설명하는 주석\n// 스레드를 대량 생성하는 방법으로 어떻게든 경쟁 조건을 만들려 시도한다. for (int i = 0; i \u0026gt; 2500; i++) { WidgetBuilderThread widgetBuilderThread = new WidgetBuilderThread(widgetBuilder, text, parent, failFlag); Thread thread = new Thread(widgetBuilderThread); thread.start(); }  결과를 경고하는 주석\n// 여유 시간이 충분하지 않다면 실행하지 마십시오. public void _testWithReallyBigFile() { ... }  중요성을 강조하는 주석\nString listItemContent = match.group(3).trim(); // 여기서 trim은 정말 중요하다. trim 함수는 문자열에서 시작 공백을 제거한다. // 문자열에 시작 공백이 있으면 다른 문자열로 인식되기 때문이다. new ListItemWidget(this, listItemContent, this.level + 1); return buildList(text.substring(match.end()));  공개 API에서 Javadocs\n 설명이 잘 된 공개 API는 참으로 유용하고 만족스럽다. 공개 API를 구현한다면 반드시 훌륭한 Javadocs 작성을 추천한다. 하지만 여느 주석과 마찬가지로 Javadocs 역시 독자를 오도하거나, 잘못 위치하거나, 그릇된 정보를 전달할 가능성이 존재하는 것 역시 잊으면 안 된다.   \n4. 나쁜 주석  주절거리는 주석(특별한 이유없이 달리는 주석)\n 같은 이야기를 중복하는 주석\n 오해의 여지가 있는 주석\n 의무적으로 다는 주석\n 모든 함수에 Javadocs를 달거나 모든 변수에 주석을 달아야 한다는 규칙은 어리석기 그지없다. 이런 주석은 코드를 복잡하게 만들며, 거짓말을 퍼뜨리고, 혼동과 무질서를 초래한다. 아래와 같은 주석은 아무 가치도 없다.\n/** * * @param title CD 제목 * @param author CD 저자 * @param tracks CD 트랙 숫자 * @param durationInMinutes CD 길이(단위: 분) */ public void addCD(String title, String author, int tracks, int durationInMinutes) { CD cd = new CD(); cd.title = title; cd.author = author; cd.tracks = tracks; cd.duration = durationInMinutes; cdList.add(cd); }   소스 코드 관리 시스템이 해주는 것들\n 저자를 표시하는 주석\n 이력(기록)을 표시하는 주석\n 주석으로 처리한 코드\n 소스 코드 관리 시스템은 우리의 지난 코드들을 보관해준다.\n  위치를 표시하는 주석\n 닫는 괄호에 다는 주석\n 전역 정보(소스 코드 전체적으로 다는 주석)\n 주석은 반드시 근처에 있는 코드에 한해서만 기술하자.  비공개 코드에서 Javadocs\n 공개 API에서는 Javadocs가 유용하지만 공개하지 않을 코드이면 Javadocs는 쓸모가 없다.   \n결론  좋은 주석의 예시로 TODO 주석 같은게 있었지만, 이는 현재 다른 툴로 충분히 다룰수 있으므로 제외하였다.\n 사실 나쁜 주석으로 여러 예시들을 나열 했는데, 좋은 주석 예제들을 자세히보고 그 외의 주석들은 안다는게 편할듯 하다.\n 예전에야 주석이 잘 짜여져야 보기 편하다 했지만, 확실히 불필요한 주석은 가독성을 저해하고 유지보수가 되면서 왜곡된 정보들이 노출되는 것 같다. 앞으로 주석은 가급적 지양하고 함수명과 변수명을 통해 내 의도가 드러나도록 만들도록 해야겠다.\n  \n출저 : https://github.com/Yooii-Studios/Clean-Code\n출저 : Clean Code 클린 코드 : 애자일 소프트웨어 장인 정신\n","id":20,"section":"posts","summary":"Chapter 04 - 주석 나쁜 코드에 주석을 달지 마라. 새로 짜라. - 브라이언 W.커니핸, P.J.플라우거 1. 불필요한 주석을 없애자. 주석은 코드로 의도를 표현하지 못하여","tags":["클린코드"],"title":"Chapter 04 - 주석","uri":"https://chlalstjd430.github.io/2020/01/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C_004/","year":"2020"},{"content":" Chapter 03 - 함수 이번 시간에는 clean한 함수를 만드는 방법에 공부하였다. 어떻게 해야 좋은 함수를 만들 수 있는지 같이 확인 해 보자. 1. 함수는 작을수록(분리될수록) 좋다.  다음은 코드의 예시다, 위의 코드보다 아래 코드처럼 5줄 이내로 줄여서 사용할 것을 권장한다.\npublic static String renderPageWithSetupsAndTeardowns( PageData pageData, boolean isSuite) throws Exception { boolean isTestPage = pageData.hasAttribute(\u0026quot;Test\u0026quot;); if (isTestPage) { WikiPage testPage = pageData.getWikiPage(); StringBuffer newPageContent = new StringBuffer(); includeSetupPages(testPage, newPageContent, isSuite); newPageContent.append(pageData.getContent()); includeTeardownPages(testPage, newPageContent, isSuite); pageData.setContent(newPageContent.toString()); } return pageData.getHtml(); }  public static String renderPageWithSetupsAndTeardowns( PageData pageData, boolean isSuite) throws Exception { if (isTestPage(pageData)) includeSetupAndTeardownPages(pageData, isSuite); return pageData.getHtml(); }  에네르기파를 자제하자\n 우리는 간혹 if~else 문으로 depth가 3단계 넘어가는 경우도 보게된다. 그러한 코드는 가독성 뿐만 아니라 상당히 비효율적인 코드이다.   \n2. 함수는 하나의 기능만!  함수는 한 가지 기능만 해야한다. 한가지 함수내에서 기능들을 여러가지 나눌 수 있다면 그 함수는 하나가 아닌 여러작업을 하는 함수이다.  \n3. 함수 당 추상화 수준은 하나로  한 함수 내에서 추상화 수준은 섞이지 않고 동일해야 된다.\n 내려가기 규칙(위에서 아래로 코드 읽기)\n 함수 추상화 부분이 한번에 한단계씩 낮아지는 것이 가장 이상적이다.   \n4. switch는 댜형적 객체를 생성하는 코드 안에서만 사용을 권장한다.  물론 불가피한 상황에서는 적절히 이용할 수 있다.\n switch를 abstract factory에 숨겨 다형적 코드를 생성하는 예\npublic abstract class Employee { public abstract boolean isPayday(); public abstract Money calculatePay(); public abstract void deliverPay(Money pay); } public interface EmployeeFactory { public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType; } public class EmployeeFactoryImpl implements EmployeeFactory { public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType { switch (r.type) { case COMMISSIONED: return new CommissionedEmployee(r) ; case HOURLY: return new HourlyEmployee(r); case SALARIED: return new SalariedEmploye(r); default: throw new InvalidEmployeeType(r.type); } } }   \n5. 함수 인수 함수에서 이상적인 인수 개수는 0개(무항). 인수는 코드 이해에 방해가 되는 요소이므로 최선은 0개이고, 차선은 1개뿐인 경우이다. 출력인수(함수의 반환 값이 아닌 입력 인수로 결과를 받는 경우)는 이해하기 어려우므로 왠만하면 쓰지 않는 것이 좋겠다.\n 많이 쓰이는 단항 형식\n 인수에 질문을 던지는 경우\n boolean fileExists(“MyFile”);\n 인수를 뭔가로 변환해 결과를 변환하는 경우\n InputStream fileOpen(“MyFile”);\n 이벤트 함수일 경우 (이 경우에는 이벤트라는 사실이 코드에 명확하게 드러나야 한다.)\n  플래그 인수\n bool값을 넘기는 것 자체가 함수의 기능이 하나가 아닌 것을 입증하게 된다. 즉, 플래그 인수는 쓰지말자.  단항 함수\n 단항 함수는 함수와 인수가 동사/명사 쌍을 이루어야 한다.\n writeField(name);\n 함수이름에 키워드(인수 이름)을 추가하면 인수 순서를 기억할 필요가 없다.\n assertExpectedEqualsActual(expected, actual);\n  다항 함수\n 단항 함수보다 한번에 알아보기 힘들다. 이항 함수의 경우에는 무조건적으로 지양해야 할 대상은 아니지만 가능하면 단항 함수로 변경하여 사용하자.\n 결론적으로 매개변수가 많아질수록 코드의 이해도는 떨어질 것이다.\n 많은 매개변수를 전달해야 할 때 클래스로 변수를 넘길수는 없는지 생각해보자.\n 때로는 String format 같은 인수 개수가 가변적인 경우도 필요하다.\n   \n6. 부수 효과를 일으키지 말자! 부수효과는 함수에서 한 가지 역할만 하겠다고 약속하고 거짓말을 하는 셈이다.\n\n7. 명령과 조회를 분리하라 함수는 객체 상태를 변겅하거나, 객체 정보를 반환하거나 둘 중 하나다. 둘 다 수행해서는 안된다.\n\n\u0026lt;br?\n8. 오류코드보다 예외를 사용하자 try/catch 를 사용하면 코드가 훨씬 간결해진다.\n if/else 로 정상 작동과 오류 처리 작동을 뒤섞는 구조는 정말 보기 안좋다. 그러므로 try/catch 로 예외 처리를 진행하자.\n// 보기 안좋은 if/else로 정상/오류 작동 처리 if (deletePage(page) == E_OK) { if (registry.deleteReference(page.name) == E_OK) { if (configKeys.deleteKey(page.name.makeKey()) == E_OK) { logger.log(\u0026quot;page deleted\u0026quot;); } else { logger.log(\u0026quot;configKey not deleted\u0026quot;); } } else { logger.log(\u0026quot;deleteReference from registry failed\u0026quot;); } } else { logger.log(\u0026quot;delete failed\u0026quot;); return E_ERROR; }  // try/catch를 사용한 예외 처리 public void delete(Page page) { try { deletePageAndAllReferences(page); } catch (Exception e) { logError(e); } } private void deletePageAndAllReferences(Page page) throws Exception { deletePage(page); registry.deleteReference(page.name); configKeys.deleteKey(page.name.makeKey()); } private void logError(Exception e) { logger.log(e.getMessage()); }   \n9. 코드의 중복은 없애자  중복은 모든 소프트웨어에서 악의 근원이다. 중복된 코드는 하나의 함수로 만들어 재사용하자.  \n10. 구조적 프로그래밍 다익스크라의 구조적 프로그래밍의 원칙을 따르자면 모든 함수와 함수 내 모든 블록에 입구와 출구가 하나여야 된다. 즉, 함수는 return문이 하나여야 되며, 루프 안에서 break나 continue를 사용해선 안된며 goto는 절대로, 절대로 사용하지 말자. 함수가 클 경우에만 상당 이익을 제공하므로, 함수를 작게 만든다면 오히려 여러차례 사용하는 것이 함수의 의도를 표현하기 쉬워진다.\n그런데 구조적 프로그래밍의 목표와 규율은 공감하지만 함수가 작다면 위 규칙은 별 이익을 제공하지 못한다. 함수가 아주 클 때만 상당한 이익을 제공한다. 그러므로 함수를 작게 만든다면 간혹 return, break, continue를 사용해도 괜찮다. 오히려 때로는 단일 입/출구 규칙보다 의도를 표현하기 쉬워진다.\n결론  이 문서에서 다루지는 않았지만 chapter02 - 의미있는 이름에서 함수명을 짓는 방법도 나와있으니 참고하면 좋을 것 같다.\n 처음부터 완벽히 위의 10개의 규칙들을 적용하며 함수를 만들면 좋지만, 사람이다보니 처음부터 완벽할수는 없다. 차근차근 습관을 길들이도록 하자.\n  \n출저 : https://github.com/Yooii-Studios/Clean-Code\n출저 : Clean Code 클린 코드 : 애자일 소프트웨어 장인 정신\n","id":21,"section":"posts","summary":"Chapter 03 - 함수 이번 시간에는 clean한 함수를 만드는 방법에 공부하였다. 어떻게 해야 좋은 함수를 만들 수 있는지 같이 확인 해 보자. 1. 함수는 작을수록(분리될수록","tags":["클린코드"],"title":"Chapter 03 - 함수","uri":"https://chlalstjd430.github.io/2020/01/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C_003/","year":"2020"},{"content":" 백준 문제 바로가기 \n사용 언어  C++  적용 알고리즘  다익스트라 알고리즘  문제풀이 이 문제는 얼핏 보면 단순 다익스트라 알고리즘을 한번 적용하여 풀 수 있는 문제로 보인다. 그러나 문제를 잘 들여다 보면 다음과 같은 문구를 확인할 수 있다.\n 세준이는 한번 이동했던 정점은 물론, 한번 이동했던 간선도 다시 이동할 수 있다. 하지만 반드시 최단 경로로 이동해야 한다는 사실에 주의하라. 1번 정점에서 N번 정점으로 이동할 때, 주어진 두 정점을 반드시 거치면서 최단 경로로 이동하는 프로그램을 작성하시오.\n 이 문구를 통해 우리는 반드시 주어진 두 정점을 거쳐 1부터 N번의 정점으로 이동하여야 한다. 위 문제를 해결하기 위해서 반드시 거쳐야 할 두 정점을 a,b라고 가정해보면 다음과 같은 과정이 나온다.\n1. a-\u0026gt;b로 이동하는 과정\n 1 -\u0026gt; a -\u0026gt; b -\u0026gt; N\n dijkstra(1-\u0026gt;a) + dijkstra(a-\u0026gt;b) + dijkstra(b-\u0026gt;N)\n  2. b-\u0026gt;a로 이동하는 과정\n 1 -\u0026gt; b -\u0026gt; a -\u0026gt; N\n dijkstra(1-\u0026gt;b) + dijkstra(b-\u0026gt;a) + dijkstra(a -\u0026gt; N)\n  총 2가지의 과정 중 적은 과정을 택하여 값으로 출력하면 된다. 그리하여 작성된 코드를 보면 다음과 같다.\n코드 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; const int INF = 1000000; // 과정을 진행할 때 INF가 3번 더해지는 경우가 있으니 이를 고려하여 INF값을 설정하여야 한다. const int MAX = 10000; int N, E; vector\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; graph[MAX]; int visited[MAX]; void dijkstra(int start) { visited[start] = 0; priority_queue\u0026lt;pair\u0026lt;int,int\u0026gt; \u0026gt; pq; pq.push(make_pair(0, start)); while (!pq.empty()) { int current = pq.top().second; int distance = -pq.top().first; pq.pop(); int size = graph[current].size(); for(int i = 0; i \u0026lt; size; i++){ int next = graph[current][i].first; int nextDistance = distance + graph[current][i].second; if (nextDistance \u0026lt; visited[next]) { visited[next] = nextDistance; pq.push(make_pair(-nextDistance, next)); } } } } // 초기화 void init() { fill(\u0026amp;visited[0], \u0026amp;visited[MAX - 1], INF); } // 다익스트라 알고리즘 실행 후 원하는 경로가 있는지 확인 int isINF(int goal) { if (visited[goal] == INF) return INF; else return visited[goal]; } int isPossible(int a, int b, int c, int d) { init(); dijkstra(a); int a_b = isINF(b); init(); dijkstra(b); int b_c = isINF(c); init(); dijkstra(c); int c_d = isINF(d); // 3개의 경로 중 하나라도 경로가 없으면 두 정점을 거쳐서 1부터 N까지 갈 수 없으므로 INF값을 리턴 if (a_b == INF || b_c == INF || c_d == INF) return INF; // 3개의 경로 모두 값이 있으면 합계 리턴 return a_b + b_c + c_d; } int main() { cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; E; int a, b, c; int start, goal; for (int i = 0; i \u0026lt; E; i++) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; // 무방향 그래프이므로 a에서 b로 가는 것과 b에서 a로 가는 것 둘다 받아야 한다. graph[a].push_back(make_pair(b, c)); graph[b].push_back(make_pair(a, c)); } cin \u0026gt;\u0026gt; start \u0026gt;\u0026gt; goal; int one = isPossible(1, start, goal, N); int two = isPossible(1, goal, start, N); int result = min(one, two); // 두가지 과정 모두 경로가 없으면 -1 리턴 cout \u0026lt;\u0026lt; (result \u0026gt;= INF ? -1 : result); }  ","id":22,"section":"posts","summary":"백준 문제 바로가기 사용 언어 C++ 적용 알고리즘 다익스트라 알고리즘 문제풀이 이 문제는 얼핏 보면 단순 다익스트라 알고리즘을 한번 적용하여 풀 수 있는 문제로 보인다. 그","tags":["다익스트라 알고리즘"],"title":"백준 1504 - 특정한 최단 경로","uri":"https://chlalstjd430.github.io/2020/01/%EB%B0%B1%EC%A4%801504/","year":"2020"},{"content":" Chapter 02 - 의미있는 이름 \n1. 의도가 담긴 이름을 짓자  변수명/메서드명을 통해서 역할을 추정할 수 있도록 이름을 짓자.\n 별도의 주석이 필요 없을 정도로 명확하게 이름을 짓자.\n 예시\nint d; (X) -\u0026gt; int elapsedTimeInDays; public void getThem(){ ... } (x) -\u0026gt; public void getFlaggedCells(){ ... } (o)   \n2. 그릇된 정보를 피하자.  중의적인 의미를 피하자.\n 개발자에게 특수한 의미를 가지는 단어(Collection - list 등)는 실제 컨테이너가 해당 타입이 아닌 경우 변수명에 넣지 말자.\n 예시\nString[] customerList; (x) -\u0026gt; List\u0026lt;String\u0026gt; customerList; (o)   \n3. 불용어(noise word)를 사용하지 말자.  클래스 이름에 Manager, Processor, Data, Info 같은 불용어를 붙이지 말자.\n 예시\nClass StudentInfo{ ... } (x) -\u0026gt; Class Student{ ... } (o)   \n4. 발음하기 쉬운 이름을 사용하자.  숫자를 혼용하지 말자.\n 우리가 아는 단어 위주로 사용하자.\n  \n5. 검색하기 쉬운 이름을 사용하자.  상수는 static final과 같이 정희하여 사용하자.\n 변수의 이름은 변수의 범위에 비례하여 길어진다.\n  6. 클래스/메서드  변수\n 변수명에 해당 변수의 타입등을 적지말자.  클래스\n 명사 혹은 명사구(Custemer, Student)를 사용하고 동사는 사용하지 말자.  메서드\n 동사 혹은 동사구(updatePayment, deleteAccount)하자.\n 접근자는 get, 변경자는 set, 조건자는 is로 시작하자. (should, has 도 가능)\n 생성자를 오버로드할 경우 정적 팩토리 메서드를 사용하고 해당 생성자를 private로 선언한다.\n 예시\nComplex fulcrumPoint = new Complex(23.0); (x) Complex fulcrumPoint = Complex.FromRealNumber(23.0); (o)    \n7. 함부로 이름을 줄이지 말자. GS (x) -\u0026gt; GasStation (o)  \n결론  사실 위의 내용 말고 \u0026ldquo; -를 사용하자\u0026rdquo;, \u0026ldquo;-를 하지말자\u0026rdquo; 라는 내용이 더 있다. 하지만 근본적인 내용들은 위의 내용과 겹칠 뿐더러 오히려 더 나열하면 헷갈릴 것 같아 정리 내용에서 제외하였다.\n 결론적으로 이름을 성의있게 지어야 한다는 것을 알게 되었다. 나 역시도 어느정도 성의 있게 지켜가며 이름을 지었지만 이번 공부를 통해 더 명확하게 이름을 지을 수 있을 것 같다.\n  \n출저 : https://github.com/Yooii-Studios/Clean-Code\n출저 : Clean Code 클린 코드 : 애자일 소프트웨어 장인 정신\n","id":23,"section":"posts","summary":"Chapter 02 - 의미있는 이름 1. 의도가 담긴 이름을 짓자 변수명/메서드명을 통해서 역할을 추정할 수 있도록 이름을 짓자. 별도의 주석이 필요 없을 정도로 명확하게 이름을 짓자","tags":["클린코드"],"title":"Chapter 02 - 의미있는 이름","uri":"https://chlalstjd430.github.io/2020/01/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C_002/","year":"2020"},{"content":" 01.21부로 클린 코드에 대하여 요약한 게시글을 보고 나만의 후기를 남길 예정이다.\n책은 우선시 되는 다른 공부가 어느정도 정리되면 그 때 읽어볼 예정이다.\n\nChapter 01 - 깨끗한 코드 \n1. 나쁜 코드 우리는 종종 당장의 문제를 해결하기 위해 나쁜 코드(가독성,효율성,등 여러면에서)를 작성하고는 한다. 이러한 코드들은 당장의 문제를 해결해 줄 뿐이지 추후 결과적으로는 우리에게 최악의 상황을 초래한다. 그렇기 때문에 초기에 나쁜 코드가 아닌 클린한 코드를 작성하는 것이 중요하다.\n\n2. 보이스카우트 규칙  \u0026ldquo;Leave the campground cleaner than you found it.\u0026rdquo;\n 위 문구는 보이스카우트에서 인용된 문구이다. 이 말을 우리(프로그래머)의 언어로 받아 들이면 다음과 같다.\n \u0026ldquo;눈 앞에 더러운 코드가 보이면 조금이라도(변수명,if문 한줄) 개선하여라\u0026rdquo;\n 한번에 모든걸 하려면 어렵다. 그러나 조금씩이라도 변화를 지속하다보면 그것이 습관이되고 결국에는 근본적인 문제점 또한 해결 될 것이다.\n\n3. 같이 읽어보면 좋은 책 클린 코드에서는 이 책이 Agile Sorfware Development의 프리퀄이라고 말하였다. 추후에 해당 책도 읽어보면 좋을 듯 하다.\n\n결론  깨끗한 코드를 만들기 위해서 무작정 당장의 문제 해결에 집중하지 말고 장기적인 관점에서 코드를 작성하다.\n 보이스카우트 규칙에 따라 많이는 아니더라도 조금씩이라도 코드를 고쳐나가자.\n Agile Sorfware Development을 시간이 되면 읽어보자.\n  \n출저 : https://github.com/Yooii-Studios/Clean-Code\n출저 : Clean Code 클린 코드 : 애자일 소프트웨어 장인 정신\n","id":24,"section":"posts","summary":"01.21부로 클린 코드에 대하여 요약한 게시글을 보고 나만의 후기를 남길 예정이다. 책은 우선시 되는 다른 공부가 어느정도 정리되면 그 때 읽어볼 예정이다. Chapter 01 -","tags":["클린코드"],"title":"Chapter 01 - 깨끗한 코드","uri":"https://chlalstjd430.github.io/2020/01/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C_001/","year":"2020"},{"content":" 백준 문제 바로가기 \n사용 언어  C++  적용 알고리즘  다이나믹 프로그래밍  문제풀이   포도주 잔을 선택하면 그 잔에 들어있는 포도주는 모두 마셔야 하고, 마신 후에는 원래 위치에 다시 놓아야 한다. 연속으로 놓여 있는 3잔을 모두 마실 수는 없다.   문제의 조건 중 위 두가지 조건으로 보아 일정한 규칙을 세울 수 있다.\n포도주를 마실때 총 3가지 조건으로 나누어지게 된다.\n첫번째 포도주인 경우\n 현재까지의 포도주 양 = 현재 포도주 양 + 이전까지의 포도주 양\n 두번째 포도주인 경우\n 현재까지의 포도주 양 = 현재 포도주 양 + 이전 포도주 양 + 현재-3까지의 포도주 양\n 세번째 포도주인 경우(건너띄는 포도주)\n 현재까지의 포도주 양 = 이전까지의 포도주 양\n 이를 통해 다음과 같은 코드가 나오게 되었다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; long long int podo[10002]; long long int dp[10002]; int main() { int n; long long int maxPodo; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; podo[i]; } if (n == 1) { cout \u0026lt;\u0026lt; podo[1]; return 0; } else if (n == 2) { cout \u0026lt;\u0026lt; max(podo[1], (podo[1] + podo[2])); return 0; } dp[1] = podo[1]; dp[2] = dp[1] + podo[2]; maxPodo = dp[2]; for (int i = 3; i \u0026lt;= n; i++) { dp[i] = max(podo[i] + dp[i - 2], max((podo[i] + podo[i - 1] + dp[i - 3]), dp[i-1]) ); maxPodo = max(maxPodo, dp[i]); } cout \u0026lt;\u0026lt; maxPodo; }  ","id":25,"section":"posts","summary":"백준 문제 바로가기 사용 언어 C++ 적용 알고리즘 다이나믹 프로그래밍 문제풀이 포도주 잔을 선택하면 그 잔에 들어있는 포도주는 모두 마셔야 하고, 마신 후에는 원래 위치에","tags":["다이나믹 프로그래밍"],"title":"백준 2156 - 포도주 시식","uri":"https://chlalstjd430.github.io/2020/01/%EB%B0%B1%EC%A4%802156/","year":"2020"},{"content":"☞ 백준 문제 바로가기[9465- 스티커]\n\u0026nbsp;\n\u0026nbsp;\n사용 언어\n- C++\n\u0026nbsp;\n﻿적용 알고리즘\n- Dynamic Programing(다이나믹 프로그래밍)\n-\u0026nbsp;관련 동영상 강의 바로가기\n\u0026nbsp;\n\u0026nbsp;\n관련 문제\n- 백준\n\u0026nbsp;-\u0026gt;\u0026nbsp;1149,\u0026nbsp;9465,\u0026nbsp;2579, 1003, 11726, 11727 2133, 14852, 11048, 1309,\u0026nbsp; 2156, 2864, 1965, 2293, 11066, 9461, 1520, 10942\n\u0026nbsp;\n문제 풀이\n다이나믹 프로그래밍(Dynamic Programing) 문제를 풀 때에는 항상\u0026nbsp;문제의 조건과\u0026nbsp;하나의 값을 가질 수 있는 경우이다.\n현재 문제에서의 조건은 다음과 같다.\n\n1. 스티커는 2N의 크기이다.\n2. 뗀 스티커의 왼쪽,위,오른쪽,아래의 스티커는 사용 할 수 없다.\n\n따라서 왼쪽부터 스티커를 뗀다고 하면, 최종적으로 마지막 (0,N),(1,N)의 스티커 중 하나는 뗴어져야한다. 이를 가지고 조건을 만든다면.\n1) 마지막 스티커가 첫번째 줄인 경우 - (0,N)\n(1) 이전 스티커가 현재 스티커 기준으로 왼쪽 대각선 아래인 경우 - (1,N-1)\n현재 스티커까지의 합 = 현재 스티커 + 왼쪽 대각선 아래 스티커까지의 합\ndp([0][N]) = [0][N] + dp([1][N-1])\u0026nbsp;\n(2) 이전 스티커가 현재 스티커 기준으로 왼쪽에서 두번째인 경우 - (0, N-2)\n현재 스티커까지의 합 = 현재 스티커 + 왼쪽 두번째 스티커까지의 합\ndp([0][N]) = [0][N] + dp([0][N-2])\n(3) 이전 스티커가 현재 스티커 기준으로 왼쪽에서 두번째, 대각선 아래인 경우 - (1, N-2)\n현재 스티커까지의 합 = 현재 스티커 + 왼쪽 두번째,대각선 아래 스티커까지의 합\ndp([0][N]) = [0][N] + dp([1][N-2])\n\n- dp([0][N]) = (1),(2),(3) 중에 가장 큰 값\n\n2) 마지막 스티커가 두번째 줄인 경우 - (1,N)\n(1) 이전 스티커가 현재 스티커 기준으로 왼쪽 대각선 위인 경우 - (0,N-1)\n현재 스티커까지의 합 = 현재 스티커 + 왼쪽 대각선 위 스티커까지의 합\ndp([1][N]) = [1][N] + dp([0][N-1])\u0026nbsp;\n(2) 이전 스티커가 현재 스티커 기준으로 왼쪽에서 두번째인 경우 - (1, N-2)\n현재 스티커까지의 합 = 현재 스티커 + 왼쪽 두번째 스티커까지의 합\ndp([1][N]) = [1][N] + dp([1][N-2])\n(3) 이전 스티커가 현재 스티커 기준으로 왼쪽에서 두번째, 대각선 위인 경우 - (1, N-2)\n현재 스티커까지의 합 = 현재 스티커 + 왼쪽 두번째,대각선 위 스티커까지의 합\ndp([1][N]) = [1][N] + dp([0][N-2])\n\n- dp([1][N]) = (1),(2),(3) 중에 가장 큰 값\n\n최종적으로 dp[0][N]과 dp[1][N] 중에 큰 값이 답이 될 수 있다.\u0026nbsp;\n\n이를 통해 스티커와 DP 배열을 선언한다.\n\n12int\u0026nbsp;sticker[2][100002];int\u0026nbsp;dp[2][100002];cs이후 앞에서 설명한 조건을 통해 최대값을 구한 후 출력하면 문제를 해결 할 수 있다.\n123456789dp[0][1]\u0026nbsp;=\u0026nbsp;sticker[0][1];dp[1][1]\u0026nbsp;=\u0026nbsp;sticker[1][1];\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;j\u0026nbsp;=\u0026nbsp;2;\u0026nbsp;j\u0026nbsp;\u0026lt;=\u0026nbsp;n;\u0026nbsp;j++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[0][j]\u0026nbsp;=\u0026nbsp;sticker[0][j]\u0026nbsp;+\u0026nbsp;max(dp[1][j\u0026nbsp;-\u0026nbsp;1],\u0026nbsp;max(dp[0][j\u0026nbsp;-\u0026nbsp;2],\u0026nbsp;dp[1][j\u0026nbsp;-\u0026nbsp;2]));\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[1][j]\u0026nbsp;=\u0026nbsp;sticker[1][j]\u0026nbsp;+\u0026nbsp;max(dp[0][j\u0026nbsp;-\u0026nbsp;1],\u0026nbsp;max(dp[0][j\u0026nbsp;-\u0026nbsp;2],\u0026nbsp;dp[1][j\u0026nbsp;-\u0026nbsp;2]));}\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;max(dp[0][n],\u0026nbsp;dp[1][n])\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;endl;Colored by Color Scriptercs\n\u0026nbsp;\n\u0026nbsp;\n최종 코드\n\n12345678910111213141516171819202122232425262728293031323334353637383940#include\u0026nbsp;\u0026lt;iostream\u0026gt;#include\u0026nbsp;\u0026lt;algorithm\u0026gt;\u0026nbsp;using\u0026nbsp;namespace\u0026nbsp;std;\u0026nbsp;int\u0026nbsp;sticker[2][100002];//스티커를\u0026nbsp;저장할\u0026nbsp;배열int\u0026nbsp;dp[2][100002];//dp\u0026nbsp;전용\u0026nbsp;배열\u0026nbsp;int\u0026nbsp;main()\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;tc,n;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;tc;//테스트\u0026nbsp;케이스\u0026nbsp;입력\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;i\u0026nbsp;\u0026lt;\u0026nbsp;tc;\u0026nbsp;i++)\u0026nbsp;{//테스트\u0026nbsp;케이스\u0026nbsp;만큼\u0026nbsp;반복\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;n;//스티커\u0026nbsp;크기\u0026nbsp;입력\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;j\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;j\u0026nbsp;\u0026lt;\u0026nbsp;2;\u0026nbsp;j++)\u0026nbsp;{//스티커\u0026nbsp;값\u0026nbsp;입력\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;k\u0026nbsp;=\u0026nbsp;1;\u0026nbsp;k\u0026nbsp;\u0026lt;=\u0026nbsp;n;\u0026nbsp;k++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;sticker[j][k];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;//dp\u0026nbsp;첫번째\u0026nbsp;값\u0026nbsp;입력\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[0][1]\u0026nbsp;=\u0026nbsp;sticker[0][1];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[1][1]\u0026nbsp;=\u0026nbsp;sticker[1][1];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;//dp\u0026nbsp;구하기\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;j\u0026nbsp;=\u0026nbsp;2;\u0026nbsp;j\u0026nbsp;\u0026lt;=\u0026nbsp;n;\u0026nbsp;j++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[0][j]\u0026nbsp;=\u0026nbsp;sticker[0][j]\u0026nbsp;+\u0026nbsp;max(dp[1][j\u0026nbsp;-\u0026nbsp;1],\u0026nbsp;max(dp[0][j\u0026nbsp;-\u0026nbsp;2],\u0026nbsp;dp[1][j\u0026nbsp;-\u0026nbsp;2]));\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[1][j]\u0026nbsp;=\u0026nbsp;sticker[1][j]\u0026nbsp;+\u0026nbsp;max(dp[0][j\u0026nbsp;-\u0026nbsp;1],\u0026nbsp;max(dp[0][j\u0026nbsp;-\u0026nbsp;2],\u0026nbsp;dp[1][j\u0026nbsp;-\u0026nbsp;2]));\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;//최종\u0026nbsp;값\u0026nbsp;출력\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;max(dp[0][n],\u0026nbsp;dp[1][n])\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;endl;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;//스티커와\u0026nbsp;DP\u0026nbsp;배열\u0026nbsp;초기화\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;j\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;j\u0026nbsp;\u0026lt;=\u0026nbsp;n;\u0026nbsp;j++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[0][j]\u0026nbsp;=\u0026nbsp;sticker[0][j]\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[1][j]\u0026nbsp;=\u0026nbsp;sticker[1][j]\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}Colored by Color Scriptercs\n\n추가적으로 질문사항이 있으시면 언제든지 댓글을 달아주세요:D\n\n\u0026nbsp;\n\n\u0026nbsp;\n\n\u0026nbsp;\n\n\u0026nbsp;\n","id":26,"section":"posts","summary":"☞ 백준 문제 바로가기[9465- 스티커] \u0026nbsp; \u0026nbsp; 사용 언어 - C++ \u0026nbsp; ﻿적용 알고리즘 - Dynamic Programing(다이나믹 프로그래밍) -\u0026nbsp;관련 동영상","tags":["다이나믹 프로그래밍"],"title":"백준 9465 - 스티커","uri":"https://chlalstjd430.github.io/2020/01/%EB%B0%B1%EC%A4%809465/","year":"2020"},{"content":"☞ 백준 문제 바로가기[2579- 계단 오르기]\n\u0026nbsp;\n\u0026nbsp;\n사용 언어\n- C++\n\u0026nbsp;\n﻿적용 알고리즘\n- Dynamic Programing(다이나믹 프로그래밍)\n-\u0026nbsp;관련 동영상 강의 바로가기\n\u0026nbsp;\n\u0026nbsp;\n관련 문제\n- 백준\n\u0026nbsp;-\u0026gt;\u0026nbsp;1149,\u0026nbsp;9465,\u0026nbsp;2579, 1003, 11726, 11727 2133, 14852, 11048, 1309,\u0026nbsp; 2156, 2864, 1965, 2293, 11066, 9461, 1520, 10942\n\u0026nbsp;\n문제 풀이\n문제에서 주어진 조건들을 먼저 살표보면 다음과 같습니다.\n\n1. 계단은 한번에 1개 혹은 2개를 오를 수 있다.\n2. 계단은 연속으로 3칸을 오를 수 없다.\n3. 마지막 계단은 무조건 밟아야한다.\n\n따라서 마지막 계단을 밟아야한다면 다음과 같이 두 조건으로 분류 할 수 있습니다.\n1) 마지막 계단이 처음 밟는 계단일 경우\n마지막 계단까지의 값 = 마지막 계단 값 + [마지막 - 2]까지 밟았던 값들의 총합\nN = N + dp(n-2)\n\n2) 마지막 계단이 마지막으로(두번째로) 밟는 계단일 경우\n마지막 계단까지의 값 = 마지막 계단 값 + [마지막 - 1] 계단의 값 + [마지막 - 3] 까지 밟았던 값들의 총합\nN = N + N-1 +dp(n-3)\n\n이를 통해 N을 stair(=현재 계단)이라고 하고 하면 다음과 같이 전역 변수를 선언 할 수 있습니다.\n\n12int\u0026nbsp;stair[301];int\u0026nbsp;dp[301];cs이어서 두가지의 경우 중 큰 값들을 나란히 넣어주고 최종적으로 마지막 계단 값을 출력하면 결과를 도출해 낼 수 있습니다.\n\n123456dp[1]\u0026nbsp;=\u0026nbsp;stair[1];dp[2]\u0026nbsp;=\u0026nbsp;stair[2]\u0026nbsp;+\u0026nbsp;dp[1];for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;3;\u0026nbsp;i\u0026nbsp;\u0026lt;=\u0026nbsp;tc;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[i]\u0026nbsp;=\u0026nbsp;stair[i]\u0026nbsp;+\u0026nbsp;\u0026nbsp;max(dp[i\u0026nbsp;-\u0026nbsp;2],\u0026nbsp;(stair[i\u0026nbsp;-\u0026nbsp;1]\u0026nbsp;+\u0026nbsp;dp[i\u0026nbsp;-\u0026nbsp;3]));}cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;dp[tc];Colored by Color Scriptercs\n\u0026nbsp;\n\u0026nbsp;\n최종 코드\n\n12345678910111213141516171819202122#include\u0026nbsp;\u0026lt;iostream\u0026gt;#include\u0026nbsp;\u0026lt;algorithm\u0026gt;\u0026nbsp;using\u0026nbsp;namespace\u0026nbsp;std;\u0026nbsp;int\u0026nbsp;stair[301];int\u0026nbsp;dp[301];\u0026nbsp;int\u0026nbsp;main()\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;tc;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;tc;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;1;\u0026nbsp;i\u0026nbsp;\u0026lt;=\u0026nbsp;tc;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;stair[i];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[1]\u0026nbsp;=\u0026nbsp;stair[1];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[2]\u0026nbsp;=\u0026nbsp;stair[2]\u0026nbsp;+\u0026nbsp;dp[1];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;3;\u0026nbsp;i\u0026nbsp;\u0026lt;=\u0026nbsp;tc;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[i]\u0026nbsp;=\u0026nbsp;stair[i]\u0026nbsp;+\u0026nbsp;\u0026nbsp;max(dp[i\u0026nbsp;-\u0026nbsp;2],\u0026nbsp;(stair[i\u0026nbsp;-\u0026nbsp;1]\u0026nbsp;+\u0026nbsp;dp[i\u0026nbsp;-\u0026nbsp;3]));\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;dp[tc];}\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;Colored by Color Scriptercs\n추가적으로 질문사항이 있으시면 언제든지 댓글을 달아주세요:D\n\n\u0026nbsp;\n\n\u0026nbsp;\n\n\u0026nbsp;\n","id":27,"section":"posts","summary":"☞ 백준 문제 바로가기[2579- 계단 오르기] \u0026nbsp; \u0026nbsp; 사용 언어 - C++ \u0026nbsp; ﻿적용 알고리즘 - Dynamic Programing(다이나믹 프로그래밍) -\u0026nbsp;관련 동","tags":["다이나믹 프로그래밍"],"title":"백준 2579 - 계단 오르기","uri":"https://chlalstjd430.github.io/2020/01/%EB%B0%B1%EC%A4%802579/","year":"2020"},{"content":"☞ 백준 문제 바로가기[1149 - RGB거리]\n\u0026nbsp;\n\u0026nbsp;\n사용 언어\n- C++\n\u0026nbsp;\n﻿적용 알고리즘\n- Dynamic Programing(다이나믹 프로그래밍)\n-\u0026nbsp;관련 동영상 강의 바로가기\n\u0026nbsp;\n\u0026nbsp;\n관련 문제\n- 백준\n\u0026nbsp;-\u0026gt;\u0026nbsp;1149,\u0026nbsp;9465,\u0026nbsp;2579, 1003, 11726, 11727 2133, 14852, 11048, 1309,\u0026nbsp; 2156, 2864, 1965, 2293, 11066, 9461, 1520, 10942\n\u0026nbsp;\n문제 풀이\n해당 문제에서 요구하는 것은 하나의 집에 대헤서 이웃하는 집(i-1,i+1)과 다른 페인트를 색칠하게 하는 것이다. 그리하여 모든 집을 칠하는 최소 페인트 비용을 구하면된다.\n우선 하나의 집에 대헤서 각각의 페인트 비용을 저장하기 위해 다음과 같은 전역 변수를 선언해주었다.\n\n1int\u0026nbsp;cost[1001][3];cs그리고 문제 해결을 위해서 다음과 같은 접근을 하게 되었다.\n\n12345\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;1;\u0026nbsp;i\u0026nbsp;\u0026lt;\u0026nbsp;n;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cost[i][0]\u0026nbsp;=\u0026nbsp;cost[i][0]\u0026nbsp;+\u0026nbsp;min(cost[i\u0026nbsp;-\u0026nbsp;1][1],\u0026nbsp;cost[i\u0026nbsp;-\u0026nbsp;1][2]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cost[i][1]\u0026nbsp;=\u0026nbsp;cost[i][1]\u0026nbsp;+\u0026nbsp;min(cost[i\u0026nbsp;-\u0026nbsp;1][0],\u0026nbsp;cost[i\u0026nbsp;-\u0026nbsp;1][2]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cost[i][2]\u0026nbsp;=\u0026nbsp;cost[i][2]\u0026nbsp;+\u0026nbsp;min(cost[i\u0026nbsp;-\u0026nbsp;1][0],\u0026nbsp;cost[i\u0026nbsp;-\u0026nbsp;1][1]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}Colored by Color Scriptercs\n﻿이를 가지고 최종적으로 가장 비용이 적은 결과를 출력하게 되었다.\u0026nbsp;\n\n1cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;min(cost[n\u0026nbsp;-\u0026nbsp;1][0],\u0026nbsp;min(cost[n\u0026nbsp;-\u0026nbsp;1][1],\u0026nbsp;cost[n\u0026nbsp;-\u0026nbsp;1][2]));cs실제로 문제의 예제를 가지고 테스트하면\n1. 첫번째\nR : 26[R]\nG : 40[G]\nB : 83[B]\n\u0026nbsp;\n2. 두번째\u0026nbsp;\nR : 49[R] + 40[첫번째의 G]\nG : 60[G] + 26[첫번째의\u0026nbsp;R]\nB : 57[B] + 26[첫번째의 R]\n\u0026nbsp;\n4. 세번째\u0026nbsp;\nR : 13[R] + ( 57 + 26[첫번째의 R])[두번째의 B] = 96\nG: 89[G]\u0026hellip;\nB : 99[B]\u0026hellip;\n최종적으로 나온 값의 가장 작은 값이 예체의 출력값과 같은 것을 확인 할 수 있다.\n\u0026nbsp;\u0026nbsp;\n\n최종 코드\n\n123456789101112131415161718192021222324252627#include\u0026nbsp;\u0026lt;iostream\u0026gt;#include\u0026nbsp;\u0026lt;algorithm\u0026gt;\u0026nbsp;using\u0026nbsp;namespace\u0026nbsp;std;\u0026nbsp;int\u0026nbsp;cost[1001][3];\u0026nbsp;int\u0026nbsp;main()\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;n;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;r,\u0026nbsp;g,\u0026nbsp;b;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;n;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;i\u0026nbsp;\u0026lt;\u0026nbsp;n;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;cost[i][0]\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;cost[i][1]\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;cost[i][2];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;1;\u0026nbsp;i\u0026nbsp;\u0026lt;\u0026nbsp;n;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cost[i][0]\u0026nbsp;=\u0026nbsp;cost[i][0]\u0026nbsp;+\u0026nbsp;min(cost[i\u0026nbsp;-\u0026nbsp;1][1],\u0026nbsp;cost[i\u0026nbsp;-\u0026nbsp;1][2]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cost[i][1]\u0026nbsp;=\u0026nbsp;cost[i][1]\u0026nbsp;+\u0026nbsp;min(cost[i\u0026nbsp;-\u0026nbsp;1][0],\u0026nbsp;cost[i\u0026nbsp;-\u0026nbsp;1][2]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cost[i][2]\u0026nbsp;=\u0026nbsp;cost[i][2]\u0026nbsp;+\u0026nbsp;min(cost[i\u0026nbsp;-\u0026nbsp;1][0],\u0026nbsp;cost[i\u0026nbsp;-\u0026nbsp;1][1]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;min(cost[n\u0026nbsp;-\u0026nbsp;1][0],\u0026nbsp;min(cost[n\u0026nbsp;-\u0026nbsp;1][1],\u0026nbsp;cost[n\u0026nbsp;-\u0026nbsp;1][2]));}Colored by Color Scriptercs\n﻿\n\n\n추가적으로 질문사항이 있으시면 언제든지 댓글을 달아주세요:D\n\n\u0026nbsp;\n\n\u0026nbsp;\n","id":28,"section":"posts","summary":"☞ 백준 문제 바로가기[1149 - RGB거리] \u0026nbsp; \u0026nbsp; 사용 언어 - C++ \u0026nbsp; ﻿적용 알고리즘 - Dynamic Programing(다이나믹 프로그래밍) -\u0026nbsp;관련 동","tags":["다이나믹 프로그래밍"],"title":"백준 1149 - RGB거리","uri":"https://chlalstjd430.github.io/2020/01/%EB%B0%B1%EC%A4%801149/","year":"2020"},{"content":" 백준 문제 바로가기 \n사용 언어  C++  적용 알고리즘  최소 스패닝 트리 합집합 찾기  문제풀이 일반적으로 난이도가 쉬운 최소 스패닝 트리 문제를 풀 때, 가중치 값 기준으로 정렬 후 크르스칼 알고리즘을 적용하면 문제를 쉽게 풀 수 있습니다. 그러나 해당 문제는 가중치 값 기준으로 정렬할 때 다른 문제와 다르다는 것을 느낄 수 있습니다.\n먼저 정렬을 위해서 문제 중 이 한 문장을 잘 이해할 필요가 있겠습니다\n 두 행성 A(xA, yA, zA)와 B(xB, yB, zB)를 터널로 연결할 때 드는 비용은 min(|xA-xB|, |yA-yB|, |zA-zB|)이다.\n 이 문장을 통해 최종적으로 x,y,z 값을 각각 기준으로 정렬후 모든 값들을 vector에 넣어 정렬한 뒤 크루스칼 알고리즘을 적용하면 답이 나올 것을 예상할수 있었습니다.\n먼저 Planet 클래스와, Planet 클래스를 x,y,z 값으로 정렬 후 담아줄수 있는 Edge 클래스를 생성합니다.\n//행성 정보를 담아줄 Planet 클래스 class Planet { public: int node[3]; int index; Planet(int x, int y, int z, int index) { node[0] = x; node[1] = y; node[2] = z; this-\u0026gt;index = index; } }; //Planet Class를 x,y,z기준으로 각각 sort를 위해 만들어줍니다. bool cmpX (Planet \u0026amp;planet, Planet \u0026amp;planet2) { return planet.node[0] \u0026lt; planet2.node[0]; } bool cmpY(Planet \u0026amp;planet, Planet \u0026amp;planet2) { return planet.node[1] \u0026lt; planet2.node[1]; } bool cmpZ(Planet \u0026amp;planet, Planet \u0026amp;planet2) { return planet.node[2] \u0026lt; planet2.node[2]; } //sort이후 가중치 정보를 담아줄 Edge 클래스를 만들어줍니다. class Edge { public: int x, y; int value; Edge(int x, int y, int value) { this-\u0026gt;x = x; this-\u0026gt;y = y; this-\u0026gt;value = value; } bool operator \u0026lt;(Edge \u0026amp;edge) { return this-\u0026gt;value \u0026lt; edge.value; } };  이후 앞서 말씀드린 것처럼 x,y,z 기준으로 Plaent Class를 정렬 후 Edge Class에 담아 최종적으로 Edge Class를 정렬 후 크루스칼 알고리즘을 적용하면 결과가 나옵니다.\n//정렬 과정 sort(planet.begin(), planet.end(), cmpX); for (int i = 0; i \u0026lt; N - 1; i++) { edge.push_back(Edge(planet[i].index, planet[i + 1].index, abs(planet[i].node[0] - planet[i + 1].node[0]))); } sort(planet.begin(), planet.end(), cmpY); for (int i = 0; i \u0026lt; N - 1; i++) { edge.push_back(Edge(planet[i].index, planet[i + 1].index, abs(planet[i].node[1] - planet[i + 1].node[1]))); } sort(planet.begin(), planet.end(), cmpZ); for (int i = 0; i \u0026lt; N - 1; i++) { edge.push_back(Edge(planet[i].index, planet[i + 1].index, abs(planet[i].node[2] - planet[i + 1].node[2]))); } sort(edge.begin(), edge.end());  최종코드 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; class Planet { public: int node[3]; int index; Planet(int x, int y, int z, int index) { node[0] = x; node[1] = y; node[2] = z; this-\u0026gt;index = index; } }; bool cmpX (Planet \u0026amp;planet, Planet \u0026amp;planet2) { return planet.node[0] \u0026lt; planet2.node[0]; } bool cmpY(Planet \u0026amp;planet, Planet \u0026amp;planet2) { return planet.node[1] \u0026lt; planet2.node[1]; } bool cmpZ(Planet \u0026amp;planet, Planet \u0026amp;planet2) { return planet.node[2] \u0026lt; planet2.node[2]; } class Edge { public: int x, y; int value; Edge(int x, int y, int value) { this-\u0026gt;x = x; this-\u0026gt;y = y; this-\u0026gt;value = value; } bool operator \u0026lt;(Edge \u0026amp;edge) { return this-\u0026gt;value \u0026lt; edge.value; } }; int getParent(int parent[], int x) { if (parent[x] == x) return x; return getParent(parent, parent[x]); } void unionParent(int parent[], int x, int y) { x = getParent(parent, x); y = getParent(parent, y); if (x \u0026gt; y) parent[x] = y; else parent[y] = x; } bool findParent(int parent[], int x, int y) { x = getParent(parent, x); y = getParent(parent, y); if (x == y) return true; return false; } int dist[100002]; vector\u0026lt;Planet\u0026gt; planet; vector\u0026lt;Edge\u0026gt; edge; int main() { int N; int x, y, z; int sum = 0; cin \u0026gt;\u0026gt; N; for (int i = 0; i \u0026lt; N; i++) { cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; z; planet.push_back(Planet(x, y, z, i)); } for (int i = 0; i \u0026lt;= N; i++) { dist[i] = i; } sort(planet.begin(), planet.end(), cmpX); for (int i = 0; i \u0026lt; N - 1; i++) { edge.push_back(Edge(planet[i].index, planet[i + 1].index, abs(planet[i].node[0] - planet[i + 1].node[0]))); } sort(planet.begin(), planet.end(), cmpY); for (int i = 0; i \u0026lt; N - 1; i++) { edge.push_back(Edge(planet[i].index, planet[i + 1].index, abs(planet[i].node[1] - planet[i + 1].node[1]))); } sort(planet.begin(), planet.end(), cmpZ); for (int i = 0; i \u0026lt; N - 1; i++) { edge.push_back(Edge(planet[i].index, planet[i + 1].index, abs(planet[i].node[2] - planet[i + 1].node[2]))); } sort(edge.begin(), edge.end()); for (int i = 0; i \u0026lt; edge.size(); i++) { if (!(findParent(dist, edge[i].x, edge[i].y))) { sum += edge[i].value; unionParent(dist, edge[i].x, edge[i].y); } } cout \u0026lt;\u0026lt; sum; }  추가적인 질문사항 있으시면 언제든지 댓글 달아주시면 감사하겠습니다😊\n","id":29,"section":"posts","summary":"백준 문제 바로가기 사용 언어 C++ 적용 알고리즘 최소 스패닝 트리 합집합 찾기 문제풀이 일반적으로 난이도가 쉬운 최소 스패닝 트리 문제를 풀 때, 가중치 값 기준으로 정렬 후","tags":["최소 스패닝 트리"],"title":"백준 2887 - 행성터널","uri":"https://chlalstjd430.github.io/2020/01/%EB%B0%B1%EC%A4%802887/","year":"2020"},{"content":"☞ 백준 문제 바로가기[ 1991 - 트리 순회]\n\u0026nbsp;\n\u0026nbsp;\n사용 언어\n- C++\n\u0026nbsp;\n﻿적용 알고리즘\n- 이진 트리 전위/중위/후위 순회 알고리즘\n-\u0026nbsp;관련 동영상 강의 바로가기\n\u0026nbsp;\n\u0026nbsp;\n관련 문제\n- 관련 문제들은 추후에 수정하도록 하겠습니다.\n\u0026nbsp;\n문제 풀이\n- 해당 문제는 이진 트리를 이용하여 순회 알고리즘을 사용하는 문제입니다.\n먼저 다음과 같이 이진 트리 구조를 가진 구조체를 만들어줍니다.\n\n\n12345typedef\u0026nbsp;struct\u0026nbsp;node\u0026nbsp;tree;typedef\u0026nbsp;struct\u0026nbsp;node{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;char\u0026nbsp;data;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;tree\u0026nbsp;left,\u0026nbsp;right;};cs\n이후 전위/중위/후위 함수를 만들어줍니다.\n\n\n123456789101112131415161718192021222324//전위void\u0026nbsp;preorder(tree\u0026nbsp;tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;tr-\u0026gt;data;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;preorder(tr-\u0026gt;left);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;preorder(tr-\u0026gt;right);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}}//중위void\u0026nbsp;inorder(tree\u0026nbsp;tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;inorder(tr-\u0026gt;left);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;tr-\u0026gt;data;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;inorder(tr-\u0026gt;right);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}}//후위void\u0026nbsp;postorder(tree\u0026nbsp;tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;postorder(tr-\u0026gt;left);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;postorder(tr-\u0026gt;right);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;tr-\u0026gt;data;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}}cs\u0026nbsp;\n마지막으로 다음과 같이 데이터를 받고 출력해주면 정상적으로 결과가 나온 것을 확인 하실 수 있습니다.\n\n\n12345678910111213141516171819int\u0026nbsp;main()\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;node\u0026nbsp;nodes[27];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;nodeCnt;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;char\u0026nbsp;a,\u0026nbsp;b,\u0026nbsp;c;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;nodeCnt;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;i\u0026nbsp;\u0026lt;\u0026nbsp;nodeCnt;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;a\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;b\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;c;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1].data\u0026nbsp;=\u0026nbsp;a;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;(b\u0026nbsp;==\u0026nbsp;\u0026rsquo;.\u0026rsquo;)\u0026nbsp;?\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1].left\u0026nbsp;=\u0026nbsp;NULL\u0026nbsp;:\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1].left\u0026nbsp;=\u0026nbsp;\u0026amp;nodes[b\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;(c\u0026nbsp;==\u0026nbsp;\u0026rsquo;.\u0026rsquo;)\u0026nbsp;?\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1].right\u0026nbsp;=\u0026nbsp;NULL\u0026nbsp;:\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1].right\u0026nbsp;=\u0026nbsp;\u0026amp;nodes[c\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;preorder(\u0026amp;nodes[1]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;endl;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;inorder(\u0026amp;nodes[1]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;endl;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;postorder(\u0026amp;nodes[1]);;}Colored by Color Scriptercs\n최종 코드\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include\u0026nbsp;\u0026lt;iostream\u0026gt;\u0026nbsp;using\u0026nbsp;namespace\u0026nbsp;std;\u0026nbsp;typedef\u0026nbsp;struct\u0026nbsp;node\u0026nbsp;tree;typedef\u0026nbsp;struct\u0026nbsp;node{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;char\u0026nbsp;data;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;tree\u0026nbsp;left,\u0026nbsp;right;};\u0026nbsp;//전위void\u0026nbsp;preorder(tree\u0026nbsp;tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;tr-\u0026gt;data;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;preorder(tr-\u0026gt;left);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;preorder(tr-\u0026gt;right);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}}//중위void\u0026nbsp;inorder(tree\u0026nbsp;tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;inorder(tr-\u0026gt;left);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;tr-\u0026gt;data;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;inorder(tr-\u0026gt;right);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}}//후위void\u0026nbsp;postorder(tree\u0026nbsp;tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;postorder(tr-\u0026gt;left);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;postorder(tr-\u0026gt;right);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;tr-\u0026gt;data;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}}\u0026nbsp;int\u0026nbsp;main()\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;node\u0026nbsp;nodes[27];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;nodeCnt;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;char\u0026nbsp;a,\u0026nbsp;b,\u0026nbsp;c;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;nodeCnt;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;i\u0026nbsp;\u0026lt;\u0026nbsp;nodeCnt;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;a\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;b\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;c;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1].data\u0026nbsp;=\u0026nbsp;a;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;(b\u0026nbsp;==\u0026nbsp;\u0026rsquo;.\u0026rsquo;)\u0026nbsp;?\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1].left\u0026nbsp;=\u0026nbsp;NULL\u0026nbsp;:\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1].left\u0026nbsp;=\u0026nbsp;\u0026amp;nodes[b\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;(c\u0026nbsp;==\u0026nbsp;\u0026rsquo;.\u0026rsquo;)\u0026nbsp;?\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1].right\u0026nbsp;=\u0026nbsp;NULL\u0026nbsp;:\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1].right\u0026nbsp;=\u0026nbsp;\u0026amp;nodes[c\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;preorder(\u0026amp;nodes[1]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;endl;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;inorder(\u0026amp;nodes[1]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;endl;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;postorder(\u0026amp;nodes[1]);;}Colored by Color Scriptercs\n\n추가적으로 질문사항이 있으시면 언제든지 댓글을 달아주세요:D\n\n\u0026nbsp;\n","id":30,"section":"posts","summary":"☞ 백준 문제 바로가기[ 1991 - 트리 순회] \u0026nbsp; \u0026nbsp; 사용 언어 - C++ \u0026nbsp; ﻿적용 알고리즘 - 이진 트리 전위/중위/후위 순회 알고리즘 -\u0026nbsp;관련 동영상 강의 바로가기","tags":["이진 트리 알고리즘"],"title":"백준 1991 - 트리 순회","uri":"https://chlalstjd430.github.io/2020/01/%EB%B0%B1%EC%A4%801991/","year":"2020"},{"content":" IT 동아리 정보 1. YAPP  6-7월 / 12-1월  2. NEXTERS  5월 / 11월  3. SOPT  3월 / 9월  4. 프로그라피  2-3월 / 8월  5. Mash-Up  3월 / 8-9월  6. DEPROMEET  2월 / 9월  7. 멋쟁이사자처럼  2월  그 외 IT 활동 1. S/W 마에스트로(1월 중순 - 2월 중순) 2. 우아한 테크코스(10월 ~ 11월) 3. 우아한 테크캠프(5월) 4. 스마일 게이트 서버캠프(11월) 5. 42SEOUL 6. SSAFY(삼성 청년 소프트웨어 아카데미) 7. Slipp 스터디(6-7월/12-1월) ","id":31,"section":"posts","summary":"IT 동아리 정보 1. YAPP 6-7월 / 12-1월 2. NEXTERS 5월 / 11월 3. SOPT 3월 / 9월 4. 프로그라피 2-3월 / 8월 5. Mash-Up 3월 / 8-9월 6. DEPROMEET 2월 / 9월 7. 멋쟁이사자처럼","tags":["IT 정보","IT 동아리"],"title":"IT 동아리 정보","uri":"https://chlalstjd430.github.io/2020/01/%EC%A0%95%EB%B3%B4_001/","year":"2020"},{"content":" 2020년 학업 계획 1. IT동아리\n- YOURSSU 활동중(19.11.01~ )\n YAPP\n 지원중(1.18 면접)\n 최종 합격(1.22)\n   \n2. S/W 마에스트로\n- 1월 중순~말 서류 접수\n 서류 준비중(1.22~)  \n3. 클린코드 공부\n- 1) 블로그 읽기\n- 2) Clean Code 책 읽기\n- 클린코드 정리중 4. Spring Framework 더 자유롭게 다루기\n- 1) 프로젝트 하면서 필요한 부분 학습\n- 2) 인프런 강의\n5. JPA/DB 공부\n- 1) 프로젝트 하면서 필요한 부분 학습\n- 2) 인프런 강의\n6. 학점 4.0\n- 평균 학점 3.5이상 유지하기\n7. 여름/겨울에 인턴활동\n- S/W마에스트로 활동중이라면 겨울에라도 지원하기\n8. 꾸준한 알고리즘 공부\n- 스터디 활동 (01/01 ~ 02.28 진행중)\n- github 9. 프로젝트 실제 런칭 해보기\n10. 꾸준한 블로그 포스팅\n- 최소 1일 1포스팅\n11. S/W 관련 공모전 나가보기\n12. ACM 도전\n- 교내 입상이라도..\n13. AWS 공부\n14. 교내 멘토 활동 지원해보기\n15. 깃에 1일 1커밋\n16. 삼성 SW 역량 테스트(A형) 취득\n17. TDD로 개발하기!\n","id":32,"section":"posts","summary":"2020년 학업 계획 1. IT동아리 - YOURSSU 활동중(19.11.01~ ) YAPP 지원중(1.18 면접) 최종 합격(1.22) 2. S/W 마에스트로 - 1월 중순~말 서류 접","tags":["계획"],"title":"2020 학업 계획","uri":"https://chlalstjd430.github.io/2020/01/2020%EA%B3%84%ED%9A%8D_001/","year":"2020"},{"content":"Reactive Programing\u0026nbsp;간단 정리!\n\u0026nbsp;\n안녕하세요,\u0026nbsp;이 글에서는 제가\u0026nbsp;Reactive Programing을 처음 접하게 되며 알게된 내용들을 간략하게 설명하고자합니다.\u0026nbsp;개인적인 이해가 담겨져있는 글이므로 정확하지 않은 부분에 대하여 언제든지 피드백 해주시면 감사하겠습니다:D\n\u0026nbsp;\n\u0026nbsp;\n\n\n\n\nReactive Programing이란?\n\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp;\n\n유어슈에 들어오고\u0026nbsp;Reactive Programing을 처음 접하게 되었습니다.\u0026nbsp;이후\u0026nbsp;Reactive Programing의 정의에 대하여 찾아보았고,\u0026nbsp;그중에서 가장 간결하면서 명확한 정의를 소개해드리겠습니다.\u0026nbsp;\n\u0026nbsp;\nReactive programming is programming with asynchronous data streams.\n\n리엑티브 프로그래밍은 비동기적 데이터 흐름을 처리하는 프로그래밍이다.\n\u0026nbsp;\n\u0026nbsp;Reactive Programming에서의 핵심은 모든 것들을 비동기적인 데이터의 흐름으로 간주한다는 것입니다. 다시 말하여 기존에 정해진 절차에 따라 작성한 코드가 실행되는 명령형 프로그래밍과는 다르게 리엑티브 프로그래밍은 데이터의 흐름을 정의하고 데이터가 변경되었을 때 연관되는 함수나 수식이 같이 변경되는 방식입니다.\u0026nbsp; 이것을 사용자의 입장에서 보았을 때\u0026nbsp; 실시간 반응이 이루어진다고 할 수 있습니다. 대표적으로 엑셀을 예로 들어보겠습니다.\n\u0026nbsp;A\n\u0026nbsp;B\n\u0026nbsp;C\n\u0026nbsp;6\n\u0026nbsp;7\n\u0026nbsp;= A1 + B1\n\n이라는 표가 있을 때 우리는 C1의 값으로 13을 기대할 수 있습니다.\n\u0026nbsp;A\n\u0026nbsp;B\n\u0026nbsp;C\n\u0026nbsp;6\n\u0026nbsp;7\n13\n\n실제로 수행 결과 13이 나오는 것을 알 수있습니다. 그렇다면 여기서 A를 10으로 변경하였을 때도 C는 13일까요?\n\n\u0026nbsp;A\n\u0026nbsp;B\n\u0026nbsp;C\n\u0026nbsp;10\n\u0026nbsp;7\n17\n결과는 17입니다. A가 변함에 따라 C의 값이 달라지게 됩니다. 우리는 엑셀을 통해서 데이터의 흐름에 따라 결과값이 다르게 표현되는 것을 확인 하실 수 있습니다.\n\u0026nbsp;\n\u0026nbsp;이러한 Reactive Programming은 함수형 프로그래밍(Functional Programming)을 지원 받습니다. 함수형 프로그래밍은\u0026nbsp; 데이터를 immutable하게 취급하고, 데이터 변경시 원본 데이터는 유지하고 새로운 데이터를 만들어 변경하고, 관점을 데이터가 아닌 Process에 집중하게 됩니다. 그리하여 Side-effect 최소화해 병렬처리에서 큰 장점을 가져오게 됩니다.\n\u0026nbsp;\n\u0026nbsp;\n​\n\n\n\n왜\u0026nbsp;Reactive Programing일까?\n\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;\u0026nbsp;\n\n\u0026nbsp;리엑티브 선언문에 따른\u0026nbsp;4가지 속성은 응답성,탄력성,유연성,메시지 구동으로 이루어져있고 내용은 다음과 같습니다.\n\u0026nbsp;\u0026nbsp;https://www.reactivemanifesto.org/ko\n응답성(Responsive):\u0026nbsp;시스템이 가능한 한 즉각적으로 응답하는 것을 응답성이 있다고 합니다.\u0026nbsp;응답성은 사용자의 편의성과 유용성의 기초가 되지만,\u0026nbsp;그것뿐만 아니라 문제를 신속하게 탐지하고 효과적으로 대처할 수 있는 것을 의미합니다.\u0026nbsp;응답성 있는 시스템은 신속하고 일관성 있는 응답 시간을 제공하고,\u0026nbsp;신뢰할 수 있는 상한선을 설정하여 일관된 서비스 품질을 제공합니다.\u0026nbsp;이러한 일관된 동작은 오류 처리를 단순화하고,\u0026nbsp;일반 사용자에게 신뢰를 조성하고,\u0026nbsp;새로운 상호작용을 촉진합니다.\n\n탄력성(Resilient):\u0026nbsp;시스템이\u0026nbsp;장애에 직면하더라도 응답성을 유지 하는 것을 탄력성이 있다고 합니다.\u0026nbsp;탄력성은 고가용성 시스템,\u0026nbsp;미션 크리티컬 시스템에만 적용되지 않습니다.\u0026nbsp;탄력성이 없는 시스템은 장애가 발생할 경우 응답성을 잃게 됩니다.\u0026nbsp;탄력성은\u0026nbsp;복제,\u0026nbsp;봉쇄,\u0026nbsp;격리, 위임에 의해 실현됩니다.\u0026nbsp;장애는 각각의\u0026nbsp;구성 요소에 포함되며 구성 요소들은 서로 분리되어 있기 때문에 이는 시스템이 부분적으로 고장이 나더라도,\u0026nbsp;전체 시스템을 위험하게 하지 않고 복구 할 수 있도록 보장합니다.\u0026nbsp;각 구성 요소의 복구 프로세스는 다른(외부의)\u0026nbsp;구성 요소에 위임되며 필요한 경우 복제를 통해 고가용성이 보장됩니다.\u0026nbsp;구성 요소의 클라이언트는 장애를 처리하는데에 압박을 받지 않습니다.\n\n유연성(Elastic):\u0026nbsp;시스템이 작업량이 변화하더라도 응답성을 유지하는 것을 유연성이라고 합니다.\u0026nbsp;리액티브 시스템은 입력 속도의 변화에 따라 이러한 입력에 할당된\u0026nbsp;자원을 증가시키거나 감소키면서 변화에 대응합니다.\u0026nbsp;이것은 시스템에서 경쟁하는 지점이나 중앙 집중적인 병목 현상이 존재하지 않도록 설계하여,\u0026nbsp;구성 요소를 샤딩하거나 복제하여 입력을 분산시키는 것을 의미합니다.\u0026nbsp;리액티브 시스템은 실시간 성능을 측정하는 도구를 제공하여 응답성 있고 예측 가능한 규모 확장 알고리즘을 지원합니다.\u0026nbsp;이 시스템은 하드웨어 상품 및 소프트웨어 플랫폼에 비용 효율이 높은 방식으로\u0026nbsp;유연성을 제공합니다.\n\n메시지 구동(Message Driven):\u0026nbsp;리액티브 시스템은\u0026nbsp;비동기 메시지 전달에 의존하여 구성 요소 사이에서 느슨한 결합,\u0026nbsp;격리,\u0026nbsp;위치 투명성을 보장하는 경계를 형성합니다.\u0026nbsp;이 경계는\u0026nbsp;장애를 메시지로 지정하는 수단을 제공합니다.\u0026nbsp;명시적인 메시지 전달은 시스템에 메시지 큐를 생성하고,\u0026nbsp;모니터링하며 필요시\u0026nbsp;배압을 적용함으로써 유연성을 부여하고,\u0026nbsp;부하 관리와 흐름제어를 가능하게 합니다.\u0026nbsp;위치 투명 메시징을 통신 수단으로 사용하면 단일 호스트든 클러스터를 가로지르든 동일한 구성과 의미를 갖고 장애를 관리할 수 있습니다.\u0026nbsp;논블로킹\u0026nbsp;통신은 수신자가 활성화가 되어 있을 때만\u0026nbsp;자원을 소비할 수 있기 때문에 시스템 부하를 억제할 수 있습니다.\n\u0026nbsp;\n\u0026nbsp;\n이러한 특징들가 더불어\u0026nbsp;과거보다\u0026nbsp;다양한 웹,앱의 UI 이벤트가 존재하는\u0026nbsp;현대에 더 나은 자원 활용과 확장성에 대한 필요성이 증가되고 더 나아가 모든 구현체가 상호운영할 수 있는 표준으로 특정 구현체에 얽매이는 감소가 추구되기 때문에\u0026nbsp;Reactive Programming이 사용됩니다.\u0026nbsp;\n\n\u0026nbsp;\n\n\n\n\n\n\n마무리\n\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;\u0026nbsp;\n\n간략하게\u0026nbsp;Reactive Programming을 알아보았는데,\u0026nbsp;단순히\u0026nbsp;Reactive Programming추종하며 따라가기 보다는 충분히 고민하고 이해하는게 좋을 것 같습니다.\u0026nbsp;이것으로 저의 첫번째 글은 마무리하고 추후에\u0026nbsp;Reactive Streams와 관련된 주제로 다음에 찾아뵙도록 하겠습니다:D\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n참고\n리엑티브 정의\nhttps://gist.github.com/staltz/868e7e9bc2a7b8c1f754#reactive-programming-is-programming-with-asynchronous-data-streams\n리엑티브 선언문\nhttps://www.reactivemanifesto.org/ko\u0026nbsp;\n","id":33,"section":"posts","summary":"Reactive Programing\u0026nbsp;간단 정리! \u0026nbsp; 안녕하세요,\u0026nbsp;이 글에서는 제가\u0026nbsp;Reactive Programing을 처음 접","tags":["리액티브 프로그래밍"],"title":"Reactive Programming이란?","uri":"https://chlalstjd430.github.io/2020/01/%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_reactive_programming/","year":"2020"},{"content":"☞ 백준 문제 바로가기[ 6497 - 전력난 ]\n\u0026nbsp;\n\u0026nbsp;\n사용 언어\n- C++\n\u0026nbsp;\n﻿적용 알고리즘\n- 크루스칼 알고리즘(Kruscal Algorithm)\n- 합집합 찾기 알고리즘(Union - Find)\n- 최소 스패닝 트리(MST)\n-\u0026nbsp;관련 동영상 강의 바로가기\n\u0026nbsp;\n\u0026nbsp;\n관련 문제\n-\u0026nbsp;1922(네트워크 연결),\u0026nbsp;1647(도시 분할 계획),\u0026nbsp;2887(행성 터널),\u0026nbsp;1197(최소 스패닝 트리)\n- 해당 문제들 풀이내용은 추후에 게시하도록 하겠습니다.\n\u0026nbsp;\n문제 풀이\n- 해당 문제는 크루스칼 알고리즘만 알고있다면 간단하게 풀수있는 MST 문제입니다. 먼저 코드를 보시면 다음과 같습니다.\n\u0026nbsp;\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include\u0026nbsp;\u0026lt;iostream\u0026gt;#include\u0026nbsp;\u0026lt;vector\u0026gt;#include\u0026nbsp;\u0026lt;algorithm\u0026gt;\u0026nbsp;using\u0026nbsp;namespace\u0026nbsp;std;\u0026nbsp;int\u0026nbsp;dist[200002];int\u0026nbsp;m,\u0026nbsp;n;\u0026nbsp;class\u0026nbsp;Edge\u0026nbsp;{public:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;node[2];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;value;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;Edge(int\u0026nbsp;x,\u0026nbsp;int\u0026nbsp;y,\u0026nbsp;int\u0026nbsp;value)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;this-\u0026gt;node[0]\u0026nbsp;=\u0026nbsp;x;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;this-\u0026gt;node[1]\u0026nbsp;=\u0026nbsp;y;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;this-\u0026gt;value\u0026nbsp;=\u0026nbsp;value;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;bool\u0026nbsp;operator\u0026nbsp;\u0026lt;\u0026nbsp;(Edge\u0026nbsp;\u0026amp;edge)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;return\u0026nbsp;this-\u0026gt;value\u0026nbsp;\u0026lt;\u0026nbsp;edge.value;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}};\u0026nbsp;int\u0026nbsp;getParent(int\u0026nbsp;parent[],\u0026nbsp;int\u0026nbsp;num)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(parent[num]\u0026nbsp;==\u0026nbsp;num)\u0026nbsp;return\u0026nbsp;num;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;return\u0026nbsp;parent[num]\u0026nbsp;=\u0026nbsp;getParent(parent,\u0026nbsp;parent[num]);}\u0026nbsp;void\u0026nbsp;unionParent(int\u0026nbsp;parent[],\u0026nbsp;int\u0026nbsp;x,\u0026nbsp;int\u0026nbsp;y)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;x\u0026nbsp;=\u0026nbsp;getParent(parent,\u0026nbsp;x);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;y\u0026nbsp;=\u0026nbsp;getParent(parent,\u0026nbsp;y);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(x\u0026nbsp;\u0026gt;\u0026nbsp;y)parent[x]\u0026nbsp;=\u0026nbsp;y;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;else\u0026nbsp;parent[y]\u0026nbsp;=\u0026nbsp;x;\u0026nbsp;}\u0026nbsp;bool\u0026nbsp;equalParent(int\u0026nbsp;parent[],\u0026nbsp;int\u0026nbsp;x,\u0026nbsp;int\u0026nbsp;y)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;x\u0026nbsp;=\u0026nbsp;getParent(parent,\u0026nbsp;x);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;y\u0026nbsp;=\u0026nbsp;getParent(parent,\u0026nbsp;y);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(x\u0026nbsp;==\u0026nbsp;y)\u0026nbsp;return\u0026nbsp;true;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;return\u0026nbsp;false;}\u0026nbsp;int\u0026nbsp;main()\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;vector\u0026lt;Edge\u0026gt;\u0026nbsp;map;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;while\u0026nbsp;(true)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;m\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;n;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(m\u0026nbsp;==\u0026nbsp;0\u0026nbsp;\u0026amp;\u0026amp;\u0026nbsp;n\u0026nbsp;==\u0026nbsp;0)\u0026nbsp;break;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;i\u0026nbsp;\u0026lt;=\u0026nbsp;m;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dist[i]\u0026nbsp;=\u0026nbsp;i;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;x\u0026nbsp;=\u0026nbsp;0,\u0026nbsp;y\u0026nbsp;=\u0026nbsp;0,\u0026nbsp;z\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;i\u0026nbsp;\u0026lt;\u0026nbsp;n;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;x\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;y\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;z;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;map.push_back(Edge(x,\u0026nbsp;y,\u0026nbsp;z));\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;sort(map.begin(),\u0026nbsp;map.end());\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;size\u0026nbsp;=\u0026nbsp;map.size();\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;sum\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;i\u0026nbsp;\u0026lt;\u0026nbsp;size;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;sum\u0026nbsp;+=\u0026nbsp;map[i].value;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;i\u0026nbsp;\u0026lt;\u0026nbsp;size;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(!equalParent(dist,\u0026nbsp;map[i].node[0],\u0026nbsp;map[i].node[1]))\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;unionParent(dist,\u0026nbsp;map[i].node[0],\u0026nbsp;map[i].node[1]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;sum\u0026nbsp;-=\u0026nbsp;map[i].value;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;sum\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;endl;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;map.clear(); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}}\n\n\u0026nbsp;\n\n\u0026nbsp;기본적인 크루스칼 알고리즘을 적용해 구하는 MST 구조와 같습니다. 다만 문제를 풀 때 주의하실 점은 문제 요구사항입니다.\n처음에 문제를 풀었을 때, 요구사항 중\u0026nbsp;\n\u0026nbsp;\n출력각 테스트 케이스마다 한 줄에 걸쳐 절약할 수 있는 최대 비용을 출력한다.\n\u0026nbsp;\n라는 내용을 인지하지 못하여서 최소 비용 값이 왜 다르지하고 한동안 코드를 다시 분석하는 행위를 반복하였습니다.\u0026nbsp;\n\u0026nbsp;\n추가적으로\n입력입력은 여러 개의 테스트 케이스로 구분되어 있다.\n각 테스트 케이스의 첫째 줄에는 집의 수 m과 길의 수 n이 주어진다. (1 ≤ m ≤ 200000,\u0026nbsp;m-1 ≤ n ≤ 200000)\n이어서 n개의 줄에 각 길에 대한 정보 x, y, z가 주어지는데, 이는 x번 집과 y번 집 사이에 양방향 도로가 있으며 그 거리가 z미터라는 뜻이다. (0 ≤ x, y \u0026lt; m,\u0026nbsp;x ≠ y)\n도시는 항상 연결 그래프의 형태이고(즉, 어떤 두 집을 골라도 서로 왕래할 수 있는 경로가 있다), 도시상의 모든 길의 거리 합은 231미터보다 작다.\n입력의 끝에서는 첫 줄에 0이 2개 주어진다.\n\u0026nbsp;\n라는 입력 조건에서 첫번째 줄과 마지막 줄 또한 무시하고 문제를 제출하였다가 틀렸습니다.\n\u0026nbsp;\n\u0026nbsp;\n그외에는 별다른 어려움은 없었던 것 같습니다! 코드에 대한 지적이나 풀이에 대한 질문은 댓글로 남겨주시면 확인 후 답장 메일이나 댓글을 달아드리겠습니다:D\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n","id":34,"section":"posts","summary":"☞ 백준 문제 바로가기[ 6497 - 전력난 ] \u0026nbsp; \u0026nbsp; 사용 언어 - C++ \u0026nbsp; ﻿적용 알고리즘 - 크루스칼 알고리즘(Kruscal Algorithm) - 합집합 찾기 알고리즘(Union - Find) - 최","tags":["크루스칼 알고리즘"],"title":"백준6497 - 전력난","uri":"https://chlalstjd430.github.io/2020/01/%EB%B0%B1%EC%A4%806497/","year":"2020"}],"tags":[{"title":"IT 동아리","uri":"https://chlalstjd430.github.io/tags/it-%EB%8F%99%EC%95%84%EB%A6%AC/"},{"title":"IT 정보","uri":"https://chlalstjd430.github.io/tags/it-%EC%A0%95%EB%B3%B4/"},{"title":"JWT","uri":"https://chlalstjd430.github.io/tags/jwt/"},{"title":"KMP 알고리즘","uri":"https://chlalstjd430.github.io/tags/kmp-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"title":"spring webflux","uri":"https://chlalstjd430.github.io/tags/spring-webflux/"},{"title":"계획","uri":"https://chlalstjd430.github.io/tags/%EA%B3%84%ED%9A%8D/"},{"title":"그리디 알고리즘","uri":"https://chlalstjd430.github.io/tags/%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"title":"다이나믹 프로그래밍","uri":"https://chlalstjd430.github.io/tags/%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"},{"title":"다익스트라 알고리즘","uri":"https://chlalstjd430.github.io/tags/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"title":"리액티브 프로그래밍","uri":"https://chlalstjd430.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"},{"title":"위상 정렬 알고리즘","uri":"https://chlalstjd430.github.io/tags/%EC%9C%84%EC%83%81-%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"title":"이진 트리 알고리즘","uri":"https://chlalstjd430.github.io/tags/%EC%9D%B4%EC%A7%84-%ED%8A%B8%EB%A6%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"title":"최소 스패닝 트리","uri":"https://chlalstjd430.github.io/tags/%EC%B5%9C%EC%86%8C-%EC%8A%A4%ED%8C%A8%EB%8B%9D-%ED%8A%B8%EB%A6%AC/"},{"title":"크루스칼 알고리즘","uri":"https://chlalstjd430.github.io/tags/%ED%81%AC%EB%A3%A8%EC%8A%A4%EC%B9%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"title":"클린코드","uri":"https://chlalstjd430.github.io/tags/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C/"}]}