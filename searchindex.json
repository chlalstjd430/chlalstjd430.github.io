{"categories":[{"title":"2020 계획","uri":"https://chlalstjd430.github.io/categories/2020-%EA%B3%84%ED%9A%8D/"},{"title":"IT 정보","uri":"https://chlalstjd430.github.io/categories/it-%EC%A0%95%EB%B3%B4/"},{"title":"리액티브 프로그래밍","uri":"https://chlalstjd430.github.io/categories/%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"},{"title":"백준 문제풀이","uri":"https://chlalstjd430.github.io/categories/%EB%B0%B1%EC%A4%80-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/"}],"posts":[{"content":"☞ 백준 문제 바로가기[ 1991 - 트리 순회]\n\u0026nbsp;\n\u0026nbsp;\n사용 언어\n- C++\n\u0026nbsp;\n﻿적용 알고리즘\n- 이진 트리 전위/중위/후위 순회 알고리즘\n-\u0026nbsp;관련 동영상 강의 바로가기\n\u0026nbsp;\n\u0026nbsp;\n관련 문제\n- 관련 문제들은 추후에 수정하도록 하겠습니다.\n\u0026nbsp;\n문제 풀이\n- 해당 문제는 이진 트리를 이용하여 순회 알고리즘을 사용하는 문제입니다.\n먼저 다음과 같이 이진 트리 구조를 가진 구조체를 만들어줍니다.\n\n\n12345typedef\u0026nbsp;struct\u0026nbsp;node\u0026nbsp;tree;typedef\u0026nbsp;struct\u0026nbsp;node{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;char\u0026nbsp;data;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;tree\u0026nbsp;left,\u0026nbsp;right;};cs\n이후 전위/중위/후위 함수를 만들어줍니다.\n\n\n123456789101112131415161718192021222324//전위void\u0026nbsp;preorder(tree\u0026nbsp;tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;tr-\u0026gt;data;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;preorder(tr-\u0026gt;left);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;preorder(tr-\u0026gt;right);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}}//중위void\u0026nbsp;inorder(tree\u0026nbsp;tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;inorder(tr-\u0026gt;left);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;tr-\u0026gt;data;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;inorder(tr-\u0026gt;right);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}}//후위void\u0026nbsp;postorder(tree\u0026nbsp;tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;postorder(tr-\u0026gt;left);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;postorder(tr-\u0026gt;right);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;tr-\u0026gt;data;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}}cs\u0026nbsp;\n마지막으로 다음과 같이 데이터를 받고 출력해주면 정상적으로 결과가 나온 것을 확인 하실 수 있습니다.\n\n\n12345678910111213141516171819int\u0026nbsp;main()\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;node\u0026nbsp;nodes[27];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;nodeCnt;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;char\u0026nbsp;a,\u0026nbsp;b,\u0026nbsp;c;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;nodeCnt;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;i\u0026nbsp;\u0026lt;\u0026nbsp;nodeCnt;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;a\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;b\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;c;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1].data\u0026nbsp;=\u0026nbsp;a;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;(b\u0026nbsp;==\u0026nbsp;\u0026rsquo;.\u0026rsquo;)\u0026nbsp;?\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1].left\u0026nbsp;=\u0026nbsp;NULL\u0026nbsp;:\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1].left\u0026nbsp;=\u0026nbsp;\u0026amp;nodes[b\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;(c\u0026nbsp;==\u0026nbsp;\u0026rsquo;.\u0026rsquo;)\u0026nbsp;?\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1].right\u0026nbsp;=\u0026nbsp;NULL\u0026nbsp;:\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1].right\u0026nbsp;=\u0026nbsp;\u0026amp;nodes[c\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;preorder(\u0026amp;nodes[1]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;endl;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;inorder(\u0026amp;nodes[1]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;endl;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;postorder(\u0026amp;nodes[1]);;}Colored by Color Scriptercs\n최종 코드\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include\u0026nbsp;\u0026lt;iostream\u0026gt;\u0026nbsp;using\u0026nbsp;namespace\u0026nbsp;std;\u0026nbsp;typedef\u0026nbsp;struct\u0026nbsp;node\u0026nbsp;tree;typedef\u0026nbsp;struct\u0026nbsp;node{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;char\u0026nbsp;data;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;tree\u0026nbsp;left,\u0026nbsp;right;};\u0026nbsp;//전위void\u0026nbsp;preorder(tree\u0026nbsp;tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;tr-\u0026gt;data;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;preorder(tr-\u0026gt;left);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;preorder(tr-\u0026gt;right);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}}//중위void\u0026nbsp;inorder(tree\u0026nbsp;tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;inorder(tr-\u0026gt;left);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;tr-\u0026gt;data;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;inorder(tr-\u0026gt;right);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}}//후위void\u0026nbsp;postorder(tree\u0026nbsp;tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;postorder(tr-\u0026gt;left);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;postorder(tr-\u0026gt;right);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;tr-\u0026gt;data;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}}\u0026nbsp;int\u0026nbsp;main()\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;node\u0026nbsp;nodes[27];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;nodeCnt;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;char\u0026nbsp;a,\u0026nbsp;b,\u0026nbsp;c;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;nodeCnt;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;i\u0026nbsp;\u0026lt;\u0026nbsp;nodeCnt;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;a\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;b\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;c;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1].data\u0026nbsp;=\u0026nbsp;a;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;(b\u0026nbsp;==\u0026nbsp;\u0026rsquo;.\u0026rsquo;)\u0026nbsp;?\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1].left\u0026nbsp;=\u0026nbsp;NULL\u0026nbsp;:\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1].left\u0026nbsp;=\u0026nbsp;\u0026amp;nodes[b\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;(c\u0026nbsp;==\u0026nbsp;\u0026rsquo;.\u0026rsquo;)\u0026nbsp;?\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1].right\u0026nbsp;=\u0026nbsp;NULL\u0026nbsp;:\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1].right\u0026nbsp;=\u0026nbsp;\u0026amp;nodes[c\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;preorder(\u0026amp;nodes[1]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;endl;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;inorder(\u0026amp;nodes[1]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;endl;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;postorder(\u0026amp;nodes[1]);;}Colored by Color Scriptercs\n\n추가적으로 질문사항이 있으시면 언제든지 댓글을 달아주세요:D\n\n\u0026nbsp;\n","id":0,"section":"posts","summary":"☞ 백준 문제 바로가기[ 1991 - 트리 순회] \u0026nbsp; \u0026nbsp; 사용 언어 - C++ \u0026nbsp; ﻿적용 알고리즘 - 이진 트리 전위/중위/후위 순회 알고리즘 -\u0026nbsp;관련 동영상 강의 바로가기","tags":["algoritm","백준","전력난","1991"],"title":"백준 1991 - 트리 순회","uri":"https://chlalstjd430.github.io/2020/01/%EB%B0%B1%EC%A4%801991/","year":"2020"},{"content":" IT 동아리 정보 1. YAPP  6-7월 / 12-1월  2. NEXTERS  5월 / 11월  3. SOPT  3월 / 9월  4. 프로그라피  2-3월 / 8월  5. Mash-Up  3월 / 8-9월  6. DEPROMEET  2월 / 9월  7. 멋쟁이사자처럼  2월  그 외 IT 활동 1. S/W 마에스트로 2. 우아한 테크코스 3. 우아한 테크캠프 4. 스마일 게이트 서버캠프 5. 42SEOUL 6. SSAFY(삼성 청년 소프트웨어 아카데미) ","id":1,"section":"posts","summary":"IT 동아리 정보 1. YAPP 6-7월 / 12-1월 2. NEXTERS 5월 / 11월 3. SOPT 3월 / 9월 4. 프로그라피 2-3월 / 8월 5. Mash-Up 3월 / 8-9월 6. DEPROMEET 2월 / 9월 7. 멋쟁이사자처럼","tags":["IT 정보","IT 동아리"],"title":"IT 동아리 정보","uri":"https://chlalstjd430.github.io/2020/01/%EC%A0%95%EB%B3%B4_001/","year":"2020"},{"content":" 2020년 학업 계획 1. IT동아리\n- YOURSSU 활동중(19.11.01~ )\n- 현재 YAPP 지원중(1.18 면접)\n2. S/W 마에스트로\n- 1월 중순~말 서류 접수\n3. 클린코드 공부\n- 1) 블로그 읽기\n- 2) Clean Code 책 읽기\n4. Spring Framework 더 자유롭게 다루기\n- 1) 프로젝트 하면서 필요한 부분 학습\n- 2) 인프런 강의\n5. Jpa/DB 공부\n- 1) 프로젝트 하면서 필요한 부분 학습\n- 2) 인프런 강의\n6. 학점 4.0\n- 평균 학점 3.5이상 유지하기\n7. 여름/겨울에 인턴활동\n- S/W마에스트로 활동중이라면 겨울에라도 지원하기\n8. 꾸준한 알고리즘 공부\n- 스터디 활동(01/01 ~ 02.28 진행중)\n- 최소 1일 1~2문제\n9. 프로젝트 실제 런칭 해보기\n10. 꾸준한 블로그 포스팅\n- 최소 1일 1포스팅\n11. S/W 관련 공모전 나가보기\n12. ACM 도전\n- 교내 입상이라도..\n13. AWS 공부\n14. 교내 멘토 활동 지원해보기\n15. 깃에 1일 1커밋\n16.삼성 SW 역량 테스트(A형) 취득\n","id":2,"section":"posts","summary":"2020년 학업 계획 1. IT동아리 - YOURSSU 활동중(19.11.01~ ) - 현재 YAPP 지원중(1.18 면접) 2. S/W 마에스트로 - 1월 중순~말 서류 접수 3. 클린코드 공","tags":["계획","2020"],"title":"2020 학업 계획","uri":"https://chlalstjd430.github.io/2020/01/2020%EA%B3%84%ED%9A%8D_001/","year":"2020"},{"content":"Reactive Programing\u0026nbsp;간단 정리!\n\u0026nbsp;\n안녕하세요,\u0026nbsp;이 글에서는 제가\u0026nbsp;Reactive Programing을 처음 접하게 되며 알게된 내용들을 간략하게 설명하고자합니다.\u0026nbsp;개인적인 이해가 담겨져있는 글이므로 정확하지 않은 부분에 대하여 언제든지 피드백 해주시면 감사하겠습니다:D\n\u0026nbsp;\n\u0026nbsp;\n\n\n\n\nReactive Programing이란?\n\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp;\n\n유어슈에 들어오고\u0026nbsp;Reactive Programing을 처음 접하게 되었습니다.\u0026nbsp;이후\u0026nbsp;Reactive Programing의 정의에 대하여 찾아보았고,\u0026nbsp;그중에서 가장 간결하면서 명확한 정의를 소개해드리겠습니다.\u0026nbsp;\n\u0026nbsp;\nReactive programming is programming with asynchronous data streams.\n\n리엑티브 프로그래밍은 비동기적 데이터 흐름을 처리하는 프로그래밍이다.\n\u0026nbsp;\n\u0026nbsp;Reactive Programming에서의 핵심은 모든 것들을 비동기적인 데이터의 흐름으로 간주한다는 것입니다. 다시 말하여 기존에 정해진 절차에 따라 작성한 코드가 실행되는 명령형 프로그래밍과는 다르게 리엑티브 프로그래밍은 데이터의 흐름을 정의하고 데이터가 변경되었을 때 연관되는 함수나 수식이 같이 변경되는 방식입니다.\u0026nbsp; 이것을 사용자의 입장에서 보았을 때\u0026nbsp; 실시간 반응이 이루어진다고 할 수 있습니다. 대표적으로 엑셀을 예로 들어보겠습니다.\n\u0026nbsp;A\n\u0026nbsp;B\n\u0026nbsp;C\n\u0026nbsp;6\n\u0026nbsp;7\n\u0026nbsp;= A1 + B1\n\n이라는 표가 있을 때 우리는 C1의 값으로 13을 기대할 수 있습니다.\n\u0026nbsp;A\n\u0026nbsp;B\n\u0026nbsp;C\n\u0026nbsp;6\n\u0026nbsp;7\n13\n\n실제로 수행 결과 13이 나오는 것을 알 수있습니다. 그렇다면 여기서 A를 10으로 변경하였을 때도 C는 13일까요?\n\n\u0026nbsp;A\n\u0026nbsp;B\n\u0026nbsp;C\n\u0026nbsp;10\n\u0026nbsp;7\n17\n결과는 17입니다. A가 변함에 따라 C의 값이 달라지게 됩니다. 우리는 엑셀을 통해서 데이터의 흐름에 따라 결과값이 다르게 표현되는 것을 확인 하실 수 있습니다.\n\u0026nbsp;\n\u0026nbsp;이러한 Reactive Programming은 함수형 프로그래밍(Functional Programming)을 지원 받습니다. 함수형 프로그래밍은\u0026nbsp; 데이터를 immutable하게 취급하고, 데이터 변경시 원본 데이터는 유지하고 새로운 데이터를 만들어 변경하고, 관점을 데이터가 아닌 Process에 집중하게 됩니다. 그리하여 Side-effect 최소화해 병렬처리에서 큰 장점을 가져오게 됩니다.\n\u0026nbsp;\n\u0026nbsp;\n​\n\n\n\n왜\u0026nbsp;Reactive Programing일까?\n\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;\u0026nbsp;\n\n\u0026nbsp;리엑티브 선언문에 따른\u0026nbsp;4가지 속성은 응답성,탄력성,유연성,메시지 구동으로 이루어져있고 내용은 다음과 같습니다.\n\u0026nbsp;\u0026nbsp;https://www.reactivemanifesto.org/ko\n응답성(Responsive):\u0026nbsp;시스템이 가능한 한 즉각적으로 응답하는 것을 응답성이 있다고 합니다.\u0026nbsp;응답성은 사용자의 편의성과 유용성의 기초가 되지만,\u0026nbsp;그것뿐만 아니라 문제를 신속하게 탐지하고 효과적으로 대처할 수 있는 것을 의미합니다.\u0026nbsp;응답성 있는 시스템은 신속하고 일관성 있는 응답 시간을 제공하고,\u0026nbsp;신뢰할 수 있는 상한선을 설정하여 일관된 서비스 품질을 제공합니다.\u0026nbsp;이러한 일관된 동작은 오류 처리를 단순화하고,\u0026nbsp;일반 사용자에게 신뢰를 조성하고,\u0026nbsp;새로운 상호작용을 촉진합니다.\n\n탄력성(Resilient):\u0026nbsp;시스템이\u0026nbsp;장애에 직면하더라도 응답성을 유지 하는 것을 탄력성이 있다고 합니다.\u0026nbsp;탄력성은 고가용성 시스템,\u0026nbsp;미션 크리티컬 시스템에만 적용되지 않습니다.\u0026nbsp;탄력성이 없는 시스템은 장애가 발생할 경우 응답성을 잃게 됩니다.\u0026nbsp;탄력성은\u0026nbsp;복제,\u0026nbsp;봉쇄,\u0026nbsp;격리, 위임에 의해 실현됩니다.\u0026nbsp;장애는 각각의\u0026nbsp;구성 요소에 포함되며 구성 요소들은 서로 분리되어 있기 때문에 이는 시스템이 부분적으로 고장이 나더라도,\u0026nbsp;전체 시스템을 위험하게 하지 않고 복구 할 수 있도록 보장합니다.\u0026nbsp;각 구성 요소의 복구 프로세스는 다른(외부의)\u0026nbsp;구성 요소에 위임되며 필요한 경우 복제를 통해 고가용성이 보장됩니다.\u0026nbsp;구성 요소의 클라이언트는 장애를 처리하는데에 압박을 받지 않습니다.\n\n유연성(Elastic):\u0026nbsp;시스템이 작업량이 변화하더라도 응답성을 유지하는 것을 유연성이라고 합니다.\u0026nbsp;리액티브 시스템은 입력 속도의 변화에 따라 이러한 입력에 할당된\u0026nbsp;자원을 증가시키거나 감소키면서 변화에 대응합니다.\u0026nbsp;이것은 시스템에서 경쟁하는 지점이나 중앙 집중적인 병목 현상이 존재하지 않도록 설계하여,\u0026nbsp;구성 요소를 샤딩하거나 복제하여 입력을 분산시키는 것을 의미합니다.\u0026nbsp;리액티브 시스템은 실시간 성능을 측정하는 도구를 제공하여 응답성 있고 예측 가능한 규모 확장 알고리즘을 지원합니다.\u0026nbsp;이 시스템은 하드웨어 상품 및 소프트웨어 플랫폼에 비용 효율이 높은 방식으로\u0026nbsp;유연성을 제공합니다.\n\n메시지 구동(Message Driven):\u0026nbsp;리액티브 시스템은\u0026nbsp;비동기 메시지 전달에 의존하여 구성 요소 사이에서 느슨한 결합,\u0026nbsp;격리,\u0026nbsp;위치 투명성을 보장하는 경계를 형성합니다.\u0026nbsp;이 경계는\u0026nbsp;장애를 메시지로 지정하는 수단을 제공합니다.\u0026nbsp;명시적인 메시지 전달은 시스템에 메시지 큐를 생성하고,\u0026nbsp;모니터링하며 필요시\u0026nbsp;배압을 적용함으로써 유연성을 부여하고,\u0026nbsp;부하 관리와 흐름제어를 가능하게 합니다.\u0026nbsp;위치 투명 메시징을 통신 수단으로 사용하면 단일 호스트든 클러스터를 가로지르든 동일한 구성과 의미를 갖고 장애를 관리할 수 있습니다.\u0026nbsp;논블로킹\u0026nbsp;통신은 수신자가 활성화가 되어 있을 때만\u0026nbsp;자원을 소비할 수 있기 때문에 시스템 부하를 억제할 수 있습니다.\n\u0026nbsp;\n\u0026nbsp;\n이러한 특징들가 더불어\u0026nbsp;과거보다\u0026nbsp;다양한 웹,앱의 UI 이벤트가 존재하는\u0026nbsp;현대에 더 나은 자원 활용과 확장성에 대한 필요성이 증가되고 더 나아가 모든 구현체가 상호운영할 수 있는 표준으로 특정 구현체에 얽매이는 감소가 추구되기 때문에\u0026nbsp;Reactive Programming이 사용됩니다.\u0026nbsp;\n\n\u0026nbsp;\n\n\n\n\n\n\n마무리\n\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;\u0026nbsp;\n\n간략하게\u0026nbsp;Reactive Programming을 알아보았는데,\u0026nbsp;단순히\u0026nbsp;Reactive Programming추종하며 따라가기 보다는 충분히 고민하고 이해하는게 좋을 것 같습니다.\u0026nbsp;이것으로 저의 첫번째 글은 마무리하고 추후에\u0026nbsp;Reactive Streams와 관련된 주제로 다음에 찾아뵙도록 하겠습니다:D\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n참고\n리엑티브 정의\nhttps://gist.github.com/staltz/868e7e9bc2a7b8c1f754#reactive-programming-is-programming-with-asynchronous-data-streams\n리엑티브 선언문\nhttps://www.reactivemanifesto.org/ko\u0026nbsp;\n","id":3,"section":"posts","summary":"Reactive Programing\u0026nbsp;간단 정리! \u0026nbsp; 안녕하세요,\u0026nbsp;이 글에서는 제가\u0026nbsp;Reactive Programing을 처음 접","tags":["Reactive Programming","리액티브"],"title":"Reactive Programming이란?","uri":"https://chlalstjd430.github.io/2020/01/%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_001/","year":"2020"},{"content":"☞ 백준 문제 바로가기[ 6497 - 전력난 ]\n\u0026nbsp;\n\u0026nbsp;\n사용 언어\n- C++\n\u0026nbsp;\n﻿적용 알고리즘\n- 크루스칼 알고리즘(Kruscal Algorithm)\n- 합집합 찾기 알고리즘(Union - Find)\n- 최소 스패닝 트리(MST)\n-\u0026nbsp;관련 동영상 강의 바로가기\n\u0026nbsp;\n\u0026nbsp;\n관련 문제\n-\u0026nbsp;1922(네트워크 연결),\u0026nbsp;1647(도시 분할 계획),\u0026nbsp;2887(행성 터널),\u0026nbsp;1197(최소 스패닝 트리)\n- 해당 문제들 풀이내용은 추후에 게시하도록 하겠습니다.\n\u0026nbsp;\n문제 풀이\n- 해당 문제는 크루스칼 알고리즘만 알고있다면 간단하게 풀수있는 MST 문제입니다. 먼저 코드를 보시면 다음과 같습니다.\n\u0026nbsp;\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include\u0026nbsp;\u0026lt;iostream\u0026gt;#include\u0026nbsp;\u0026lt;vector\u0026gt;#include\u0026nbsp;\u0026lt;algorithm\u0026gt;\u0026nbsp;using\u0026nbsp;namespace\u0026nbsp;std;\u0026nbsp;int\u0026nbsp;dist[200002];int\u0026nbsp;m,\u0026nbsp;n;\u0026nbsp;class\u0026nbsp;Edge\u0026nbsp;{public:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;node[2];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;value;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;Edge(int\u0026nbsp;x,\u0026nbsp;int\u0026nbsp;y,\u0026nbsp;int\u0026nbsp;value)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;this-\u0026gt;node[0]\u0026nbsp;=\u0026nbsp;x;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;this-\u0026gt;node[1]\u0026nbsp;=\u0026nbsp;y;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;this-\u0026gt;value\u0026nbsp;=\u0026nbsp;value;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;bool\u0026nbsp;operator\u0026nbsp;\u0026lt;\u0026nbsp;(Edge\u0026nbsp;\u0026amp;edge)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;return\u0026nbsp;this-\u0026gt;value\u0026nbsp;\u0026lt;\u0026nbsp;edge.value;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}};\u0026nbsp;int\u0026nbsp;getParent(int\u0026nbsp;parent[],\u0026nbsp;int\u0026nbsp;num)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(parent[num]\u0026nbsp;==\u0026nbsp;num)\u0026nbsp;return\u0026nbsp;num;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;return\u0026nbsp;parent[num]\u0026nbsp;=\u0026nbsp;getParent(parent,\u0026nbsp;parent[num]);}\u0026nbsp;void\u0026nbsp;unionParent(int\u0026nbsp;parent[],\u0026nbsp;int\u0026nbsp;x,\u0026nbsp;int\u0026nbsp;y)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;x\u0026nbsp;=\u0026nbsp;getParent(parent,\u0026nbsp;x);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;y\u0026nbsp;=\u0026nbsp;getParent(parent,\u0026nbsp;y);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(x\u0026nbsp;\u0026gt;\u0026nbsp;y)parent[x]\u0026nbsp;=\u0026nbsp;y;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;else\u0026nbsp;parent[y]\u0026nbsp;=\u0026nbsp;x;\u0026nbsp;}\u0026nbsp;bool\u0026nbsp;equalParent(int\u0026nbsp;parent[],\u0026nbsp;int\u0026nbsp;x,\u0026nbsp;int\u0026nbsp;y)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;x\u0026nbsp;=\u0026nbsp;getParent(parent,\u0026nbsp;x);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;y\u0026nbsp;=\u0026nbsp;getParent(parent,\u0026nbsp;y);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(x\u0026nbsp;==\u0026nbsp;y)\u0026nbsp;return\u0026nbsp;true;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;return\u0026nbsp;false;}\u0026nbsp;int\u0026nbsp;main()\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;vector\u0026lt;Edge\u0026gt;\u0026nbsp;map;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;while\u0026nbsp;(true)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;m\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;n;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(m\u0026nbsp;==\u0026nbsp;0\u0026nbsp;\u0026amp;\u0026amp;\u0026nbsp;n\u0026nbsp;==\u0026nbsp;0)\u0026nbsp;break;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;i\u0026nbsp;\u0026lt;=\u0026nbsp;m;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dist[i]\u0026nbsp;=\u0026nbsp;i;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;x\u0026nbsp;=\u0026nbsp;0,\u0026nbsp;y\u0026nbsp;=\u0026nbsp;0,\u0026nbsp;z\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;i\u0026nbsp;\u0026lt;\u0026nbsp;n;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;x\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;y\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;z;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;map.push_back(Edge(x,\u0026nbsp;y,\u0026nbsp;z));\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;sort(map.begin(),\u0026nbsp;map.end());\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;size\u0026nbsp;=\u0026nbsp;map.size();\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;sum\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;i\u0026nbsp;\u0026lt;\u0026nbsp;size;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;sum\u0026nbsp;+=\u0026nbsp;map[i].value;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;i\u0026nbsp;\u0026lt;\u0026nbsp;size;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(!equalParent(dist,\u0026nbsp;map[i].node[0],\u0026nbsp;map[i].node[1]))\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;unionParent(dist,\u0026nbsp;map[i].node[0],\u0026nbsp;map[i].node[1]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;sum\u0026nbsp;-=\u0026nbsp;map[i].value;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;sum\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;endl;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;map.clear(); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}}\n\n\u0026nbsp;\n\n\u0026nbsp;기본적인 크루스칼 알고리즘을 적용해 구하는 MST 구조와 같습니다. 다만 문제를 풀 때 주의하실 점은 문제 요구사항입니다.\n처음에 문제를 풀었을 때, 요구사항 중\u0026nbsp;\n\u0026nbsp;\n출력각 테스트 케이스마다 한 줄에 걸쳐 절약할 수 있는 최대 비용을 출력한다.\n\u0026nbsp;\n라는 내용을 인지하지 못하여서 최소 비용 값이 왜 다르지하고 한동안 코드를 다시 분석하는 행위를 반복하였습니다.\u0026nbsp;\n\u0026nbsp;\n추가적으로\n입력입력은 여러 개의 테스트 케이스로 구분되어 있다.\n각 테스트 케이스의 첫째 줄에는 집의 수 m과 길의 수 n이 주어진다. (1 ≤ m ≤ 200000,\u0026nbsp;m-1 ≤ n ≤ 200000)\n이어서 n개의 줄에 각 길에 대한 정보 x, y, z가 주어지는데, 이는 x번 집과 y번 집 사이에 양방향 도로가 있으며 그 거리가 z미터라는 뜻이다. (0 ≤ x, y \u0026lt; m,\u0026nbsp;x ≠ y)\n도시는 항상 연결 그래프의 형태이고(즉, 어떤 두 집을 골라도 서로 왕래할 수 있는 경로가 있다), 도시상의 모든 길의 거리 합은 231미터보다 작다.\n입력의 끝에서는 첫 줄에 0이 2개 주어진다.\n\u0026nbsp;\n라는 입력 조건에서 첫번째 줄과 마지막 줄 또한 무시하고 문제를 제출하였다가 틀렸습니다.\n\u0026nbsp;\n\u0026nbsp;\n그외에는 별다른 어려움은 없었던 것 같습니다! 코드에 대한 지적이나 풀이에 대한 질문은 댓글로 남겨주시면 확인 후 답장 메일이나 댓글을 달아드리겠습니다:D\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n","id":4,"section":"posts","summary":"☞ 백준 문제 바로가기[ 6497 - 전력난 ] \u0026nbsp; \u0026nbsp; 사용 언어 - C++ \u0026nbsp; ﻿적용 알고리즘 - 크루스칼 알고리즘(Kruscal Algorithm) - 합집합 찾기 알고리즘(Union - Find) - 최","tags":["algoritm","백준","전력난","6497"],"title":"백준6497 - 전력난","uri":"https://chlalstjd430.github.io/2020/01/%EB%B0%B1%EC%A4%806497/","year":"2020"}],"tags":[{"title":"1991","uri":"https://chlalstjd430.github.io/tags/1991/"},{"title":"2020","uri":"https://chlalstjd430.github.io/tags/2020/"},{"title":"6497","uri":"https://chlalstjd430.github.io/tags/6497/"},{"title":"algoritm","uri":"https://chlalstjd430.github.io/tags/algoritm/"},{"title":"IT 동아리","uri":"https://chlalstjd430.github.io/tags/it-%EB%8F%99%EC%95%84%EB%A6%AC/"},{"title":"IT 정보","uri":"https://chlalstjd430.github.io/tags/it-%EC%A0%95%EB%B3%B4/"},{"title":"Reactive Programming","uri":"https://chlalstjd430.github.io/tags/reactive-programming/"},{"title":"계획","uri":"https://chlalstjd430.github.io/tags/%EA%B3%84%ED%9A%8D/"},{"title":"리액티브","uri":"https://chlalstjd430.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C/"},{"title":"백준","uri":"https://chlalstjd430.github.io/tags/%EB%B0%B1%EC%A4%80/"},{"title":"전력난","uri":"https://chlalstjd430.github.io/tags/%EC%A0%84%EB%A0%A5%EB%82%9C/"}]}