{"categories":[{"title":"2020 계획","uri":"https://chlalstjd430.github.io/categories/2020-%EA%B3%84%ED%9A%8D/"},{"title":"IT 정보","uri":"https://chlalstjd430.github.io/categories/it-%EC%A0%95%EB%B3%B4/"},{"title":"리액티브 프로그래밍","uri":"https://chlalstjd430.github.io/categories/%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"},{"title":"백준 문제풀이","uri":"https://chlalstjd430.github.io/categories/%EB%B0%B1%EC%A4%80-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/"},{"title":"클린코드","uri":"https://chlalstjd430.github.io/categories/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C/"}],"posts":[{"content":" 백준 문제 바로가기 \n사용 언어  C++  적용 알고리즘  위상 정렬 알고리즘  문제풀이 해당 문제에서 요구하는 것은 2가지이다.\n1. 모든 사람들이 만나는 시간 2. 1분도 쉬지 않고 달려야 하는 도로의 수 - 즉, 1번 요구사항에서 나온 시간에 딱 맞게 도착했을 때 거쳐간 도로의 수  2번째 요구사항이 나같은 경우 이해하기 힘들었는데, 쉽게 설명하자면 1번 요구사항에서 나온 시간만큼 걸려서 도착 도시에 도착했을 때, 시작 도시부터 거쳐간 도로의 개수를 구하면 된다. 해당 문제는 역추적 방식을 이용하면 문제를 쉽게 풀 수 있다.\n 먼저 지도 정보를 담을 클래스를 만들어주자.\nclass Edge { public: int node; int time; Edge(int node, int time) { this-\u0026gt;node = node; this-\u0026gt;time = time; } };  이후 위상 정렬 알고리즘을 사용하기 위한 변수들을 선언해준다.\nint n; int start, goal; int inDegree[MAX]; int result[MAX], visited[MAX]; vector\u0026lt;Edge\u0026gt; map[MAX]; vector\u0026lt;Edge\u0026gt; reverseMap[MAX];    여기서 reverseMap이라는게 나온데 이는 visted배열과 함께 이후 역추적 때 사용하기 위해 선언한 것이다.   위상 정렬 함수를 선언해준다.\nvoid topologySort() { queue\u0026lt;int\u0026gt; q; q.push(start); while (!q.empty()) { int current = q.front(); q.pop(); int mapSize = map[current].size(); for (int i = 0; i \u0026lt; mapSize; i++) { Edge next = Edge(map[current][i].node, map[current][i].time); int totalTime = next.time + result[current]; if (result[next.node] \u0026lt;= totalTime) { result[next.node] = totalTime; } if (--inDegree[next.node] == 0) { q.push(next.node); } } } cout \u0026lt;\u0026lt; result[goal] \u0026lt;\u0026lt; endl; }  역추적을 위한 함수를 선언해준다.\nvoid traceBack() { queue\u0026lt;int\u0026gt; q; int count = 0; q.push(goal); while (!q.empty()) { int front = q.front(); q.pop(); int reverseMapSize = reverseMap[front].size(); for (int i = 0; i \u0026lt; size i++) { Edge next = Edge(reverseMap[front][i].node, reverseMap[front][i].time); if (result[front] - result[next.node] == next.time) { if (visited[next.node] == 0) { q.push(next.node); visited[next.node] = 1; } } } } cout \u0026lt;\u0026lt; count; }    이 함수안에서는 queue에 goal을 넣고 시작해서 시작점이 아닌 도착점에서 시작한다.\n for문 안에 if조건문이 중요한 부분이다. 이미 result를 구했으므로 result 배열을 통해서 현재 도시까지의 거리 - 현재-1 도시까지의 거리 의 값이 다음 찾을 도시의 time정보랑 값이 같다면 해당 도로는 이전 거쳐가는 도로가 확실함으로 count를 증가시킨다.\n 이후 해동 도시를 queue에 다시 담지 않도록 방문 처리를 해준다음, queue에 담는다.\n  코드 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;algorithm\u0026gt; #define MAX 10002 using namespace std; class Edge { public: int node; int time; Edge(int node, int time) { this-\u0026gt;node = node; this-\u0026gt;time = time; } }; int n, start, goal; int inDegree[MAX], result[MAX], visited[MAX]; vector\u0026lt;Edge\u0026gt; map[MAX]; vector\u0026lt;Edge\u0026gt; reverseMap[MAX]; void topologySort() { queue\u0026lt;int\u0026gt; q; q.push(start); while (!q.empty()) { int current = q.front(); q.pop(); int mapSize = map[current].size(); for (int i = 0; i \u0026lt; mapSize; i++) { Edge next = Edge(map[current][i].node, map[current][i].time); int totalTime = next.time + result[current]; if (result[next.node] \u0026lt;= totalTime) { result[next.node] = totalTime; } if (--inDegree[next.node] == 0) { q.push(next.node); } } } cout \u0026lt;\u0026lt; result[goal] \u0026lt;\u0026lt; endl; } void traceBack() { queue\u0026lt;int\u0026gt; q; int count = 0; q.push(goal); while (!q.empty()) { int front = q.front(); q.pop(); int reverseMapSize = reverseMap[front].size(); for (int i = 0; i \u0026lt; size i++) { Edge next = Edge(reverseMap[front][i].node, reverseMap[front][i].time); if (result[front] - result[next.node] == next.time) { count++; if (visited[next.node] == 0) { q.push(next.node); visited[next.node] = 1; } } } } cout \u0026lt;\u0026lt; count; } int main() { int m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; m; i++) { int x, node, time; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; node \u0026gt;\u0026gt; time; map[x].push_back(Edge(node, time)); reverseMap[node].push_back(Edge(x, time)); inDegree[node]++; } cin \u0026gt;\u0026gt; start \u0026gt;\u0026gt; goal; topologySort(); traceBack(); }  ","id":0,"section":"posts","summary":"백준 문제 바로가기 사용 언어 C++ 적용 알고리즘 위상 정렬 알고리즘 문제풀이 해당 문제에서 요구하는 것은 2가지이다. 1. 모든 사람들이 만나는 시간 2. 1분도 쉬지 않고 달","tags":["위상 정렬 알고리즘"],"title":"백준 1948 - 임계경로","uri":"https://chlalstjd430.github.io/2020/01/%EB%B0%B1%EC%A4%801948/","year":"2020"},{"content":" Chapter 04 - 주석  나쁜 코드에 주석을 달지 마라. 새로 짜라. - 브라이언 W.커니핸, P.J.플라우거\n \n1. 불필요한 주석을 없애자.  주석은 코드로 의도를 표현하지 못하여 실패를 만회하기 위해 사용하는 것이다. 즉, 주석은 언제나 실패를 의미한다.\n 오래된 코드일수록 코드를 유지보수해도 주석을 유지보수하는 경우는 거의 없다.\n  \n2. 주석 대신 코드로 의도를 표현하라! // 직원에게 복지 혜택을 받을 자격이 있는지 검사한다. if ((emplotee.flags \u0026amp; HOURLY_FLAG) \u0026amp;\u0026amp; (employee.age \u0026gt; 65)  위 코드를 주석을 제거하고 함수 이름만으로 표현하면\nif (employee.isEligibleForFullBenefits())  다음과 같은 코드가 된다. 훨씬 보기 좋지 않은가?\n\n3. 필요한 주석  법적인 주석 : 소스 파일 첫머리에 들어가는 저작권 정보와 소유권 정보 등   // Copyright \u0026copy; 2003, 2004, 2005 by Object Montor, Inc. All right reserved. // GNU General Public License\n  정보를 제공하는 주석\n// kk:mm:ss EEE, MMM dd, yyyy 형식이다. Pattern timeMatcher = Pattern.compile(\u0026quot;\\\\d*:\\\\d*\\\\d* \\\\w*, \\\\w*, \\\\d*, \\\\d*\u0026quot;);  의도를 설명하는 주석\n// 스레드를 대량 생성하는 방법으로 어떻게든 경쟁 조건을 만들려 시도한다. for (int i = 0; i \u0026gt; 2500; i++) { WidgetBuilderThread widgetBuilderThread = new WidgetBuilderThread(widgetBuilder, text, parent, failFlag); Thread thread = new Thread(widgetBuilderThread); thread.start(); }  결과를 경고하는 주석\n// 여유 시간이 충분하지 않다면 실행하지 마십시오. public void _testWithReallyBigFile() { ... }  중요성을 강조하는 주석\nString listItemContent = match.group(3).trim(); // 여기서 trim은 정말 중요하다. trim 함수는 문자열에서 시작 공백을 제거한다. // 문자열에 시작 공백이 있으면 다른 문자열로 인식되기 때문이다. new ListItemWidget(this, listItemContent, this.level + 1); return buildList(text.substring(match.end()));  공개 API에서 Javadocs\n 설명이 잘 된 공개 API는 참으로 유용하고 만족스럽다. 공개 API를 구현한다면 반드시 훌륭한 Javadocs 작성을 추천한다. 하지만 여느 주석과 마찬가지로 Javadocs 역시 독자를 오도하거나, 잘못 위치하거나, 그릇된 정보를 전달할 가능성이 존재하는 것 역시 잊으면 안 된다.   \n4. 나쁜 주석  주절거리는 주석(특별한 이유없이 달리는 주석)\n 같은 이야기를 중복하는 주석\n 오해의 여지가 있는 주석\n 의무적으로 다는 주석\n 모든 함수에 Javadocs를 달거나 모든 변수에 주석을 달아야 한다는 규칙은 어리석기 그지없다. 이런 주석은 코드를 복잡하게 만들며, 거짓말을 퍼뜨리고, 혼동과 무질서를 초래한다. 아래와 같은 주석은 아무 가치도 없다.\n/** * * @param title CD 제목 * @param author CD 저자 * @param tracks CD 트랙 숫자 * @param durationInMinutes CD 길이(단위: 분) */ public void addCD(String title, String author, int tracks, int durationInMinutes) { CD cd = new CD(); cd.title = title; cd.author = author; cd.tracks = tracks; cd.duration = durationInMinutes; cdList.add(cd); }   소스 코드 관리 시스템이 해주는 것들\n 저자를 표시하는 주석\n 이력(기록)을 표시하는 주석\n 주석으로 처리한 코드\n 소스 코드 관리 시스템은 우리의 지난 코드들을 보관해준다.\n  위치를 표시하는 주석\n 닫는 괄호에 다는 주석\n 전역 정보(소스 코드 전체적으로 다는 주석)\n 주석은 반드시 근처에 있는 코드에 한해서만 기술하자.  비공개 코드에서 Javadocs\n 공개 API에서는 Javadocs가 유용하지만 공개하지 않을 코드이면 Javadocs는 쓸모가 없다.   \n결론  좋은 주석의 예시로 TODO 주석 같은게 있었지만, 이는 현재 다른 툴로 충분히 다룰수 있으므로 제외하였다.\n 사실 나쁜 주석으로 여러 예시들을 나열 했는데, 좋은 주석 예제들을 자세히보고 그 외의 주석들은 안다는게 편할듯 하다.\n 예전에야 주석이 잘 짜여져야 보기 편하다 했지만, 확실히 불필요한 주석은 가독성을 저해하고 유지보수가 되면서 왜곡된 정보들이 노출되는 것 같다. 앞으로 주석은 가급적 지양하고 함수명과 변수명을 통해 내 의도가 드러나도록 만들도록 해야겠다.\n  \n출저 : https://github.com/Yooii-Studios/Clean-Code\n출저 : Clean Code 클린 코드 : 애자일 소프트웨어 장인 정신\n","id":1,"section":"posts","summary":"Chapter 04 - 주석 나쁜 코드에 주석을 달지 마라. 새로 짜라. - 브라이언 W.커니핸, P.J.플라우거 1. 불필요한 주석을 없애자. 주석은 코드로 의도를 표현하지 못하여","tags":["클린코드"],"title":"Chapter 04 - 주석","uri":"https://chlalstjd430.github.io/2020/01/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C_004/","year":"2020"},{"content":" Chapter 03 - 함수 이번 시간에는 clean한 함수를 만드는 방법에 공부하였다. 어떻게 해야 좋은 함수를 만들 수 있는지 같이 확인 해 보자. 1. 함수는 작을수록(분리될수록) 좋다.  다음은 코드의 예시다, 위의 코드보다 아래 코드처럼 5줄 이내로 줄여서 사용할 것을 권장한다.\npublic static String renderPageWithSetupsAndTeardowns( PageData pageData, boolean isSuite) throws Exception { boolean isTestPage = pageData.hasAttribute(\u0026quot;Test\u0026quot;); if (isTestPage) { WikiPage testPage = pageData.getWikiPage(); StringBuffer newPageContent = new StringBuffer(); includeSetupPages(testPage, newPageContent, isSuite); newPageContent.append(pageData.getContent()); includeTeardownPages(testPage, newPageContent, isSuite); pageData.setContent(newPageContent.toString()); } return pageData.getHtml(); }  public static String renderPageWithSetupsAndTeardowns( PageData pageData, boolean isSuite) throws Exception { if (isTestPage(pageData)) includeSetupAndTeardownPages(pageData, isSuite); return pageData.getHtml(); }  에네르기파를 자제하자\n 우리는 간혹 if~else 문으로 depth가 3단계 넘어가는 경우도 보게된다. 그러한 코드는 가독성 뿐만 아니라 상당히 비효율적인 코드이다.   \n2. 함수는 하나의 기능만!  함수는 한 가지 기능만 해야한다. 한가지 함수내에서 기능들을 여러가지 나눌 수 있다면 그 함수는 하나가 아닌 여러작업을 하는 함수이다.  \n3. 함수 당 추상화 수준은 하나로  한 함수 내에서 추상화 수준은 섞이지 않고 동일해야 된다.\n 내려가기 규칙(위에서 아래로 코드 읽기)\n 함수 추상화 부분이 한번에 한단계씩 낮아지는 것이 가장 이상적이다.   \n4. switch는 댜형적 객체를 생성하는 코드 안에서만 사용을 권장한다.  물론 불가피한 상황에서는 적절히 이용할 수 있다.\n switch를 abstract factory에 숨겨 다형적 코드를 생성하는 예\npublic abstract class Employee { public abstract boolean isPayday(); public abstract Money calculatePay(); public abstract void deliverPay(Money pay); } public interface EmployeeFactory { public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType; } public class EmployeeFactoryImpl implements EmployeeFactory { public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType { switch (r.type) { case COMMISSIONED: return new CommissionedEmployee(r) ; case HOURLY: return new HourlyEmployee(r); case SALARIED: return new SalariedEmploye(r); default: throw new InvalidEmployeeType(r.type); } } }   \n5. 함수 인수 함수에서 이상적인 인수 개수는 0개(무항). 인수는 코드 이해에 방해가 되는 요소이므로 최선은 0개이고, 차선은 1개뿐인 경우이다. 출력인수(함수의 반환 값이 아닌 입력 인수로 결과를 받는 경우)는 이해하기 어려우므로 왠만하면 쓰지 않는 것이 좋겠다.\n 많이 쓰이는 단항 형식\n 인수에 질문을 던지는 경우\n boolean fileExists(“MyFile”);\n 인수를 뭔가로 변환해 결과를 변환하는 경우\n InputStream fileOpen(“MyFile”);\n 이벤트 함수일 경우 (이 경우에는 이벤트라는 사실이 코드에 명확하게 드러나야 한다.)\n  플래그 인수\n bool값을 넘기는 것 자체가 함수의 기능이 하나가 아닌 것을 입증하게 된다. 즉, 플래그 인수는 쓰지말자.  단항 함수\n 단항 함수는 함수와 인수가 동사/명사 쌍을 이루어야 한다.\n writeField(name);\n 함수이름에 키워드(인수 이름)을 추가하면 인수 순서를 기억할 필요가 없다.\n assertExpectedEqualsActual(expected, actual);\n  다항 함수\n 단항 함수보다 한번에 알아보기 힘들다. 이항 함수의 경우에는 무조건적으로 지양해야 할 대상은 아니지만 가능하면 단항 함수로 변경하여 사용하자.\n 결론적으로 매개변수가 많아질수록 코드의 이해도는 떨어질 것이다.\n 많은 매개변수를 전달해야 할 때 클래스로 변수를 넘길수는 없는지 생각해보자.\n 때로는 String format 같은 인수 개수가 가변적인 경우도 필요하다.\n   \n6. 부수 효과를 일으키지 말자! 부수효과는 함수에서 한 가지 역할만 하겠다고 약속하고 거짓말을 하는 셈이다.\n\n7. 명령과 조회를 분리하라 함수는 객체 상태를 변겅하거나, 객체 정보를 반환하거나 둘 중 하나다. 둘 다 수행해서는 안된다.\n\n\u0026lt;br?\n8. 오류코드보다 예외를 사용하자 try/catch 를 사용하면 코드가 훨씬 간결해진다.\n if/else 로 정상 작동과 오류 처리 작동을 뒤섞는 구조는 정말 보기 안좋다. 그러므로 try/catch 로 예외 처리를 진행하자.\n// 보기 안좋은 if/else로 정상/오류 작동 처리 if (deletePage(page) == E_OK) { if (registry.deleteReference(page.name) == E_OK) { if (configKeys.deleteKey(page.name.makeKey()) == E_OK) { logger.log(\u0026quot;page deleted\u0026quot;); } else { logger.log(\u0026quot;configKey not deleted\u0026quot;); } } else { logger.log(\u0026quot;deleteReference from registry failed\u0026quot;); } } else { logger.log(\u0026quot;delete failed\u0026quot;); return E_ERROR; }  // try/catch를 사용한 예외 처리 public void delete(Page page) { try { deletePageAndAllReferences(page); } catch (Exception e) { logError(e); } } private void deletePageAndAllReferences(Page page) throws Exception { deletePage(page); registry.deleteReference(page.name); configKeys.deleteKey(page.name.makeKey()); } private void logError(Exception e) { logger.log(e.getMessage()); }   \n9. 코드의 중복은 없애자  중복은 모든 소프트웨어에서 악의 근원이다. 중복된 코드는 하나의 함수로 만들어 재사용하자.  \n10. 구조적 프로그래밍 다익스크라의 구조적 프로그래밍의 원칙을 따르자면 모든 함수와 함수 내 모든 블록에 입구와 출구가 하나여야 된다. 즉, 함수는 return문이 하나여야 되며, 루프 안에서 break나 continue를 사용해선 안된며 goto는 절대로, 절대로 사용하지 말자. 함수가 클 경우에만 상당 이익을 제공하므로, 함수를 작게 만든다면 오히려 여러차례 사용하는 것이 함수의 의도를 표현하기 쉬워진다.\n그런데 구조적 프로그래밍의 목표와 규율은 공감하지만 함수가 작다면 위 규칙은 별 이익을 제공하지 못한다. 함수가 아주 클 때만 상당한 이익을 제공한다. 그러므로 함수를 작게 만든다면 간혹 return, break, continue를 사용해도 괜찮다. 오히려 때로는 단일 입/출구 규칙보다 의도를 표현하기 쉬워진다.\n결론  이 문서에서 다루지는 않았지만 chapter02 - 의미있는 이름에서 함수명을 짓는 방법도 나와있으니 참고하면 좋을 것 같다.\n 처음부터 완벽히 위의 10개의 규칙들을 적용하며 함수를 만들면 좋지만, 사람이다보니 처음부터 완벽할수는 없다. 차근차근 습관을 길들이도록 하자.\n  \n출저 : https://github.com/Yooii-Studios/Clean-Code\n출저 : Clean Code 클린 코드 : 애자일 소프트웨어 장인 정신\n","id":2,"section":"posts","summary":"Chapter 03 - 함수 이번 시간에는 clean한 함수를 만드는 방법에 공부하였다. 어떻게 해야 좋은 함수를 만들 수 있는지 같이 확인 해 보자. 1. 함수는 작을수록(분리될수록","tags":["클린코드"],"title":"Chapter 03 - 함수","uri":"https://chlalstjd430.github.io/2020/01/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C_003/","year":"2020"},{"content":" 백준 문제 바로가기 \n사용 언어  C++  적용 알고리즘  다익스트라 알고리즘  문제풀이 이 문제는 얼핏 보면 단순 다익스트라 알고리즘을 한번 적용하여 풀 수 있는 문제로 보인다. 그러나 문제를 잘 들여다 보면 다음과 같은 문구를 확인할 수 있다.\n 세준이는 한번 이동했던 정점은 물론, 한번 이동했던 간선도 다시 이동할 수 있다. 하지만 반드시 최단 경로로 이동해야 한다는 사실에 주의하라. 1번 정점에서 N번 정점으로 이동할 때, 주어진 두 정점을 반드시 거치면서 최단 경로로 이동하는 프로그램을 작성하시오.\n 이 문구를 통해 우리는 반드시 주어진 두 정점을 거쳐 1부터 N번의 정점으로 이동하여야 한다. 위 문제를 해결하기 위해서 반드시 거쳐야 할 두 정점을 a,b라고 가정해보면 다음과 같은 과정이 나온다.\n1. a-\u0026gt;b로 이동하는 과정\n 1 -\u0026gt; a -\u0026gt; b -\u0026gt; N\n dijkstra(1-\u0026gt;a) + dijkstra(a-\u0026gt;b) + dijkstra(b-\u0026gt;N)\n  2. b-\u0026gt;a로 이동하는 과정\n 1 -\u0026gt; b -\u0026gt; a -\u0026gt; N\n dijkstra(1-\u0026gt;b) + dijkstra(b-\u0026gt;a) + dijkstra(a -\u0026gt; N)\n  총 2가지의 과정 중 적은 과정을 택하여 값으로 출력하면 된다. 그리하여 작성된 코드를 보면 다음과 같다.\n코드 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; const int INF = 1000000; // 과정을 진행할 때 INF가 3번 더해지는 경우가 있으니 이를 고려하여 INF값을 설정하여야 한다. const int MAX = 10000; int N, E; vector\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; graph[MAX]; int visited[MAX]; void dijkstra(int start) { visited[start] = 0; priority_queue\u0026lt;pair\u0026lt;int,int\u0026gt; \u0026gt; pq; pq.push(make_pair(0, start)); while (!pq.empty()) { int current = pq.top().second; int distance = -pq.top().first; pq.pop(); int size = graph[current].size(); for(int i = 0; i \u0026lt; size; i++){ int next = graph[current][i].first; int nextDistance = distance + graph[current][i].second; if (nextDistance \u0026lt; visited[next]) { visited[next] = nextDistance; pq.push(make_pair(-nextDistance, next)); } } } } // 초기화 void init() { fill(\u0026amp;visited[0], \u0026amp;visited[MAX - 1], INF); } // 다익스트라 알고리즘 실행 후 원하는 경로가 있는지 확인 int isINF(int goal) { if (visited[goal] == INF) return INF; else return visited[goal]; } int isPossible(int a, int b, int c, int d) { init(); dijkstra(a); int a_b = isINF(b); init(); dijkstra(b); int b_c = isINF(c); init(); dijkstra(c); int c_d = isINF(d); // 3개의 경로 중 하나라도 경로가 없으면 두 정점을 거쳐서 1부터 N까지 갈 수 없으므로 INF값을 리턴 if (a_b == INF || b_c == INF || c_d == INF) return INF; // 3개의 경로 모두 값이 있으면 합계 리턴 return a_b + b_c + c_d; } int main() { cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; E; int a, b, c; int start, goal; for (int i = 0; i \u0026lt; E; i++) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; // 무방향 그래프이므로 a에서 b로 가는 것과 b에서 a로 가는 것 둘다 받아야 한다. graph[a].push_back(make_pair(b, c)); graph[b].push_back(make_pair(a, c)); } cin \u0026gt;\u0026gt; start \u0026gt;\u0026gt; goal; int one = isPossible(1, start, goal, N); int two = isPossible(1, goal, start, N); int result = min(one, two); // 두가지 과정 모두 경로가 없으면 -1 리턴 cout \u0026lt;\u0026lt; (result \u0026gt;= INF ? -1 : result); }  ","id":3,"section":"posts","summary":"백준 문제 바로가기 사용 언어 C++ 적용 알고리즘 다익스트라 알고리즘 문제풀이 이 문제는 얼핏 보면 단순 다익스트라 알고리즘을 한번 적용하여 풀 수 있는 문제로 보인다. 그","tags":["다익스트라 알고리즘"],"title":"백준 1504 - 특정한 최단 경로","uri":"https://chlalstjd430.github.io/2020/01/%EB%B0%B1%EC%A4%801504/","year":"2020"},{"content":" Chapter 02 - 의미있는 이름 \n1. 의도가 담긴 이름을 짓자  변수명/메서드명을 통해서 역할을 추정할 수 있도록 이름을 짓자.\n 별도의 주석이 필요 없을 정도로 명확하게 이름을 짓자.\n 예시\nint d; (X) -\u0026gt; int elapsedTimeInDays; public void getThem(){ ... } (x) -\u0026gt; public void getFlaggedCells(){ ... } (o)   \n2. 그릇된 정보를 피하자.  중의적인 의미를 피하자.\n 개발자에게 특수한 의미를 가지는 단어(Collection - list 등)는 실제 컨테이너가 해당 타입이 아닌 경우 변수명에 넣지 말자.\n 예시\nString[] customerList; (x) -\u0026gt; List\u0026lt;String\u0026gt; customerList; (o)   \n3. 불용어(noise word)를 사용하지 말자.  클래스 이름에 Manager, Processor, Data, Info 같은 불용어를 붙이지 말자.\n 예시\nClass StudentInfo{ ... } (x) -\u0026gt; Class Student{ ... } (o)   \n4. 발음하기 쉬운 이름을 사용하자.  숫자를 혼용하지 말자.\n 우리가 아는 단어 위주로 사용하자.\n  \n5. 검색하기 쉬운 이름을 사용하자.  상수는 static final과 같이 정희하여 사용하자.\n 변수의 이름은 변수의 범위에 비례하여 길어진다.\n  6. 클래스/메서드  변수\n 변수명에 해당 변수의 타입등을 적지말자.  클래스\n 명사 혹은 명사구(Custemer, Student)를 사용하고 동사는 사용하지 말자.  메서드\n 동사 혹은 동사구(updatePayment, deleteAccount)하자.\n 접근자는 get, 변경자는 set, 조건자는 is로 시작하자. (should, has 도 가능)\n 생성자를 오버로드할 경우 정적 팩토리 메서드를 사용하고 해당 생성자를 private로 선언한다.\n 예시\nComplex fulcrumPoint = new Complex(23.0); (x) Complex fulcrumPoint = Complex.FromRealNumber(23.0); (o)    \n7. 함부로 이름을 줄이지 말자. GS (x) -\u0026gt; GasStation (o)  \n결론  사실 위의 내용 말고 \u0026ldquo; -를 사용하자\u0026rdquo;, \u0026ldquo;-를 하지말자\u0026rdquo; 라는 내용이 더 있다. 하지만 근본적인 내용들은 위의 내용과 겹칠 뿐더러 오히려 더 나열하면 헷갈릴 것 같아 정리 내용에서 제외하였다.\n 결론적으로 이름을 성의있게 지어야 한다는 것을 알게 되었다. 나 역시도 어느정도 성의 있게 지켜가며 이름을 지었지만 이번 공부를 통해 더 명확하게 이름을 지을 수 있을 것 같다.\n  \n출저 : https://github.com/Yooii-Studios/Clean-Code\n출저 : Clean Code 클린 코드 : 애자일 소프트웨어 장인 정신\n","id":4,"section":"posts","summary":"Chapter 02 - 의미있는 이름 1. 의도가 담긴 이름을 짓자 변수명/메서드명을 통해서 역할을 추정할 수 있도록 이름을 짓자. 별도의 주석이 필요 없을 정도로 명확하게 이름을 짓자","tags":["클린코드"],"title":"Chapter 02 - 의미있는 이름","uri":"https://chlalstjd430.github.io/2020/01/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C_002/","year":"2020"},{"content":" 01.21부로 클린 코드에 대하여 요약한 게시글을 보고 나만의 후기를 남길 예정이다.\n책은 우선시 되는 다른 공부가 어느정도 정리되면 그 때 읽어볼 예정이다.\n\nChapter 01 - 깨끗한 코드 \n1. 나쁜 코드 우리는 종종 당장의 문제를 해결하기 위해 나쁜 코드(가독성,효율성,등 여러면에서)를 작성하고는 한다. 이러한 코드들은 당장의 문제를 해결해 줄 뿐이지 추후 결과적으로는 우리에게 최악의 상황을 초래한다. 그렇기 때문에 초기에 나쁜 코드가 아닌 클린한 코드를 작성하는 것이 중요하다.\n\n2. 보이스카우트 규칙  \u0026ldquo;Leave the campground cleaner than you found it.\u0026rdquo;\n 위 문구는 보이스카우트에서 인용된 문구이다. 이 말을 우리(프로그래머)의 언어로 받아 들이면 다음과 같다.\n \u0026ldquo;눈 앞에 더러운 코드가 보이면 조금이라도(변수명,if문 한줄) 개선하여라\u0026rdquo;\n 한번에 모든걸 하려면 어렵다. 그러나 조금씩이라도 변화를 지속하다보면 그것이 습관이되고 결국에는 근본적인 문제점 또한 해결 될 것이다.\n\n3. 같이 읽어보면 좋은 책 클린 코드에서는 이 책이 Agile Sorfware Development의 프리퀄이라고 말하였다. 추후에 해당 책도 읽어보면 좋을 듯 하다.\n\n결론  깨끗한 코드를 만들기 위해서 무작정 당장의 문제 해결에 집중하지 말고 장기적인 관점에서 코드를 작성하다.\n 보이스카우트 규칙에 따라 많이는 아니더라도 조금씩이라도 코드를 고쳐나가자.\n Agile Sorfware Development을 시간이 되면 읽어보자.\n  \n출저 : https://github.com/Yooii-Studios/Clean-Code\n출저 : Clean Code 클린 코드 : 애자일 소프트웨어 장인 정신\n","id":5,"section":"posts","summary":"01.21부로 클린 코드에 대하여 요약한 게시글을 보고 나만의 후기를 남길 예정이다. 책은 우선시 되는 다른 공부가 어느정도 정리되면 그 때 읽어볼 예정이다. Chapter 01 -","tags":["클린코드"],"title":"Chapter 01 - 깨끗한 코드","uri":"https://chlalstjd430.github.io/2020/01/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C_001/","year":"2020"},{"content":" 백준 문제 바로가기 \n사용 언어  C++  적용 알고리즘  다이나믹 프로그래밍  문제풀이   포도주 잔을 선택하면 그 잔에 들어있는 포도주는 모두 마셔야 하고, 마신 후에는 원래 위치에 다시 놓아야 한다. 연속으로 놓여 있는 3잔을 모두 마실 수는 없다.   문제의 조건 중 위 두가지 조건으로 보아 일정한 규칙을 세울 수 있다.\n포도주를 마실때 총 3가지 조건으로 나누어지게 된다.\n첫번째 포도주인 경우\n 현재까지의 포도주 양 = 현재 포도주 양 + 이전까지의 포도주 양\n 두번째 포도주인 경우\n 현재까지의 포도주 양 = 현재 포도주 양 + 이전 포도주 양 + 현재-3까지의 포도주 양\n 세번째 포도주인 경우(건너띄는 포도주)\n 현재까지의 포도주 양 = 이전까지의 포도주 양\n 이를 통해 다음과 같은 코드가 나오게 되었다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; long long int podo[10002]; long long int dp[10002]; int main() { int n; long long int maxPodo; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; podo[i]; } if (n == 1) { cout \u0026lt;\u0026lt; podo[1]; return 0; } else if (n == 2) { cout \u0026lt;\u0026lt; max(podo[1], (podo[1] + podo[2])); return 0; } dp[1] = podo[1]; dp[2] = dp[1] + podo[2]; maxPodo = dp[2]; for (int i = 3; i \u0026lt;= n; i++) { dp[i] = max(podo[i] + dp[i - 2], max((podo[i] + podo[i - 1] + dp[i - 3]), dp[i-1]) ); maxPodo = max(maxPodo, dp[i]); } cout \u0026lt;\u0026lt; maxPodo; }  ","id":6,"section":"posts","summary":"백준 문제 바로가기 사용 언어 C++ 적용 알고리즘 다이나믹 프로그래밍 문제풀이 포도주 잔을 선택하면 그 잔에 들어있는 포도주는 모두 마셔야 하고, 마신 후에는 원래 위치에","tags":["다이나믹 프로그래밍"],"title":"백준 2156 - 포도주 시식","uri":"https://chlalstjd430.github.io/2020/01/%EB%B0%B1%EC%A4%802156/","year":"2020"},{"content":"☞ 백준 문제 바로가기[9465- 스티커]\n\u0026nbsp;\n\u0026nbsp;\n사용 언어\n- C++\n\u0026nbsp;\n﻿적용 알고리즘\n- Dynamic Programing(다이나믹 프로그래밍)\n-\u0026nbsp;관련 동영상 강의 바로가기\n\u0026nbsp;\n\u0026nbsp;\n관련 문제\n- 백준\n\u0026nbsp;-\u0026gt;\u0026nbsp;1149,\u0026nbsp;9465,\u0026nbsp;2579, 1003, 11726, 11727 2133, 14852, 11048, 1309,\u0026nbsp; 2156, 2864, 1965, 2293, 11066, 9461, 1520, 10942\n\u0026nbsp;\n문제 풀이\n다이나믹 프로그래밍(Dynamic Programing) 문제를 풀 때에는 항상\u0026nbsp;문제의 조건과\u0026nbsp;하나의 값을 가질 수 있는 경우이다.\n현재 문제에서의 조건은 다음과 같다.\n\n1. 스티커는 2N의 크기이다.\n2. 뗀 스티커의 왼쪽,위,오른쪽,아래의 스티커는 사용 할 수 없다.\n\n따라서 왼쪽부터 스티커를 뗀다고 하면, 최종적으로 마지막 (0,N),(1,N)의 스티커 중 하나는 뗴어져야한다. 이를 가지고 조건을 만든다면.\n1) 마지막 스티커가 첫번째 줄인 경우 - (0,N)\n(1) 이전 스티커가 현재 스티커 기준으로 왼쪽 대각선 아래인 경우 - (1,N-1)\n현재 스티커까지의 합 = 현재 스티커 + 왼쪽 대각선 아래 스티커까지의 합\ndp([0][N]) = [0][N] + dp([1][N-1])\u0026nbsp;\n(2) 이전 스티커가 현재 스티커 기준으로 왼쪽에서 두번째인 경우 - (0, N-2)\n현재 스티커까지의 합 = 현재 스티커 + 왼쪽 두번째 스티커까지의 합\ndp([0][N]) = [0][N] + dp([0][N-2])\n(3) 이전 스티커가 현재 스티커 기준으로 왼쪽에서 두번째, 대각선 아래인 경우 - (1, N-2)\n현재 스티커까지의 합 = 현재 스티커 + 왼쪽 두번째,대각선 아래 스티커까지의 합\ndp([0][N]) = [0][N] + dp([1][N-2])\n\n- dp([0][N]) = (1),(2),(3) 중에 가장 큰 값\n\n2) 마지막 스티커가 두번째 줄인 경우 - (1,N)\n(1) 이전 스티커가 현재 스티커 기준으로 왼쪽 대각선 위인 경우 - (0,N-1)\n현재 스티커까지의 합 = 현재 스티커 + 왼쪽 대각선 위 스티커까지의 합\ndp([1][N]) = [1][N] + dp([0][N-1])\u0026nbsp;\n(2) 이전 스티커가 현재 스티커 기준으로 왼쪽에서 두번째인 경우 - (1, N-2)\n현재 스티커까지의 합 = 현재 스티커 + 왼쪽 두번째 스티커까지의 합\ndp([1][N]) = [1][N] + dp([1][N-2])\n(3) 이전 스티커가 현재 스티커 기준으로 왼쪽에서 두번째, 대각선 위인 경우 - (1, N-2)\n현재 스티커까지의 합 = 현재 스티커 + 왼쪽 두번째,대각선 위 스티커까지의 합\ndp([1][N]) = [1][N] + dp([0][N-2])\n\n- dp([1][N]) = (1),(2),(3) 중에 가장 큰 값\n\n최종적으로 dp[0][N]과 dp[1][N] 중에 큰 값이 답이 될 수 있다.\u0026nbsp;\n\n이를 통해 스티커와 DP 배열을 선언한다.\n\n12int\u0026nbsp;sticker[2][100002];int\u0026nbsp;dp[2][100002];cs이후 앞에서 설명한 조건을 통해 최대값을 구한 후 출력하면 문제를 해결 할 수 있다.\n123456789dp[0][1]\u0026nbsp;=\u0026nbsp;sticker[0][1];dp[1][1]\u0026nbsp;=\u0026nbsp;sticker[1][1];\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;j\u0026nbsp;=\u0026nbsp;2;\u0026nbsp;j\u0026nbsp;\u0026lt;=\u0026nbsp;n;\u0026nbsp;j++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[0][j]\u0026nbsp;=\u0026nbsp;sticker[0][j]\u0026nbsp;+\u0026nbsp;max(dp[1][j\u0026nbsp;-\u0026nbsp;1],\u0026nbsp;max(dp[0][j\u0026nbsp;-\u0026nbsp;2],\u0026nbsp;dp[1][j\u0026nbsp;-\u0026nbsp;2]));\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[1][j]\u0026nbsp;=\u0026nbsp;sticker[1][j]\u0026nbsp;+\u0026nbsp;max(dp[0][j\u0026nbsp;-\u0026nbsp;1],\u0026nbsp;max(dp[0][j\u0026nbsp;-\u0026nbsp;2],\u0026nbsp;dp[1][j\u0026nbsp;-\u0026nbsp;2]));}\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;max(dp[0][n],\u0026nbsp;dp[1][n])\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;endl;Colored by Color Scriptercs\n\u0026nbsp;\n\u0026nbsp;\n최종 코드\n\n12345678910111213141516171819202122232425262728293031323334353637383940#include\u0026nbsp;\u0026lt;iostream\u0026gt;#include\u0026nbsp;\u0026lt;algorithm\u0026gt;\u0026nbsp;using\u0026nbsp;namespace\u0026nbsp;std;\u0026nbsp;int\u0026nbsp;sticker[2][100002];//스티커를\u0026nbsp;저장할\u0026nbsp;배열int\u0026nbsp;dp[2][100002];//dp\u0026nbsp;전용\u0026nbsp;배열\u0026nbsp;int\u0026nbsp;main()\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;tc,n;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;tc;//테스트\u0026nbsp;케이스\u0026nbsp;입력\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;i\u0026nbsp;\u0026lt;\u0026nbsp;tc;\u0026nbsp;i++)\u0026nbsp;{//테스트\u0026nbsp;케이스\u0026nbsp;만큼\u0026nbsp;반복\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;n;//스티커\u0026nbsp;크기\u0026nbsp;입력\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;j\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;j\u0026nbsp;\u0026lt;\u0026nbsp;2;\u0026nbsp;j++)\u0026nbsp;{//스티커\u0026nbsp;값\u0026nbsp;입력\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;k\u0026nbsp;=\u0026nbsp;1;\u0026nbsp;k\u0026nbsp;\u0026lt;=\u0026nbsp;n;\u0026nbsp;k++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;sticker[j][k];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;//dp\u0026nbsp;첫번째\u0026nbsp;값\u0026nbsp;입력\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[0][1]\u0026nbsp;=\u0026nbsp;sticker[0][1];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[1][1]\u0026nbsp;=\u0026nbsp;sticker[1][1];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;//dp\u0026nbsp;구하기\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;j\u0026nbsp;=\u0026nbsp;2;\u0026nbsp;j\u0026nbsp;\u0026lt;=\u0026nbsp;n;\u0026nbsp;j++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[0][j]\u0026nbsp;=\u0026nbsp;sticker[0][j]\u0026nbsp;+\u0026nbsp;max(dp[1][j\u0026nbsp;-\u0026nbsp;1],\u0026nbsp;max(dp[0][j\u0026nbsp;-\u0026nbsp;2],\u0026nbsp;dp[1][j\u0026nbsp;-\u0026nbsp;2]));\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[1][j]\u0026nbsp;=\u0026nbsp;sticker[1][j]\u0026nbsp;+\u0026nbsp;max(dp[0][j\u0026nbsp;-\u0026nbsp;1],\u0026nbsp;max(dp[0][j\u0026nbsp;-\u0026nbsp;2],\u0026nbsp;dp[1][j\u0026nbsp;-\u0026nbsp;2]));\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;//최종\u0026nbsp;값\u0026nbsp;출력\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;max(dp[0][n],\u0026nbsp;dp[1][n])\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;endl;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;//스티커와\u0026nbsp;DP\u0026nbsp;배열\u0026nbsp;초기화\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;j\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;j\u0026nbsp;\u0026lt;=\u0026nbsp;n;\u0026nbsp;j++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[0][j]\u0026nbsp;=\u0026nbsp;sticker[0][j]\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[1][j]\u0026nbsp;=\u0026nbsp;sticker[1][j]\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}Colored by Color Scriptercs\n\n추가적으로 질문사항이 있으시면 언제든지 댓글을 달아주세요:D\n\n\u0026nbsp;\n\n\u0026nbsp;\n\n\u0026nbsp;\n\n\u0026nbsp;\n","id":7,"section":"posts","summary":"☞ 백준 문제 바로가기[9465- 스티커] \u0026nbsp; \u0026nbsp; 사용 언어 - C++ \u0026nbsp; ﻿적용 알고리즘 - Dynamic Programing(다이나믹 프로그래밍) -\u0026nbsp;관련 동영상","tags":["다이나믹 프로그래밍"],"title":"백준 9465 - 스티커","uri":"https://chlalstjd430.github.io/2020/01/%EB%B0%B1%EC%A4%809465/","year":"2020"},{"content":"☞ 백준 문제 바로가기[2579- 계단 오르기]\n\u0026nbsp;\n\u0026nbsp;\n사용 언어\n- C++\n\u0026nbsp;\n﻿적용 알고리즘\n- Dynamic Programing(다이나믹 프로그래밍)\n-\u0026nbsp;관련 동영상 강의 바로가기\n\u0026nbsp;\n\u0026nbsp;\n관련 문제\n- 백준\n\u0026nbsp;-\u0026gt;\u0026nbsp;1149,\u0026nbsp;9465,\u0026nbsp;2579, 1003, 11726, 11727 2133, 14852, 11048, 1309,\u0026nbsp; 2156, 2864, 1965, 2293, 11066, 9461, 1520, 10942\n\u0026nbsp;\n문제 풀이\n문제에서 주어진 조건들을 먼저 살표보면 다음과 같습니다.\n\n1. 계단은 한번에 1개 혹은 2개를 오를 수 있다.\n2. 계단은 연속으로 3칸을 오를 수 없다.\n3. 마지막 계단은 무조건 밟아야한다.\n\n따라서 마지막 계단을 밟아야한다면 다음과 같이 두 조건으로 분류 할 수 있습니다.\n1) 마지막 계단이 처음 밟는 계단일 경우\n마지막 계단까지의 값 = 마지막 계단 값 + [마지막 - 2]까지 밟았던 값들의 총합\nN = N + dp(n-2)\n\n2) 마지막 계단이 마지막으로(두번째로) 밟는 계단일 경우\n마지막 계단까지의 값 = 마지막 계단 값 + [마지막 - 1] 계단의 값 + [마지막 - 3] 까지 밟았던 값들의 총합\nN = N + N-1 +dp(n-3)\n\n이를 통해 N을 stair(=현재 계단)이라고 하고 하면 다음과 같이 전역 변수를 선언 할 수 있습니다.\n\n12int\u0026nbsp;stair[301];int\u0026nbsp;dp[301];cs이어서 두가지의 경우 중 큰 값들을 나란히 넣어주고 최종적으로 마지막 계단 값을 출력하면 결과를 도출해 낼 수 있습니다.\n\n123456dp[1]\u0026nbsp;=\u0026nbsp;stair[1];dp[2]\u0026nbsp;=\u0026nbsp;stair[2]\u0026nbsp;+\u0026nbsp;dp[1];for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;3;\u0026nbsp;i\u0026nbsp;\u0026lt;=\u0026nbsp;tc;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[i]\u0026nbsp;=\u0026nbsp;stair[i]\u0026nbsp;+\u0026nbsp;\u0026nbsp;max(dp[i\u0026nbsp;-\u0026nbsp;2],\u0026nbsp;(stair[i\u0026nbsp;-\u0026nbsp;1]\u0026nbsp;+\u0026nbsp;dp[i\u0026nbsp;-\u0026nbsp;3]));}cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;dp[tc];Colored by Color Scriptercs\n\u0026nbsp;\n\u0026nbsp;\n최종 코드\n\n12345678910111213141516171819202122#include\u0026nbsp;\u0026lt;iostream\u0026gt;#include\u0026nbsp;\u0026lt;algorithm\u0026gt;\u0026nbsp;using\u0026nbsp;namespace\u0026nbsp;std;\u0026nbsp;int\u0026nbsp;stair[301];int\u0026nbsp;dp[301];\u0026nbsp;int\u0026nbsp;main()\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;tc;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;tc;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;1;\u0026nbsp;i\u0026nbsp;\u0026lt;=\u0026nbsp;tc;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;stair[i];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[1]\u0026nbsp;=\u0026nbsp;stair[1];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[2]\u0026nbsp;=\u0026nbsp;stair[2]\u0026nbsp;+\u0026nbsp;dp[1];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;3;\u0026nbsp;i\u0026nbsp;\u0026lt;=\u0026nbsp;tc;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[i]\u0026nbsp;=\u0026nbsp;stair[i]\u0026nbsp;+\u0026nbsp;\u0026nbsp;max(dp[i\u0026nbsp;-\u0026nbsp;2],\u0026nbsp;(stair[i\u0026nbsp;-\u0026nbsp;1]\u0026nbsp;+\u0026nbsp;dp[i\u0026nbsp;-\u0026nbsp;3]));\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;dp[tc];}\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;Colored by Color Scriptercs\n추가적으로 질문사항이 있으시면 언제든지 댓글을 달아주세요:D\n\n\u0026nbsp;\n\n\u0026nbsp;\n\n\u0026nbsp;\n","id":8,"section":"posts","summary":"☞ 백준 문제 바로가기[2579- 계단 오르기] \u0026nbsp; \u0026nbsp; 사용 언어 - C++ \u0026nbsp; ﻿적용 알고리즘 - Dynamic Programing(다이나믹 프로그래밍) -\u0026nbsp;관련 동","tags":["다이나믹 프로그래밍"],"title":"백준 2579 - 계단 오르기","uri":"https://chlalstjd430.github.io/2020/01/%EB%B0%B1%EC%A4%802579/","year":"2020"},{"content":"☞ 백준 문제 바로가기[1149 - RGB거리]\n\u0026nbsp;\n\u0026nbsp;\n사용 언어\n- C++\n\u0026nbsp;\n﻿적용 알고리즘\n- Dynamic Programing(다이나믹 프로그래밍)\n-\u0026nbsp;관련 동영상 강의 바로가기\n\u0026nbsp;\n\u0026nbsp;\n관련 문제\n- 백준\n\u0026nbsp;-\u0026gt;\u0026nbsp;1149,\u0026nbsp;9465,\u0026nbsp;2579, 1003, 11726, 11727 2133, 14852, 11048, 1309,\u0026nbsp; 2156, 2864, 1965, 2293, 11066, 9461, 1520, 10942\n\u0026nbsp;\n문제 풀이\n해당 문제에서 요구하는 것은 하나의 집에 대헤서 이웃하는 집(i-1,i+1)과 다른 페인트를 색칠하게 하는 것이다. 그리하여 모든 집을 칠하는 최소 페인트 비용을 구하면된다.\n우선 하나의 집에 대헤서 각각의 페인트 비용을 저장하기 위해 다음과 같은 전역 변수를 선언해주었다.\n\n1int\u0026nbsp;cost[1001][3];cs그리고 문제 해결을 위해서 다음과 같은 접근을 하게 되었다.\n\n12345\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;1;\u0026nbsp;i\u0026nbsp;\u0026lt;\u0026nbsp;n;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cost[i][0]\u0026nbsp;=\u0026nbsp;cost[i][0]\u0026nbsp;+\u0026nbsp;min(cost[i\u0026nbsp;-\u0026nbsp;1][1],\u0026nbsp;cost[i\u0026nbsp;-\u0026nbsp;1][2]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cost[i][1]\u0026nbsp;=\u0026nbsp;cost[i][1]\u0026nbsp;+\u0026nbsp;min(cost[i\u0026nbsp;-\u0026nbsp;1][0],\u0026nbsp;cost[i\u0026nbsp;-\u0026nbsp;1][2]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cost[i][2]\u0026nbsp;=\u0026nbsp;cost[i][2]\u0026nbsp;+\u0026nbsp;min(cost[i\u0026nbsp;-\u0026nbsp;1][0],\u0026nbsp;cost[i\u0026nbsp;-\u0026nbsp;1][1]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}Colored by Color Scriptercs\n﻿이를 가지고 최종적으로 가장 비용이 적은 결과를 출력하게 되었다.\u0026nbsp;\n\n1cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;min(cost[n\u0026nbsp;-\u0026nbsp;1][0],\u0026nbsp;min(cost[n\u0026nbsp;-\u0026nbsp;1][1],\u0026nbsp;cost[n\u0026nbsp;-\u0026nbsp;1][2]));cs실제로 문제의 예제를 가지고 테스트하면\n1. 첫번째\nR : 26[R]\nG : 40[G]\nB : 83[B]\n\u0026nbsp;\n2. 두번째\u0026nbsp;\nR : 49[R] + 40[첫번째의 G]\nG : 60[G] + 26[첫번째의\u0026nbsp;R]\nB : 57[B] + 26[첫번째의 R]\n\u0026nbsp;\n4. 세번째\u0026nbsp;\nR : 13[R] + ( 57 + 26[첫번째의 R])[두번째의 B] = 96\nG: 89[G]\u0026hellip;\nB : 99[B]\u0026hellip;\n최종적으로 나온 값의 가장 작은 값이 예체의 출력값과 같은 것을 확인 할 수 있다.\n\u0026nbsp;\u0026nbsp;\n\n최종 코드\n\n123456789101112131415161718192021222324252627#include\u0026nbsp;\u0026lt;iostream\u0026gt;#include\u0026nbsp;\u0026lt;algorithm\u0026gt;\u0026nbsp;using\u0026nbsp;namespace\u0026nbsp;std;\u0026nbsp;int\u0026nbsp;cost[1001][3];\u0026nbsp;int\u0026nbsp;main()\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;n;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;r,\u0026nbsp;g,\u0026nbsp;b;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;n;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;i\u0026nbsp;\u0026lt;\u0026nbsp;n;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;cost[i][0]\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;cost[i][1]\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;cost[i][2];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;1;\u0026nbsp;i\u0026nbsp;\u0026lt;\u0026nbsp;n;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cost[i][0]\u0026nbsp;=\u0026nbsp;cost[i][0]\u0026nbsp;+\u0026nbsp;min(cost[i\u0026nbsp;-\u0026nbsp;1][1],\u0026nbsp;cost[i\u0026nbsp;-\u0026nbsp;1][2]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cost[i][1]\u0026nbsp;=\u0026nbsp;cost[i][1]\u0026nbsp;+\u0026nbsp;min(cost[i\u0026nbsp;-\u0026nbsp;1][0],\u0026nbsp;cost[i\u0026nbsp;-\u0026nbsp;1][2]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cost[i][2]\u0026nbsp;=\u0026nbsp;cost[i][2]\u0026nbsp;+\u0026nbsp;min(cost[i\u0026nbsp;-\u0026nbsp;1][0],\u0026nbsp;cost[i\u0026nbsp;-\u0026nbsp;1][1]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;min(cost[n\u0026nbsp;-\u0026nbsp;1][0],\u0026nbsp;min(cost[n\u0026nbsp;-\u0026nbsp;1][1],\u0026nbsp;cost[n\u0026nbsp;-\u0026nbsp;1][2]));}Colored by Color Scriptercs\n﻿\n\n\n추가적으로 질문사항이 있으시면 언제든지 댓글을 달아주세요:D\n\n\u0026nbsp;\n\n\u0026nbsp;\n","id":9,"section":"posts","summary":"☞ 백준 문제 바로가기[1149 - RGB거리] \u0026nbsp; \u0026nbsp; 사용 언어 - C++ \u0026nbsp; ﻿적용 알고리즘 - Dynamic Programing(다이나믹 프로그래밍) -\u0026nbsp;관련 동","tags":["다이나믹 프로그래밍"],"title":"백준 1149 - RGB거리","uri":"https://chlalstjd430.github.io/2020/01/%EB%B0%B1%EC%A4%801149/","year":"2020"},{"content":" 백준 문제 바로가기 \n사용 언어  C++  적용 알고리즘  최소 스패닝 트리 합집합 찾기  문제풀이 일반적으로 난이도가 쉬운 최소 스패닝 트리 문제를 풀 때, 가중치 값 기준으로 정렬 후 크르스칼 알고리즘을 적용하면 문제를 쉽게 풀 수 있습니다. 그러나 해당 문제는 가중치 값 기준으로 정렬할 때 다른 문제와 다르다는 것을 느낄 수 있습니다.\n먼저 정렬을 위해서 문제 중 이 한 문장을 잘 이해할 필요가 있겠습니다\n 두 행성 A(xA, yA, zA)와 B(xB, yB, zB)를 터널로 연결할 때 드는 비용은 min(|xA-xB|, |yA-yB|, |zA-zB|)이다.\n 이 문장을 통해 최종적으로 x,y,z 값을 각각 기준으로 정렬후 모든 값들을 vector에 넣어 정렬한 뒤 크루스칼 알고리즘을 적용하면 답이 나올 것을 예상할수 있었습니다.\n먼저 Planet 클래스와, Planet 클래스를 x,y,z 값으로 정렬 후 담아줄수 있는 Edge 클래스를 생성합니다.\n//행성 정보를 담아줄 Planet 클래스 class Planet { public: int node[3]; int index; Planet(int x, int y, int z, int index) { node[0] = x; node[1] = y; node[2] = z; this-\u0026gt;index = index; } }; //Planet Class를 x,y,z기준으로 각각 sort를 위해 만들어줍니다. bool cmpX (Planet \u0026amp;planet, Planet \u0026amp;planet2) { return planet.node[0] \u0026lt; planet2.node[0]; } bool cmpY(Planet \u0026amp;planet, Planet \u0026amp;planet2) { return planet.node[1] \u0026lt; planet2.node[1]; } bool cmpZ(Planet \u0026amp;planet, Planet \u0026amp;planet2) { return planet.node[2] \u0026lt; planet2.node[2]; } //sort이후 가중치 정보를 담아줄 Edge 클래스를 만들어줍니다. class Edge { public: int x, y; int value; Edge(int x, int y, int value) { this-\u0026gt;x = x; this-\u0026gt;y = y; this-\u0026gt;value = value; } bool operator \u0026lt;(Edge \u0026amp;edge) { return this-\u0026gt;value \u0026lt; edge.value; } };  이후 앞서 말씀드린 것처럼 x,y,z 기준으로 Plaent Class를 정렬 후 Edge Class에 담아 최종적으로 Edge Class를 정렬 후 크루스칼 알고리즘을 적용하면 결과가 나옵니다.\n//정렬 과정 sort(planet.begin(), planet.end(), cmpX); for (int i = 0; i \u0026lt; N - 1; i++) { edge.push_back(Edge(planet[i].index, planet[i + 1].index, abs(planet[i].node[0] - planet[i + 1].node[0]))); } sort(planet.begin(), planet.end(), cmpY); for (int i = 0; i \u0026lt; N - 1; i++) { edge.push_back(Edge(planet[i].index, planet[i + 1].index, abs(planet[i].node[1] - planet[i + 1].node[1]))); } sort(planet.begin(), planet.end(), cmpZ); for (int i = 0; i \u0026lt; N - 1; i++) { edge.push_back(Edge(planet[i].index, planet[i + 1].index, abs(planet[i].node[2] - planet[i + 1].node[2]))); } sort(edge.begin(), edge.end());  최종코드 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; class Planet { public: int node[3]; int index; Planet(int x, int y, int z, int index) { node[0] = x; node[1] = y; node[2] = z; this-\u0026gt;index = index; } }; bool cmpX (Planet \u0026amp;planet, Planet \u0026amp;planet2) { return planet.node[0] \u0026lt; planet2.node[0]; } bool cmpY(Planet \u0026amp;planet, Planet \u0026amp;planet2) { return planet.node[1] \u0026lt; planet2.node[1]; } bool cmpZ(Planet \u0026amp;planet, Planet \u0026amp;planet2) { return planet.node[2] \u0026lt; planet2.node[2]; } class Edge { public: int x, y; int value; Edge(int x, int y, int value) { this-\u0026gt;x = x; this-\u0026gt;y = y; this-\u0026gt;value = value; } bool operator \u0026lt;(Edge \u0026amp;edge) { return this-\u0026gt;value \u0026lt; edge.value; } }; int getParent(int parent[], int x) { if (parent[x] == x) return x; return getParent(parent, parent[x]); } void unionParent(int parent[], int x, int y) { x = getParent(parent, x); y = getParent(parent, y); if (x \u0026gt; y) parent[x] = y; else parent[y] = x; } bool findParent(int parent[], int x, int y) { x = getParent(parent, x); y = getParent(parent, y); if (x == y) return true; return false; } int dist[100002]; vector\u0026lt;Planet\u0026gt; planet; vector\u0026lt;Edge\u0026gt; edge; int main() { int N; int x, y, z; int sum = 0; cin \u0026gt;\u0026gt; N; for (int i = 0; i \u0026lt; N; i++) { cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; z; planet.push_back(Planet(x, y, z, i)); } for (int i = 0; i \u0026lt;= N; i++) { dist[i] = i; } sort(planet.begin(), planet.end(), cmpX); for (int i = 0; i \u0026lt; N - 1; i++) { edge.push_back(Edge(planet[i].index, planet[i + 1].index, abs(planet[i].node[0] - planet[i + 1].node[0]))); } sort(planet.begin(), planet.end(), cmpY); for (int i = 0; i \u0026lt; N - 1; i++) { edge.push_back(Edge(planet[i].index, planet[i + 1].index, abs(planet[i].node[1] - planet[i + 1].node[1]))); } sort(planet.begin(), planet.end(), cmpZ); for (int i = 0; i \u0026lt; N - 1; i++) { edge.push_back(Edge(planet[i].index, planet[i + 1].index, abs(planet[i].node[2] - planet[i + 1].node[2]))); } sort(edge.begin(), edge.end()); for (int i = 0; i \u0026lt; edge.size(); i++) { if (!(findParent(dist, edge[i].x, edge[i].y))) { sum += edge[i].value; unionParent(dist, edge[i].x, edge[i].y); } } cout \u0026lt;\u0026lt; sum; }  추가적인 질문사항 있으시면 언제든지 댓글 달아주시면 감사하겠습니다😊\n","id":10,"section":"posts","summary":"백준 문제 바로가기 사용 언어 C++ 적용 알고리즘 최소 스패닝 트리 합집합 찾기 문제풀이 일반적으로 난이도가 쉬운 최소 스패닝 트리 문제를 풀 때, 가중치 값 기준으로 정렬 후","tags":["최소 스패닝 트리"],"title":"백준 2887 - 행성터널","uri":"https://chlalstjd430.github.io/2020/01/%EB%B0%B1%EC%A4%802887/","year":"2020"},{"content":"☞ 백준 문제 바로가기[ 1991 - 트리 순회]\n\u0026nbsp;\n\u0026nbsp;\n사용 언어\n- C++\n\u0026nbsp;\n﻿적용 알고리즘\n- 이진 트리 전위/중위/후위 순회 알고리즘\n-\u0026nbsp;관련 동영상 강의 바로가기\n\u0026nbsp;\n\u0026nbsp;\n관련 문제\n- 관련 문제들은 추후에 수정하도록 하겠습니다.\n\u0026nbsp;\n문제 풀이\n- 해당 문제는 이진 트리를 이용하여 순회 알고리즘을 사용하는 문제입니다.\n먼저 다음과 같이 이진 트리 구조를 가진 구조체를 만들어줍니다.\n\n\n12345typedef\u0026nbsp;struct\u0026nbsp;node\u0026nbsp;tree;typedef\u0026nbsp;struct\u0026nbsp;node{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;char\u0026nbsp;data;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;tree\u0026nbsp;left,\u0026nbsp;right;};cs\n이후 전위/중위/후위 함수를 만들어줍니다.\n\n\n123456789101112131415161718192021222324//전위void\u0026nbsp;preorder(tree\u0026nbsp;tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;tr-\u0026gt;data;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;preorder(tr-\u0026gt;left);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;preorder(tr-\u0026gt;right);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}}//중위void\u0026nbsp;inorder(tree\u0026nbsp;tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;inorder(tr-\u0026gt;left);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;tr-\u0026gt;data;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;inorder(tr-\u0026gt;right);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}}//후위void\u0026nbsp;postorder(tree\u0026nbsp;tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;postorder(tr-\u0026gt;left);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;postorder(tr-\u0026gt;right);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;tr-\u0026gt;data;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}}cs\u0026nbsp;\n마지막으로 다음과 같이 데이터를 받고 출력해주면 정상적으로 결과가 나온 것을 확인 하실 수 있습니다.\n\n\n12345678910111213141516171819int\u0026nbsp;main()\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;node\u0026nbsp;nodes[27];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;nodeCnt;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;char\u0026nbsp;a,\u0026nbsp;b,\u0026nbsp;c;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;nodeCnt;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;i\u0026nbsp;\u0026lt;\u0026nbsp;nodeCnt;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;a\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;b\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;c;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1].data\u0026nbsp;=\u0026nbsp;a;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;(b\u0026nbsp;==\u0026nbsp;\u0026rsquo;.\u0026rsquo;)\u0026nbsp;?\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1].left\u0026nbsp;=\u0026nbsp;NULL\u0026nbsp;:\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1].left\u0026nbsp;=\u0026nbsp;\u0026amp;nodes[b\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;(c\u0026nbsp;==\u0026nbsp;\u0026rsquo;.\u0026rsquo;)\u0026nbsp;?\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1].right\u0026nbsp;=\u0026nbsp;NULL\u0026nbsp;:\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1].right\u0026nbsp;=\u0026nbsp;\u0026amp;nodes[c\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;preorder(\u0026amp;nodes[1]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;endl;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;inorder(\u0026amp;nodes[1]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;endl;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;postorder(\u0026amp;nodes[1]);;}Colored by Color Scriptercs\n최종 코드\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include\u0026nbsp;\u0026lt;iostream\u0026gt;\u0026nbsp;using\u0026nbsp;namespace\u0026nbsp;std;\u0026nbsp;typedef\u0026nbsp;struct\u0026nbsp;node\u0026nbsp;tree;typedef\u0026nbsp;struct\u0026nbsp;node{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;char\u0026nbsp;data;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;tree\u0026nbsp;left,\u0026nbsp;right;};\u0026nbsp;//전위void\u0026nbsp;preorder(tree\u0026nbsp;tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;tr-\u0026gt;data;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;preorder(tr-\u0026gt;left);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;preorder(tr-\u0026gt;right);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}}//중위void\u0026nbsp;inorder(tree\u0026nbsp;tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;inorder(tr-\u0026gt;left);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;tr-\u0026gt;data;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;inorder(tr-\u0026gt;right);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}}//후위void\u0026nbsp;postorder(tree\u0026nbsp;tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;postorder(tr-\u0026gt;left);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;postorder(tr-\u0026gt;right);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;tr-\u0026gt;data;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}}\u0026nbsp;int\u0026nbsp;main()\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;node\u0026nbsp;nodes[27];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;nodeCnt;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;char\u0026nbsp;a,\u0026nbsp;b,\u0026nbsp;c;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;nodeCnt;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;i\u0026nbsp;\u0026lt;\u0026nbsp;nodeCnt;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;a\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;b\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;c;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1].data\u0026nbsp;=\u0026nbsp;a;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;(b\u0026nbsp;==\u0026nbsp;\u0026rsquo;.\u0026rsquo;)\u0026nbsp;?\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1].left\u0026nbsp;=\u0026nbsp;NULL\u0026nbsp;:\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1].left\u0026nbsp;=\u0026nbsp;\u0026amp;nodes[b\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;(c\u0026nbsp;==\u0026nbsp;\u0026rsquo;.\u0026rsquo;)\u0026nbsp;?\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1].right\u0026nbsp;=\u0026nbsp;NULL\u0026nbsp;:\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1].right\u0026nbsp;=\u0026nbsp;\u0026amp;nodes[c\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;preorder(\u0026amp;nodes[1]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;endl;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;inorder(\u0026amp;nodes[1]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;endl;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;postorder(\u0026amp;nodes[1]);;}Colored by Color Scriptercs\n\n추가적으로 질문사항이 있으시면 언제든지 댓글을 달아주세요:D\n\n\u0026nbsp;\n","id":11,"section":"posts","summary":"☞ 백준 문제 바로가기[ 1991 - 트리 순회] \u0026nbsp; \u0026nbsp; 사용 언어 - C++ \u0026nbsp; ﻿적용 알고리즘 - 이진 트리 전위/중위/후위 순회 알고리즘 -\u0026nbsp;관련 동영상 강의 바로가기","tags":["이진 트리 알고리즘"],"title":"백준 1991 - 트리 순회","uri":"https://chlalstjd430.github.io/2020/01/%EB%B0%B1%EC%A4%801991/","year":"2020"},{"content":" IT 동아리 정보 1. YAPP  6-7월 / 12-1월  2. NEXTERS  5월 / 11월  3. SOPT  3월 / 9월  4. 프로그라피  2-3월 / 8월  5. Mash-Up  3월 / 8-9월  6. DEPROMEET  2월 / 9월  7. 멋쟁이사자처럼  2월  그 외 IT 활동 1. S/W 마에스트로 2. 우아한 테크코스 3. 우아한 테크캠프 4. 스마일 게이트 서버캠프 5. 42SEOUL 6. SSAFY(삼성 청년 소프트웨어 아카데미) ","id":12,"section":"posts","summary":"IT 동아리 정보 1. YAPP 6-7월 / 12-1월 2. NEXTERS 5월 / 11월 3. SOPT 3월 / 9월 4. 프로그라피 2-3월 / 8월 5. Mash-Up 3월 / 8-9월 6. DEPROMEET 2월 / 9월 7. 멋쟁이사자처럼","tags":["IT 정보","IT 동아리"],"title":"IT 동아리 정보","uri":"https://chlalstjd430.github.io/2020/01/%EC%A0%95%EB%B3%B4_001/","year":"2020"},{"content":" 2020년 학업 계획 1. IT동아리\n- YOURSSU 활동중(19.11.01~ )\n YAPP\n 지원중(1.18 면접)\n 최종 합격(1.22)\n   \n2. S/W 마에스트로\n- 1월 중순~말 서류 접수\n 서류 준비중(1.22~)  \n3. 클린코드 공부\n- 1) 블로그 읽기\n- 2) Clean Code 책 읽기\n- 클린코드 정리중 4. Spring Framework 더 자유롭게 다루기\n- 1) 프로젝트 하면서 필요한 부분 학습\n- 2) 인프런 강의\n5. JPA/DB 공부\n- 1) 프로젝트 하면서 필요한 부분 학습\n- 2) 인프런 강의\n6. 학점 4.0\n- 평균 학점 3.5이상 유지하기\n7. 여름/겨울에 인턴활동\n- S/W마에스트로 활동중이라면 겨울에라도 지원하기\n8. 꾸준한 알고리즘 공부\n- 스터디 활동 (01/01 ~ 02.28 진행중)\n- github 9. 프로젝트 실제 런칭 해보기\n10. 꾸준한 블로그 포스팅\n- 최소 1일 1포스팅\n11. S/W 관련 공모전 나가보기\n12. ACM 도전\n- 교내 입상이라도..\n13. AWS 공부\n14. 교내 멘토 활동 지원해보기\n15. 깃에 1일 1커밋\n16. 삼성 SW 역량 테스트(A형) 취득\n17. TDD로 개발하기!\n","id":13,"section":"posts","summary":"2020년 학업 계획 1. IT동아리 - YOURSSU 활동중(19.11.01~ ) YAPP 지원중(1.18 면접) 최종 합격(1.22) 2. S/W 마에스트로 - 1월 중순~말 서류 접","tags":["계획"],"title":"2020 학업 계획","uri":"https://chlalstjd430.github.io/2020/01/2020%EA%B3%84%ED%9A%8D_001/","year":"2020"},{"content":"Reactive Programing\u0026nbsp;간단 정리!\n\u0026nbsp;\n안녕하세요,\u0026nbsp;이 글에서는 제가\u0026nbsp;Reactive Programing을 처음 접하게 되며 알게된 내용들을 간략하게 설명하고자합니다.\u0026nbsp;개인적인 이해가 담겨져있는 글이므로 정확하지 않은 부분에 대하여 언제든지 피드백 해주시면 감사하겠습니다:D\n\u0026nbsp;\n\u0026nbsp;\n\n\n\n\nReactive Programing이란?\n\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp;\n\n유어슈에 들어오고\u0026nbsp;Reactive Programing을 처음 접하게 되었습니다.\u0026nbsp;이후\u0026nbsp;Reactive Programing의 정의에 대하여 찾아보았고,\u0026nbsp;그중에서 가장 간결하면서 명확한 정의를 소개해드리겠습니다.\u0026nbsp;\n\u0026nbsp;\nReactive programming is programming with asynchronous data streams.\n\n리엑티브 프로그래밍은 비동기적 데이터 흐름을 처리하는 프로그래밍이다.\n\u0026nbsp;\n\u0026nbsp;Reactive Programming에서의 핵심은 모든 것들을 비동기적인 데이터의 흐름으로 간주한다는 것입니다. 다시 말하여 기존에 정해진 절차에 따라 작성한 코드가 실행되는 명령형 프로그래밍과는 다르게 리엑티브 프로그래밍은 데이터의 흐름을 정의하고 데이터가 변경되었을 때 연관되는 함수나 수식이 같이 변경되는 방식입니다.\u0026nbsp; 이것을 사용자의 입장에서 보았을 때\u0026nbsp; 실시간 반응이 이루어진다고 할 수 있습니다. 대표적으로 엑셀을 예로 들어보겠습니다.\n\u0026nbsp;A\n\u0026nbsp;B\n\u0026nbsp;C\n\u0026nbsp;6\n\u0026nbsp;7\n\u0026nbsp;= A1 + B1\n\n이라는 표가 있을 때 우리는 C1의 값으로 13을 기대할 수 있습니다.\n\u0026nbsp;A\n\u0026nbsp;B\n\u0026nbsp;C\n\u0026nbsp;6\n\u0026nbsp;7\n13\n\n실제로 수행 결과 13이 나오는 것을 알 수있습니다. 그렇다면 여기서 A를 10으로 변경하였을 때도 C는 13일까요?\n\n\u0026nbsp;A\n\u0026nbsp;B\n\u0026nbsp;C\n\u0026nbsp;10\n\u0026nbsp;7\n17\n결과는 17입니다. A가 변함에 따라 C의 값이 달라지게 됩니다. 우리는 엑셀을 통해서 데이터의 흐름에 따라 결과값이 다르게 표현되는 것을 확인 하실 수 있습니다.\n\u0026nbsp;\n\u0026nbsp;이러한 Reactive Programming은 함수형 프로그래밍(Functional Programming)을 지원 받습니다. 함수형 프로그래밍은\u0026nbsp; 데이터를 immutable하게 취급하고, 데이터 변경시 원본 데이터는 유지하고 새로운 데이터를 만들어 변경하고, 관점을 데이터가 아닌 Process에 집중하게 됩니다. 그리하여 Side-effect 최소화해 병렬처리에서 큰 장점을 가져오게 됩니다.\n\u0026nbsp;\n\u0026nbsp;\n​\n\n\n\n왜\u0026nbsp;Reactive Programing일까?\n\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;\u0026nbsp;\n\n\u0026nbsp;리엑티브 선언문에 따른\u0026nbsp;4가지 속성은 응답성,탄력성,유연성,메시지 구동으로 이루어져있고 내용은 다음과 같습니다.\n\u0026nbsp;\u0026nbsp;https://www.reactivemanifesto.org/ko\n응답성(Responsive):\u0026nbsp;시스템이 가능한 한 즉각적으로 응답하는 것을 응답성이 있다고 합니다.\u0026nbsp;응답성은 사용자의 편의성과 유용성의 기초가 되지만,\u0026nbsp;그것뿐만 아니라 문제를 신속하게 탐지하고 효과적으로 대처할 수 있는 것을 의미합니다.\u0026nbsp;응답성 있는 시스템은 신속하고 일관성 있는 응답 시간을 제공하고,\u0026nbsp;신뢰할 수 있는 상한선을 설정하여 일관된 서비스 품질을 제공합니다.\u0026nbsp;이러한 일관된 동작은 오류 처리를 단순화하고,\u0026nbsp;일반 사용자에게 신뢰를 조성하고,\u0026nbsp;새로운 상호작용을 촉진합니다.\n\n탄력성(Resilient):\u0026nbsp;시스템이\u0026nbsp;장애에 직면하더라도 응답성을 유지 하는 것을 탄력성이 있다고 합니다.\u0026nbsp;탄력성은 고가용성 시스템,\u0026nbsp;미션 크리티컬 시스템에만 적용되지 않습니다.\u0026nbsp;탄력성이 없는 시스템은 장애가 발생할 경우 응답성을 잃게 됩니다.\u0026nbsp;탄력성은\u0026nbsp;복제,\u0026nbsp;봉쇄,\u0026nbsp;격리, 위임에 의해 실현됩니다.\u0026nbsp;장애는 각각의\u0026nbsp;구성 요소에 포함되며 구성 요소들은 서로 분리되어 있기 때문에 이는 시스템이 부분적으로 고장이 나더라도,\u0026nbsp;전체 시스템을 위험하게 하지 않고 복구 할 수 있도록 보장합니다.\u0026nbsp;각 구성 요소의 복구 프로세스는 다른(외부의)\u0026nbsp;구성 요소에 위임되며 필요한 경우 복제를 통해 고가용성이 보장됩니다.\u0026nbsp;구성 요소의 클라이언트는 장애를 처리하는데에 압박을 받지 않습니다.\n\n유연성(Elastic):\u0026nbsp;시스템이 작업량이 변화하더라도 응답성을 유지하는 것을 유연성이라고 합니다.\u0026nbsp;리액티브 시스템은 입력 속도의 변화에 따라 이러한 입력에 할당된\u0026nbsp;자원을 증가시키거나 감소키면서 변화에 대응합니다.\u0026nbsp;이것은 시스템에서 경쟁하는 지점이나 중앙 집중적인 병목 현상이 존재하지 않도록 설계하여,\u0026nbsp;구성 요소를 샤딩하거나 복제하여 입력을 분산시키는 것을 의미합니다.\u0026nbsp;리액티브 시스템은 실시간 성능을 측정하는 도구를 제공하여 응답성 있고 예측 가능한 규모 확장 알고리즘을 지원합니다.\u0026nbsp;이 시스템은 하드웨어 상품 및 소프트웨어 플랫폼에 비용 효율이 높은 방식으로\u0026nbsp;유연성을 제공합니다.\n\n메시지 구동(Message Driven):\u0026nbsp;리액티브 시스템은\u0026nbsp;비동기 메시지 전달에 의존하여 구성 요소 사이에서 느슨한 결합,\u0026nbsp;격리,\u0026nbsp;위치 투명성을 보장하는 경계를 형성합니다.\u0026nbsp;이 경계는\u0026nbsp;장애를 메시지로 지정하는 수단을 제공합니다.\u0026nbsp;명시적인 메시지 전달은 시스템에 메시지 큐를 생성하고,\u0026nbsp;모니터링하며 필요시\u0026nbsp;배압을 적용함으로써 유연성을 부여하고,\u0026nbsp;부하 관리와 흐름제어를 가능하게 합니다.\u0026nbsp;위치 투명 메시징을 통신 수단으로 사용하면 단일 호스트든 클러스터를 가로지르든 동일한 구성과 의미를 갖고 장애를 관리할 수 있습니다.\u0026nbsp;논블로킹\u0026nbsp;통신은 수신자가 활성화가 되어 있을 때만\u0026nbsp;자원을 소비할 수 있기 때문에 시스템 부하를 억제할 수 있습니다.\n\u0026nbsp;\n\u0026nbsp;\n이러한 특징들가 더불어\u0026nbsp;과거보다\u0026nbsp;다양한 웹,앱의 UI 이벤트가 존재하는\u0026nbsp;현대에 더 나은 자원 활용과 확장성에 대한 필요성이 증가되고 더 나아가 모든 구현체가 상호운영할 수 있는 표준으로 특정 구현체에 얽매이는 감소가 추구되기 때문에\u0026nbsp;Reactive Programming이 사용됩니다.\u0026nbsp;\n\n\u0026nbsp;\n\n\n\n\n\n\n마무리\n\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;\u0026nbsp;\n\n간략하게\u0026nbsp;Reactive Programming을 알아보았는데,\u0026nbsp;단순히\u0026nbsp;Reactive Programming추종하며 따라가기 보다는 충분히 고민하고 이해하는게 좋을 것 같습니다.\u0026nbsp;이것으로 저의 첫번째 글은 마무리하고 추후에\u0026nbsp;Reactive Streams와 관련된 주제로 다음에 찾아뵙도록 하겠습니다:D\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n참고\n리엑티브 정의\nhttps://gist.github.com/staltz/868e7e9bc2a7b8c1f754#reactive-programming-is-programming-with-asynchronous-data-streams\n리엑티브 선언문\nhttps://www.reactivemanifesto.org/ko\u0026nbsp;\n","id":14,"section":"posts","summary":"Reactive Programing\u0026nbsp;간단 정리! \u0026nbsp; 안녕하세요,\u0026nbsp;이 글에서는 제가\u0026nbsp;Reactive Programing을 처음 접","tags":["리액티브 프로그래밍"],"title":"Reactive Programming이란?","uri":"https://chlalstjd430.github.io/2020/01/%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_001/","year":"2020"},{"content":"☞ 백준 문제 바로가기[ 6497 - 전력난 ]\n\u0026nbsp;\n\u0026nbsp;\n사용 언어\n- C++\n\u0026nbsp;\n﻿적용 알고리즘\n- 크루스칼 알고리즘(Kruscal Algorithm)\n- 합집합 찾기 알고리즘(Union - Find)\n- 최소 스패닝 트리(MST)\n-\u0026nbsp;관련 동영상 강의 바로가기\n\u0026nbsp;\n\u0026nbsp;\n관련 문제\n-\u0026nbsp;1922(네트워크 연결),\u0026nbsp;1647(도시 분할 계획),\u0026nbsp;2887(행성 터널),\u0026nbsp;1197(최소 스패닝 트리)\n- 해당 문제들 풀이내용은 추후에 게시하도록 하겠습니다.\n\u0026nbsp;\n문제 풀이\n- 해당 문제는 크루스칼 알고리즘만 알고있다면 간단하게 풀수있는 MST 문제입니다. 먼저 코드를 보시면 다음과 같습니다.\n\u0026nbsp;\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include\u0026nbsp;\u0026lt;iostream\u0026gt;#include\u0026nbsp;\u0026lt;vector\u0026gt;#include\u0026nbsp;\u0026lt;algorithm\u0026gt;\u0026nbsp;using\u0026nbsp;namespace\u0026nbsp;std;\u0026nbsp;int\u0026nbsp;dist[200002];int\u0026nbsp;m,\u0026nbsp;n;\u0026nbsp;class\u0026nbsp;Edge\u0026nbsp;{public:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;node[2];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;value;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;Edge(int\u0026nbsp;x,\u0026nbsp;int\u0026nbsp;y,\u0026nbsp;int\u0026nbsp;value)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;this-\u0026gt;node[0]\u0026nbsp;=\u0026nbsp;x;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;this-\u0026gt;node[1]\u0026nbsp;=\u0026nbsp;y;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;this-\u0026gt;value\u0026nbsp;=\u0026nbsp;value;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;bool\u0026nbsp;operator\u0026nbsp;\u0026lt;\u0026nbsp;(Edge\u0026nbsp;\u0026amp;edge)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;return\u0026nbsp;this-\u0026gt;value\u0026nbsp;\u0026lt;\u0026nbsp;edge.value;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}};\u0026nbsp;int\u0026nbsp;getParent(int\u0026nbsp;parent[],\u0026nbsp;int\u0026nbsp;num)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(parent[num]\u0026nbsp;==\u0026nbsp;num)\u0026nbsp;return\u0026nbsp;num;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;return\u0026nbsp;parent[num]\u0026nbsp;=\u0026nbsp;getParent(parent,\u0026nbsp;parent[num]);}\u0026nbsp;void\u0026nbsp;unionParent(int\u0026nbsp;parent[],\u0026nbsp;int\u0026nbsp;x,\u0026nbsp;int\u0026nbsp;y)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;x\u0026nbsp;=\u0026nbsp;getParent(parent,\u0026nbsp;x);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;y\u0026nbsp;=\u0026nbsp;getParent(parent,\u0026nbsp;y);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(x\u0026nbsp;\u0026gt;\u0026nbsp;y)parent[x]\u0026nbsp;=\u0026nbsp;y;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;else\u0026nbsp;parent[y]\u0026nbsp;=\u0026nbsp;x;\u0026nbsp;}\u0026nbsp;bool\u0026nbsp;equalParent(int\u0026nbsp;parent[],\u0026nbsp;int\u0026nbsp;x,\u0026nbsp;int\u0026nbsp;y)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;x\u0026nbsp;=\u0026nbsp;getParent(parent,\u0026nbsp;x);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;y\u0026nbsp;=\u0026nbsp;getParent(parent,\u0026nbsp;y);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(x\u0026nbsp;==\u0026nbsp;y)\u0026nbsp;return\u0026nbsp;true;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;return\u0026nbsp;false;}\u0026nbsp;int\u0026nbsp;main()\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;vector\u0026lt;Edge\u0026gt;\u0026nbsp;map;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;while\u0026nbsp;(true)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;m\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;n;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(m\u0026nbsp;==\u0026nbsp;0\u0026nbsp;\u0026amp;\u0026amp;\u0026nbsp;n\u0026nbsp;==\u0026nbsp;0)\u0026nbsp;break;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;i\u0026nbsp;\u0026lt;=\u0026nbsp;m;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dist[i]\u0026nbsp;=\u0026nbsp;i;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;x\u0026nbsp;=\u0026nbsp;0,\u0026nbsp;y\u0026nbsp;=\u0026nbsp;0,\u0026nbsp;z\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;i\u0026nbsp;\u0026lt;\u0026nbsp;n;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;x\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;y\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;z;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;map.push_back(Edge(x,\u0026nbsp;y,\u0026nbsp;z));\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;sort(map.begin(),\u0026nbsp;map.end());\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;size\u0026nbsp;=\u0026nbsp;map.size();\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;sum\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;i\u0026nbsp;\u0026lt;\u0026nbsp;size;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;sum\u0026nbsp;+=\u0026nbsp;map[i].value;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;i\u0026nbsp;\u0026lt;\u0026nbsp;size;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(!equalParent(dist,\u0026nbsp;map[i].node[0],\u0026nbsp;map[i].node[1]))\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;unionParent(dist,\u0026nbsp;map[i].node[0],\u0026nbsp;map[i].node[1]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;sum\u0026nbsp;-=\u0026nbsp;map[i].value;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;sum\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;endl;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;map.clear(); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}}\n\n\u0026nbsp;\n\n\u0026nbsp;기본적인 크루스칼 알고리즘을 적용해 구하는 MST 구조와 같습니다. 다만 문제를 풀 때 주의하실 점은 문제 요구사항입니다.\n처음에 문제를 풀었을 때, 요구사항 중\u0026nbsp;\n\u0026nbsp;\n출력각 테스트 케이스마다 한 줄에 걸쳐 절약할 수 있는 최대 비용을 출력한다.\n\u0026nbsp;\n라는 내용을 인지하지 못하여서 최소 비용 값이 왜 다르지하고 한동안 코드를 다시 분석하는 행위를 반복하였습니다.\u0026nbsp;\n\u0026nbsp;\n추가적으로\n입력입력은 여러 개의 테스트 케이스로 구분되어 있다.\n각 테스트 케이스의 첫째 줄에는 집의 수 m과 길의 수 n이 주어진다. (1 ≤ m ≤ 200000,\u0026nbsp;m-1 ≤ n ≤ 200000)\n이어서 n개의 줄에 각 길에 대한 정보 x, y, z가 주어지는데, 이는 x번 집과 y번 집 사이에 양방향 도로가 있으며 그 거리가 z미터라는 뜻이다. (0 ≤ x, y \u0026lt; m,\u0026nbsp;x ≠ y)\n도시는 항상 연결 그래프의 형태이고(즉, 어떤 두 집을 골라도 서로 왕래할 수 있는 경로가 있다), 도시상의 모든 길의 거리 합은 231미터보다 작다.\n입력의 끝에서는 첫 줄에 0이 2개 주어진다.\n\u0026nbsp;\n라는 입력 조건에서 첫번째 줄과 마지막 줄 또한 무시하고 문제를 제출하였다가 틀렸습니다.\n\u0026nbsp;\n\u0026nbsp;\n그외에는 별다른 어려움은 없었던 것 같습니다! 코드에 대한 지적이나 풀이에 대한 질문은 댓글로 남겨주시면 확인 후 답장 메일이나 댓글을 달아드리겠습니다:D\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n","id":15,"section":"posts","summary":"☞ 백준 문제 바로가기[ 6497 - 전력난 ] \u0026nbsp; \u0026nbsp; 사용 언어 - C++ \u0026nbsp; ﻿적용 알고리즘 - 크루스칼 알고리즘(Kruscal Algorithm) - 합집합 찾기 알고리즘(Union - Find) - 최","tags":["크루스칼 알고리즘"],"title":"백준6497 - 전력난","uri":"https://chlalstjd430.github.io/2020/01/%EB%B0%B1%EC%A4%806497/","year":"2020"}],"tags":[{"title":"IT 동아리","uri":"https://chlalstjd430.github.io/tags/it-%EB%8F%99%EC%95%84%EB%A6%AC/"},{"title":"IT 정보","uri":"https://chlalstjd430.github.io/tags/it-%EC%A0%95%EB%B3%B4/"},{"title":"계획","uri":"https://chlalstjd430.github.io/tags/%EA%B3%84%ED%9A%8D/"},{"title":"다이나믹 프로그래밍","uri":"https://chlalstjd430.github.io/tags/%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"},{"title":"다익스트라 알고리즘","uri":"https://chlalstjd430.github.io/tags/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"title":"리액티브 프로그래밍","uri":"https://chlalstjd430.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"},{"title":"위상 정렬 알고리즘","uri":"https://chlalstjd430.github.io/tags/%EC%9C%84%EC%83%81-%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"title":"이진 트리 알고리즘","uri":"https://chlalstjd430.github.io/tags/%EC%9D%B4%EC%A7%84-%ED%8A%B8%EB%A6%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"title":"최소 스패닝 트리","uri":"https://chlalstjd430.github.io/tags/%EC%B5%9C%EC%86%8C-%EC%8A%A4%ED%8C%A8%EB%8B%9D-%ED%8A%B8%EB%A6%AC/"},{"title":"크루스칼 알고리즘","uri":"https://chlalstjd430.github.io/tags/%ED%81%AC%EB%A3%A8%EC%8A%A4%EC%B9%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"title":"클린코드","uri":"https://chlalstjd430.github.io/tags/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C/"}]}