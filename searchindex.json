{"categories":[{"title":"2020 계획","uri":"https://chlalstjd430.github.io/categories/2020-%EA%B3%84%ED%9A%8D/"},{"title":"AWS","uri":"https://chlalstjd430.github.io/categories/aws/"},{"title":"IT 정보","uri":"https://chlalstjd430.github.io/categories/it-%EC%A0%95%EB%B3%B4/"},{"title":"디자인패턴","uri":"https://chlalstjd430.github.io/categories/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/"},{"title":"리액티브 프로그래밍","uri":"https://chlalstjd430.github.io/categories/%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"},{"title":"백엔드","uri":"https://chlalstjd430.github.io/categories/%EB%B0%B1%EC%97%94%EB%93%9C/"},{"title":"백준 문제풀이","uri":"https://chlalstjd430.github.io/categories/%EB%B0%B1%EC%A4%80-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/"},{"title":"스터디","uri":"https://chlalstjd430.github.io/categories/%EC%8A%A4%ED%84%B0%EB%94%94/"},{"title":"알고리즘","uri":"https://chlalstjd430.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"title":"클린코드","uri":"https://chlalstjd430.github.io/categories/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C/"},{"title":"프로그래머스 문제풀이","uri":"https://chlalstjd430.github.io/categories/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4/"}],"posts":[{"content":" Sigleton pattern(싱글톤 패턴) 이번에 학습할 디자인 패턴은 싱글톤 패턴 입니다.\nSigleton pattern(싱글톤 패턴)이란? 위키에서는 다음과 같이 정의합니다.\n 싱글턴 패턴(Singleton pattern)을 따르는 클래스는, 생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나이고 최초 생성 이후에 호출된 생성자는 최초의 생성자가 생성한 객체를 리턴한다. 이와 같은 디자인 유형을 싱글턴 패턴이라고 한다. 주로 공통된 객체를 여러개 생성해서 사용하는 DBCP(DataBase Connection Pool)와 같은 상황에서 많이 사용된다.\n Sigleton pattern(싱글톤 패턴) 구현 방법? 싱글톤을 구현하는 방법에는 Eager Initialization, Static Block Initialization, Lazy Initialization, Thread Safe Singleton, Bill Pugh Singleton Implementaion, Enum Singleton 등 다양한 방법이 있습니다. 이중 가장 널리 쓰이는 Bill Pugh Singleton Implementaion 으로 구현하는 방법을 소개해드리도록 하겠습니다.\npublic class Singleton { private Singleton(){} private static class SingletonHelper{ private static final Singleton INSTANCE = new Singleton(); } public static Singleton getInstance(){ return SingletonHelper.INSTANCE; } }  해당 코드는 synchronized를 사용하지 않기 때문에 성능 저하와 멀티 스레드의 환경에서 모두 유용하여 널리 쓰입니다.\n간략하게 싱글톤 패턴에 대해 소개해드렸는데, 싱글톤 패턴의 경우 무작정 사용하기보다는 정말 필요한 상황에서만 사용해야 메모리 관리면에서도 효율적으로 관리할 수 있습니다. 이점 참고하셔서 효율적인 코드 작성하셨으면 좋겠습니다. 감사합니다.\n\n출처\n [생성 패턴] 싱글톤(Singleton) 패턴을 구현하는 6가지 방법  ","id":0,"section":"posts","summary":"Sigleton pattern(싱글톤 패턴) 이번에 학습할 디자인 패턴은 싱글톤 패턴 입니다. Sigleton pattern(싱글톤 패턴)이란? 위키에서는 다음과 같이 정의합니다.","tags":null,"title":"[DesignPattern] Sigleton pattern(싱글톤 패턴)","uri":"https://chlalstjd430.github.io/2020/06/06_sigleton_pattern/","year":"2020"},{"content":" Strategy pattern(전략 패턴) 이번에 학습할 디자인 패턴은 전략 패턴 입니다.\nStrategy pattern(전략 패턴)이란? 위키에서는 다음과 같이 정의합니다.\n 전략 패턴(strategy pattern) 또는 정책 패턴(policy pattern)은 실행 중에 알고리즘을 선택할 수 있게 하는 행위 소프트웨어 디자인 패턴이다.\n 예제를 보고 이해해봅시다.\n예제 - 로봇 만들기 우리는 공격과 이동 기능이 있는 TaekwonV, Atom 로봇을 만든다고 가정하자, 그렇다면 다음과 같은 클래스 구조를 생각할 수 있다.\n해당 클래스를 보며 다음과 같은 문제에 대해 생각해보자.\n 새로운 로봇을 만들어 기존의 공격 또는 이동 방법을 추가하거나 수정하려면 어떻게 할까? 예를 들어 새로웃 로봇(선가드)를 만들어 태권V의 미사일 공격 기능을 추가하려면?\n 기존 로봇의 공격 또는 이동 방법을 수정하려면 어떤 변경 작업을 해야하는가?\n  먼저 기존의 클래스 구조를 따라서 새로운 로븟을 만들려면\n다음과 같은 클래스를 추가하면 된다. 그러나 로봇이 추가될 때 마다 attack과 move 메소드를 수정해주어야 하고, 로봇들이 같은 기능을 할 경우 코드의 중복이 많이 생길 것이다.\n이에 우리는 전략 패턴을 이용해보자.\n예제 - 로봇 만들기(전략 패턴 이용)  Robot의 멤버로 MovingStrategy와 AttackStrategy가 멤버 변수가 사진에서 누락되었습니다.  기존의 클래스 구조와 비교를 하면 MovingStrategy, AttackStrategy와 같은 인터페이스를 만들고, 해당 클래스들을의 구체 클래스를 만드는 것을 확인하실 수 있습니다. 이후 Robot클래세 setter을 이용하여 move와 attack의 동작을 달리 할 수 있게 하였습니다.\n이를 통해 추후 각 로봇들이 추가됨에 따라 반복되는 기능은 쉽게 구현할 수 있고, 기능들을 동적으로 변경할 수 있게 되었습니다.\n\n참고 - JAVA 객체지향 디자인 패턴 \n","id":1,"section":"posts","summary":"Strategy pattern(전략 패턴) 이번에 학습할 디자인 패턴은 전략 패턴 입니다. Strategy pattern(전략 패턴)이란? 위키에서는 다음과 같이 정의합니다. 전략 패","tags":null,"title":"[DesignPattern] Strategy pattern(전략 패턴)","uri":"https://chlalstjd430.github.io/2020/06/05_strategy_pattern/","year":"2020"},{"content":" Abstract factory pattern(추상 팩토리 패턴) 이번에 학습할 디자인 패턴은 추상 팩토리 패턴 입니다.\n추상 팩토리 패턴이란? 위키에서는 다음과 같이 정의합니다.\n 추상 팩토리 패턴(Abstract factory pattern)은 다양한 구성 요소 별로 \u0026lsquo;객체의 집합\u0026rsquo;을 생성해야 할 때 유용하다. 이 패턴을 사용하여 상황에 알맞은 객체를 생성할 수 있다.\n 문장으로 이해하는 것보다 정확한 예제로 이해해봅시다!\n엘리베이터 부품 업체 변경하기 다음은 LG와 현대 업체의 모터와 문을 지원하는 클래스들의 다이어그램입니다.\nMotor, Door Class의 핵심 메소드는 다음과 같습니다.\nclass Motor{ public void move(Direction direction){ // 1) 이미 이동 중이면 무시한다. // 2) 만약 문이 열려 있으면 문을 닫는다. // 3) 모터를 구동해서 이동시킨다. // 4) 모터의 상태를 이동중으로 설정한다. } } class Door{ public void open(){ // 1) 이미 문이 열려있으면 무시한다. // 2) 문을 연다 -\u0026gt; 이 부분만 LG, 현대에서 달라짐 // 3) 문의 상태를 닫힘으로 설정한다. }  이를 유념하고, 위의 클래스다이어그램이 구현된 코드들을 살펴 봅시다.\nenum DoorStatus { CLOSED, OPENED } abstract class Door { private DoorStatus doorStatus; public Door() { this.doorStatus = DoorStatus.CLOSED; } public DoorStatus getDoorStatus() { return doorStatus; } public void close() { if(doorStatus == DoorStatus.CLOSED) return; doorStatus = DoorStatus.CLOSED; } protected abstract void doClose(); public void open() { if(doorStatus == DoorStatus.OPENED) return; doorStatus = DoorStatus.OPENED; } protected abstract void doOpen(); } class LGDoor extends Door{ @Override protected void doClose() { System.out.println(\u0026quot;close LG Door\u0026quot;); } @Override protected void doOpen() { System.out.println(\u0026quot;open LG Door\u0026quot;); } } class HyundaiDoor extends Door{ @Override protected void doClose() { System.out.println(\u0026quot;close Hyundai Door\u0026quot;); } @Override protected void doOpen() { System.out.println(\u0026quot;open Hyundai Door\u0026quot;); } }  먼저 Door와 관련된 클래스들은 템플릿 메소드 패턴이 적용된 것을 확인하실 수 있습니다.\n이후 모터와 도어 클래스에 팩토리 메서드를 적용해보겠습니다.\nenum Direction { UP, DOWN } enum VendorID { LG, HYUNDAI } class MotorFactory{ public static Motor createMotor(VendorID vendorID){ Motor motor = null; switch (vendorID){ case LG: motor = new LGMotor(); break; case HYUNDAI: motor = new HyundaiMotor(); break; } return motor; } } class DoorFactory{ public static Door createDoor(VendorID vendorID){ Door door = null; switch (vendorID){ case HYUNDAI: door = new HyundaiDoor(); break; case LG: door = new LGDoor(); break; } return door; } } enum MotorStatus { MOVING, STOPPED } abstract class Motor { private MotorStatus motorStatus; private Door door; public Motor(){ motorStatus = MotorStatus.STOPPED; } public MotorStatus getMotorStatus(){ return this.motorStatus; } public void setMotorStatus(MotorStatus motorStatus){ this.motorStatus = motorStatus; } public void move(Direction direction){ MotorStatus motorStatus = getMotorStatus(); if(motorStatus == motorStatus.MOVING){ return; } door.close(); moveMotor(direction); setMotorStatus(MotorStatus.MOVING); } protected abstract void moveMotor(Direction direction); public void stop(){ motorStatus = MotorStatus.STOPPED; } public void setDoor(Door door){ this.door = door; } } class LGMotor extends Motor{ @Override protected void moveMotor(Direction direction) { System.out.println(\u0026quot;move LG Motor \u0026quot; + direction); } } class HyundaiMotor extends Motor{ @Override protected void moveMotor(Direction direction) { System.out.println(\u0026quot;move Hyundai Motor\u0026quot; + direction); } } public class Client { public static void main(String[] args) { Door lgDoor = DoorFactory.createDoor(VendorID.LG); Motor lgMotor = MotorFactory.createMotor(VendorID.LG); lgMotor.setDoor(lgDoor); lgDoor.open(); lgMotor.move(Direction.UP); } }  이전에 배웠던 패턴들을 이용해보았는데, 이를 통해 부품의 교체가 수월해 보입니다. 그러나 현재는 Door와 Motor의 부품만 필요로하는데, 그 외 여러가지 부품들이 필요한 경우 에는 어떻게 대응해야 할까요?\n예를 들어 총 8개의 부품이 추가된다면, 다음과 같이 8개의 Factory Class들을 만들어야 할 것입니다.\n이렇게 되면 부품이 생길 때마다 팩토리 클래스를 만들어야 해서 코드의 복잡도는 더 커질 것입니다. 이에 해결책으로 다음과 같은 방법을 정의하였습니다.\n위 다이어그램은 부품이 아니라 제조업체 별로 팩토리를 정의하였습니다.\n이를 소스코드로 보면 다음과 같습니다.\nabstract class ElevatorFactory{ public abstract Motor createMotor(); public abstract Door createDoor(); } class LGElevatorFactory extends ElevatorFactory{ @Override public Motor createMotor() { return new LGMotor(); } @Override public Door createDoor() { return new LGDoor(); } } class HyundaiElevatorFactory extends ElevatorFactory{ @Override public Motor createMotor() { return new HyundaiMotor(); } @Override public Door createDoor() { return new HyundaiDoor(); } } public class Client { public static void main(String[] args) { ElevatorFactory elevatorFactory = new LGElevatorFactory(); Door door = elevatorFactory.createDoor(); Motor motor = elevatorFactory.createMotor(); motor.setDoor(door); door.open(); motor.move(Direction.UP); } }  부품별로 팩토리를 만드는 것이 아닌 제조사별로 팩토리 클래스를만들어 비교적 간겨한 코드가 작성되었습니다.\n추가적으로 삼성 엘리베이터가 다음과 같이 추가된다면 어떻게할까요?\n이는 다른 코드와 마찬가지로 다음과 같이 코드를 작성할 것입니다.\nclass SamsungElevatorFactory extends ElevatorFactory{ @Override public Motor createMotor() { return new SamsungMotor(); } @Override public Door createDoor() { return new SamsungDoor(); } } class SamsungDoor extends Door{ @Override protected void doClose() { System.out.println(\u0026quot;close Samsung Door\u0026quot;); } @Override protected void doOpen() { System.out.println(\u0026quot;open Samsung Door\u0026quot;); } } class SamsungMotor extends Motor{ @Override protected void moveMotor(Direction direction) { System.out.println(\u0026quot;moce Samsung Motor\u0026quot;); } } public class Client { public static void main(String[] args) { ElevatorFactory elevatorFactory = new SamsungElevatorFactory(); Door door = elevatorFactory.createDoor(); Motor motor = elevatorFactory.createMotor(); motor.setDoor(door); door.open(); motor.move(Direction.UP); } }  손 쉽게 다른 제조업체의 엘리베이터도 추가할 수 있습니다! 그러면 이제 이제까지 배웠던 디자인 패턴들을 적용하여 더 코드를 효율적이게 만들지 생각해보면 더 좋은 학습니다. 예를들어, Factory 클래스를 생성하는 부분을 팩토리 메소드 패턴을 적용하여 설계하자. 그리고 제조업체 별 팩토리는 1개만 필요하다면, 싱글톤 패턴을 적용해보면 보다 더 간결하고 명확한 다이어그램이 그려질 겁니다. 해당 코드는 오늘 다루지않겠지만 모두 시간이되면 고민해보고 적용해보시면 좋을 것 같습니다!\n\n참고 - JAVA 객체지향 디자인 패턴 \n","id":2,"section":"posts","summary":"Abstract factory pattern(추상 팩토리 패턴) 이번에 학습할 디자인 패턴은 추상 팩토리 패턴 입니다. 추상 팩토리 패턴이란? 위키에서는 다음과 같이 정의합니다. 추상 팩","tags":null,"title":"[DesignPattern] Abstract factory pattern(추상 팩토리 패턴)","uri":"https://chlalstjd430.github.io/2020/06/04_abstact_factory_pattern/","year":"2020"},{"content":" RESTful API를 설계할 때 내가 만난 대부분은 주로 \u0026ldquo;수정\u0026rdquo; 기능에 대헤 PUT 을 사용하게 됩니다. 그러나 수정할 때 무조건 PUT 을 이용하는 것을 옳지 못한 방법입니다. 수정할 때는 PUT 말고 PATCH 가 있는데, 오늘 이 둘의 차이점을 간략하게 소개하고자 합니다.\nPUT  자원의 전체 수정, 자원내 모든 필드가 필요하다.\n PATCH  자원의 일부분 수정, 자원내 일부 필드가 필요하다.\n 예를 들어, 다음과 같은 User 정보가 있다고 가정해봅시다.\n{ name : \u0026quot;test_name\u0026quot; nickname : \u0026quot;test_nickname\u0026quot; email : \u0026quot;test@test.com\u0026quot; }  /users/{userId} URl에 PUT과 PATCH 로 다음과 같이 수정된 값을 요청해보면\n{ \u0026quot;nickname\u0026quot;: \u0026quot;test_nicknmae2\u0026quot; }  먼저 PUT의 경우에는\n{ name : null nickname : \u0026quot;test_nickname2\u0026quot; email : null }  PATCH는\n{ name : \u0026quot;test_name\u0026quot; nickname : \u0026quot;test_nickname2\u0026quot; email : \u0026quot;test@test.com\u0026quot; }  로 보내게됩니다. 위의 상황에서 PUT은 자원의 전체를 보내지않고 일부분만 보내게되면 나머지 데이터가 유실된채 null값이 들어가게 됩니다. 그렇기에 수정할 때 무조건적으로 PUT을 사용하는게 아닌, 적절하게 PUT과 PATCH를 이용하여 사용해야된다는 것을 알 수 있습니다.\n사실 너무 당연한 이야기로 들리시는 분들도 있지만, 의외로 모르시는 분들이 많아 포스팅을 간략하게 작성해보았습니다. 오해가 있을만한 정보가 있거나 궁금한게 있으시면 언제든지 댓글 남겨주세요🙋‍♂️\n","id":3,"section":"posts","summary":"RESTful API를 설계할 때 내가 만난 대부분은 주로 \u0026ldquo;수정\u0026rdquo; 기능에 대헤 PUT 을 사용하게 됩니다. 그러나 수정할 때 무조건 PUT 을 이용하는 것을 옳지","tags":null,"title":"[HTTP Method] PUT과 PATCH의 차이점","uri":"https://chlalstjd430.github.io/2020/06/put_vs_patch/","year":"2020"},{"content":" Factory method pattern(팩토리 메소드 패턴) 이번에 학습할 디자인 패턴은 \u0026ldquo;팩토리 메소드 패턴\u0026rdquo; 입니다.\n팩토리 메소드 메서드 패턴이란? 위키에서는 다음과 같이 설명합니다.\n Factory method는 부모(상위) 클래스에 알려지지 않은 구체 클래스를 생성하는 패턴이며. 자식(하위) 클래스가 어떤 객체를 생성할지를 결정하도록 하는 패턴이기도 하다. 부모(상위) 클래스 코드에 구체 클래스 이름을 감추기 위한 방법으로도 사용한다.\n 이번에도 역시나 예제로 자세히 살펴보도록 합시다.\n\n여러 방식의 엘리베이터 스케줄링 방법 지원하기(일반) 엘리베이터 제어 시스템에서 다양한 엘리베이터 스케줄링을 지원한다고 했을 때, 다음과 같은 구조의 클래스가 있다고 가정해봅시다.\n ElevatorManager Class : 여러 엘리베이터 중에서 스케줄링에 따라서 하나의 엘리베이터를 선택하고 이동시킴\n EleveatorController Class : 하나의 엘리베이터 이동을 제어하는 클래스\n ThroughputScheduler Class : 처리량을 기준으로 스케줄링하는 클래스\n  코드로 표현하면, 다음과 같습니다.\nenum Direction {UP, DOW} class ElevatorManager { private List\u0026lt;ElevatorController\u0026gt; controllers; private ThroughputScheduler scheduler; public ElevatorManager(int controllerCount){ controllers = new ArrayList\u0026lt;ElevatorController\u0026gt;(controllerCount); for(int i = 0; i \u0026lt; controllerCount; i++){ ElevatorController controller = new ElevatorController(i); controllers.add(controller); } scheduler = new ThroughputScheduler(); } public void requestElevator(int destination, Direction direction){ int selectedElevator = scheduler.selectElevator(this, destination, direction); controllers.get(selectedElevator).gotoFloor(destination); } } class ElevatorController { private int id; private int curFloor; public ElevatorController(int id) { this.id = id; curFloor = 1; } public void gotoFloor(int destination){ System.out.println(\u0026quot;Elevator [\u0026quot; + id + \u0026quot;] Floor: \u0026quot; + curFloor); curFloor = destination; System.out.println(\u0026quot; ==\u0026gt; \u0026quot; + curFloor); } } class ThroughputScheduler { public int selectElevator(ElevatorManager manager, int destination, Direction direction){ // 실제 구현하지는 않음 return 0; } } public class Client { public static void main(String[] args) { ElevatorManager em = new ElevatorManager(1); em.requestElevator(4, Direction.UP); } }  먼저 코도를 잘 읽어가며 각 클래스들의 기능들을 자세히 파악해봅시다. 이후 다음과 문제점을 어떻게 해결할지 생각해봅시다.\n 🙋‍♂️문제점\n 현대 ElevatorManager는 ThroughputScheduler를 이용하고 있다. 즉 엘리베이터의 처리량을 최대화시키는 전략을 사용하고 있다. 만약 다른 스케쥴링 전략을 사용해야 한다면? 예를 들어 사용자의 대기시간을 최소화시키는 엘리베이터를 선택하는 전략을 사용해야 한다면?\n 스케쥴링 전략이 프로그램 실행 중에 변경을 해야 한다면? 즉, 동적 스케쥴링을 지원해야 한다면 어떻게 해야할까? 예를 들어 오전에는 대기시간 최소화 전략을 사용하고 오후에는 처리량 최대화 전략을 사용해야 한다면?\n   먼저 기존에 자주 사용하는 패턴으로 \u0026ldquo;Strategy Patter(전략 패턴)\u0026rdquo; 을 생각하기 쉽습니다. 그렇다면 해당 패턴으로 위와 같은 문제를 해결해봅시다!\n\n여러 방식의 엘리베이터 스케줄링 방법 지원하기(Strategy patter 적용) 스트래티지 패턴을 적용하면, 다음과 같이 클래스 구조가 나오게 됩니다.\n위의 다이어그램에서 ElevatorController가 표현되어있지 않지만, ElevatorManager와 연결되어있다고 생각하고 보면 된다.\n해당 구조를 보면 ElevatorSheduler를 구현한 클래스들이 생겨서, 위의 문제점을 해결할 수 있을 것으로 보입니다. 실제 코드를 봐볼까요?\ninterface ElevatorScheduler { public int selectElevator(ElevatorManager manager, int destination, Direction direction); } class ThroughputScheduler implements ElevatorScheduler{ @Override public int selectElevator(ElevatorManager manager, int destination, Direction direction){ // 실제 구현하지는 않음 return 0; } } class ResponseTimeScheduler implements ElevatorScheduler { @Override public int selectElevator(ElevatorManager manager, int destination, Direction direction) { // 실제 구현하지는 않음 return 1; } } enum Direction {UP, DOW} class ElevatorManager { private List\u0026lt;ElevatorController\u0026gt; controllers; public ElevatorManager(int controllerCount){ controllers = new ArrayList\u0026lt;ElevatorController\u0026gt;(controllerCount); for(int i = 0; i \u0026lt; controllerCount; i++){ ElevatorController controller = new ElevatorController(i); controllers.add(controller); } } public void requestElevator(int destination, Direction direction){ ElevatorScheduler scheduler; int hour = Calendar.getInstance().get(Calendar.HOUR_OF_DAY); if(hour \u0026lt; 12) { scheduler = new ResponseTimeScheduler(); } else{ scheduler = new ThroughputScheduler(); } int selectedElevator = scheduler.selectElevator(this, destination, direction); controllers.get(selectedElevator).gotoFloor(destination); } }  확실히 이전 문제점을 해결한 것 같습니다. 그러나 ElevatorManager의 requestElevator method를 자세히 살펴보도록 하겠습니다. requestElevator()는 이미 선택된 전략을가지고 엘리베이터를 이동시키는 것이 해당 메소드의 책임입니다. 그런데 현재 코드에서는 전략까지 해당 메소드에서 선택하기 때문에 함수 설계 원칙에 어긋나게 됩니다.\nint hour = Calendar.getInstance().get(Calendar.HOUR_OF_DAY); if(hour \u0026lt; 12) { scheduler = new ResponseTimeScheduler(); } else{ scheduler = new ThroughputScheduler(); }  위의 코드는 requestElevator에 있으면 옳은 방법은 아닙니다. 예를들어 현재 오전/오후에 나누어져 스케쥴러를 다르게 하지만, 특별한 공휴일, 평일, 주말마다 다르게 구현하기 위해서는 현재의 코드로는 표현하기 무리가 있어 보입니다. 그렇기에 전략을 선택하는 기능 을 분리하는게 좋아보입니다.\n\n여러 방식의 엘리베이터 스케줄링 방법 지원하기(Factory method pattern 적용) 팩토리 메소드 패턴을 이용하여 스케줄링 전략에 맞는 객체를 생성하는 코드를 별도로 정의하여봅시다. 그러면 다음과 같은 구조가 나오게 됩니다.\n기존의 클래스들에 SchedulerFactory가 추가된 것을 확인하실 수 있습니다. 해당 클래스에서는 전략들을 생성하는 알고리즘에 의해서 만들어진 Schedular를 반환하게끔 합니다. 즉, 스케줄러를 선택하는 행위는 SchedulerFactory가 하게 됩니다.\n이를 실제 코드로 살펴보도록 하겠습니다!\nenum Direction {UP, DOWN} class ElevatorManager { private List\u0026lt;ElevatorController\u0026gt; controllers; private SchedulingStrategyID strategyID; public ElevatorManager(int controllerCount, SchedulingStrategyID strategyID){ controllers = new ArrayList\u0026lt;ElevatorController\u0026gt;(controllerCount); for(int i = 0; i \u0026lt; controllerCount; i++){ ElevatorController controller = new ElevatorController(i); controllers.add(controller); } this.strategyID = strategyID; } public void setStrategyID(SchedulingStrategyID strategyID){ this.strategyID = strategyID; } public void requestElevator(int destination, Direction direction){ ElevatorScheduler scheduler = SchedulerFactory.getScheduler(strategyID); System.out.println(scheduler); int selectedElevator = scheduler.selectElevator(this, destination, direction); controllers.get(selectedElevator).gotoFloor(destination); } } class ElevatorController { private int id; private int curFloor; public ElevatorController(int id) { this.id = id; curFloor = 1; } public void gotoFloor(int destination){ System.out.println(\u0026quot;Elevator [\u0026quot; + id + \u0026quot;] Floor: \u0026quot; + curFloor); curFloor = destination; System.out.println(\u0026quot; ==\u0026gt; \u0026quot; + curFloor); } } enum SchedulingStrategyID {RESPONSE_TIME, THROUGHPUT, DYNAMIC} class SchedulerFactory { public static ElevatorScheduler getScheduler(SchedulingStrategyID strategyID){ ElevatorScheduler scheduler = null; switch (strategyID) { case RESPONSE_TIME: scheduler = new ResponseTimeScheduler(); break; case THROUGHPUT: scheduler = new ThroughputScheduler(); break; case DYNAMIC: { int hour = Calendar.getInstance().get(Calendar.HOUR_OF_DAY); if(hour \u0026lt; 12) { scheduler = new ResponseTimeScheduler(); } else{ scheduler = new ThroughputScheduler(); } break; } } return scheduler; } } interface ElevatorScheduler { public int selectElevator(ElevatorManager manager, int destination, Direction direction); } class ThroughputScheduler implements ElevatorScheduler{ @Override public int selectElevator(ElevatorManager manager, int destination, Direction direction){ // 실제 구현하지는 않음 return 0; } } class ResponseTimeScheduler implements ElevatorScheduler { @Override public int selectElevator(ElevatorManager manager, int destination, Direction direction) { // 실제 구현하지는 않음 return 1; } } public class Client { public static void main(String[] args) { ElevatorManager emWithResponseTimerScheduler = new ElevatorManager(2, SchedulingStrategyID.RESPONSE_TIME); emWithResponseTimerScheduler.requestElevator(10, Direction.UP); ElevatorManager emWithThroughputScheduler = new ElevatorManager(2, SchedulingStrategyID.RESPONSE_TIME); emWithThroughputScheduler.requestElevator(10, Direction.UP); ElevatorManager emWithDynamicScheduler = new ElevatorManager(2, SchedulingStrategyID.RESPONSE_TIME); emWithDynamicScheduler.requestElevator(10, Direction.UP); } }  SchedulerFactory Class를 보면 확실히 이전과 다르게 스케줄러를 선택하는 책임이 분리가 되는 것을 확인하실 수 있습니다.\n추가적으로 스케줄러는 지속적으로 사용되기 때문에 각각의 스케줄러를 싱글톤 패턴까지 적용하면 더 성능적으로 효율적인 구조가 될 수 있습니다. 그러나 오늘 이 시간에서는 팩토리 메소드 패턴을 설명하기 위한 시간이기 때문에, 생략하고 이 부분은 스스로 고민하시고 적용해보시면 좋을 것 같습니다:D\n더불어 팩토리 메소드 패턴은 상속을 이용하여 구현을 할 수도 있는데 간단하게만 설명하도록 하겠습니다.\n디자인 패턴을 구현하는데 절대적인 방법은 없습니다. 디자인 패턴은 다양한 방법으로 적용할 수 있기에 예제에 나온 방법만 생각하시지마시고 원론적인 부분을 이해하여 필요할 때 실제 프로젝트에 적용하며 학습하시면 좋을 것 같습니다.\n\n결과적으로 위의 과정을 통해서 Factory method pattern을 이용하면 객체의 생성 코드를 별도의 클래스/메소드로 분리함으로써 객체 생성의 변화를 대비하는데 굉장히 유용한 것을 알 수 있었습니다.\n\n참고 - JAVA 객체지향 디자인 패턴 \n","id":4,"section":"posts","summary":"Factory method pattern(팩토리 메소드 패턴) 이번에 학습할 디자인 패턴은 \u0026ldquo;팩토리 메소드 패턴\u0026rdquo; 입니다. 팩토리 메소드 메서드 패턴이란","tags":null,"title":"[DesignPattern] Factory method pattern(팩토리 메소드 패턴)","uri":"https://chlalstjd430.github.io/2020/06/03_factory_method_pattern/","year":"2020"},{"content":" Template Method Pattern(템플릿 메소드 패턴) 이번에 학습할 디자인 패턴은 \u0026ldquo;템플릿 메소드 패턴\u0026rdquo; 입니다.\n템플릿 메서드 패턴이란?  알고리즘의 구조를 변경하지 않고 알고리즘의 특정 단계들을 다시 정의할 수 있게 해준다.\n 위의 내용은 위키에 나온 정의입니다. 해당 문장을 다시 표현하자면 \u0026ldquo;구현시 달라질 수 있는 메소드들을 구현클래스에서 선언 후 호출\u0026rdquo;하는 디자인 패턴입니다.\n백문이 불여일견, 같이 예제를 가지고 살펴보도록 합시다.\n엘레베이터 제어 시스템에서 모터를 구동시키는 기능(일반 ver) 엘레베이터 제어 시스템에서 도터를 구동시킬 떄 여러 회사의 모터를 지원하기 위해서는 어떻게 할까?\n\n먼저 다음과 같은 구조의 클래스가 있다고 생각해봅시다.\n HyundiaMotor Class : 모터를 제어하여 엘리베이터를 이동시키는 클래스가 Door Class : 문을 열거나 다는 기능을 제공하는 클래스  이를 코드로 표현하면 다음과 같습니다\nenum DoorStatus { CLOSED, OPENED } enum MotorStatus { MOVING, STOPPED } enum Direction { UP, DOWN } class Door { private DoorStatus doorStatus; public Door() { this.doorStatus = DoorStatus.CLOSED; } public DoorStatus getDoorStatus() { return doorStatus; } public void close() { doorStatus = DoorStatus.CLOSED; } public void open() { doorStatus = DoorStatus.OPENED; } } class HyundaiMotor { private Door door; private MotorStatus motorStatus; public HyundaiMotor(Door door) { this.door = door; this.motorStatus = MotorStatus.STOPPED; } private void moveHyundaiMotor(Direction direction){ System.out.println(\u0026quot;Hyundai Motor 구동\u0026quot;); } public MotorStatus getMotorStatus() { return motorStatus; } private void setMotorStatus(MotorStatus motorStatus){ this.motorStatus = motorStatus; } public void move(Direction direction){ MotorStatus motorStatus = getMotorStatus(); if(motorStatus == MotorStatus.MOVING) return; DoorStatus doorStatus = door.getDoorStatus(); if(doorStatus == DoorStatus.OPENED) door.close(); moveHyundaiMotor(direction); setMotorStatus(MotorStatus.MOVING); } }  위와 같은 코드를 가지고 실제 현대모터를 가지고 윗층으로 이동시키는 코드를 작성하면\npublic class Client { public static void main(String[] args) { Door door = new Door(); HyundaiMotor hyundaiMotor = new HyundaiMotor(door); hyundaiMotor.move(Direction.UP); } }  다음과 같이 구현할 수 있습니다.\n지금까지 현대 모터를 가지고 실행되는 엘리베이터를 만들었는데, 어떠한 상황이 생겨서 LG 모터를 사용해야 한다고 생각해봅시다. 어떻게 해야할까요?\n먼저 LG Moter라는 클래스를 다음과 같이 구현할 것입니다.\nclass LGMoter { private Door door; private MotorStatus motorStatus; public LGMoter(Door door) { this.door = door; this.motorStatus = MotorStatus.STOPPED; } private void moveLGMoter(Direction direction){ System.out.println(\u0026quot;LG Motor 구동\u0026quot;); } public MotorStatus getMotorStatus() { return motorStatus; } private void setMotorStatus(MotorStatus motorStatus){ this.motorStatus = motorStatus; } public void move(Direction direction){ MotorStatus motorStatus = getMotorStatus(); if(motorStatus == MotorStatus.MOVING) return; DoorStatus doorStatus = door.getDoorStatus(); if(doorStatus == DoorStatus.OPENED) door.close(); moveLGMoter(direction); setMotorStatus(MotorStatus.MOVING); } }  이렇게 구현하면 LGMoter도 마찬가지로 사용가능하게 될겁니다. 그러나 코드를 보면 MoveLGMoter 메소드말고는 바뀐 부분이 없습니다. 이는 OCP 원칙에 위배됩니다. 그래서 다음과 같이 클래스 구조를 변경할 것입니다.\n이렇게 하면 OCP원칙을 지키며 모터를 상속만해주면 다양한 모터들을 구현할 수 있는 것으로 보입니다. 코드로 구현하면 다음과 같습니다.\nabstract class Motor { protected Door door; private MotorStatus motorStatus; public Motor(Door door) { this.door = door; motorStatus = MotorStatus.STOPPED; } public MotorStatus getMotorStatus() { return motorStatus; } protected void setMotorStatus(MotorStatus motorStatus) { this.motorStatus = motorStatus; } } class HyundaiMotor extends Motor { public HyundaiMotor(Door door) { super(door); } private void moveHyundaiMotor(Direction direction){ System.out.println(\u0026quot;Hyundai Motor 구동\u0026quot;); } public void move(Direction direction){ MotorStatus motorStatus = getMotorStatus(); if(motorStatus == MotorStatus.MOVING) return; DoorStatus doorStatus = door.getDoorStatus(); if(doorStatus == DoorStatus.OPENED) door.close(); moveHyundaiMotor(direction); setMotorStatus(MotorStatus.MOVING); } } class LGMoter extends Motor { public LGMoter(Door door) { super(door); } private void moveLGMoter(Direction direction){ System.out.println(\u0026quot;LG Motor 구동\u0026quot;); } public void move(Direction direction){ MotorStatus motorStatus = getMotorStatus(); if(motorStatus == MotorStatus.MOVING) return; DoorStatus doorStatus = door.getDoorStatus(); if(doorStatus == DoorStatus.OPENED) door.close(); moveLGMoter(direction); setMotorStatus(MotorStatus.MOVING); } }  비교적 깔끔해진 코드를 볼 수있습니다. 그러나 자세히 move 메소드를 살펴보면 현대와 LG 모터 모두 똑같은 코드가 중복되는 부분이 보입니다. 지금 2개의 모터를 예제로 들었지만 이후 10개,100개의 모터와 호환이 되어야한다면 수 많은 코드가 중복되어 해당 로직이 변경된다고 하면 10번, 100번 넘게 코드를 수정해야하는 높은 유지보수 비용이 발생합니다. 그렇다면 어떻게 이를 대처할까요?\n엘레베이터 제어 시스템에서 모터를 구동시키는 기능(템플릿 메소드 패턴 적용 ver) 이러한 상황에서 템플릿 메소드 패턴을 활용하는 것을 살펴보도록 하겠습니다. 패턴을 적용하면 다음과 같은 구조가 나오게 됩니다.\n얼핏 보면 크게 달라진게 없어보이지만, Motor 추상 클래스에 move와 moveMotor 메소드가 추가된것을 확인하실 수 있습니다. 이를 코드를 통해 자세히 확인해봅시다.\nabstract class Motor { private Door door; private MotorStatus motorStatus; public Motor(Door door) { this.door = door; motorStatus = MotorStatus.STOPPED; } public MotorStatus getMotorStatus() { return motorStatus; } private void setMotorStatus(MotorStatus motorStatus) { this.motorStatus = motorStatus; } public void move(Direction direction){ MotorStatus motorStatus = getMotorStatus(); if(motorStatus == MotorStatus.MOVING) return; DoorStatus doorStatus = door.getDoorStatus(); if(doorStatus == DoorStatus.OPENED) door.close(); moveMotor(direction); setMotorStatus(MotorStatus.MOVING); } protected abstract void moveMotor(Direction direction); } class HyundaiMotor extends Motor { public HyundaiMotor(Door door) { super(door); } public void moveMotor(Direction direction){ System.out.println(\u0026quot;Hyundai Motor 구동\u0026quot;); } } class LGMotor extends Motor { public LGMotor(Door door) { super(door); } public void moveMotor(Direction direction){ System.out.println(\u0026quot;LG Motor 구동\u0026quot;); } }  Motor 추상 클래스에 move메소드를 구현하고 moveMotor 추상 메소드를 활용하여 HyudaMotor와 LGMotor가 훨씬 간소해졌습니다. 뿐만 아니라 전체적인 코드량도 감소하였고, move의 로직이 변경될 떄 Motor의 move 메소드만 변경하면되서 유지보스 측면에서도 훨씬 좋아졌습니다.\n위와 같은 상황을 보았을 떄, 템플릿 메소드 패턴을 활용하면 전체적인 알고리즘을 구현하면서 상이한 부분은 하위 클래스에서 구현할 수 있도록 해 주는 디자인 패턴으로서 전체적인 알고리즘의 코드를 재사용하는데 유용하다는 것을 알 수 있었습니다.\n참고 - JAVA 객체지향 디자인 패턴 \n","id":5,"section":"posts","summary":"Template Method Pattern(템플릿 메소드 패턴) 이번에 학습할 디자인 패턴은 \u0026ldquo;템플릿 메소드 패턴\u0026rdquo; 입니다. 템플릿 메서드 패턴이란? 알고","tags":null,"title":"[DesignPattern] Template Method Pattern(템플릿 메소드 패턴)","uri":"https://chlalstjd430.github.io/2020/05/02_templete_method_pattern/","year":"2020"},{"content":" 코디미 상담 후기 - 백엔드 개발자를 꿈꾸는 초보 개발자에 대한 조언 최근 코덕이라는 이사이트를 애용하는데, 해당 사이트에서 코디미 라는 곳을 알게되었습니다. 코디미는 개발자 취업/커리어/이력서 등 다양한 고민을 상담해주는 곳인데, 평소 존경하던 우아한 형제 개발자 이동욱(a.k.a jojoldu)님이 1차적으로 무료로 상담을 해준다고해서 후다닥 신청했습니다.\n\n\n평소 백엔드 개발을 그 동안 진행해오면서 공부해야될 것이 너무 많고 알아야할 것도 많아서 너무 막막했는데, 그래서 고민이 술술(?) 나왔던 것 같습니다. 그렇게 은근한 기대를 하며 하루를 보내던 도중\n\n다음과 같은 메일을 받았고, 이후 동욱님에게 고민한 내용에 대한 답변도 받게되었습니다. 답변 내용은 굉장히 도움이 많이 되었고 저와 같은 초보 개발자분들에게 도움이 될만한 내용들이 충분히 담아져있었습니다. 이에 질문 했던 내용과 답변들을 공유하여 저와 같은 초보 개발자분들에게 도움을 드리고자 글을 작성합니다.\n질문 내용 사실 질문 내용이 엄청 구체적이지는 않은 것 같은데, 그래도 동욱님이 제 질문의 의도를 잘 이해주셔서 다행입니다..ㅎ. 무튼 제가 동욱님에게 질문을 간략하게 정리하면 다음과 같습니다.(정말 간략하게 정리했어요..대충한거 아님..ㅎ)\n 대기업SI 보다는 기술 기반의 서비스 기업에 취업하고 싶습니다. 해당하는 기업에 백엔드 개발자로 취업하기 위해서는 어떠한 준비를 하는게 좋을까요?\n 공부를 하다보면 학생으로서 접하기 힘든 다양한 현업 기술들을 듣게 됩니다. 이러한 부분을 반드시 학습해야하는지? 혹은 현재 공부하던 내용들에 대한 깊은 이해를 점검하는게 좋을지?\n private repository들에 대한 어필을 할 수 있는 방법이 무엇이 있을까요?\n 기업에서 요구하는 신입 백엔드 개발자 능력은 어느 정도인가요?\n  위의 내용과 같이 크게 4가지로 나누어 질문을 드렸습니다.\n질문 답변 동욱님께서는 1,2,4번의 질문들을 묶어서 답변해주셨고, 이후 3번 질문에 대한 답변도 말씀해주셨습니다. 내용은 길지만 핵심만 간략하게 설명드리도록 하겠습니다.\n질문 1,2,4\n 요즘 모든 기업들은 코딩 테스트 를 진행한다. 지금부터 꾸준하게 코딩 테스트 를 준비하는 것을 추천한다.\n 본인만의 학습 방법을 찾아야한다.\n 스프링으로 백엔드 개발 공부를 한다고, 회사에 가서 스프링으로 백엔드를 할 거라는 보장은 없다. 회사에서 \u0026ldquo;전 스프링만 해서 프론트는 하고 싶지 않아요.\u0026rdquo;, \u0026ldquo;전 스프링만 해서 장고는 몰라요.\u0026rdquo; 라는 답변을 하면 그것이 과연 신입으로서 좋은 자세일까?\n 즉, 새로운 무언가를 배울 때, 빠르게 학습할 수 있는 본인만의 학습 방법 을 찾는게 중요하다.\n  1~2개의 기술만 하더라도 이에 대해 깊게 파고자 하는 습관을 들이는게 중요\n 많은 기술을 간단하게 사용하는 것은 전혀 도움이 되지 않는다. 그것보다는 프로젝트를 진행하면서 많은 문제 들을 직면하고 단순히 해결하는 것만이 아니라 \u0026ldquo;왜 발생했는지?\u0026rdquo;, \u0026ldquo;왜 해결됐는지?\u0026rdquo;, \u0026ldquo;이 기술이 어떠한 구조인지?\u0026rdquo; 등을 상세하게 파악하는게 중요하다.  먼저 배운것과 역량은 다르다\n 현업의 기술들을 학생으로서 익힌다하여도 책에 있는 예제, 간단한 듀토리얼 정도를 구현하는 것에 대해 전부일텐데, 누구나 시작하면 도달 할 수 있는 정도의 레벨만 가진 분을 연봉 4천,5천을 주며 뽑아야할 이유가 있는지?  신입 개발자가 당장 실무에서 쓰는 기술을 알아야 채용이 되는 것은 아니라는 예\n 신입기준으로는 당장 쓸 구체적인 응용기술을 아는 것도 당연히 선택을 받는데 도움이 됩니다. 실무자들이 면접을 볼때 같이 나눌수 있는 이야기가 많아지기 때문입니다. 특히 신입이라도 당장 와서 일할수 있는 사람을 찾는 조직에서는 실무기술을 가급적 많이 아는 사람을 선호할듯합니다. 그런데 실무 기술을 써본 경험이 있어도 그 기술에 대해 자세히 설명할수 없다면 오히려 경험 안했다고 이야기하는 것보다 더 부정적인 영향을 미칠수 있습니다. 예를 들면 Java로 DB를 쓰는 개발을 해봤다고했는데 그게 MyBatis를 썼는지 JPA를 썼는지도 모르는 경우입니다. 반면 잠깐 써보고 아직 깊이 모르는 기술이라도 구체적인 이야기를 체계적으로 할 수 있다면 더 긍적적인 요인이 됩니다. 예를 들어 MyBatis를 처음 썼는데 어떤 상황이 어려웠고, 알고보니 MyBatis의 어떤 특성 때문이였고, 이를 어떻게 해결했는지 등에 대한 구체적인 이야기를 하는 사람이면, '이 사람은 쓰는 기술에 대해서 제대로 파악을 하려고 했구나'를 느낄수 있습니다. 그런 사람이면 MyBatis를 당장 안 쓰고 JPA를 쓰는 프로젝트에라도 바로 적응할수 있겠구나 하는 느낌을 줍니다. 신입 개발자를 채용할때는 현재 할 수 있는 일이 얼마나 되는지를 넘어서 앞으로 얼마나 발전가능성이 있는지에 더 중점을 둬야된다고 생각합니다. 면접관 입장에서는 자신이 잘 아는 기술을 단편적으로 물어보는것에 그치지 않고 사람이 가진 학습 능력, 학습 의지 등을 파악해야하는데, 당연히 쉬운 일은 아닙니다. 지원자 입장에서는 성장가능성을 표현할수 있는 방법은 여러가지일 것 같습니다. 위와 같이 실무에서 쓰는 이미 잘 알고 있고, 그걸 학습해온 과정을 잘 설명하는 것도 하나의 방법입니다. 학교에서 한 팀 프로젝트라도 남 다르게 한 면이 있다면 실무기술을 잘 몰라도 충분히 앞으로 성장 가능성을 보여줄수 있다고 생각합니다. 코딩 테스트에서 문제를 센스있게 파악한다던지, 유창하고 거침없이 코딩을 할 수 있는것도 자신을 잘 드러낼수 있는 방법입니다. 글을 쓰다보니 '신입개발자로 지원할 때는 자신이 앞으로 빠른 속도로 발전할수 있다는 가능성을 보여주는 것이 중요한데 실무에서 쓰는 기술을 일부 아는 것은 그 방법 중의 하나이다. 그러나 유일한 방법은 아니다.' 정도로 제 생각은 정리가되네요. 글을 쓰다보니 몇년전의 어느 인턴 지원자의 면접이 기억납니다. Linux 커널에 관심이 많은 학생이였는데, 사실 제가 인턴의 업무로 염두에 두었던 분야는 그쪽은 아니였습니다. 코딩 테스트도 제가 계획한 둔 인턴 과제에서는 쓰지 않을 C++로 하기도했습니다. 당시에 엄격한 기준으로 채점을 하는 시스템을 이용해서 코딩 테스트를 했는데, 그 시스템의 판정으로는 그 학생은 문제를 통과하지 못했습니다. 그렇지만 거의 답에 근접한 방식으로 코딩을 했고, 무엇보다 유창하고 거침없이 코딩을 하는 모습이 인상적이였습니다. 하나의 방법이 잘 안되자 그 다음 생각나는 아이디어를 바로 빠르게 타이핑해나갔습니다. 저는 그 학생을 합격시키고, 연관된 업무가 있을만한 다른 프로젝트 쪽에 추천을 드렸습니다. 인턴을 거쳐서 그 학생은 최종 입사를 했습니다. 그런데 처음 그 신입사원이 했던 분야는 그 학생이 깊게 팠던 Linux 커널등과 관련된 분야는 아니였습니다. Java 웹개발과 JavaScript와 Angular.js로 FE개발까지 했던것으로 알고 있습니다. 그때의 인턴은 몇년이 지나서 Linux 커널에 코드 기여를하고 Deview 2018에 [대형 컨테이너 클러스터에서의 고가용성](https://deview.kr/2018/schedule/268) 라는 발표를 하기도했습니다. 그 발표를 두고 어떤 분들은 DEVIEW 2018의 최고의 발표라고도 말씀을 하셨듯습니다.  백엔드 개발자가 참고할만한 좋은 글 추천\n  질문 3\n 남들에게 공개하지 못하는 코드는 어필할 방법은 없다. 어느 면접관이든 코드에 더 관심을 갖기 때문이다. 그렇기에 이전 프로젝트보다 훨씬 좋은 퀄리티로 본인만의 사이드 프로젝트를 public하게 진행하는 것이 좋을 것 같다.  그 외\n 문제를 해결해 나가는 과정을 블로그 에 정리하여라.\n 최근 회사의 추세는 인턴을 뽑아 괜찮은 분들을 정규직 전환을 시키는 형태로 가고 있다. 막학기에 준비하는 것보다 지금부터(현재 3학년) 내년 인턴 합격을 준비하는 것이 좋을 것이다.\n  위에 간략하게 답변을 정리해보았는데, 사실 제가 간략하게 정리해서 그렇지 더 좋은 말씀들이 많았습니다. 그러면 이렇게 좋은 이야기를 저는 어떻게 행동으로 옮길 수 있을까요? 이에 대하여 많은 고민을 하게 됩니다. 그리고 다음과 같은 계획을 세우게 됩니다.\n앞으로 나는  WHY 에 집중하는 개발자가 될 것입니다.\n 사실 이는 어찌보면 당연한 부분이다. 내가 jvm에서 동작하는 언어를 선택하였다면, 왜? 선택하였는지 이유를 말할 수 있어야한다. 만약 실제 기업 면접에서 \u0026ldquo;OOO을 사용하셨는데, 왜 사용하셨는지 말씀해주실 수 있나요?\u0026rdquo; 라고 물어보았을 떄, 단순하게 \u0026ldquo;그냥..많이 하길래\u0026rdquo; 라는 두루뭉실한 말은 이유가 될 수 없습니다. 앞으로 개발하는데 있어서 무언가를 선택 하고 사용할 때 왜 내가 선택하고, 사용했는지 당당히 말할 수 있도록 해야겠습니다.   -\n 꾸준한 알고리즘 공부를 진행할 것입니다.\n 사실 이 부분은 대다수가 인지하고 있을거라 생각합니다. IT기업 대부분이 코딩 테스트를 지향하고 있고, 실제로 인적성으로만 걸렀던 몇몇 대기업들도 코딩 테스트로 전환되고 있는 추세다.\n 이를 위해서 나는 6월 중순(현재 학교 재학 + 프로젝트를 동시에 3개 진행중이라 시간적인 여유가 없다..)부터 구체적으로 알고리즘 공부 계획을 세워 꾸준하게 역량을 키우도록 할 것입니다.\n  블로그 활동 을 꾸준하게 할 것입니다.\n 블로그는 남에게 나를 어필할 수 있는 좋은 수단인 것 같습니다. 앞으로 내가 문제를 직면했을 때, 어떻게 해결해나가는 과정을 추후 면접자분들에게도 어필 할 수 있도록 블로그 글을 작성할 것입니다. (목표는 이동욱님 블로그..ㅋ)  넓은 범위의 역량 을 습득할 것입니다.\n 여기서 넓은 범위란 무작정 많은 기술을 공부하고 습득할 것이라는 말이 아닙니다! 제가 말한 넓은 범위란 너무 백엔드 개발에 국한된 공부가 아닌 인접한 공부(프론트, 디비 등)를 말씀드린 것입니다!   제가 성장함에 필요한 조건(?)들을 나열해보았습니다. 앞으로 개발 공부를 진행하는 동안 다음과 같은 조건을 필히 지켜가며 공부하다보면 현업에서도 인정받고 저 또한 누군가에게 귀감이 되는 사람이 될거라 생각합니다.\n그럼 이 글을 읽으시는 모든 개발자분들 모두 꾸준한 성장을 이루어 원하는 결과를 얻길 바라며 글을 마치겠습니다! 모두 화이팅입니다 :D\n","id":6,"section":"posts","summary":"코디미 상담 후기 - 백엔드 개발자를 꿈꾸는 초보 개발자에 대한 조언 최근 코덕이라는 이사이트를 애용하는데, 해당 사이트에서 코디미 라는 곳을 알게되었습니다. 코디","tags":null,"title":"코디미상담 후기 - 백엔드 개발자를 꿈꾸는 초보 개발자에 대한 조언","uri":"https://chlalstjd430.github.io/2020/05/%EC%A0%95%EB%B3%B4_002/","year":"2020"},{"content":" AWS EC2를 이용하여 Spring Boot 배포하기(3) 안녕하세요! 오늘은 지난 포스팅에 이어서 서버에서 Spring Boot를 배포하는 과정을 안내해드리도록 하겠습니다. 우리는 github 레포지토리가 존재한다는 가정하에 진행하겠습니다.\n1. 호스트 네임 변경하기 EC2 서버에 접속하면, \u0026ldquo;ubuntu@ip - ip주소\u0026rdquo;가 등장하는데 ip주소만 봤을 때, 어떠한 서비스인지 알 수 없으니 호스트 네임을 변경해주도록 합시다.\n먼저,\n sudo vim /etc/cloud/cloud.cfg\n 라는 명령어를 이용하여 cloud.cfg를 열어줍니다. 이후 방향키를 내려가며 \u0026ldquo;preserve_hostname: false\u0026rdquo;을 true로 변경해줍니다.\n 참고 : vi 에디터 사용법  이후\n sudo hostnamectl set-hostname \u0026ldquo;호스트이름\u0026rdquo;\n 명령어를 이용해 호스트이름을 설정해주고 \u0026ldquo;reboot\u0026rdquo; 명령어를 이용해 서버를 재시작해주시면 다음과 같이 정상적으로 호스트이름이 설정된 것을 확인하실 수 있습니다.\n\n2. Java 8 설치 먼저 서버에 Java 8을 설치해주어야한다(나는 배포 할 프로젝트가 8버전이다)\n Ubuntu에서 Java 8 설치 글을 참고해주세요!   3. MySQL 설치 이후 MySQL도 설치해 봅시다.\n Ubuntu에서 MySQL 설치 글을 참고해주세요!  \n3. git clone 하기 EC2에는 기본적으로 git이 설치가 되어있습니다, 그렇기에 바로 git clone을 시도해줍니다.\n git clone 본인 repository\n 🙋‍♂️주의 : Permission denied(publickey)가 나오게 되면 해당 블로그 글을 참고해 키를 등록해주세요\n이렇게 하게 되면 root안에 방금 clone한 폴더가 등장합니다.\n이후\n dir\n 명령어를 사용해 clone한 폴더가 생겼는지 확인하고,\n cd 폴더명 // 현재 위치를 [폴더명]으로 이동 sudo chmod 777 ./gradlew // ./gradlew에게 권한을 부여 sudo ./gradlew build // gradle build  명령어를 순차적으로 실행하고, jar파일의 이름을 찾아\n $ java –jar [이름].jar \u0026amp;\n 명령어를 실행하면 서버에 배포가 됩니다.\n지금까지 AWS EC2에 Spring Boot 배포하는 것을 소개해드렸는데, 사실 제 블로그 글에 부족한게 많습니다. 사실 추후에 RDS를 사용하여 배포하는 것을 보여드리기 위해 지금은 중간중간 생략한 과정도 많아 그냥 참고용으로만 봐주시면 감사하겠습니다. 추가적으로 궁금하신 사항들은 저에게 물어보셔도되고 훌륭한 다른 포스팅들을 검색하셔도 됩니다.\n추후 RDS를 이용하는 법에 대해서도 간단히 소개해드릴 예정이니 그때 뵙겠습니다. 그럼 20000!!\n참고 문헌 - 스프링 부트와 AWS로 혼자 구현하는 웹 서비스\n","id":7,"section":"posts","summary":"AWS EC2를 이용하여 Spring Boot 배포하기(3) 안녕하세요! 오늘은 지난 포스팅에 이어서 서버에서 Spring Boot를 배포하는 과정을 안내해드리도록 하겠습니다. 우리는 github","tags":null,"title":"AWS EC2를 이용하여 Spring Boot 배포하기(3)","uri":"https://chlalstjd430.github.io/2020/05/aws_ec2_03/","year":"2020"},{"content":" AWS EC2를 이용하여 Spring Boot 배포하기(2) - AWS EC2 서버 접속 오늘은 AWS EC2 서버에 접속하는 과정을 소개해드리도록 하겠습니다. 먼저 시작하기 전에 해당 글은 윈도우 를 이용하여 접속하는 방법을 안내해드리는 점 참고해주세요!\n1. putty 다운로드 및 키 발급 윈도우에서는 Mac과 같이 ssh 접속하기에 불편한 점이 많아 별도의 클라이언트를 설치해줍니다.\n1. putty 사이트에서 다운로드 후 putty.exe,puttygen.exe 모두 다운로드하였으면, puttygen.exe 부터 실행시켜줍니다. 이후 Load를 클릭합니다. 2. 이전 AWS 발급한 Pem 키가 저장되어있는 곳을 찾아 클릭해줍시다. 그러면 다음과 같이 키가 발급되었다는 팝업창이 나옵니다.\n3. 이후 Save private Key 를 클릭해 안전한 장소에 발급된 키를 저장해줍니다. 2. putty를 이용하여 AWS EC2 서버 접속 1. 먼저 AWS에서 인스턴스와 연결한 탄력적 ip를 알아옵니다. 그리고 다음 사진과 같이 Host Name을 설정해줍니다.(자신의 탄력적 ip를 적으시면 됩니다) 주의 : 이전에 AWS 보안그룹에 22포트는 내 IP에서만 접근이 가능하도록 설정하였습니다. 설정한 IP의 장소가 맞는지 확인해주세요!\n2. 이후 왼쪽 카테고리의 Connection - SSH - Auth로 이동하여 이전에 발급한 ppk를 Browse..를 클릭하여 불러옵니다. 주의 : pem키를 찾을 때 모든 파일에서 찾기를 하셔야 pem키가 보입니다.\n3. ppk를 잘 불러왔으면, 다시 왼쪽 카테고리에서 제일 위에 있는 Session 으로 이동합니다. 이후 Saved Sessions 에 본인의 서비스명을 입력하고 Save 해줍시다. 이후 저장한 세션을 선택 후 Open 해줍시다! 3. AWS EC2 접속 open 해주면 보안 알림창이 처음에 나오는데 그냥 \u0026lsquo;예\u0026rsquo;를 눌러주시면 됩니다. 그러면 이후 다음과 같은화면이 나오며 접속이 완료됩니다!\n그럼 다음 포스팅에서 본격적으로 AWS EC2 서버에 Spring Boot를 배포하는 작업을 보여드리겠습니다. 다음 포스팅에서 봐용~!👐\n참고 문헌 - 스프링 부트와 AWS로 혼자 구현하는 웹 서비스\n","id":8,"section":"posts","summary":"AWS EC2를 이용하여 Spring Boot 배포하기(2) - AWS EC2 서버 접속 오늘은 AWS EC2 서버에 접속하는 과정을 소개해드리도록 하겠습니다. 먼저 시작하기 전에 해당 글은 윈도우 를 이","tags":null,"title":"AWS EC2를 이용하여 Spring Boot 배포하기(2)","uri":"https://chlalstjd430.github.io/2020/05/aws_ec2_02/","year":"2020"},{"content":" AWS EC2를 이용하여 Spring Boot 배포하기(1) 저는 지금까지 AWS EC2를 이용하여 여러번 서버를 배포해보았었는데요. 이번에 그 과정들을 간단하게 블로그에 담고자 글을 작성합니다.\n먼저 시작하기 전에 제가 배포하려는 서비스는 다음과 같습니다.\n 실제 운영할 서비스는 아니고 간단한 토이 프로젝트의 느낌이다. 나는 빠르게 프로젝트를 배포하여야한다. 나는 현재 돈이 없다..(ㅜㅜ)  이러한 조건의 서비스를 배포하기 위해서 PAAS의 Heroku도 생각했지만, 예전에 Heroku를 사용했을 떄, 서버 region이 외국에 있고 Cold Start 문제가 있어 서비스를 운영하는데 어려움을 많이 느꼇습니다. 그렇기에 AWS에서 제공해주는 프리 티어를 이용하여 간단하게 EC2 서버에 서비스를 배포할 계획을 하였습니다. 그러면 시작해보도록 하겠습니다!\n\n 본 글은 AWS에 회원가입 모두 완료되었다는 가정하에 진행됩니다.\n EC2 인스턴스 생성하기 \n1. 인스턴스 시작 먼저 인스턴스를 만들어주기 위해 EC2 대시보드로 이동합시다! 이동하게 되면 위와 같은 화면을 마주하게 되는데요~, 여기서 화면 중앙의 인스턴스 시작 버튼을 눌러줍시다.\n\n2. 단계 1: Amazon Machine Image(AMI) 선택 AWS EC2에서는 Amazaon Linux, Ubunto, SUSE 등 다양한 OS를 제공하고 있습니다. 저는 이중에서 \u0026ldquo;Ubuntu Server 18.04 LTS (HVM), SSD Volume Type\u0026rdquo; 를 선택하겠습니다.\n🤷‍♂️ Why?\n OS는 Window와 Linux가 대표적인데, 보안적인 부분이나 비용적인 부분에서 Window보다 좋기 때문에 대체적으로 서버는 Linux를 이용합니다.\n 그렇다면 Linux 기반의 OS에도 여러가지가 있는데, 왜 Ubunto인가?\n 저는 EC2는 프리티어로만 사용할 예정이고 실제 Linux에 대해 전반적으로 지식이 많은게 아닌 초보자이기 때문에, 쉽게 접할 수 있는 Ubuntu를 선택하였습니다.  Ubuntu는 2년바다 크게 업데이트가 진행된다, 그래서 최근 20.4버전이 나와있다. 그러나 최신 버전이라고 무조건 좋다는 법은 없다. 출시된지 아직 한달도 안되었기 떄문에 그 동안 검증된 18.04 버전을 선택하겠다.\n 사실 내가 사용하려는 수준에서는 이 모든게 크게 상관없을 듯 하다(?)\n  어찌됐든 AMI른 선택해주었다면 다음 단계로 넘어가보자.\n\n3. 단계 2: 인스턴스 유형 선택 여기서는 t2.micro를 선택하시면 됩니다~\n🤷‍♂️ Why?\n 앞서 말했다시피 현재 배포할 서비스는 지속적으로 관리할 서비스가 아닙니다. 잘된다면 서비스를 계속 운영할 수 있겠지만 현재 상황에서는 그러한 계획이 없기 떄문에, 무료로 제공되는 \u0026ldquo;프리티어\u0026rdquo;를 이용할 것입니다. 그렇기에 선택의 여지가 없습니다..  (돈 없는 학식은 웁니다 ㅜㅜ)\n 참고  해당 유형에 대해 간략하게 설명드리면 \u0026ldquo;T시리즈\u0026rdquo;라고 불리는 유형이다. 이 서비스는 크레딧 이라는 일종의 CPU를 사용할 수 있는 포인트 개념이 있습니다. 관련된 내용은 해당 블로그를 참고하시면 좋을 것 같습니다. T2 instance 특징은 무엇인가요?   \n4. 단계 3: 인스턴스 세부 정보 구성 해당 사항은 추가적으로 건드리지 않고 그대로 진행하겠습니다!\n🤷‍♂️ Why?\n 현재 한대의 서버를 가지고 간단한 프로젝트를 배포하기 위해서이니, 별다른 설정을 하지않겠습니다.\n 추가적으로 해당 관련 정보를 수정하기 위해서는 추가적인 공부가 필요할 것 같아 당장 EC2를 이용하기 위해서는 그대로 넘어가도록하겠습니다.\n  \n5. 단계 4: 스토리지 추가 해당 스토리지의 크기를 30으로 설정해줍시다!\n🤷‍♂️ Why?\n 프리 티어에서는 최대 30GB의 스토리지를 사용할 수 있기 떄문에 우리는 최~대한 이를 활용하기 위해서 최대한으로 설정해줍시다!  \n6. 단계 5: 태그 추가 태그는 웹 콘솔에서 표기될 태그인 Name 태그를 등록합니다.\n(태그 추가 클릭 - 키에 Name입력 - 값에 본인의 서비스를 나타낼 수 있는 값을 입력)\n🤷‍♂️ Why?\n 여러 인스턴스가 있을 경우 이를 태그별로 구분하기 위해 본인의 서비스를 나타낼 수 있는 값으로 등록을합니다.  \n7. 단계 6: 보안 그룹 구성 보안 그룹은 사진과 같이 규칙을 추가하겠습니다.\n🤷‍♂️ Why?\n 22포트\n 22포트의 경우는 AWS EC2에 터미널로 접속할 떄를 이야기합니다. 해당 포트는 내 IP에서만 접속하게끔 설정을 하였는데요, 이유는 pem키가 없으면 접속이 불가능하나 pem키가 노출되었을 때 서버에서 비트 코인 채굴 서버로 이용될 수 있기 떄문입니다! 그러므로 내 IP로설정하고 장소가 이동될 떄 마다 내 IP를 다시 받아 이용하시는게 보안적으로 좋습니다 :D\n 말도 안 되는 과금의 추억. 요금 폭탄\n  80,443 포트\n http,https 통신을 위해 기본적으로 추가해줍니다~.   \n8. 단계 7: 인스턴스 시작 검토  해당 단계에서는 그동안 저희가 설정했던 부분들이 일괄적으로 나오게 됩니다. 이상없는지 확인해주고 시작하기 버튼을 클릭합시다!\n 이후 새 키 페어 생성 을 설정하고(기존 키 페어가 없다는 가정하에 진행하겠습니다.) 키 페어 이름을 서비스와 연관지어 짓고, 키 페어 다운로드를 클릭합니다. 이후 키 페어를 안전한 위치에 저장해줍니다.\n 위 과정이 완료되었으면 인스턴스 시작을 클릭합니다!\n  다음과 같은 화면이 나오면 다시 EC2 대시보드로 이동해봅시다.\n\n9. 인스턴스 생성 확인 짜잔-! 인스턴스 상태가 초록불과 함께 running이라 나와있으면 해당 인스턴스가 잘 실행되고 있음을 뜻합니다.(인스턴스가 생성되고 실행되는 과정까지 시간이 소요될 수 있습니다.)\n잠깐! 저희가 EC2 서버를 실제 접속하기 전에 해야할 일이 있습니다!\n\n10. 탄력적 IP 할당 인스턴스는 하나의 서버이기 떄문에 IP가 존재합니다. 인스턴스 생성시 항상 새 IP를 할당받고, 같은 인스턴스를 중지하고 다시 시작할 떄도 새 IP가 할당됩니다. 그렇게 되면 매번 접속해야 하는 IP가 변경되어 PC에서 매번 접속시 IP 주소를 확인해야하는 번거로움이 있습니다. 그렇기에 고정 IP를 가지게 해야하는데요, 우리는 이를 위해서 탄력적 IP를 할당합시다.\n1. 먼저 탄력적 IP 메뉴를 클릭합니다. 2. 탄력적 IP 주소 할당 을 클릭합니다. 3. 다음 화면에서 할당을 클릭합니다. 4. 탄력적 IP를 할당받으신걸 확인하실 수 있습니다. 그러면 이전에 저희가 만든 인스턴스와 탄력적 IP를 연결해보도록 하겠습니다! 먼저 퍼블릭 IPv4 주소 밑의 IP를 클릭합시다. 5. 이후 그대로 탄력적 IP 주소 연결 을 클릭합니다. 6. 이후 이전에 만든 인스턴스와 프라이빗 IP 주소를 설정합니다. 처음 AWS EC2 이용하시는 분은 그냥 그대로 설정하시고 연결하시면 됩니다. 7. 아래와 같이 나오게되면, 탄력적 IP가 해당 인스턴스와 연결되었음을 알 수 있습니다. 실제로 EC2 인스턴스를 확인하면 탄력적 IP가 연결된것도 확인하실 수 있습니다!\n지금까지 EC2 인스턴스 생성과 탄력적 IP 주소 연결까지의 과정을 소개해드렸습니다. 다음 포스팅에는 본격적으로 AWS EC2에 접속하는 방법과 서버에 Spring Boot를 배포하는 과정을 소개해드릴게요. 그럼 다음 포스팅떄 뵙겠습니다 :D\n참고 문헌 - 스프링 부트와 AWS로 혼자 구현하는 웹 서비스\n","id":9,"section":"posts","summary":"AWS EC2를 이용하여 Spring Boot 배포하기(1) 저는 지금까지 AWS EC2를 이용하여 여러번 서버를 배포해보았었는데요. 이번에 그 과정들을 간단하게 블로그에 담고자 글을","tags":null,"title":"AWS EC2를 이용하여 Spring Boot 배포하기(1)","uri":"https://chlalstjd430.github.io/2020/05/aws_ec2_01/","year":"2020"},{"content":" DecoratorPattern(데코레이터 패턴) 데코레인터 패턴이란?  객체의 결합 을 통해 기능을 동적으로 유연하게 확장 할 수 있게 해주는 패턴\n 위의 한 문장으로 정확히 무엇인지 정확히 이해하기 힘듭니다, 아래의 내용을 통해 데코레이터 패턴을 살펴봅시다!\n도로 표시 방법 조합하기(데코레이터 패턴을 모를 떄 ver) 도로가 있을 떄 차선을 표시해야할 떄 우리는 어떻게 클래스를 만들까?\n도로가 있을 떄 차선을 표시하기 위해 기본적으로 2가지 클래스를 만들어보았습니다! - RodaDisplay Class : 기본 도로 표시 기능을 제공하는 클래스 - RoadDIsplayWithLane Class : 기본 도로 표시에 추가적으로 차선을 표시하는 클래스\n이 둘을 코드로 표현하면 다음과 같습니다~\npublic class Client { public static void main(String[] args) { System.out.println(\u0026quot;첫번째 draw\u0026quot;); RoadDisplay roadDisplay = new RoadDisplay(); roadDisplay.draw(); System.out.println(\u0026quot;\\n두번째 draw\u0026quot;); RoadDisplay roadDisplayWithLane = new RoadDisplayWithLane(); roadDisplayWithLane.draw(); } } class RoadDisplay{ public void draw(){ System.out.println(\u0026quot;도로 기본 표시\u0026quot;); } } class RoadDisplayWithLane extends RoadDisplay{ public void draw(){ super.draw(); drawLane(); } private void drawLane(){ System.out.println(\u0026quot;차선 표시\u0026quot;); } }  위의 코드 중 main을 보면 \u0026ldquo;draw()\u0026ldquo;라는 메소드를 사용하여 기능을 통일 시켜주었습니다. 그래서 결과를 보면\n첫번째 draw 도로 기본 표시 두번째 draw 도로 기본 표시 차선 표시  다음과 같이 출력이 됩니다. 동일한 \u0026ldquo;draw()\u0026ldquo;메소드를 수행했지만 다른 출력값이 나오는 것을 확인할 수 있습니다.\n기능만 봐서는 잘 작동하는 것 같은데,,과연 해당 코드에 문제점이 없을까요?🤔\n문제점이 있는지 확인하기 위해 다음과 같은 사항을 체크해봅시다!\n 또 다른 추가적인 도로 표시 기능을 구현하고 싶다면 어떻게 해야 하는가?(도로 표시에 교통량도 표시하고싶다면..!?)🚖🚖🚖\n 뿐만아니라 여러가지 추가 기능의 조합하여 제공하고 싶다면 어떻게 해야 할까요? 예를 들어 기본 도로 표시에 차선 표시 기능과 교통량 표시 기능을 함께 제공하고 싶다면요! 🏞 + 🚖🚖🚖\n  위의 사항들을 다음과 같이 시도해봅시다!\n추가적으로 RoadDisplay를 상속받는 RoadDisplayWithTraffic 클래스를 구현하는거죠!! 즉, 코드를 보면 다음과 같습니다!\npublic class Client { public static void main(String[] args) { System.out.println(\u0026quot;첫번째 draw\u0026quot;); RoadDisplay roadDisplay = new RoadDisplay(); roadDisplay.draw(); System.out.println(\u0026quot;\\n두번째 draw\u0026quot;); RoadDisplay roadDisplayWithLane = new RoadDisplayWithLane(); roadDisplayWithLane.draw(); System.out.println(\u0026quot;\\n세번째 draw\u0026quot;); RoadDisplay roadDisplayWithTraffic = new RoadDisplayWithTraffic(); roadDisplayWithTraffic.draw(); } } class RoadDisplay{ public void draw(){ System.out.println(\u0026quot;도로 기본 표시\u0026quot;); } } class RoadDisplayWithLane extends RoadDisplay{ public void draw(){ super.draw(); drawLane(); } private void drawLane(){ System.out.println(\u0026quot;차선 표시\u0026quot;); } } class RoadDisplayWithTraffic extends RoadDisplay{ public void draw(){ super.draw(); drawTraffic(); } private void drawTraffic(){ System.out.println(\u0026quot;교통량 표시\u0026quot;); } }  이 코드의 실행 결과도\n첫번째 draw 도로 기본 표시 두번째 draw 도로 기본 표시 차선 표시 세번째 draw 도로 기본 표시 교통량 표시  로 잘 수행이됩니다. 그렇다면 이와 같은 방식으로 기능들을 조합하여 사용하자는 두번째 사항 에 부합되도록 하려면 어떻게할까요?\n위와 같은 표처럼 많은 기능을 구현하기 위해 우리는 다음과 같이 코드를 작성해야할지 모릅니다..\nclass RoadDisplay{ public void draw(){ System.out.println(\u0026quot;도로 기본 표시\u0026quot;); } } class RoadDisplayWithLane extends RoadDisplay{ public void draw(){ super.draw(); drawLane(); } private void drawLane(){ System.out.println(\u0026quot;차선 표시\u0026quot;); } } class RoadDisplayWithTraffic extends RoadDisplay{ public void draw(){ super.draw(); drawTraffic(); } private void drawTraffic(){ System.out.println(\u0026quot;교통량 표시\u0026quot;); } } class RoadDisplayWithCrossing extends RoadDisplay{ public void draw(){ super.draw(); drawCrossing(); } private void drawCrossing(){ System.out.println(\u0026quot;교차료 표시\u0026quot;); } } class RoadDisplayWithLaneTraffic extends RoadDisplay{ public void draw(){ super.draw(); drawLane(); drawTraffic(); } private void drawLane(){ System.out.println(\u0026quot;차선 표시\u0026quot;); } private void drawTraffic(){ System.out.println(\u0026quot;교통량 표시\u0026quot;); } } class RoadDisplayWithLaneCrossing extends RoadDisplay{ public void draw(){ super.draw(); drawLane(); drawCrossing(); } private void drawLane(){ System.out.println(\u0026quot;차선 표시\u0026quot;); } private void drawCrossing(){ System.out.println(\u0026quot;교차료 표시\u0026quot;); } } . . . . .  위의 코드를 보면 무언가 문제가 있다고 느껴지시지 않나요? 위의 코드를 보면 중복된 코드들이 많이 보입니다. \u0026ldquo;차선 표시\u0026rdquo;를 print해주는 문장만 벌써 3개 등장했습니다.. 그러면 기능들이 추가될 떄마다 중복된 코드는\u0026hellip;.\n맞습니다..기능이 추가될 떄마다 우리는 불필요한 하드 코딩을 하게 됩니다.\n그러면 데코레이터 패턴을 적용하면 어떻게 해결될까요!?\n데코레이터 패턴 적용 ver 다음은 데코레이터 패턴을 적용한 후의 클래스 다이어그램입니다.\n훨씬 간결해진 구조 보이시나요!? 기존에 기능들을 조합하기 위해 조합되는 기능만큼 클래스들을 생성했는데, 데코리에터 패턴을 이용하면 고유한 기능들 개수만큼만 클래스를 생성해주시면 됩니다! 그러면 코드를 볼까요?\npublic class Client { public static void main(String[] args) { Display roadWithLaneAndTraffic = new TrafficDecorator( new LaneDecorator( new CrossingDecorator( new RoadDisplay() ) ) ); System.out.println(\u0026quot;--- draw 호출 ---\u0026quot;); roadWithLaneAndTraffic.draw(); } } abstract class Display{ public abstract void draw(); } class RoadDisplay extends Display{ @Override public void draw() { System.out.println(\u0026quot;도로 기본 표시\u0026quot;); } } class DisplayDecorator extends Display{ private Display decorateDisplay; public DisplayDecorator(Display decorateDisplay){ this.decorateDisplay = decorateDisplay; } @Override public void draw() { decorateDisplay.draw(); } } class LaneDecorator extends DisplayDecorator{ public LaneDecorator(Display decorateDisplay){ super(decorateDisplay); } @Override public void draw() { super.draw(); drawLane(); } private void drawLane(){ System.out.println(\u0026quot;\\t차선 표시\u0026quot;); } } class CrossingDecorator extends DisplayDecorator{ public CrossingDecorator(Display decorateDisplay){ super(decorateDisplay); } @Override public void draw() { super.draw(); drawCrossing(); } private void drawCrossing(){ System.out.println(\u0026quot;\\t횡단보도 표시\u0026quot;); } } class TrafficDecorator extends DisplayDecorator{ public TrafficDecorator(Display decorateDisplay){ super(decorateDisplay); } @Override public void draw() { super.draw(); drawTraffic(); } private void drawTraffic(){ System.out.println(\u0026quot;\\t교통량 표시\u0026quot;); } }  수행결과\n--- draw 호출 --- 도로 기본 표시 횡단보도 표시 차선 표시 교통량 표시  main안의 코드들을 살펴봅시다! 예전에 해당 기능을 구현하기 위해서는 새로 클래스를 만들어서 구현했는데, 데코레이터 페턴이 적용된 현재는 생성자 DisplayDecorator 클래스를 상속받는 클래스들의 생성자에 구현하고자 하는 기능들을 추가하면 간단하게 구현됩니다. 즉, 새로운 클래스 구현이 아닌 생성자에 필요한 기능을 담는 것으로 기능의 조합이 가능해집니다!\n이로써 우리는 앞으로 데코레이터 패턴을 이용하여 기본 기능에 추가될 수 있는 많은 수의 부가 기능에 대해서 다양한 조합을 동적으로 구현할 수 있습니다~! 참고 - JAVA 객체지향 디자인 패턴 \n","id":10,"section":"posts","summary":"DecoratorPattern(데코레이터 패턴) 데코레인터 패턴이란? 객체의 결합 을 통해 기능을 동적으로 유연하게 확장 할 수 있게 해주는 패턴 위의 한 문장","tags":null,"title":"[DesignPattern] Decorator Pattern(데코레이터 패턴)","uri":"https://chlalstjd430.github.io/2020/05/01_decorator_pattern/","year":"2020"},{"content":" 문제링크 \n사용언어  c++  \n주의사항  방금그곡 서비스에서는 음악 제목, 재생이 시작되고 끝난 시각, 악보를 제공한다.\n 네오가 기억한 멜로디와 악보에 사용되는 음은 C, C#, D, D#, E, F, F#, G, G#, A, A#, B 12개이다.\n 각 음은 1분에 1개씩 재생된다. 음악은 반드시 처음부터 재생되며 음악 길이보다 재생된 시간이 길 때는 음악이 끊김 없이 처음부터 반복해서 재생된다. 음악 길이보다 재생된 시간이 짧을 때는 처음부터 재생 시간만큼만 재생된다.\n 음악이 00:00를 넘겨서까지 재생되는 일은 없다.\n 조건이 일치하는 음악이 여러 개일 때에는 라디오에서 재생된 시간이 제일 긴 음악 제목을 반환한다. 재생된 시간도 같을 경우 먼저 입력된 음악 제목을 반환한다.\n 조건이 일치하는 음악이 없을 때에는 (None)을 반환한다.\n  \n문제풀이 처음 문제를 풀때 \u0026lsquo;#\u0026lsquo;을 고려하지못하여서, 마지막에 m과 melody를 비교하기 힘들었다, 이후 처음부터 멜로디들의 코드를 \u0026ldquo;C, C#, D, D#, E, F, F#, G, G#, A, A#, B \u0026ldquo;로 구별하여 vector에 담아 비교하니 쉽게 구현할 수 있었다. 다만 문제를 어떻게 풀지 생각하는건 쉬웠는데..실제로 구현해보니 시간이 너..무 오래걸렸다..\n문제풀이 방식은 다음과 같다.\n musicinfos의 string 정보를 \u0026lsquo;,\u0026lsquo;로 split하여 곡 정보를 받아온다.\n 이후 시작시간과 끝시간을 이용하여 총 재생시간을 구한다.\n 음악 정보의 멜로디를 비교하기 전에 총 재생시간이 이전에 조건이 일치했던 음악이 있는지와 그 음악의 재생시간보다 큰지 비교한다.\n 이후 해당 음악정보가 조건이 일치한지 검색한다.\n 조건에 일치하면 answer에 곡 제목을 담아준다.\n  여기서 melody들을 그냥 string으로 비교하는 것보다 코드별로 분리하는 함수를 만들어서 코드들을 순서대로 vector에 담아 비교하는 것이 더 쉽다.\n코드를 보면 다음과 같다.\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; // 4 6 7 8 9 12 15 18 19 vector\u0026lt;string\u0026gt; splitChar(string str, char ch){ vector\u0026lt;string\u0026gt; v; int ind = 0; for(int i = 0; i \u0026lt; str.size(); i++){ if(str[i] == ch){ v.push_back(str.substr(ind, i - ind)); ind = i + 1; } } v.push_back(str.substr(ind, str.size()-1)); return v; } bool searchMelody(vector\u0026lt;string\u0026gt; m, vector\u0026lt;string\u0026gt; melody){ bool result = true; for(int i = 0; i \u0026lt; melody.size(); i++){ if(melody[i] != m[0]) continue; int k = i; for(int j = 0; j \u0026lt; m.size(); j++){ if(melody[k] != m[j]) { result = false; break; } k++; } if(result) { return result; } result = true; } return false; } vector\u0026lt;string\u0026gt; findMelodyCode(string melody){ vector\u0026lt;string\u0026gt; melodyCode; for(int j = 0; j \u0026lt; melody.size() - 1; j++){ string code = \u0026quot;\u0026quot;; code += melody[j]; if(melody[j+1] == '#'){ code += melody[j+1]; j++; } melodyCode.push_back(code); } if(melody[melody.size() - 1] != '#'){ string code = \u0026quot;\u0026quot;; code += melody[melody.size() - 1]; melodyCode.push_back(code); } return melodyCode; } string solution(string m, vector\u0026lt;string\u0026gt; musicinfos) { string answer = \u0026quot;(None)\u0026quot;; int currentTime = 0; for(int i = 0; i \u0026lt; musicinfos.size(); i++){ vector\u0026lt;string\u0026gt; musicinfo = splitChar(musicinfos[i], ','); vector\u0026lt;string\u0026gt; startTime = splitChar(musicinfo[0], ':'); vector\u0026lt;string\u0026gt; endTime = splitChar(musicinfo[1], ':'); int sumTime = (stoi(endTime[0]) - stoi(startTime[0]))*60 + (stoi(endTime[1]) - stoi(startTime[1])); if(currentTime \u0026gt; sumTime) continue; if(currentTime == sumTime){ if(answer != \u0026quot;(None)\u0026quot;) continue; } vector\u0026lt;string\u0026gt; melodyCode = findMelodyCode(musicinfo[3]); vector\u0026lt;string\u0026gt; melody; for(int j = 0; j \u0026lt; sumTime; j++){ int ind = j%melodyCode.size(); melody.push_back(melodyCode[ind]); } if(searchMelody(findMelodyCode(m), melody)){ answer = musicinfo[2]; currentTime = sumTime; } } return answer; }  ","id":11,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 방금그곡 서비스에서는 음악 제목, 재생이 시작되고 끝난 시각, 악보를 제공한다. 네오가 기억한 멜로디와 악보에 사용되는 음은 C, C#, D,","tags":null,"title":"프로그래머스 - [3차] 방금그곡","uri":"https://chlalstjd430.github.io/2020/04/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_022/","year":"2020"},{"content":" 문제링크 \n사용언어  c++  \n주의사항  비트마스킹을 이용하여 풀 수 있는 문제이다. 기본적인 비트연산자에 대하여 숙지하여야한다.\n dfs로도 풀 수 있긴하다.  관계 데이터베이스에서 릴레이션(Relation)의 튜플(Tuple)을 유일하게 식별할 수 있는 속성(Attribute) 또는 속성의 집합 중, 다음 두 성질을 만족하는 것을 후보 키(Candidate Key)라고 한다.\n 유일성(uniqueness) : 릴레이션에 있는 모든 튜플에 대해 유일하게 식별되어야 한다.\n 최소성(minimality) : 유일성을 가진 키를 구성하는 속성(Attribute) 중 하나라도 제외하는 경우 유일성이 깨지는 것을 의미한다. 즉, 릴레이션의 모든 튜플을 유일하게 식별하는 데 꼭 필요한 속성들로만 구성되어야 한다.\n   \n문제풀이 해당 문제를 비트마스킹으로 푸는 코드를 이해하는데 오래걸렸다..애초에 비트연산자를 안쓴지 오래되어 까먹은 부분도 있고, 이러한 문제유형을 접해본게 처음인지라 나에게는 많이 어려웠다.\n해당 문제를 비트마스킹으로 풀기 전에 이론적으로 내가 생각한 부분은 이렇다.\n colum개수만큼 for문을 진행하면서 colum의 개수중 i개를 조합한다.\n 이후 조합된 colum이 후보키가 될 수 있는지 확인한다.\n 이렇게 선출된 후보키들중 다른 후보키에 포함되는 경우 다른 후보키를 후보키에서 제외한다.\n 예시) \u0026ldquo;이름\u0026rdquo;이라는 칼럼자체가 후보키가 될 수있으면 {\u0026ldquo;이름\u0026rdquo;,\u0026ldquo;학번\u0026rdquo;},{\u0026ldquo;이름\u0026rdquo;,\u0026ldquo;전공\u0026rdquo;} 등 \u0026ldquo;이름\u0026rdquo;이 들어간 후보키는 최소성에 어긋난다.   위와 같이 과정을 생각하고 막상 코드를 구현하려했더니 dfs밖에 생각이 나지 않았다. 그래서 코드를 구현하다보니 내가 많이 복잡하게 구현한다는 느낌을 받아 검색을 통해 비트마스킹을 이용하여 문제를 풀 수 있다는 것을 알게되었다. 비트마스킹을 이용하여 문제를 푸는게 처음이라 코드를 이해하고 적용하는데 오래걸렸다. 코드는 다음과 같다.\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int countBits(int n){ int ret = 0; while(n){ if(n \u0026amp; 1) ret++; n = n \u0026gt;\u0026gt; 1; } return ret; } bool cmp(int a, int b){ a = countBits(a); b = countBits(b); return a \u0026lt; b; } bool check(vector\u0026lt;vector\u0026lt;string\u0026gt; \u0026gt; relation , int rowSize, int colSize, int subset){ // 예시) relation, 6, 4, 1(= 0001) // subset의 값에 있는 같은 자리에 대헤서 후보키가 될 수 있는지 검사한다. for(int i = 0; i \u0026lt; rowSize - 1; i++){ for(int j = i + 1; j \u0026lt; rowSize; j++){ bool isSame = true; for(int k = 0; k \u0026lt; colSize; k++){ if ((subset \u0026amp; 1 \u0026lt;\u0026lt; k) == 0) continue; // subset의 자리에 없는 colum은 지나친다. // 한 row에 값잍 틀린게 있으면(즉, 후보키가 될 수 있으면) isSame에 flase를 주고 해당 row에서 다음 row를 검사한다. // 예시로 subset = 3(0011) 일 때, 검색하는 row의 3번째자리나 4번째자리에 값중 하나만 달라도 후보키가 될 수 있다. if (relation[i][k] != relation[j][k]) { isSame = false; break; } } if (isSame) return false; // 해당 row의 값이 같으면 후보키가 될 수 없다. } } return true; } int solution(vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; relation) { int answer = 0; int rowSize = relation.size(); int colSize = relation[0].size(); vector\u0026lt;int\u0026gt; candidates; // colSize로 표현할 수 있는 비트개수만큼 for문 진행 for(int i = 1; i \u0026lt; (1 \u0026lt;\u0026lt; colSize); i++){ // 후보키가 될 수 있는지 여부를 탐색 if(check(relation, rowSize, colSize, i)) candidates.push_back(i); } // colum의 개수가 작은 순서대로 정렬 sort(candidates.begin(), candidates.end(), cmp); while(!candidates.empty()){ // sort된 후보키중 가장 작은 후보키를 답으로 제출 int n = candidates[0]; candidates.erase(candidates.begin()); answer++; // 이후 해당 후보키가 포함된 후보키들은 답에서 제외 for(int i = 0; i \u0026lt; candidates.size(); i++){ if((n \u0026amp; candidates[i]) == n){ candidates.erase(candidates.begin() + i); i = -1; } } } return answer; }  ","id":12,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 비트마스킹을 이용하여 풀 수 있는 문제이다. 기본적인 비트연산자에 대하여 숙지하여야한다. dfs로도 풀 수 있긴하다. 관계 데이터","tags":null,"title":"프로그래머스 - 후보키","uri":"https://chlalstjd430.github.io/2020/04/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_021/","year":"2020"},{"content":" 문제링크 \n사용언어  c++  \n주의사항  최솟값이 8보다 크면 -1을 return 합니다.  \n문제풀이  해당 문제는 DP로 풀지못하여 DFS를 활용하였습니다. Count가 9이상이면 -1을 리턴하기때문에 N은 최대 9번 연속으로 나열될 수 있습니다. 코드는 다음과 같습니다.\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int minNum = 9; void dfs(int count, int number, int current, int target) { if(count \u0026gt; 8) return; if(current == target){ minNum = min(minNum, count); } int tmp = 0; for(int i = 0; i \u0026lt; 8 - count; i++){ tmp = tmp*10 + number; dfs(count + 1 + i, number, current + tmp, target); dfs(count + 1 + i, number, current / tmp, target); dfs(count + 1 + i, number, current * tmp, target); dfs(count + 1 + i, number, current - tmp, target); } } int solution(int N, int number) { int answer = 0; dfs(0, N, 0, number); if(minNum \u0026gt;= 9) answer = -1; else answer = minNum; return answer; }   ","id":13,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 최솟값이 8보다 크면 -1을 return 합니다. 문제풀이 해당 문제는 DP로 풀지못하여 DFS를 활용하였습니다. Count가 9이상이면","tags":null,"title":"프로그래머스 - N으로 표현","uri":"https://chlalstjd430.github.io/2020/04/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_020/","year":"2020"},{"content":" 문제링크 \n사용언어  c++  \n주의사항  double형으로 값들을 계산할 경우 부동소수점에 유의해야 한다.  \n문제풀이 해당 문제를 풀기위한 순서는 다음과 같다.\n lines를 \u0026lsquo; \u0026rsquo; 단위로 1차적으로 split한다.   마지막 단어인 \u0026rsquo;s\u0026rsquo;는 빼준다.   1번에의하여 split된 시간값을 \u0026lsquo;:\u0026rsquo; 단위로 다시한번 split해준다.\n 2번에의하여 split된 값들을 이용하여 시작시간과 종료시간을 구하여 값을 저장한다.\n   시작 시간을 구할 떄, 0.001초에 해당하는 값은 더해주어야한다.(처리시간은 시작시간과 끝시간을 포함)   각각 로그들의 시작시간과 종료시간별로 1초가 지난 값들 안에 다른 로그들이 범위에 들어있는지 확인하여 최대 처리량을 구한다.\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; double abs(double num){ if(num \u0026gt; 0) return num; return -num; } vector\u0026lt;string\u0026gt; splitByChar(string str, char ch){ vector\u0026lt;string\u0026gt; result; int ind = 0; for(int i = 0; i \u0026lt; str.size(); i++){ if(str[i] == ch){ result.push_back(str.substr(ind, i - ind)); ind = i + 1; } } result.push_back(str.substr(ind, str.size() - ind )); return result; } int solution(vector\u0026lt;string\u0026gt; lines) { int answer = 0; int size = lines.size(); vector\u0026lt;long\u0026gt; startTime; vector\u0026lt;long\u0026gt; endTime; for(int i = 0; i \u0026lt; size; i++){ vector\u0026lt;string\u0026gt; line = splitByChar(lines[i], ' '); vector\u0026lt;string\u0026gt; time = splitByChar(line[1], ':'); long d = (long)(stoi(time[0])*60*60*1000 + stoi(time[1])*60*1000 + stod(time[2])*1000); startTime.push_back(d - stod(line[2])*1000 + 1); endTime.push_back(d); } for(int i = 0; i\u0026lt; size; i++){ long s = startTime[i]; long e = endTime[i]; int tmp1 = 0; int tmp2 = 0; for(int j = 0; j \u0026lt; size; j++){ long cs = startTime[j]; long ce = endTime[j]; if(s \u0026lt;= ce \u0026amp;\u0026amp; s + 999 \u0026gt;= cs) tmp1++; if(e \u0026lt;= ce \u0026amp;\u0026amp; e + 999 \u0026gt;= cs) tmp2++; } answer = max(answer, max(tmp1,tmp2)); } return answer; }   ","id":14,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 double형으로 값들을 계산할 경우 부동소수점에 유의해야 한다. 문제풀이 해당 문제를 풀기위한 순서는 다음과 같다. lines","tags":null,"title":"프로그래머스 - [1차] 추석 트래픽","uri":"https://chlalstjd430.github.io/2020/04/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_019/","year":"2020"},{"content":" 문제링크 \n사용언어  c++  \n주의사항  입력으로 판의 높이 m, 폭 n과 판의 배치 정보 board가 들어온다.\n 2 ≦ n, m ≦ 30\n board는 길이 n인 문자열 m개의 배열로 주어진다. 블록을 나타내는 문자는 대문자 A에서 Z가 사용된다.\n 문제를 풀때 이 부분을 놓치면 9번 TC를 통과하지 못하게 된다.   \n문제풀이 해당 문제를 풀기 위해서 문제를 이해하고 어떻게 해야 문제를 풀 수 있을지 생각해보았다.\n 2x2블록들을 찾는다.\n 1번에서 찾은 블록들을 빈 블록 처리를 해준다.\n 블록들을 아래로 떨어트려 준다.\n 1~3 과정을 2x2블록을 찾지 못할 떄까지 진행한다.\n 2x2블록을 찾지 못하였으면 비어있는 블록들의 개수를 세준다.\n  위의 과정을 거치면 우리는 답을 구할 수 있다는 것을 알 수 있다. 그러면 코드로 구현해보자.\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; vector\u0026lt;string\u0026gt; friendsBoard; int nx[] = {0, 0, 1, 1}; int ny[] = {0, 1, 0, 1}; int answer = 0; // 블록을 아래로 떨어트리는 함수 void pushBoard(){ int w = friendsBoard[0].size(); int h = friendsBoard.size(); for(int i = h - 1; i \u0026gt;= 0; i--){ for(int j = w - 1; j \u0026gt;= 0; j--){ if(friendsBoard[i][j] != 'x') continue; int ind = -1; for(int k = i; k \u0026gt;= 0; k--){ if(friendsBoard[k][j] != 'x') { ind = k; break; } } if(ind == -1) continue; int cur = i; for(int k = ind; k \u0026gt;= 0; k--){ if(cur \u0026lt; 0) break; friendsBoard[cur][j] = friendsBoard[k][j]; friendsBoard[k][j] = 'x'; cur--; } } } } // 2x2 블록을 찾는 함수 bool findFriends(){ vector\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; boardLocation; int w = friendsBoard[0].size(); int h = friendsBoard.size(); for(int i = 0; i \u0026lt; h; i++){ for(int j = 0; j \u0026lt; w; j++){ bool find[4] = {false, }; char v = friendsBoard[i][j]; if(v == 'x') continue; for(int k = 0; k \u0026lt; 4; k++){ int x = i + nx[k]; int y = j + ny[k]; if(0 \u0026gt; x || 0 \u0026gt; y || x \u0026gt;= h || y \u0026gt;= w ) break; if(v == friendsBoard[x][y]){ find[k] = true; continue; } break; } if(find[0] \u0026amp;\u0026amp; find[1] \u0026amp;\u0026amp; find[2] \u0026amp;\u0026amp; find[3]){ for(int k = 0; k \u0026lt; 4; k++){ boardLocation.push_back(make_pair(i + nx[k], j + ny[k])); } find[0] = find[1] = find[2] = find[3] = false; } } } for(int i = 0; i \u0026lt; boardLocation.size(); i++){ int x = boardLocation[i].first; int y = boardLocation[i].second; friendsBoard[x][y] = 'x'; } if(boardLocation.size() == 0){ return false; } return true; } // 비어있는 블락을 찾는 함수 void findAnswer(){ int w = friendsBoard[0].size(); int h = friendsBoard.size(); for(int i = 0; i \u0026lt; h; i++){ for(int j = 0; j \u0026lt; w; j++){ if(friendsBoard[i][j] == 'x') answer++; } } } int solution(int m, int n, vector\u0026lt;string\u0026gt; board) { friendsBoard = board; bool find = true; findFriends(); while(find){ pushBoard(); find = findFriends(); } findAnswer(); return answer; }  ","id":15,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 입력으로 판의 높이 m, 폭 n과 판의 배치 정보 board가 들어온다. 2 ≦ n, m ≦ 30 board는 길이 n인 문자열 m개의 배열로 주어진","tags":null,"title":"프로그래머스 - [1차] 프렌즈4블록","uri":"https://chlalstjd430.github.io/2020/03/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_018/","year":"2020"},{"content":" 문제링크 \n사용언어  c++  \n주의사항  문자열의 길이 : 1,000,000이하의 자연수\n 문자열은 모두 소문자로 이루어져 있습니다.\n  \n문제풀이 처음에 for문을 계속 돌려줘가며 탐색하는 방식으로 문제를 풀었다. 그러나 이 방식은 효율성 테스트를 통과하지 못하였고 다른 방법을 모색하였다. 이를 해결하기 위한 좋은 방법으로는 stack 자료구조를 활용하는 방법이다. 과정은 다음과 같다.\n 첫 글자는 무조건 stack에 담는다.\n 이후 두번째 글자부터 for문을 진행한다.\n for문을 진행하면서 stack의 top에 있는 글자와 현재 글자가 같다면 stack을 pop 시켜준다.\n 같지 않다면 stack에 push해준다.\n 위와 같은 과정을 계속 진행하며 stack이 비어있다면 answer를 1로 변환해준다.\n  위 과정에서 stack에 top을 가르키기 전에 stack이 비어있는지 확인하여 비어있다면 비교하지 않고 해당 값을 push 해줘야한다. 코드를 보면 다음과 같다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;stack\u0026gt; using namespace std; int solution(string s) { int answer = 0; stack\u0026lt;char\u0026gt; st; st.push(s[0]); for(int i = 1; i \u0026lt; s.size(); i++){ if(st.empty()){ st.push(s[i]); continue; } if(st.top() == s[i]){ st.pop(); continue; } st.push(s[i]); } if(st.empty()) answer = 1; return answer; }  ","id":16,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 문자열의 길이 : 1,000,000이하의 자연수 문자열은 모두 소문자로 이루어져 있습니다. 문제풀이 처음에 for문을 계속 돌려","tags":null,"title":"프로그래머스 - 짝지어 제거하기","uri":"https://chlalstjd430.github.io/2020/03/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_017/","year":"2020"},{"content":" 문제링크 \n사용언어  c++  \n주의사항  행의 개수 N : 100,000 이하의 자연수\n 열의 개수는 4개이고, 땅(land)은 2차원 배열로 주어집니다.\n 점수 : 100 이하의 자연수\n  \n문제풀이 처음 문제를 풀 때는 재귀로 문제에 접그하였더니 예제는 통과하였지만, 실행을 하니 모두 실패가 나왔다. 그래서 DP로 접근하여 문제를 풀기로 했다. 문제 풀이 과정은 다음과 같다.\n 행의 두번째 줄부터 열을 차례대로 검사한다.\n 해당칸은 이전 행에서 열이 같잊않은 칸들 중 가장 큰수를 더한값이 된다. 즉, n = n + max(n-1)(열이 같지 않은 칸 중 가장 큰 값) 이라는 점화식이 이용된다.\n 마지막 행까지 검사가 끝나면 마지막 행에서 가장 큰 값을 찾아 답을 구한다.\n  이를 코드로 표현하면 다음과 같습니다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int landW; int landH; int answer; void dfs(int x, int y, int sum, vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; land){ if(x \u0026gt;= landH || y \u0026gt;= landW){ return; } sum += land[x][y]; answer = max(answer, sum); for(int i = 0; i \u0026lt; landW; i++){ if(i == y) continue; dfs(x+1, i, sum, land); } } int solution(vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; land) { answer = 0; landH = land.size(); landW = land[0].size(); for(int i = 0; i \u0026lt; landH; i++){ for(int j = 0; j \u0026lt; landW; j++){ dfs(i,j,0, land); } } return answer; }  ","id":17,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 행의 개수 N : 100,000 이하의 자연수 열의 개수는 4개이고, 땅(land)은 2차원 배열로 주어집니다. 점수 : 100 이하의 자연수 문제풀이","tags":null,"title":"프로그래머스 - 땅따먹기","uri":"https://chlalstjd430.github.io/2020/03/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_016/","year":"2020"},{"content":" 문제링크 \n사용언어  c++  \n주의사항  조건 1. n의 다음 큰 숫자는 n보다 큰 자연수 입니다.\n 조건 2. n의 다음 큰 숫자와 n은 2진수로 변환했을 때 1의 갯수가 같습니다.\n 조건 3. n의 다음 큰 숫자는 조건 1, 2를 만족하는 수 중 가장 작은 수 입니다.\n  \n문제풀이 문제의 조건에 맞게 문제의 풀이 과정은 다음과 같이 진행하였다.\n n을 2진법으로 변환한데 1의 갯수를 센다.\n n+1 부터 1000000까지 차례대로 2진법 변환을 하며 1의 갯수를 센다.\n 2번 과정을 반복하다 n의 2진법의 1의 갯수와 같은게 있으면 answer에 값을 저장하고 끝낸다.\n  위 과정을 코드로 표현하면 다음과 같습니다.\nusing namespace std; int cntN(int n){ int cnt = 0; while(n \u0026gt; 1){ if(n%2 == 1) cnt++; n /= 2; } return cnt; } int solution(int n) { int answer = 0; int current = cntN(n); for(int i = n+1; i \u0026lt; 1000001; i++){ if(current == cntN(i)){ answer = i; break; } } return answer; }  ","id":18,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 조건 1. n의 다음 큰 숫자는 n보다 큰 자연수 입니다. 조건 2. n의 다음 큰 숫자와 n은 2진수로 변환했을 때 1의 갯수가 같습니다. 조건 3.","tags":null,"title":"프로그래머스 - 다음 큰 숫자","uri":"https://chlalstjd430.github.io/2020/03/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_015/","year":"2020"},{"content":" 문제링크 \n사용언어  c++  \n주의사항  DP를 적용하여 문제를 풀지않으면 시간 초과가 된다.  \n문제풀이  array[N][N] = (array[N-1][N], array[N][N-1], array[N-1][N-1]) 중 가장 작은 값 + 1\n 위의 점화식을 이용하여 문제를 풀면된다. 다만, 맨 윗줄과 맨 왼쪽줄을 제외하고 검사를 하기 때문에 해당 부분에 1값이 있는지 확인해줘야한다. 코드를 보면 다음과 같다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; bool visited[1002][1002]; void dfs(int x, int y){ } int solution(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; board) { int answer = 0; int h = board.size(); int w = board[0].size(); // 검사를 1,1부터 시작하기 때문에, 맨윗줄과 왼쪽줄에 1값이 있는지 검사한다. for(int i = 0; i \u0026lt; h; i++){ if(board[i][0] == 1) { answer = 1; break; } } for(int i = 0; i \u0026lt; w; i++){ if(board[0][i] == 1) { answer = 1; break; } } // DP를 이용하여 최대 넓이를 구한다. for(int i = 1; i \u0026lt; h; i++){ for(int j = 1; j \u0026lt; w; j++){ if(board[i][j] == 0) continue; // 진행하는 값이 0이라면 패스한다. board[i][j] = min(board[i-1][j-1], min(board[i-1][j],board[i][j-1])) + 1; // DP answer = max(board[i][j]*board[i][j], answer); // answer에 최대 넓이 값을 비교한다. } } return answer; }  ","id":19,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 DP를 적용하여 문제를 풀지않으면 시간 초과가 된다. 문제풀이 array[N][N] = (array[N-1][N], array[N][N-1], array[N-1][N-1]) 중 가장 작은 값 + 1 위의 점화식을 이용하여 문제를 풀면된다","tags":null,"title":"프로그래머스 - 가장 큰 정사각형 찾기","uri":"https://chlalstjd430.github.io/2020/03/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_014/","year":"2020"},{"content":" 문제링크 \n사용언어  c++  \n주의사항  카펫의 테두리는 브라운이고, 테두리를 제외한 부분은 빨간색이다. 이 조건을 통해 두가지 공식이 나온다.\n 넓이*높이 = brown + red\n (넓이 - 2)(높이 - 2) = red\n -2인 이유는, 높이의 경우 전체 높이에서 맨 위,아래 칸(테두리)을 뺀 값이고, 넓이의 경우 맨 왼쪽,오른쪽 칸(테두리)을 뺀 값이기 때문이다.\n   \n문제풀이 위 조건을 통해 넓이와 높이는 최소 3부터 시작되는 것을 알 수 있다. 그리하여 높이를 3부터 시작하여 차례대로 탐색하여 위 공식에 부합되는 값들을 구하면 된다. 코드는 다음과 같다.\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; solution(int brown, int red) { vector\u0026lt;int\u0026gt; answer; int sum = brown + red; for(int i = 3; i \u0026lt; sum; i++ ){ if(sum % i == 0){ int height = i; int weight = sum/height; if((height - 2)*(weight - 2) == red){ answer.push_back(weight); answer.push_back(height); break; } } } return answer; }  ","id":20,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 카펫의 테두리는 브라운이고, 테두리를 제외한 부분은 빨간색이다. 이 조건을 통해 두가지 공식이 나온다. 넓이*높이 = brown + red (넓이","tags":null,"title":"프로그래머스 - 카펫","uri":"https://chlalstjd430.github.io/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_013/","year":"2020"},{"content":" \n백준 문제 바로가기 \n사용 언어  C++  적용 알고리즘  브루트 포스\n DFS\n  주의사항  크기가 양수인 부분수열 중에서 그 수열의 원소를 다 더한 값이 S가 되는 경우의 수  문제풀이  해당 문제는 중복되지 않는 수열 조합의 합의 문제로 볼 수 있다. 그래서 재귀를 통해 문제를 풀었는데 틀렸다고 나왔다..첫 코드는 다음과 같다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int N, S; int cnt; vector\u0026lt;int\u0026gt; v; void solution(int ind, int sum) { if (N \u0026lt;= ind) { return; } if (sum == S) { cnt++; } solution(ind + 1, sum + v[ind]); solution(ind + 1, sum); } int main() { cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; for (int i = 0; i \u0026lt; N; i++) { int tmp; cin \u0026gt;\u0026gt; tmp; v.push_back(tmp); } v.push_back(0); solution(0, 0); cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; }   왜 틀렸는지 이유를 보았더니, S가 0일때 중복해서 cnt값이 증가되는 것을 알수있다. 즉, 그래서 해당 부분을 수정하여 다시 작성하였다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int N, S; int cnt; vector\u0026lt;int\u0026gt; v; void solution(int ind, int sum) { if (N \u0026lt;= ind) { return; } if (sum + v[ind] == S) { cnt++; } solution(ind + 1, sum + v[ind]); solution(ind + 1, sum); } int main() { cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; S; for (int i = 0; i \u0026lt; N; i++) { int tmp; cin \u0026gt;\u0026gt; tmp; v.push_back(tmp); } v.push_back(0); solution(0, 0); cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; }  sum과 S를 비교하는 if문에서 sum 대신에 sum + v[ind]를 비교하며 앞서 틀렸던 오류를 해결하였다. 현재 sum이 아닌 다음 sum값을 미리 비교하므로 어떠한 수도 조합하지 않았을 때 비교하는 경우는 없을 것이다.\n","id":21,"section":"posts","summary":"백준 문제 바로가기 사용 언어 C++ 적용 알고리즘 브루트 포스 DFS 주의사항 크기가 양수인 부분수열 중에서 그 수열의 원소를 다 더한 값이 S가 되는 경우의 수 문제풀이 해당 문제","tags":["브루트 포스트"],"title":"백준 1182 - 부분수열의 합","uri":"https://chlalstjd430.github.io/2020/02/%EB%B0%B1%EC%A4%801182/","year":"2020"},{"content":" 문제링크 \n사용언어  c++  \n주의사항  stock에 있는 밀가루는 오늘(0일 이후)부터 사용됩니다.\n stock과 k는 2 이상 100,000 이하입니다.\n dates의 각 원소는 1 이상 k 이하입니다.\n supplies의 각 원소는 1 이상 1,000 이하입니다.\n dates와 supplies의 길이는 1 이상 20,000 이하입니다.\n k일 째에는 밀가루가 충분히 공급되기 때문에 k-1일에 사용할 수량까지만 확보하면 됩니다.\n dates에 들어있는 날짜는 오름차순 정렬되어 있습니다.\n dates에 들어있는 날짜에 공급되는 밀가루는 작업 시작 전 새벽에 공급되는 것을 기준으로 합니다. 예를 들어 9일째에 밀가루가 바닥나더라도, 10일째에 공급받으면 10일째에는 공장을 운영할 수 있습니다. 밀가루가 바닥나는 경우는 주어지지 않습니다.\n  \n문제풀이 해당 문제는 우선순위 큐를 이용하여 풀 수 있다. 우선순위 큐를 통해 stock이 k값을 넘어갈때까지 자신이 공급받을 수 있는 밀가루를 공급받으면 된다. 이를 코드로 표현하면 다음과 같다.\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; int solution(int stock, vector\u0026lt;int\u0026gt; dates, vector\u0026lt;int\u0026gt; supplies, int k) { int answer = 0; priority_queue\u0026lt;int\u0026gt; pq; int before_stock = 0; int search_index = 0; // stock이 k를 이상일떄까지 while(stock \u0026lt; k){ int dates_size = dates.size(); // 필요한 supplies를 공급받기 위해 반복문 수행 for(int i = search_index; i \u0026lt; dates_size; i++){ // supplies를 받을 수 있는 날짜의 supplies를 pq에 저장 if(before_stock \u0026lt;= dates[i] \u0026amp;\u0026amp; dates[i] \u0026lt;= stock){ search_index = i + 1; // 저장한 날짜의 인덱스 값 저장(추후 마지막으로 저장된 인덱스 값부터만 for문) pq.push(supplies[i]); } } before_stock = stock; // 이전 stock에 현재 stock을 저장 stock += pq.top(); // 현재 stock에 pq중 가장 많은 값을 저장 pq.pop(); // 사용한 supplies값을 pop answer++; // answer 추가 } return answer; }  ","id":22,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 stock에 있는 밀가루는 오늘(0일 이후)부터 사용됩니다. stock과 k는 2 이상 100,000 이하입니다. dates의 각 원소는 1","tags":null,"title":"프로그래머스 - 라면 공장","uri":"https://chlalstjd430.github.io/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_012/","year":"2020"},{"content":" 문제링크 \n사용언어  c++  \n주의사항  숫자는 1~9까지만 존재한다\n 동일한 숫자는 없다\n  \n문제풀이 일단 문제에서 답이될 수는 123~987에서 0을 포함하거나, 동일한 숫자가 있는 경우를 제외한 모든 숫자가 처음에 답이 될 수 있다. 이후 baceball에 담겨있는 숫자와 스트라이크,볼 정보를 통해 숫자들을 다 비교하며 답이 될 수 없는 수는 완전히 제외 하다보면 답이 될 수있는 수의 개수를 구할 수 있다.\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int solution(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; baseball) { int answer = 0; int baseball_size = baseball.size(); vector\u0026lt;string\u0026gt; answers; // 가능한 모든 경우의 수 추가 for(int i = 123; i \u0026lt;= 987; i++){ string number = to_string(i); // 숫자에 0이 들어가있거나 동일한 숫자가 들어있으면 추가X if(number[1] == '0' || number[2] == '0' || number[0] == number[1] || number[1] == number[2] || number[0] == number[2]){ continue; } answers.push_back(number); } // baseball에 담긴 for(int i = 0; i \u0026lt; baseball_size; i++){ string number = to_string(baseball[i][0]); int answers_size = answers.size(); for(int j = answers.size() - 1; j \u0026gt;= 0; j--){ int strike = 0; int ball = 0; string check = answers[j]; for(int k = 0; k \u0026lt; 3; k++){ if(number[k] == check[k]){ strike++; } if(number[k] == check[(k+1)%3] || number[k] == check[(k+2)%3]){ ball++; } } if(baseball[i][1] == strike \u0026amp;\u0026amp; baseball[i][2] == ball) continue; answers.erase(answers.begin() + j); } } answer = answers.size(); return answer; }  ","id":23,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 숫자는 1~9까지만 존재한다 동일한 숫자는 없다 문제풀이 일단 문제에서 답이될 수는 123~987에서 0을 포함하거나, 동일한 숫","tags":null,"title":"프로그래머스 - 숫자 야구","uri":"https://chlalstjd430.github.io/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_011/","year":"2020"},{"content":" 문제링크 \n사용언어  c++  \n주의사항  서로 다른 옷의 조합의 수를 구하는 공식을 생각해보자.  \n문제풀이 처음에 공식을 생각하지 않은 채, 재귀로 조합으로 경우의 수를 구하여 시간초과가 났다. 이에 다른 풀이법이 있을 것을 예상하고 일정한 공식을 찾아보았다.\n 옷의 종류가 얼굴, 상의, 하의 인 경우\n  (얼굴 개수 + 1)(상의 개수 + 1)(하의 개수 + 1) - 1 이다\n 여시서 (+ 1)은 해당 옷을 입지않은 경우고, 마지막에 있는 (-1)은 전체 옷을 아무것도 안입을 떄이다.   즉, 해당 공식을 코드로 표현하면 다음과 같다.\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;map\u0026gt; using namespace std; int solution(vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; clothes) { int answer = 1; map\u0026lt;string, int\u0026gt; m; vector\u0026lt;string\u0026gt; order; // 중보되는 옷을 구한다 int clothes_size = clothes.size(); for (int i = 0; i \u0026lt; clothes_size; i++) { if (m[clothes[i][1]] == 0) { m[clothes[i][1]]++; order.push_back(clothes[i][1]); continue; } m[clothes[i][1]]++; } // 공식 수행 for (int i = 0; i \u0026lt; order.size(); i++) { answer = answer * (m[order[i]] + 1); } answer -= 1; return answer; }  ","id":24,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 서로 다른 옷의 조합의 수를 구하는 공식을 생각해보자. 문제풀이 처음에 공식을 생각하지 않은 채, 재귀로 조합으로 경우의 수를 구하여 시","tags":null,"title":"프로그래머스 - 위장","uri":"https://chlalstjd430.github.io/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_010/","year":"2020"},{"content":" 문제링크 \n사용언어  c++  \n주의사항  종이접기를 진행할 떄마다 생기는 규칙을 찾아야한다.  \n문제풀이 문제의 예제만으로는 규칙을 찾기 어려워 n=4일 떄 값을 직접 구해보아 규칙을 찾기로 하였다. n=4일 떄 값을 구하니 규칙이 보이기 시작하였다, 내가 세운 규칙은 다음과 같다.\n n = 1, 0\nn = 2, 0 0 1\nn = 3, 001 0 011\nn = 4, 0010011 0 0011011\n 위 규칙을 해석하면 다음과 같다.\n 종이를 접었을 때 나오는 결과의 가운데는 항상 0(\u0026lsquo;V\u0026rsquo;)이다.\n n = n-1 +\u0026lsquo;0\u0026rsquo; + (n-1의 가운데가 1인 값) 이다.\n 즉, 가운제를 기준으로 왼쪽은 이전에 접었던 결과와 같고, 오른쪽은 이전에 접었던 결과에서 가운데만 1(\u0026lsquo;ㅅ\u0026rsquo;)인 값이다.   위의 규칙을 코드로 작성하면 다음과 같다.\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; solution(int n) { vector\u0026lt;int\u0026gt; answer; if(n == 1) { answer.push_back(0); return answer; } if(n == 2){ answer.push_back(0); answer.push_back(0); answer.push_back(1); return answer; } string result = \u0026quot;001\u0026quot;; for(int i = 3; i \u0026lt;= n; i++){ string tmp = result; string tmp2 = result; tmp2[result.size()/2] = '1'; result = tmp + '0' + tmp2; } int result_size = result.size(); for(int i = 0; i \u0026lt; result_size; i++){ answer.push_back(result[i] - '0'); } return answer; }  ","id":25,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 종이접기를 진행할 떄마다 생기는 규칙을 찾아야한다. 문제풀이 문제의 예제만으로는 규칙을 찾기 어려워 n=4일 떄 값을 직접 구해보아","tags":null,"title":"프로그래머스 - 종이접기","uri":"https://chlalstjd430.github.io/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_009/","year":"2020"},{"content":" 문제링크 \n사용언어  c++  \n주의사항  어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다.\n 조합하여 가장 큰 수가 아닌 숫자 순서를 유지하며 k개의 수를 제거하는 것을 의미한다.   \n문제풀이 처음 문제를 풀 떄 조합을 하여 가장 큰수 인줄 알았지만, 숫자 순서를 유지한채 k개의 수를 제거하는 문제였다. 문제를 풀기 위해 어떻게 해야 가장 큰수를 구할지 생각해보았다. 먼저, answer의 길이 = (number의 길이 - k) 이다. 그러므로 answer의 길이 를 number의 길이 - k 만큼 보장한다는 전제하여 앞에서부터 가장 큰 수를 선택하면 된다. 해당 과정을 단계별로 설명하면 다음과 같다.\n 0 부터 number.size - (number.size() - k) 까지 중에 가장 큰 수 선택하여 answer에 추가\n k를 1만큼 감소\n 1,2 과정을 number.size() - k가 0이 될 때까지 혹은 answer의 길이가 초기의 number의 길이 - k 와 같을 때까지 진행한다.\n 이후 answer의 길이가 초기의 number의 길이 - k 와 같지 않다면 이전에 저장한 큰 수의 인덱스부터 number의 끝까지 answer의 뒤에 추가해준다.\n  이를 코드로 표현하면\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; string solution(string number, int k) { string answer = \u0026quot;\u0026quot;; int number_size = number.size(); int value = -1; int value_ind; int kk = k; int default_last = number_size - k; k= number_size - k; for(int i = 0; i \u0026lt;= (number_size - k); i++){ if(answer.size() == default_last) break; if(k == 0) { break; } int tmp = number[i] - '0'; if(value \u0026lt; tmp){ value = tmp; value_ind = i; } if(i == (number_size - k)){ i = value_ind; value = -1; --k; answer += number[value_ind]; } } answer += number.substr(value_ind+1); return answer; }  ","id":26,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다. 조합하여 가장 큰 수가 아닌 숫자 순서를 유지하며 k개의","tags":null,"title":"프로그래머스 - 큰 수 만들기","uri":"https://chlalstjd430.github.io/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_008/","year":"2020"},{"content":" 문제링크 \n사용언어  c++  \n주의사항  1,2,4 숫자가 반복 진행 되므로 3진법을 구하는 방법과 비슷하게 진행하면 된다.  \n문제풀이  124 나라에서는 10진법 124 수로 표현되는 과정을 보자.\n 3으로 몫을 계속해서 나누고 나머지가 0일 떄 몫을 -1 한다.\n11(10진법)일 때 11/3 = 3 ... 2 3/3 = 1 -1 ... 0 // 나머지가 0이므로 몫을 -1한다. 나머지들을 밑에서부터 나열하면 02가 된다. 9(10진법) 9/3 = 3 - 1 ... 0 2/3 = 0 ... 2 나머지들을 밑에서부터 나열하면 20가 된다.    여기서 0을 4라고 생각하면 답은 순서대로 42, 24가 된다.\n그러면 위와 같은 식을 코드로 구현해보자.\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; string solution(int n) { string answer = \u0026quot;\u0026quot;; char num[3] = {'4', '1', '2'}; // 나머지를 인덱스로하는 실제값 while(true){ if(n == 0){ break; } else{ int tmp = n%3; answer = num[tmp] + answer; n /= 3; if(tmp == 0) n--; } } return answer; }  위 코드와 과정을 이해하였다면 어떠한 진법 변환 문제도 적용할 수 있을 것이다 :D\n","id":27,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 1,2,4 숫자가 반복 진행 되므로 3진법을 구하는 방법과 비슷하게 진행하면 된다. 문제풀이 124 나라에서는 10진법 124 수로 표현되는 과정을 보","tags":null,"title":"프로그래머스 - 124 나라의 숫자","uri":"https://chlalstjd430.github.io/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_007/","year":"2020"},{"content":" Chapter 09 - 단위 테스트 사실 단위 테스트는 한 챕터로 설명하기에 부족한면이 없지않아 있다. 해당 챕터는 추후에 정리할 \u0026ldquo;자바와 JUnit을 활용한 실용주의 단위 테스트\u0026rdquo;라는 책을 가지고 정리해가며 공부할 때 더 다뤄볼 예정이다. 그러므로 해당 챕터는 생략하겠다.\n","id":28,"section":"posts","summary":"Chapter 09 - 단위 테스트 사실 단위 테스트는 한 챕터로 설명하기에 부족한면이 없지않아 있다. 해당 챕터는 추후에 정리할 \u0026ldquo;자바와 JUnit을 활용한 실용주","tags":["클린코드"],"title":"Chapter 09 - 단위 테스트","uri":"https://chlalstjd430.github.io/2020/02/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C_009/","year":"2020"},{"content":" 알고리즘 문제를 풀면서 어떠한 문제를 풀 때 어떠한 알고리즘을 적용해야하는 특징이 보이는 경우가 있다. 그래서 그러한 특징들이 보일 떄 마다 정리하려고 한다.\n알고리즘 특징 1. DFS(깊이 우선 탐색) vs BFS(넓이 우선 탐색)\nDFS/BFS는 그래프 문제의 대표적인 알고리즘이라 많은 사람들이 많이들 접해봤을 거라 생각한다. 사실 DFS로만 BFS로만 문제를 풀어야하는 경우는 거의 없다. 왠만하면 두 알고리즘 적용이 다 가능하다. 그래서 필자같은 경우에도 특별하게 메모리 초과가 날 것 같지않으면 DFS가 편해 DFS로 문제를 거의 푼다.\n DFS\n 재귀or스택을 이용하여 구현한다.\n 나는 주로 재귀를 통해 구현한다.\n  BFS\n 큐를 이용하여 구현한다.\n 나는 주로 최단 경로를 탐색할 떄 많이 적용한다.\n 가중치 없는 그래프의 최단 경로문제는 BFS로만 접근해야 한다고 한다.\n   \n2. Dynamic Programming(다이나믹 프로그래밍)\n일정한 규칙을 가지고 결과를 도출하는 문제들은 거의 DP이다. 사실 DP에서 점화식 만 구하면 어지간하면 답을 구하지만 처음 보는 문제의 점화식을 구하기는 절대 쉽지 않다. 그래서 내가 느끼기엔 더 많은 문제를 계속해서 풀어봐야 하는 것 같다.\n\n3. Greedy Algorithm(탐욕 알고리즘)\n코딩 테스트 및 여러가지 알고리즘 문제에서 대표적인 알고리즘이다. 해당 문제를 풀기 위해서는 정렬,자료구조 개념이 있으면 좋을 것 같다.\n\n3. Kruskal Algorithm(크루스칼 알고리즘)\n보통 최소 신장 트리의 구현(MST) 방법으로 채택되는 알고리즘이다.즉, 가장 적은 비용으로 모든 노드를 연결하기 위해 사용되는 알고리즘이다. 크루스칼 알고리즘에서는 Union-Finde(합집합 찾기) 를 사용한다.\n\n4. Dijkstra Algorithm(다익스트라 알고리즘)\n하나의 정점에서 다른 모든 정점까지의 최단 경로 를 구하는 문제에 사용된다. 보통 우선순위 큐(Priority Queue)를 활용해서 문제를 푼다.\n\n5. Floyd Warshall Algorithm(플로이드 와샬 알고리즘)\n다익스트라는 하나의 정점에서 다른 모든 정점이라면, 플로이드 와샬은 모든 정점에서 다른 모든 정점의 최단 경로 를 구하는 문제에 사용된다.\n\n6. Topological Sorting(위상 정렬)\n\n7. Strongly Connected Component(강한 결합 요소)\n\n","id":29,"section":"posts","summary":"알고리즘 문제를 풀면서 어떠한 문제를 풀 때 어떠한 알고리즘을 적용해야하는 특징이 보이는 경우가 있다. 그래서 그러한 특징들이 보일 떄 마다 정리하려고 한다. 알고리","tags":["알고리즘"],"title":"알고리즘 특징정리","uri":"https://chlalstjd430.github.io/2020/02/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%ED%8A%B9%EC%A7%95%EC%A0%95%EB%A6%AC/","year":"2020"},{"content":" 문제링크 \n사용언어  c++  \n주의사항  문제의 제한사항을 주의깊게 보자\n 제한사항\n 전체 학생의 수는 2명 이상 30명 이하입니다.\n 체육복을 도난당한 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다.\n 여벌의 체육복을 가져온 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다.\n 여벌 체육복이 있는 학생만 다른 학생에게 체육복을 빌려줄 수 있습니다.\n 여벌 체육복을 가져온 학생이 체육복을 도난당했을 수 있습니다. 이때 이 학생은 체육복을 하나만 도난당했다고 가정하며, 남은 체육복이 하나이기에 다른 학생에게는 체육복을 빌려줄 수 없습니다.(이 제한사항이 중요한 것 같다)\n   \n문제풀이 처음 문제를 풀었을 때 제한사항 중 마지막 부분을 읽지 못하고 문제를 풀어 답이 틀렸다고 나왔다, 이후 어떤점이 문제가 있었는지 알기 위해 문제를 다시 읽어보았고 제한사항에서 놓친 부분이 있다는 것을 알게되어서 코드를 수정하고 제출하여 정답을 맞았다.\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int solution(int n, vector\u0026lt;int\u0026gt; lost, vector\u0026lt;int\u0026gt; reserve) { int answer = 0; vector\u0026lt;int\u0026gt; v(n+2,1); // 0~n+1까지 체육복 개수를 1로 초기화 // 체육복을 잃어버린 학생의 체육복 개수 1 감소 int lostSize = lost.size(); for(int i = 0; i \u0026lt; lostSize; i++){ v[lost[i]]--; } // 여분의 체육복을 가진 학생의 체육복 개수 1 증가 int reserveSize = reserve.size(); for(int i = 0; i \u0026lt; reserveSize; i++){ int ind = reserve[i]; v[ind]++; } for(int i = 0; i \u0026lt; reserveSize; i++){ int ind = reserve[i]; // 제한사항 마지막 부분에 해당하는 학생은 넘어간다. if(v[ind] \u0026lt; 2) continue; // 체육복은 앞에 있는 학생 먼저 나눠주고 앞에 학생이 체육복이 있다면 뒤에 학생을 확인한다. if(v[ind-1] == 0) v[ind-1]++; else if(v[ind+1] == 0) v[ind+1]++; } // 체육복을 가지고 있는 학생 수만큼 answer를 증가시킨다 for(int i = 1; i \u0026lt;= n; i++){ if(v[i] != 0) { answer++; } } return answer; }  ","id":30,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 문제의 제한사항을 주의깊게 보자 제한사항 전체 학생의 수는 2명 이상 30명 이하입니다. 체육복을 도난당한 학생의 수는 1명 이상 n명","tags":null,"title":"프로그래머스 - 체육복","uri":"https://chlalstjd430.github.io/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_006/","year":"2020"},{"content":" \n백준 문제 바로가기 \n사용 언어  C++  적용 알고리즘  그리디 알고리즘\n 정렬\n  주의사항  재귀를 통해 순열을 구하여 정답을 찾았지만 메모리 초과가 나왔다.  문제풀이 초기에 순열을 통해 문제를 풀었지만 메모리 초과가 나와 다른 방법을 찾아보았다. 그 결과 30의 배수가 되기 위해서 두 가지 조건을 가져야 한다는 것을 알게 되었다.\n 마지막 일의 자리는 무조건 0이 되어야 한다.\n 마지막 숫자를 제외한 나머지 숫자들의 합은 3의 배수이다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; vector\u0026lt;char\u0026gt; v; bool cmp(char c1, char c2) { return c1 \u0026gt; c2; } int main() { string str = \u0026quot;\u0026quot;; string answer = \u0026quot;\u0026quot;; int sum = 0; cin \u0026gt;\u0026gt; str; int strSize = str.size(); for (int i = 0; i \u0026lt; strSize; i++) { v.push_back(str[i]); } // 큰 숫자대로 정렬 sort(v.begin(), v.end(), cmp); // 마지막 숫자가 0이 아니면 30의 배수가 될 수 없다. if (v[strSize - 1] != '0') { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; return 0; } // 모든 수의 합을 구한다. for (int i = 0; i \u0026lt; strSize; i++) { sum += v[i] - '0'; answer += v[i]; } if (sum % 3 == 0) { cout \u0026lt;\u0026lt; answer \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; } }   ","id":31,"section":"posts","summary":"백준 문제 바로가기 사용 언어 C++ 적용 알고리즘 그리디 알고리즘 정렬 주의사항 재귀를 통해 순열을 구하여 정답을 찾았지만 메모리 초과가 나왔다. 문제풀이 초기에 순열을","tags":["그리디 알고리즘"],"title":"백준 10610 - 30","uri":"https://chlalstjd430.github.io/2020/02/%EB%B0%B1%EC%A4%8010610/","year":"2020"},{"content":" JWT(JSON Web Token) 프로젝트를 진행 중 모바일에서 로그인 API를 제공해야 될 일이 생겼다. 기존에 웹에서 프로젝트를 할 때는 session 정보를 이용하여 로그인 기능을 제공하였는데 모바일 환경에서 JWT를 이용하여 로그인 API를 제공한다는 것을 알게되고 실제 프로젝트에 적용해봤다. 프로젝트가 끝난 이후 JWT에 대헤서 다시 한번 상기시키고 문서로 개념을 정리해보려고 한다.\n\n1. JWT란?  JWT란 JSON Web Token의 약자로 Json 포맷을 이용하여 Claim(사용자 정보나 데이터 속성 등을 의미) 정보를 디지털 서명 하고 이후 비밀 서명 키로 검증하는 Web Token입니다.\n  두 개체에서 JSON 객체를 이용해 Self-contained 방식으로 정보를 안전한게 전달\n JWT는 토큰 자체에 정보를 가지고 있다.\n 회원 인증, 정보 전달에 주로 사용\n  위의 말도 어렵다면 쉽게 정보를 가진 토큰을 통한 인증을 위해 사용된다고 이해하면 좋다.\n\n2. JWT 구조 JWT는 Header, Payload, Signature 로 3부분으로 JSON 형태를 Base64로 인코딩하여 이루져있다.\n Header\n 토큰의 첫번째 파트이다.\n 전형적으로 2가지 파트로(alg 와 typ)으로 구성되어있다.\n alg : 알고리즘 방식을 지정하며, 서명(Signature) 및 토큰 검증에 사용\n typ : 토큰의 타입\n  Payload\n 토큰의 두번째 파트이고 Claim 정보를 담고있다. Claim은 총 3가지 파트로 나누어진다.\n Claim\n Registered claims(등록된 클레임)\n  토큰 정보를 표현하기 위해 이미 정해진 종류의 데이트들이다. 모두 선택적으로 작성이 가능하며 사용할 것을 권장한다. 또한 JWT를 간결하게 위해 key는 모두 3글자이다.\n- iss : 토큰 발급자(issuer) - sub : 토큰 제목(subject) - aud : 토큰 대상자(audience) - exp : 토큰 만료 시간(expiration), NumericDate 형식으로 되어 있어야 함 ex) 1480849147370 - nbf : 토큰 활성 날짜(not before), 이 날이 지나기 전의 토큰은 활성화되지 않음 - iat : 토큰 발급 시간(issued at), 토큰 발급 이후의 경과 시간을 알 수 있음 - jti : JWT 토큰 식별자(JWT ID), 중복 방지를 위해 사용하며 일회성 토큰(Access Token) 등에 사용   토큰\n Public claims(공개 클레임)\n  충돌 방지를 위해 공개된 클레임이다. 보통 URI형식으로 짓는다.\n Private claims(비공개 클레임)  서버와 클라이언트간에 협의된 클레임 이름이다.\n  Payload의 예제로는 다음과 같습니다.\n{ // 실제 프로젝트에 적용한 AccessToken 예제 \u0026quot;sub\u0026quot;: \u0026quot;AccessToken\u0026quot;, \u0026quot;iat\u0026quot;: 1581231911, \u0026quot;exp\u0026quot;: 1581232271, \u0026quot;uid\u0026quot;: \u0026quot;21\u0026quot; }   Verify Signature  Signature(서명)은 토큰을 인코딩하거나 유효성 검증을 할 때 사용하는 고유한 암호화 코드이다. Signature는 Header와 Payload의 값을 인코딩(BASE64)하고, 이코딩한 값을 비밀 키를 이용해 Header에 정의한 알고리즘으로 해싱을 하고, 이 값을 BASE64로 인코딩하여 생산한다.\nHMACSHA256( base64UrlEncode(header) + \u0026quot;.\u0026quot; + base64UrlEncode(payload), your-256-bit-secret  \n3. JWT 장점과 단점 장점\n JWT는 발급 후 토큰 검증만 하면 되기 때문에 저장소가 필요없다.\n 세션 정보를 유지할 필요가 없어, 로드밸런싱 환경에서 유리하다.\n 토큰 기반으로 하는 다른 인증 시스템에 접근이 가능하다.\n 정보를 가지고 있어 별도의 쿼리문을 줄일 수 있다.\n  단점\n JWT는 한 번 발급되면 유효기간이 지나기 전까지 정보들을 탈취할 수 있다.\n Access Token과 Refresh Token을 이용해 피해를 줄일 수 있다.  payload 정보가 제한적이다.\n JWT는 서명에 의해 변조되지 않음을 보장할 순 있지만 데이터를 다른 사람이 볼 수 있으므로 Header나 Payload에 private한 정보는 넣지 않을 것을 권장합니다.   \n4. Access Token \u0026amp; Refresh Token 앞서 말한 JWT의 단점 중에 토큰을 탈취 당할 경우 보안에 취약하다는 단점이 있었다. 토큰의 유효기간은 길 수록 토큰이 탈취 당했을 떄 보안에 취약하게 된다. 그렇다고 토큰의 유효기간이 짧아지면 새 토큰을 발급받기 위해 로그인을 자주 시도해야 되게 된다. 이러한 문제점에서 해결 대안으로 나온 것이 Access Token과 Refresh Token 이다. 이 개념은 OAuth에서 나왔는데 이는 추후에 공부해도록 하겠다.\nAccess Token과 Refresh Token 모두 JWT 형태입니다. 로그인 완료되었을 떄 유효기간이 짧은 Access Token과 비교적 유효기간이 긴 Refresh Token을 발행합니다. Refresh Token은 Access Token의 유효기간이 만료되었을 떄 새로 Token을 발급해주는 열쇠가 됩니다.\n에를 들어보면\n 가정) Refresh Token은 유효기간이 2주, Access Token은 유효기간이 1시간이다.\n 사용자는 로그인을 하여 Refresh,Access Token을 받는다\n 사용자는 API 요청을 하다가 1시간이 지나면 Access Token이 만료된다.\n Refresh Token의 유효기간이 지나지 않았다면 새롭게 Access Token을 발급받는다.\n Refresh Token은 2주가 지나면 유효기간이 만료된다.\n 사용자는 새로 로그인을 한다.\n   위와 같은 과정을 통해 기존에 유효기간이 길 수록 보안에 취약한 Access Token으 단점을 보완하고, 유효기간을 줄일 경우 로그인을 자주 시도해야 된다는 단점을 Refresh Token으로 보완한 것을 알 수 있습니다.\n위의 예시를 조금더 자세하게 그림으로 설명하면 다음과 같습니다.\n 여기서 9~11번은 무조건적인 상황은 아니다. 클라이언트에서 Access Token의 Payload를 통해 유효기간을 알기 떄문에 API 요청전에 토큰이 만료되면 클라이언트에서 토큰 재발급을 요청할수있다.  결론적으로 Refresh Token을 통해 Access Token을 단독적으로 사용했을 때보다 보안에 좋아졌다는 점을 알 수 있다. 그러나 Access Token이 만료될 떄마다 새롭게 발급받기 위해 HTTP 요청이 많아진다는 단점이 있습니다.\n\n5. 마무리 이번 문서를 통해 JWT를 다시 정리하며 개념을 확고히 잡은 것 같습니다. 혹여나 잘못된 정보가 있으면 언제든지 댓글 달아주시면 감사하겠습니다. 다음 JWT 예제 포스팅에서 뵙도록 하겠습니다 :D\n\n참고 자료\n https://jwt.io/introduction\n https://mangkyu.tistory.com/56\n https://elfinlas.github.io/2018/08/12/whatisjwt-01/\n https://brownbears.tistory.com/440\n  ","id":32,"section":"posts","summary":"JWT(JSON Web Token) 프로젝트를 진행 중 모바일에서 로그인 API를 제공해야 될 일이 생겼다. 기존에 웹에서 프로젝트를 할 때는 session 정보를 이용하여 로그인 기능을 제공하였는데 모바","tags":["JWT"],"title":"JWT(1) - JWT(JSON Web Token)란 무엇인가?","uri":"https://chlalstjd430.github.io/2020/02/%EA%B3%B5%EB%B6%80_jwt/","year":"2020"},{"content":" Spring Webflux 최근 교내 커뮤니티 동아리 유어슈에서 Spring Webflux를 이용하여 프로젝트를 하였다. 사실 기존 동아리 스펙이 webflux로 정해져서 어쩔수 없이 새로운 프로젝트에 사용하여서 webflux가 왜 필요한지? 어떠한 장점이 있는지? 등 이해도가 부족하다는 생각이 들었다. 그래서 앞으로 webflux를 정리하고 reactive programming을 이해하하는 과정을 문서로 담아 정리하려고 한다.\n연관된 나의 글  리엑티브 프로그래밍이란?  Spring Webflux란? reactive-stack 웹 프레임워크인 Spring Webflux는 Spring 5버전부터 추가되었다. Webflux는 non-blocking을 지향하고 Reactive Streams back pressure을 지원한다. 그리고 Sprinb MVC와 Spring Webflux는 같이 사용할 수 있다.\nSpring 웹 요청을 처리하는 방식\n 요청 매핑\n 웹 요청을 어느 핸들러에게 보낼지 결정\n URL, 헤더\n @RequestMapping\n  요청 바인딩\n 핸들러에 전달할 웹 요청 준비\n 웹 URL, 헤더, 쿠키, 바디 등\n  핸들러(controller) 실행\n 전달 받은 요청 정보를 이용해 로직을 수행하고 결과를 리턴  핸들러 결과 처리(응답 생성)\n 핸들러의 리턴 값으로 웹 응답 생성\n@RestController public class MyController { @GetMapping(\u0026quot;/hello/{name}\u0026quot;) // 1. 요청 매핑 String hello(@PathVariable String name){ // 2. 요청 바인딩 return \u0026quot;Hello! \u0026quot; + name; // 3,4. 해들러 실행 후 결과 처리 } }    함수형 WebFlux가 웹 요청을 처리하는 방식\n 요청 매핑\n RouterFunction  요청 바인딩\n  -HandlerFUnction\n 핸들러 실행  -HandlerFUnction\n 핸들러 결과 처리(응답 생성)  -HandlerFUnction\nspring webflux를 사용하는 이유  비동기-논블럭킹 리엑티브 개발에 사용\n 효율적으로 등장하는 고성능 웹 애플리케이션 개발\n 서비스간 호출이 많은 마이크로서비스 아키텍처에 적합\n 새로운 방식으로 개발해보고 싶은 호기심 충족\n 발표자 토비님께서는 이를 권장하지 않는다 하셨다.  thread pool hell 발생을 저하\n 일반적으로 spring은 멀티 스레드 기반으로 동작하고, 만약 blocking IO로 진행된다면 준비된 스레드보다 더 많은 요청이 들어올 경우 thread pool hell이 발생합니다. 하지만 webflux를 사용할 경우 비동기 non-blocking IO로 서버의 코어 갯수만큼 스레드가 할당되어 사용되기 때문에, thread pool hell이 발생을 줄일 수 있습니다.  검증된 JVM과 방대한 자바 생태계를 이용할 수 있는 장점이 있습니다.\n  webflux 작동원리 지원 웹 서버/컨테이너  Sel  \n참고자료\n 스프링캠프 강의 - 토비\n20.02.07 아직 작성이 완료되지 않은 문서입니다 :D  ","id":33,"section":"posts","summary":"Spring Webflux 최근 교내 커뮤니티 동아리 유어슈에서 Spring Webflux를 이용하여 프로젝트를 하였다. 사실 기존 동아리 스펙이 webflux로 정해져서 어쩔수 없이 새로운","tags":["spring webflux"],"title":"리액티브","uri":"https://chlalstjd430.github.io/2020/02/%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_webflux/","year":"2020"},{"content":" 문제링크 \n사용언어  c++  \n\n주의사항  대각선이 지나가는 단위 정사각형의 개수를 구하는 수학적인 공식\n h + w - (h와w의 최대공약수)\n 사실 왜 이러한 공식이 나오는 지 이해는 못하였다.\n  answer의 자료형이 괜히 long long이 아니다.\n  \n문제풀이 h와 w의 최대공약수를 구하고 공식을 적용하면 문제가 나온다. 사실 공식을 알지 못하는 상태에서 다른사람들은 어떻게 문제를 풀었는지\u0026hellip;정말 대단하다.\nusing namespace std; long long solution(int w,int h) { long long answer = 1; // 최대 공약수 구하기 int gdc = 0; long long sum = (long long)w * (long long)h; int minNum = (w \u0026gt; h) ? h : w; for(int i = minNum; i \u0026gt;= i; i--){ if(w%i ==0 \u0026amp;\u0026amp; h%i == 0){ gdc = i; break; } } // 공식 적용 answer = (long long)(sum- (w+h-gdc)); return answer; }  ","id":34,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 대각선이 지나가는 단위 정사각형의 개수를 구하는 수학적인 공식 h + w - (h와w의 최대공약수) 사실 왜 이러한 공식이 나오는 지 이해","tags":null,"title":"프로그래머스 - 멀쩡한 사각형","uri":"https://chlalstjd430.github.io/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_005/","year":"2020"},{"content":" \n백준 문제 바로가기 \n사용 언어  C++  적용 알고리즘  그리디 알고리즘\n 정렬\n  문제풀이  k개의 로프를 사용하여 중량이 w인 물체를 들어올릴 때, 각각의 로프에는 모두 고르게 w/k 만큼의 중량이 걸리게 된다.\n 위의 문항을 잘 이해했다면 쉽게 문제를 풀 수 있다. w/k 만큼의 중량은 가장 적은 중량을 들어올리는 로프의 중량보다 클수 없다. 그러므로 가장 작은 중량을 들어올리는 로프부터 차례대로 보다 큰 중량을 들어올리는 로프들을 함께 사용하여 가장 많은 중량을 올리는 게 답이 될 수 있다. 말이 어려울 수 있는데 코드를 보며 이해해보도록 하자.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int main() { int tc = 0; int maxWeight = 0; // 들어올릴수 있는 가장 큰 중량의 값을 저장하는 변수 vector\u0026lt;int\u0026gt; lope; // 로프의 중량을 담는다 cin \u0026gt;\u0026gt; tc; for (int i = 0; i \u0026lt; tc; i++) { int weight; cin \u0026gt;\u0026gt; weight; lope.push_back(weight); } // 중량이 적은 순서대로 정렬한다. sort(lope.begin(), lope.end()); // i번째 로프 부터 i+1~tc의 로프를 함께 이용하여 들어올리는 중량의 값을 구하여 더 큰 중량의 값을 저장한다. for (int i = 0; i \u0026lt; tc; i++) { maxWeight = max(maxWeight, lope[i] * (tc - i)); } cout \u0026lt;\u0026lt; maxWeight \u0026lt;\u0026lt; endl; }  ","id":35,"section":"posts","summary":"백준 문제 바로가기 사용 언어 C++ 적용 알고리즘 그리디 알고리즘 정렬 문제풀이 k개의 로프를 사용하여 중량이 w인 물체를 들어올릴 때, 각각의 로프에는 모두 고르게 w/k 만","tags":["그리디 알고리즘"],"title":"백준 2217 - 로프","uri":"https://chlalstjd430.github.io/2020/02/%EB%B0%B1%EC%A4%802217/","year":"2020"},{"content":" \n백준 문제 바로가기 \n사용 언어  C++  적용 알고리즘  그리디 알고리즘\n 정렬\n  주의사항  문제의 주어진 조건을 잘 파악하고 경우의 수를 나누어야 한다.  문제풀이  문제의 내용과 조건을 보면 3가지의 경우에 한해서 답을 구할 수있다.   가장 싼 세트 가격으로 구매했을 경우\n 가장 싼 세트 가격과 가장 싼 낱개 가격으로 구매했을 경우\n 가장 싼 낱개 가격으로 구매했을 경우\n   가장 싼 세트 가격과 낱개 가격은 sort를 통해 쉽게 구할 수 있다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; bool compare(pair\u0026lt;int, int\u0026gt; p1, pair\u0026lt;int, int\u0026gt; p2) { return p1.second \u0026lt; p2.second; } int main() { int N, M; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; vector\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; brand; int minMoney = 987654321; for (int i = 0; i \u0026lt; M; i++) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; brand.push_back(make_pair(a, b)); } // 1. 모든 기타줄을 세트로만 구매했을 때 sort(brand.begin(), brand.end()); int setPrice = brand[0].first; // 가장 저렴한 세트의 가격 int setCnt = N / 6; // 세트로 나눠지는 개수 int piece = N % 6; // 세트로 나눠지고 남는 낱개 개수 minMoney = (piece == 0) ? setCnt * setPrice : (setCnt + 1)*setPrice; // 세트 개수로 나누어졌을 때 // 2. 세트 + 낱개로 구매했을 때 sort(brand.begin(), brand.end(), compare); minMoney = min(minMoney, setPrice*setCnt + piece * brand[0].second); // 3. 모든 기타줄을 낱개로만 구매했을 때 minMoney = min(minMoney, brand[0].second*N); cout \u0026lt;\u0026lt; minMoney \u0026lt;\u0026lt; endl; }   ","id":36,"section":"posts","summary":"백준 문제 바로가기 사용 언어 C++ 적용 알고리즘 그리디 알고리즘 정렬 주의사항 문제의 주어진 조건을 잘 파악하고 경우의 수를 나누어야 한다. 문제풀이 문제의 내용과 조건","tags":["그리디 알고리즘"],"title":"백준 1049 - 기타줄","uri":"https://chlalstjd430.github.io/2020/02/%EB%B0%B1%EC%A4%801049/","year":"2020"},{"content":" Chapter 08 - 경계 외부에서 사용하느 코드 또한 우리 내부코드와 \u0026ldquo;깨끗하게\u0026rdquo; 통합시켜야 한다.\n\n1. 서드파티 코드 사용하기  서드파티란?\n Map같은 경우 가급적이면 Wrapping을 하여 사용하자.\n 공개된 API에서 인자로 받거나 리턴하지 마라.   \n2. 경계를 탐험하고 공부하기  서드파티를 사용할 때 우리가 사용할 코드에 대헤서는 충분히 테스트 할 필요가 있다.\n 테스트는 값어치를 한다.\n 메인 로직에 영향을 주지 않으며 서드파티 코드를 이해할 수 있다.\n 이러한 테스트는 새 버전으로 이전에 도움을 준다.\n   \n3. 아직 존재하지 않는 코드 사용하기  아직 개발되지 않은 모듈이 필요한데, 기능은 커녕 인터페이스조차 구현되지 않은 경우가 있다.\n 필요한 인터페이스를 만들어 활용하자(임시)   \n결론  서드파티를 이용할 때 내부코드와 \u0026ldquo;깨끗하게\u0026rdquo; 통합시키자\n 서드파티 코드를 충분히 테스트하며 연습하자.\n  ","id":37,"section":"posts","summary":"Chapter 08 - 경계 외부에서 사용하느 코드 또한 우리 내부코드와 \u0026ldquo;깨끗하게\u0026rdquo; 통합시켜야 한다. 1. 서드파티 코드 사용하기 서드파티란? Map","tags":["클린코드"],"title":"Chapter 08 - 경계","uri":"https://chlalstjd430.github.io/2020/02/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C_008/","year":"2020"},{"content":" 문제링크 \n사용언어  c++  \n\n주의사항  큐와 우선순위 큐의 개념에 알고있어야 한다.\n 우선순위 큐는 항상 값이 높은 것을 앞으로 보낸다.   \n문제풀이 언뜻 보면 굉장히 쉬워보였는데, 정작 문제를 풀지 못하였다. 우선순위 큐를 활용해서 어찌저찌해서 풀 수 있을 것 같은데 방법이 생각이 안났다.\n문제는 큐 와 우선순위 큐 를 이용하면 간단하게 풀 수 있었다. 코드의 주석을 통해 설명하겠다.\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int solution(vector\u0026lt;int\u0026gt; priorities, int location) { int answer = 0; // 큐와 우선순위 큐를 적절히 활용하는게 이번 풀이의 핵심이다. queue\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; q; priority_queue\u0026lt;int\u0026gt; pq; // 큐에는 인덱스와 우선순위 정보를 차례대로, 우선순위 큐에는 우선순위 정보만을 담는다. for(int i = 0; i \u0026lt; priorities.size(); i++){ q.push(make_pair(i, priorities[i])); pq.push(priorities[i]); } int index = 1; while(!q.empty()){ // 현재 큐의 우선순위 값과 우선순위 큐의 값이 일치하다면 if(q.front().second == pq.top()){ // 현재 큐의 인덱스 정보와 찾고자하는 인덱스 정보가 일치할 경우 index값을 answer에 저장하고 while문을 종료한다. if(location == q.front().first){ answer = index; break; } // 그렇지 않은 경우 index를 증가시켜주고, q와 pq를 pop시켜준다. else{ index++; q.pop(); pq.pop(); } } // 현재 큐의 우선순위 값과 우선순위 큐의 값이 불일치하다면 현재 큐의 우선순위보다 더 높은게 뒤에 있다는 소리이므로 현재 큐의 값들을 뒤로 빼준다. else{ q.push(q.front()); q.pop(); } } return answer; }  ","id":38,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 큐와 우선순위 큐의 개념에 알고있어야 한다. 우선순위 큐는 항상 값이 높은 것을 앞으로 보낸다. 문제풀이 언뜻 보면 굉장히 쉬워보였는데","tags":null,"title":"프로그래머스 - 프린터","uri":"https://chlalstjd430.github.io/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_004/","year":"2020"},{"content":" \n백준 문제 바로가기 \n사용 언어  C++  적용 알고리즘  그리디 알고리즘\n 정렬\n  주의사항  처음 문제 풀 때 재귀를 통해 풀었으나 시간초과가 날 뿐더러 답도 틀렸었다..\n 답은 왜 틀렸는지 의문이다.   문제풀이 해당 문제는 다음과 같은 과정을 거치면 풀 수 있다.\n 회의가 끝나는 시간으로 정렬한다.(회의 끝나 시간이 작은게 앞으로)   끝나는 시간이 서로 같을 경우에는 회의의 시작시간으로 정렬한다.\n 위와 같이 정렬하는 이유는 회의 시작시간과 끝나는 시간이 같은 값이 있을 경우 더 많은 회의를 잡을 수 있기 때문이다.    가장 회의가 빨리 끝나는 회의가 첫 회의가 된다. 첫 회의의 끝나는 시간을 저장한다.\n 이후 for문을 돌리며 끝나는 회의시간 이후에 시작되는 회의시간을 차례대로 저장하며 count를 센다.\n  코드 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; vector\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; room; bool compare(pair\u0026lt;int, int\u0026gt; \u0026amp;p1, pair\u0026lt;int, int\u0026gt; \u0026amp;p2) { if (p1.second == p2.second) { return p1.first \u0026lt; p2.first; } return p1.second \u0026lt; p2.second; } int main() { int tc; cin \u0026gt;\u0026gt; tc; for (int i = 0; i \u0026lt; tc; i++) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; room.push_back(make_pair(a, b)); } sort(room.begin(), room.end(), compare); int cnt = 0; int end = 0; for (int i = 0; i \u0026lt; tc; i++) { if (end \u0026lt;= room[i].first) { end = room[i].second; cnt++; } } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; }  ","id":39,"section":"posts","summary":"백준 문제 바로가기 사용 언어 C++ 적용 알고리즘 그리디 알고리즘 정렬 주의사항 처음 문제 풀 때 재귀를 통해 풀었으나 시간초과가 날 뿐더러 답도 틀렸었다.. 답은 왜 틀렸는","tags":["그리디 알고리즘"],"title":"백준 1931 - 회의실 배정","uri":"https://chlalstjd430.github.io/2020/02/%EB%B0%B1%EC%A4%801931/","year":"2020"},{"content":" Study TODO 리스트 이것도 공부하고 싶고, 저것도 공부하고 싶고 공부하고 싶은 내용들이 너무 많다\u0026hellip; 그래서 Study todo 리스트를 만들어보았다. 단기간 내에 모든 것을 하기 힘들겠지만 너무 조급해하지않고 차근차근 하나씩 공부해볼 예정이다.\n1. Spring\n spring의 내부적인 개념\n spring webflux\n 유어슈 프로젝트 코드 공부\n reactive stream method 정리\n  spring batch\n  2. CI/CD\n 프로젝트에 적용해보기  3. Multi-Module 공부\n Multi-Module에 대하여 학습하고 프로젝트에 적용해보고 싶다.  4. Clean code\n 클린코드 정리중  5. DB 공부\n MySQL\n 효율적인 ERM 작성을 위한 공부   6. HTTP 완벽 가이드(책) 공부\n 추후에 스터디를 열어볼까 생각중..  7. 알고리즘 공부\n 스터디 진행중(01.01 ~ 02.29)  8. 코틀린 공부\n 유어슈 프로젝트 때 코틀린으로 개발을 하였는데, 자바가 주언어여서 아직 서투르다..\n yapp에서 스터디 예정\n  9. 도커 공부\n 생활코딩  10. AWS 공부\n 생활코딩\n 프리티어 버전으로 약간 경험보긴 했지만 정말 약간이라 더 학습이 필요하다.\n  11. TDD\n yapp에서 스터디 예정  12. 운영체제\n 학교 수업을 통해 공부할 예정  ","id":40,"section":"posts","summary":"Study TODO 리스트 이것도 공부하고 싶고, 저것도 공부하고 싶고 공부하고 싶은 내용들이 너무 많다\u0026hellip; 그래서 Study todo 리스트를 만들어보았다. 단기간 내에 모든 것","tags":["계획"],"title":"2020 학습하고 싶은 공부","uri":"https://chlalstjd430.github.io/2020/02/2020%EA%B3%84%ED%9A%8D_002/","year":"2020"},{"content":" Chapter 07 - 에러 핸들링 \n1. 리턴 코드 대신에 Exception을 사용하자! 기존에 flag를 이용하여 에러 코드를 리턴하거나 호출하는 측에서 예외처리를 하였다. 이런 방식은 예외처리를 잊어버리기 쉽고 로직을 헷갈리게 한다.\n\n// Bad public class DeviceController { ... public void sendShutDown() { DeviceHandle handle = getHandle(DEV1); // Check the state of the device if (handle != DeviceHandle.INVALID) { // Save the device status to the record field retrieveDeviceRecord(handle); // If not suspended, shut down if (record.getStatus() != DEVICE_SUSPENDED) { pauseDevice(handle); clearDeviceWorkQueue(handle); closeDevice(handle); } else { logger.log(\u0026quot;Device suspended. Unable to shut down\u0026quot;); } } else { logger.log(\u0026quot;Invalid handle for: \u0026quot; + DEV1.toString()); } } ... } // Good public class DeviceController { ... public void sendShutDown() { try { tryToShutDown(); } catch (DeviceShutDownError e) { logger.log(e); } } private void tryToShutDown() throws DeviceShutDownError { DeviceHandle handle = getHandle(DEV1); DeviceRecord record = retrieveDeviceRecord(handle); pauseDevice(handle); clearDeviceWorkQueue(handle); closeDevice(handle); } private DeviceHandle getHandle(DeviceID id) { ... throw new DeviceShutDownError(\u0026quot;Invalid handle for: \u0026quot; + id.toString()); ... } ... }  \n2. Try-Catch-Finally문을 먼저 쓰자  이로써 \u0026ldquo;Scrope 정의\u0026rdquo;가 가능하다.\n ▽ 잘못된 input을 넣을 경우 StorageException을 제대로 던지는지 확인하는 테스트 코드\n// Step 1: StorageException을 던지지 않으므로 이 테스트는 실패한다. @Test(expected = StorageException.class) public void retrieveSectionShouldThrowOnInvalidFileName() { sectionStore.retrieveSection(\u0026quot;invalid - file\u0026quot;); } public List\u0026lt;RecordedGrip\u0026gt; retrieveSection(String sectionName) { // dummy return until we have a real implementation return new ArrayList\u0026lt;RecordedGrip\u0026gt;(); } // Step 2: 이제 테스트는 통과한다. public List\u0026lt;RecordedGrip\u0026gt; retrieveSection(String sectionName) { try { FileInputStream stream = new FileInputStream(sectionName) } catch (Exception e) { throw new StorageException(\u0026quot;retrieval error\u0026quot;, e); } return new ArrayList\u0026lt;RecordedGrip\u0026gt;(); } // Step 3: Exception의 범위를 FileNotFoundException으로 줄여 정확히 어떤 Exception이 발생한지 체크하자. public List\u0026lt;RecordedGrip\u0026gt; retrieveSection(String sectionName) { try { FileInputStream stream = new FileInputStream(sectionName); stream.close(); } catch (FileNotFoundException e) { throw new StorageException(\u0026quot;retrieval error\u0026quot;, e); } return new ArrayList\u0026lt;RecordedGrip\u0026gt;(); }   \n3. Unchecked Exception을 사용하자  Unchecked Exception과 Checked Exception에 대하여 설명을 잘해준 블로그\n 상위 레벨 메소드에서 하위 레벨 메소드의 디테일에 대해 알아야 하기 때문에 캡슐화 또한 깨진다.\n  \n4. Exceptions로 문맥을 제공하자  예외가 발생한 이유와 좀 더 구체적인 Exception 타입을 제공하자.\n catch문의 내용이 비슷하다면 하나로 묶어서 사용하자.\n  \n5. NULL을 리턴하지 말자  null을 리턴하고 싶은 생각이 들면 Special Case object를 리턴하자.\n Null Object Patter  서드파트 라이브러리 에서 null을 리턴할 가능성이 있다면 Exception을 던지거나 Special Case object를 리턴하자.\n// Bad List\u0026lt;Employee\u0026gt; employees = getEmployees(); if (employees != null) { for(Employee e : employees) { totalPay += e.getPay(); } } // Good List\u0026lt;Employee\u0026gt; employees = getEmployees(); for(Employee e : employees) { totalPay += e.getPay(); } public List\u0026lt;Employee\u0026gt; getEmployees() { if( .. there are no employees .. ) return Collections.emptyList(); } }   \n6. NULL을 넘기지 말자  null을 메서드로 넘기는 것 또한 나쁘다\n 가장 이성적인 해법은 null을 파라미터로 받지 못하게 하는 것이다.\n  \n결론  예외처리는 가급적 Exception을 통해 처리를 해주는 것이 코드를 간결하게 한다.\n null을 리턴하지도 넘기지도 말자.\n  \n출저 : https://github.com/Yooii-Studios/Clean-Code\n출저 : Clean Code 클린 코드 : 애자일 소프트웨어 장인 정신\n","id":41,"section":"posts","summary":"Chapter 07 - 에러 핸들링 1. 리턴 코드 대신에 Exception을 사용하자! 기존에 flag를 이용하여 에러 코드를 리턴하거나 호출하는 측에서 예외처리를 하였다. 이","tags":["클린코드"],"title":"Chapter 07 - 에러 핸들링","uri":"https://chlalstjd430.github.io/2020/02/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C_007/","year":"2020"},{"content":" 문제링크 \n사용언어  c++  주의사항  문자열은 제일 앞부터 정해진 길이만큼 잘라야 합니다.  \n문제풀이 문제풀이를 위해서 다음과 같은 과정을 거치게 됩니다.\n 문자열을 자를 단위는 \u0026ldquo;1 ~ (문자열 길이/2)\u0026rdquo; 입니다.\n 문자열 단위별로 제공되는 문자열을 압축해봅니다.\n \u0026ldquo;문자열 총 길이 - (문자열 총 길이 / 문자열 자를 단위) * 문자열 자를 단위\u0026rdquo; 만큼은 압축에 포함되지 않기 때문에 별도 추가합니다.\n 이전에 가장 짧았던 문자열과 길이를 비교합니다.\n#include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int solution(string s) { int len = s.length(); int answer = len; // i = 문자열을 자를 단위 for(int i = 1; i \u0026lt;= (len/2); i++){ string result = \u0026quot;\u0026quot;; string tmp = s.substr(0, i); // 처음 비교해야 될 문자열 int cnt = 1; // 압축이 없을 경우 1 // 자를 문자열 단위만큼 이동하며 비교 for(int j = i; j \u0026lt;= len; j+=i){ // 현재 압축이 있다면 if(tmp == s.substr(j, i)){ cnt++; } // 현재 압축이 없다면 else{ // 지금까지 압축이 없었을 경우 if(cnt == 1){ result += tmp; } // 지금까지 압축이 있었을 경우 else{ result += (to_string(cnt) + tmp); } tmp = s.substr(j, i); cnt = 1; } } result += s.substr((len/i) * i); // 문자열을 자르는 단위에 포함 안되는 문자열 추가 answer = min(answer, (int)result.length()); } return answer; }   ","id":42,"section":"posts","summary":"문제링크 사용언어 c++ 주의사항 문자열은 제일 앞부터 정해진 길이만큼 잘라야 합니다. 문제풀이 문제풀이를 위해서 다음과 같은 과정을 거치게 됩니다. 문자열을 자를 단","tags":null,"title":"프로그래머스 - 문자열 압축","uri":"https://chlalstjd430.github.io/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_003/","year":"2020"},{"content":" \n백준 문제 바로가기 \n사용 언어  C++  적용 알고리즘  그리디 알고리즘  문제풀이 다음과 같은 과정을 거쳐 문제를 풀었습니다.\n 재귀를 통해 순열을 구한다.\n 해당 순열이 부등호를 충족시키는지 검사한다. (부등호를 충족시킬 경우 해당 값을 저장한다.)\n 저장된 순열 값들을 정렬 후 가장 작은 값과 큰 값을 출력한다.\n  위의 세 과정을 거치면 문제의 답을 쉽게 구할 수 있습니다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; char Inequality[11]; bool visited[11]; vector\u0026lt;char\u0026gt; num; vector\u0026lt;string\u0026gt; answer; int tc; // 3. Inequality에 저장되어있는 부등호에 맞게 비교되는 수열인지 확인 bool isPossible() { for (int i = 0; i \u0026lt; tc; i++) { if (Inequality[i] == '\u0026gt;') { if (!(num[i] - '0' \u0026gt; num[i+1] - '0')) return false; } else if(Inequality[i] == '\u0026lt;'){ if (!(num[i] - '0' \u0026lt; num[i+1] - '0')) return false; } } return true; } // 1. 순열을 만드는 재귀 함수 void dfs(int index) { // Inequality의 index값이 tc와 같아질 경우 부등호에 맞는지 검증 if (index == tc) { if (isPossible()) { string tmp = \u0026quot;\u0026quot;; int size = num.size(); for (int i = 0; i \u0026lt; size; i++) { tmp += num[i]; } answer.push_back(tmp); } return; } for (int i = 0; i \u0026lt; 10; i++) { if (visited[i]) continue; visited[i] = true; num.push_back(i + '0'); dfs(index+1); visited[i] = false; num.pop_back(); } } int main() { cin \u0026gt;\u0026gt; tc; for (int i = 0; i \u0026lt; tc; i++) { char a; cin \u0026gt;\u0026gt; a; Inequality[i] = a; } dfs(-1); // 매개변수는 dfs를 실행했을 때 dfs(0)부터 시작할수 있도록 -1값을 준다. // 3. 정렬 후 정답 출력 sort(answer.begin(), answer.end()); cout \u0026lt;\u0026lt; answer[answer.size() - 1] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; answer[0] \u0026lt;\u0026lt; endl; }  ","id":43,"section":"posts","summary":"백준 문제 바로가기 사용 언어 C++ 적용 알고리즘 그리디 알고리즘 문제풀이 다음과 같은 과정을 거쳐 문제를 풀었습니다. 재귀를 통해 순열을 구한다. 해당 순열이 부등호를","tags":["그리디 알고리즘"],"title":"백준 2529 - 부등호","uri":"https://chlalstjd430.github.io/2020/02/%EB%B0%B1%EC%A4%802529/","year":"2020"},{"content":" Chapter 06 - 객체와 자료구조 \n1. 자료 추상화  목록 6-1 구체적인 Point 클래스\npublic class Point { public double x; public double y; }  목록 6-2 추상적인 Point 클래스\npublic interface Point { double getX(); double getY(); void setCartesian(double x, double y); double getR(); double getTheta(); void setPolar(double r, double theta); }   목록 6-1같은 경우 내부 구졸르 노출하고. 목록 6-2는 구현을 완전히 숨긴다. 구현을 완전히 감추기 위해서는 추상화 가 필요하다. set,get 메서드로 변수를 다룬다고 클래스가 아니라, 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스다.\n\n2. 자료/객체 비대칭  객체 는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 제공한다.\n 자료 구조 는 자료를 그대로 공개하며 별다른 함수는 제공하지 않는다.\n  두 정의는 본질적으로 상반되며 두 개념은 사실상 정반대이다.\n 목록 6-5 절차적인 도형 (Procedural Shape)\npublic class Square { public Point topLeft; public double side; } public class Rectangle { public Point topLeft; public double height; public double width; } public class Circle { public Point center; public double radius; } public class Geometry { public final double PI = 3.141592653589793; public double area(Object shape) throws NoSuchShapeException { if (shape instanceof Square) { Square s = (Square)shape; return s.side * s.side; } else if (shape instanceof Rectangle) { Rectangle r = (Rectangle)shape; return r.height * r.width; } else if (shape instanceof Circle) { Circle c = (Circle)shape; return PI * c.radius * c.radius; } throw new NoSuchShapeException(); } }   객체 지향 프로그래머가 위 코드를 보면 의아해 할 것이다. 하지만 Geometry 클래스에 둘레 길이를 구하기 위해서 perimeter() 함수를 추가하고 싶을 경우 도형 클래스는 아무 영향도 받지 않는다. 반대로 새 도형을 추가하고 싶다면 Geometry 클래스에 속한 함수를 모두 고쳐야 한다. 그래서 두 조건은 완전히 정반대라고 할 수 있다.\n 목록 6-6 다형적인 도형 (Polymorphic Shape)\npublic class Square implements Shape { private Point topLeft; private double side; public double area() { return side * side; } } public class Rectangle implements Shape { private Point topLeft; private double height; private double width; public double area() { return height * width; } } public class Circle implements Shape { private Point center; private double radius; public final double PI = 3.141592653589793; public double area() { return PI * radius * radius; } }   이번에는 목록 6-6을 살펴보자. 객체 지향적인 도형 클래스다. 새 도형을 추가해서 기존 함수에 아무런 영향을 미치지 않는다. 반면 새 함수를 추가하고 싶다면 도형 클래스 전부를 고쳐야 한다.\n즉, 객체 지향 코드에서 어려운 변경은 절차적인 코드에서 쉬우며, 절차적인 코드에서 어려운 변경은 객체 지향 코드에서 쉽다. 그러므로 상황에 맞게 클래스 \u0026amp; 객체 지향 기법을 사용하거나, 절차적인 코드와 자료 구조를 적절하게 사용하는 것이 좋다.\n\n3. 디미터 법칩 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙이다. 좀 더 정확히 표현하자면, 디미터 법칙은 \u0026ldquo;클래스 C의 메서드 f는 다음과 같은 객체의 메서드만 호출해야 한다\u0026rdquo; 고 주장한다.\n 클래스 C\n f가 생성한 객체\nint f(){ Module module = new Modele(); module.메서드() }  f 인수로 넘어온 객체\nint f(Module module){ module.메서드() }  C 인스턴스 변수에 저장된 객체\nclass C { private Module module; ... int f(){ module.메서드(); } }   하지만 위 객체에서 허용된 메서드가 반환하는 객체의 메서드는 호출하면 안 된다.\n 기차 충돌\nfinal String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();   위와 같은 코드는 일반적으로 조잡하다 여겨지므로 가능하면 피하자.\n 잡종 구조\n 절반은 객체 절반은 자료 구조인 잡종 구조는 가급적이면 지양하자. 이는 어중간한 설계처럼 보인다.  자료 전달 객체(DTO)\n  \n결론  클래스를 만들 때 가급적이면 추상화 과정을 거쳐 만드는 것이 더 바람직한 클래스 설계라고 생각이 든다.\n 무조건 객체가 옳은 것은 아니다. 상황에 맞게 객체나 자료 구조를 사용하여야 한다.\n  \n출저 : https://github.com/Yooii-Studios/Clean-Code\n출저 : Clean Code 클린 코드 : 애자일 소프트웨어 장인 정신\n","id":44,"section":"posts","summary":"Chapter 06 - 객체와 자료구조 1. 자료 추상화 목록 6-1 구체적인 Point 클래스 public class Point { public double x; public double y; } 목록 6-2 추상적인 Point 클래스 public interface Point { double getX(); double getY(); void setCartesian(double x, double y); double getR(); double getTheta(); void setPolar(double r, double","tags":["클린코드"],"title":"Chapter 06 - 객체와 자료구조","uri":"https://chlalstjd430.github.io/2020/02/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C_006/","year":"2020"},{"content":" 문제링크 \n사용언어  c++  \n문제유형  힙/우선순위 큐  \n주의 사항  vector를 가지고 sort후 문제를 풀었더니 효율성에서 통과하지 못하였다. 이는 우선순위 큐를 선언하여 문제를 해결하였다.\n 단순 vector를 가지고 실행한 결과  priority_queue를 가지고 실행한 결과    \n문제풀이 #include \u0026lt;string\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int k; int cnt; priority_queue\u0026lt;int\u0026gt; pq; bool compare (int a, int b){ return a \u0026gt; b; } bool check_scoville(){ int top = -pq.top(); bool result = true; if(top \u0026lt; k) result = false; return result; } int solution(vector\u0026lt;int\u0026gt; scoville, int K) { int answer = 0; // 전역변수 초기화 k = K; cnt = 0; for(int i = 0; i \u0026lt; scoville.size(); i++){ pq.push(-scoville[i]); // priority_queue는 별도 설정이 없으면 가장 큰 값이 top에 있기 때문에 -를 붙여 값들을 저장한다. } while(true){ int size = pq.size(); // 모든 값들이 K를 넘거나, 1개 밖에 값이 안남은 경우 if(check_scoville() || size == 1 ){ break; } // 기존에 가장 스코빌 지수가 적은 2개를 삭제하고 섞은 음식의 스코빌 지수를 저장 int a = -pq.top(); // 가장 스코빌 지수가 적은 값, 저장할 때 -를 붙여 저장하였기 때문에 꺼낼 때 다시 -기호를 붙여 양수의 값을 받아온다. pq.pop(); int b = -pq.top(); // 두번째로 스코빌 지수가 적은 값 pq.pop(); int c = a + b*2; // 섞은 음식의 스코빌 지수를 저장 pq.push(-c); cnt++; // 한번 섞었으므로 cnt가 1증가 } // 모든 스코빌 지수가 K보다 클 경우 if(check_scoville()){ answer = cnt; } // 그렇지 못할 경우(스코빌 지수가 한개 남았을 때) else answer = -1; return answer; }  ","id":45,"section":"posts","summary":"문제링크 사용언어 c++ 문제유형 힙/우선순위 큐 주의 사항 vector를 가지고 sort후 문제를 풀었더니 효율성에서 통과하지 못하였다. 이는 우선순위 큐를 선언","tags":null,"title":"프로그래머스 - 더 맵게","uri":"https://chlalstjd430.github.io/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_002/","year":"2020"},{"content":" 문제링크 \n사용언어  c++  \n문제유형  dfs/bfs\n 그래프\n  \n주의 사항  전역 변수를 사용할 경우 함수 내에 초기화 코드를 꼭 작성하자\n 제출하면 답이 틀리려서 30분넘게 씨름했는데..solution 함수 위에 다음과 같은 주석이 있었다\u0026hellip;    // 전역 변수를 정의할 경우 함수 내에 초기화 코드를 꼭 작성해주세요.\n \n문제풀이 해당 문제에서는 DFS 혹은 BFS를 이용하여 풀 수 있는 문제이다. 나는 DFS를 선택하여 문제를 풀어보았다.\n#include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; vec; bool visited[102][102]; int M, N; int dx[] = {-1, 0, 0, 1}; int dy[] = {0, -1, 1, 0}; int area; void dfs(int x, int y, int color){ visited[x][y] = true; area++; for(int i = 0; i \u0026lt; 4; i++){ int mx = x + dx[i]; int ny = y + dy[i]; if(0 \u0026gt; mx || mx \u0026gt; M-1 || 0 \u0026gt; ny || ny \u0026gt; N-1) continue; if(!visited[mx][ny] \u0026amp;\u0026amp; vec[mx][ny] == color){ dfs(mx,ny,color); } } } // 전역 변수를 정의할 경우 함수 내에 초기화 코드를 꼭 작성해주세요. vector\u0026lt;int\u0026gt; solution(int m, int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; picture) { int number_of_area = 0; int max_size_of_one_area = 0; // 전역변수 초기화 area = 0; M = m; N = n; vec = picture; // visited 2차원 배열을 초기화 안해서 계속 틀렸었다..아마 해당 문제에서는 전역변수 설정시 자동으로 false 설정이 안되나보다. for(int i = 0; i \u0026lt; m; i++){ for(int j = 0; j \u0026lt; n; j++){ visited[i][j] = false; } } for(int i = 0; i \u0026lt; m; i++){ for(int j = 0; j \u0026lt; n; j++){ if(!visited[i][j] \u0026amp;\u0026amp; vec[i][j] \u0026gt; 0){ area = 0; dfs(i, j, vec[i][j]); number_of_area++; max_size_of_one_area = max(area, max_size_of_one_area); } } } vector\u0026lt;int\u0026gt; answer(2); answer[0] = number_of_area; answer[1] = max_size_of_one_area; return answer; }  \n","id":46,"section":"posts","summary":"문제링크 사용언어 c++ 문제유형 dfs/bfs 그래프 주의 사항 전역 변수를 사용할 경우 함수 내에 초기화 코드를 꼭 작성하자 제출하면 답이 틀리려서 30분넘게 씨름했는데..so","tags":null,"title":"프로그래머스 - 카카오 프렌즈 컬러링북","uri":"https://chlalstjd430.github.io/2020/02/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4_001/","year":"2020"},{"content":" \n백준 문제 바로가기 \n사용 언어  C++  적용 알고리즘  KMP 알고리즘  문제풀이 문제에서는 것은 단순 문자열 비교 알고리즘이 아니라 KMP나 라빈 카프 같은 효율적인 알고리즘을 요구합니다. 그러므로 저는 KMP 알고리즘을 이용하여 문제를 풀어보았습니다.\n코드는 다음과 같습니다. 설명은 주석으로 진행하겠습니다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; // vector를 사용하기 위해 선언 #include \u0026lt;string.h\u0026gt; // strlen을 사용하기 위해 선언 using namespace std; vector\u0026lt;int\u0026gt; place; // 문제에서 요구하는 답(겹치는 문자열의 개수, 위치)를 저장하기 위해 전역변수로 선언 // pattern(찾고자 하는 문자열)에 대하여 table을 만드는 함수 vector\u0026lt;int\u0026gt; makeTable(char *pattern) { int patternSize = strlen(pattern); vector\u0026lt;int\u0026gt; table(patternSize, 0); // pattern의 길이만큼 만들어줍니다. // table을 만드는 과정 int j = 0; for (int i = 1; i \u0026lt; patternSize; i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; pattern[i] != pattern[j]) { j = table[j - 1]; } if (pattern[i] == pattern[j]) { table[i] = ++j; // pattern i와 j의 값이 일치할 경우 table에 기록합니다. } } return table; } // parent(기존의 문자열)과 pattern(찾고자 하는 문자열)을 가지고 kmp 알고리즘을 수행합니다. void kmp(char *parent, char *pattern) { vector\u0026lt;int\u0026gt; table = makeTable(pattern); int parentSize = strlen(parent); int patternSize = strlen(pattern); int j = 0; for (int i = 0; i \u0026lt; parentSize; i++) { // parent와 pattern을 비교하기 때문에 parent길이만큼 확인 while (j \u0026gt; 0 \u0026amp;\u0026amp; parent[i] != pattern[j]) { j = table[j - 1]; } if (parent[i] == pattern[j]) { // j가 pattern의 길이-1과 같은 경우 if (j == patternSize - 1) { j = table[j]; place.push_back(i - patternSize + 2); // place vector에 인데스 저장 } // 길이가 같이 않을 경우 else { j++; } } } } int main() { char parent[1000002] = {}; char pattern[1000002] = {}; cin.getline(parent, 1000002); cin.getline(pattern, 1000002); kmp(parent, pattern); int size = place.size(); cout \u0026lt;\u0026lt; size \u0026lt;\u0026lt; endl; for (int i = 0; i \u0026lt; size; i++) { cout \u0026lt;\u0026lt; place[i] \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } }  ","id":47,"section":"posts","summary":"백준 문제 바로가기 사용 언어 C++ 적용 알고리즘 KMP 알고리즘 문제풀이 문제에서는 것은 단순 문자열 비교 알고리즘이 아니라 KMP나 라빈 카프 같은 효율적인 알고리즘을 요","tags":["KMP 알고리즘"],"title":"백준 1786 - 찾기","uri":"https://chlalstjd430.github.io/2020/02/%EB%B0%B1%EC%A4%801786/","year":"2020"},{"content":" Chapter 05 - 형식 맞추기 질서정연하고 깔끔하며, 일관적인 코드를 본다면 사람들에게 전문가가 짰다는 인상을 심어줄 수 있다. 반대로, 코드가 어수선해 보인다면 프로젝트 전반적으로 무성의한 태도로 작성했다고 생각할 것이다.\n\n1. 형식을 맞추는 목적 코드 형식은 의사소통의 일환이며 오늘 구현한 코드의 스타일과 가독성 수준은 용이성과 확장성에 지속적인 영향을 준다.\n 코드는 사라져도 스타일과 규율은 사라지지 않는다!\n \n2. 적절한 행 길이를 유지하라(코드의 세로 길이) 코드의 줄이 길어질 수록 코드를 이해하기 어렵기 때문에 코드의 줄을 200줄 내외로 정하여 개발하는 것이 좋다. 물론 이것이 반드시 지켜져야 될 엄격한 규칙은 아니지만 확실히 코드의 줄이 작을 수록 보기좋다.\n 신문 기사처럼 작성하라\n 신문 기사는 최상단에 표제, 첫 문단에는 요약된 기사 내용, 그리고 내려갈수록 세세한 내용 들이 등장한다. 코드 또한 이와 마찬가지로 소스파일 이름(표제) 은 간단하면서도 설명이 가능하게 지어 이름만 보고도 올바른 모듈을 살펴보고 있는지를 판단 할 수 있도록 한다. 소스파일의 첫 부분(요약 내용) 은 고차원 개념과 알고리즘을 설명한다. 아래로 내려갈수록 의도를 세세하게 묘사하며, 마지막에는 가장 저차원 함수(getter,setter같은)와 세부 내역이 나오게 한다.  개념은 빈 행으로 분리하여라\n 코드의 각 줄은 수식이나 절을 나타내고, 여러 줄의 묶음은 완결된 생각 하나를 표현한다. 생각 사이에는 빈 행을 넣어 분리하자.\n 같은 코드에 대헤서 빈 행을 다르게 표현한 코드를 보자.\n// 빈 행을 넣지 않을 경우 package fitnesse.wikitext.widgets; import java.util.regex.*; public class BoldWidget extends ParentWidget { public static final String REGEXP = \u0026quot;'''.+?'''\u0026quot;; private static final Pattern pattern = Pattern.compile(\u0026quot;'''(.+?)'''\u0026quot;, Pattern.MULTILINE + Pattern.DOTALL); public BoldWidget(ParentWidget parent, String text) throws Exception { super(parent); Matcher match = pattern.matcher(text); match.find(); addChildWidgets(match.group(1));} public String render() throws Exception { StringBuffer html = new StringBuffer(\u0026quot;\u0026lt;b\u0026gt;\u0026quot;); html.append(childHtml()).append(\u0026quot;\u0026lt;/b\u0026gt;\u0026quot;); return html.toString(); } }  // 빈 행을 넣을 경우 package fitnesse.wikitext.widgets; import java.util.regex.*; public class BoldWidget extends ParentWidget { public static final String REGEXP = \u0026quot;'''.+?'''\u0026quot;; private static final Pattern pattern = Pattern.compile(\u0026quot;'''(.+?)'''\u0026quot;, Pattern.MULTILINE + Pattern.DOTALL ); public BoldWidget(ParentWidget parent, String text) throws Exception { super(parent); Matcher match = pattern.matcher(text); match.find(); addChildWidgets(match.group(1)); } public String render() throws Exception { StringBuffer html = new StringBuffer(\u0026quot;\u0026lt;b\u0026gt;\u0026quot;); html.append(childHtml()).append(\u0026quot;\u0026lt;/b\u0026gt;\u0026quot;); return html.toString(); } }   세로 밀집도\n 줄바꿈이 개념을 분리한다면, 세로 밀집도는 연관성을 의미한다. 즉, 서로 밀집한 코드 행은 세로로 가까이 놓여야 한다.\n 같은 코드에 대헤서 세로 밀집도를 다르게 표현한 코드를 보자.\n// 의미없는 주석으로 변수를 떨어뜨려 놓아서 한눈에 파악이 잘 안된다. public class ReporterConfig { /** * The class name of the reporter listener */ private String m_className; /** * The properties of the reporter listener */ private List\u0026lt;Property\u0026gt; m_properties = new ArrayList\u0026lt;Property\u0026gt;(); public void addProperty(Property property) { m_properties.add(property); }  // 의미 없는 주석을 제거함으로써 코드가 한눈에 들어온다. // 변수 2개에 메소드가 1개인 클래스라는 사실이 드러난다. public class ReporterConfig { private String m_className; private List\u0026lt;Property\u0026gt; m_properties = new ArrayList\u0026lt;Property\u0026gt;(); public void addProperty(Property property) { m_properties.add(property); }   수직거리\n 서로 밀접한 개념은 세로로 가까이 둬야 한다. 타당한 근거가 없다면 서로 밀접한 개념은 한 파일에 속해야 마땅하다. 같은 파일에 속할 정도로 밀접한 두 개념은 세로 거리로 연관성(한 개념을 이해하는데 다른 개념이 중요한 정도)을 표현한다.\n 변수 선언\n 우리가 만든 함수는 매우 짧으므로(chapter03 참고)변수는 사용하는 위치에 최대한 가까이 선언한다.\n// InputStream이 함수 맨 처음에 선언 되어있다. private static void readPreferences() { InputStream is = null; try { is = new FileInputStream(getPreferencesFile()); setPreferences(new Properties(getPreferences())); getPreferences().load(is); } catch (IOException e) { try { if (is != null) is.close(); } catch (IOException e1) { } } }  // 모두들 알다시피 루프 제어 변수는 Test each처럼 루프 문 내부에 선언 public int countTestCases() { int count = 0; for (Test each : tests) count += each.countTestCases(); return count; }  // 드물지만, 긴 함수에서는 블록 상단 또는 루프 직전에 변수를 선언 할 수도 있다. ... for (XmlTest test : m_suite.getTests()) { TestRunner tr = m_runnerFactory.newTestRunner(this, test); tr.addListener(m_textReporter); m_testRunners.add(tr); invoker = tr.getInvoker(); for (ITestNGMethod m : tr.getBeforeSuiteMethods()) { beforeSuiteMethods.put(m.getMethod(), m); } for (ITestNGMethod m : tr.getAfterSuiteMethods()) { afterSuiteMethods.put(m.getMethod(), m); } } ...  인스턴스 변수\n 인스턴스 변수는 클래스 맨 처음에 선언한다.(자바의 경우)\n 종속 함수\n 한 함수가 다른 함수를 호출한다면(종속 함수) 두 함수는 세로로 가까이 배치한다. 일반적으로 함수 호출 종속성은 아래방향으로 유지하므로, 호출되는 함수를 호출하는 함수보다 뒤에 배치한다.\n 아래의 코드에서 makeResponse 함수에서 getPageNameOrDefault 함수를 호출하기 때문에 더 위에 작성되었다.\npublic class WikiPageResponder implements SecureResponder { protected WikiPage page; protected PageData pageData; protected String pageTitle; protected Request request; protected PageCrawler crawler; public Response makeResponse(FitNesseContext context, Request request) throws Exception { String pageName = getPageNameOrDefault(request, \u0026quot;FrontPage\u0026quot;); loadPage(pageName, context); if (page == null) return notFoundResponse(context, request); else return makePageResponse(context); } private String getPageNameOrDefault(Request request, String defaultPageName) { String pageName = request.getResource(); if (StringUtil.isBlank(pageName)) pageName = defaultPageName; return pageName; } ...    \n3. 가로 형식 맞추기 보통 행은 80자에서 120자까지로 제한한다.\n 가로 공백과 밀집도\n 가로로는 공백을 사용해 밀접/느슨한 개념을 표현한다\nprivate void measureLine(String line) { lineCount++; // 흔히 볼 수 있는 코드인데, 할당 연산자 좌우로 공백을 주어 왼쪽,오른쪽 요소가 확실하게 구분된다. int lineSize = line.length(); totalChars += lineSize; // 반면 함수이름과 괄호 사이에는 공백을 없앰으로써 함수와 인수의 밀접함을 보여준다 // 괄호 안의 인수끼리는 쉼표 뒤의 공백을 통해 인수가 별개라는 사실을 보여준다. lineWidthHistogram.addLine(lineSize, lineCount); recordWidestLine(lineSize); }  연산자의 우선순위를 강조하기 위해서도 공백을 사용한다.\n  들여쓰기\n 짧은 함수여도 들여쓰기는 가독성을 위해 사용하자.\npublic CommentWidget(ParentWidget parent, String text){super(parent, text);} public CommentWidget(ParentWidget parent, String text){ super(parent, text); } 위의 코드보다 아래의 코드가 훨씬 보기 좋다.    \n4. 팀 규칙 팀에 속해있다면 가장 우선시 되어야 할 규칙은 팀 규칙이다.\n\n5. 책의 저자가 사용하는 규칙이 드러나는 코드 public class CodeAnalyzer implements JavaFileAnalysis { private int lineCount; private int maxLineWidth; private int widestLineNumber; private LineWidthHistogram lineWidthHistogram; private int totalChars; public CodeAnalyzer() { lineWidthHistogram = new LineWidthHistogram(); } public static List\u0026lt;File\u0026gt; findJavaFiles(File parentDirectory) { List\u0026lt;File\u0026gt; files = new ArrayList\u0026lt;File\u0026gt;(); findJavaFiles(parentDirectory, files); return files; } private static void findJavaFiles(File parentDirectory, List\u0026lt;File\u0026gt; files) { for (File file : parentDirectory.listFiles()) { if (file.getName().endsWith(\u0026quot;.java\u0026quot;)) files.add(file); else if (file.isDirectory()) findJavaFiles(file, files); } } public void analyzeFile(File javaFile) throws Exception { BufferedReader br = new BufferedReader(new FileReader(javaFile)); String line; while ((line = br.readLine()) != null) measureLine(line); } private void measureLine(String line) { lineCount++; int lineSize = line.length(); totalChars += lineSize; lineWidthHistogram.addLine(lineSize, lineCount); recordWidestLine(lineSize); } private void recordWidestLine(int lineSize) { if (lineSize \u0026gt; maxLineWidth) { maxLineWidth = lineSize; widestLineNumber = lineCount; } } public int getLineCount() { return lineCount; } public int getMaxLineWidth() { return maxLineWidth; } public int getWidestLineNumber() { return widestLineNumber; } public LineWidthHistogram getLineWidthHistogram() { return lineWidthHistogram; } public double getMeanLineWidth() { return (double)totalChars/lineCount; } public int getMedianLineWidth() { Integer[] sortedWidths = getSortedWidths(); int cumulativeLineCount = 0; for (int width : sortedWidths) { cumulativeLineCount += lineCountForWidth(width); if (cumulativeLineCount \u0026gt; lineCount/2) return width; } throw new Error(\u0026quot;Cannot get here\u0026quot;); } private int lineCountForWidth(int width) { return lineWidthHistogram.getLinesforWidth(width).size(); } private Integer[] getSortedWidths() { Set\u0026lt;Integer\u0026gt; widths = lineWidthHistogram.getWidths(); Integer[] sortedWidths = (widths.toArray(new Integer[0])); Arrays.sort(sortedWidths); return sortedWidths; } }  \n결론  코드를 작성할 때 가로/세로 규칙을 적용해가며 작성하자.\n 내가 당장 쉽게 짜는 코드보다 모두가 쉽게 볼 수있는 코드를 작성하자.\n  \n출저 : https://github.com/Yooii-Studios/Clean-Code\n출저 : Clean Code 클린 코드 : 애자일 소프트웨어 장인 정신\n","id":48,"section":"posts","summary":"Chapter 05 - 형식 맞추기 질서정연하고 깔끔하며, 일관적인 코드를 본다면 사람들에게 전문가가 짰다는 인상을 심어줄 수 있다. 반대로, 코드가 어수선해 보인다면 프로젝트","tags":["클린코드"],"title":"Chapter 05 - 형식 맞추기","uri":"https://chlalstjd430.github.io/2020/01/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C_005/","year":"2020"},{"content":" 백준 문제 바로가기 \n사용 언어  C++  적용 알고리즘  위상 정렬 알고리즘  문제풀이 해당 문제에서 요구하는 것은 2가지이다.\n1. 모든 사람들이 만나는 시간 2. 1분도 쉬지 않고 달려야 하는 도로의 수 - 즉, 1번 요구사항에서 나온 시간에 딱 맞게 도착했을 때 거쳐간 도로의 수  2번째 요구사항이 나같은 경우 이해하기 힘들었는데, 쉽게 설명하자면 1번 요구사항에서 나온 시간만큼 걸려서 도착 도시에 도착했을 때, 시작 도시부터 거쳐간 도로의 개수를 구하면 된다. 해당 문제는 역추적 방식을 이용하면 문제를 쉽게 풀 수 있다.\n 먼저 지도 정보를 담을 클래스를 만들어주자.\nclass Edge { public: int node; int time; Edge(int node, int time) { this-\u0026gt;node = node; this-\u0026gt;time = time; } };  이후 위상 정렬 알고리즘을 사용하기 위한 변수들을 선언해준다.\nint n; int start, goal; int inDegree[MAX]; int result[MAX], visited[MAX]; vector\u0026lt;Edge\u0026gt; map[MAX]; vector\u0026lt;Edge\u0026gt; reverseMap[MAX];    여기서 reverseMap이라는게 나온데 이는 visted배열과 함께 이후 역추적 때 사용하기 위해 선언한 것이다.   위상 정렬 함수를 선언해준다.\nvoid topologySort() { queue\u0026lt;int\u0026gt; q; q.push(start); while (!q.empty()) { int current = q.front(); q.pop(); int mapSize = map[current].size(); for (int i = 0; i \u0026lt; mapSize; i++) { Edge next = Edge(map[current][i].node, map[current][i].time); int totalTime = next.time + result[current]; if (result[next.node] \u0026lt;= totalTime) { result[next.node] = totalTime; } if (--inDegree[next.node] == 0) { q.push(next.node); } } } cout \u0026lt;\u0026lt; result[goal] \u0026lt;\u0026lt; endl; }  역추적을 위한 함수를 선언해준다.\nvoid traceBack() { queue\u0026lt;int\u0026gt; q; int count = 0; q.push(goal); while (!q.empty()) { int front = q.front(); q.pop(); int reverseMapSize = reverseMap[front].size(); for (int i = 0; i \u0026lt; size i++) { Edge next = Edge(reverseMap[front][i].node, reverseMap[front][i].time); if (result[front] - result[next.node] == next.time) { if (visited[next.node] == 0) { q.push(next.node); visited[next.node] = 1; } } } } cout \u0026lt;\u0026lt; count; }    이 함수안에서는 queue에 goal을 넣고 시작해서 시작점이 아닌 도착점에서 시작한다.\n for문 안에 if조건문이 중요한 부분이다. 이미 result를 구했으므로 result 배열을 통해서 현재 도시까지의 거리 - 현재-1 도시까지의 거리 의 값이 다음 찾을 도시의 time정보랑 값이 같다면 해당 도로는 이전 거쳐가는 도로가 확실함으로 count를 증가시킨다.\n 이후 해동 도시를 queue에 다시 담지 않도록 방문 처리를 해준다음, queue에 담는다.\n  코드 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;algorithm\u0026gt; #define MAX 10002 using namespace std; class Edge { public: int node; int time; Edge(int node, int time) { this-\u0026gt;node = node; this-\u0026gt;time = time; } }; int n, start, goal; int inDegree[MAX], result[MAX], visited[MAX]; vector\u0026lt;Edge\u0026gt; map[MAX]; vector\u0026lt;Edge\u0026gt; reverseMap[MAX]; void topologySort() { queue\u0026lt;int\u0026gt; q; q.push(start); while (!q.empty()) { int current = q.front(); q.pop(); int mapSize = map[current].size(); for (int i = 0; i \u0026lt; mapSize; i++) { Edge next = Edge(map[current][i].node, map[current][i].time); int totalTime = next.time + result[current]; if (result[next.node] \u0026lt;= totalTime) { result[next.node] = totalTime; } if (--inDegree[next.node] == 0) { q.push(next.node); } } } cout \u0026lt;\u0026lt; result[goal] \u0026lt;\u0026lt; endl; } void traceBack() { queue\u0026lt;int\u0026gt; q; int count = 0; q.push(goal); while (!q.empty()) { int front = q.front(); q.pop(); int reverseMapSize = reverseMap[front].size(); for (int i = 0; i \u0026lt; size i++) { Edge next = Edge(reverseMap[front][i].node, reverseMap[front][i].time); if (result[front] - result[next.node] == next.time) { count++; if (visited[next.node] == 0) { q.push(next.node); visited[next.node] = 1; } } } } cout \u0026lt;\u0026lt; count; } int main() { int m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; m; i++) { int x, node, time; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; node \u0026gt;\u0026gt; time; map[x].push_back(Edge(node, time)); reverseMap[node].push_back(Edge(x, time)); inDegree[node]++; } cin \u0026gt;\u0026gt; start \u0026gt;\u0026gt; goal; topologySort(); traceBack(); }  ","id":49,"section":"posts","summary":"백준 문제 바로가기 사용 언어 C++ 적용 알고리즘 위상 정렬 알고리즘 문제풀이 해당 문제에서 요구하는 것은 2가지이다. 1. 모든 사람들이 만나는 시간 2. 1분도 쉬지 않고 달","tags":["위상 정렬 알고리즘"],"title":"백준 1948 - 임계경로","uri":"https://chlalstjd430.github.io/2020/01/%EB%B0%B1%EC%A4%801948/","year":"2020"},{"content":" Chapter 04 - 주석  나쁜 코드에 주석을 달지 마라. 새로 짜라. - 브라이언 W.커니핸, P.J.플라우거\n \n1. 불필요한 주석을 없애자.  주석은 코드로 의도를 표현하지 못하여 실패를 만회하기 위해 사용하는 것이다. 즉, 주석은 언제나 실패를 의미한다.\n 오래된 코드일수록 코드를 유지보수해도 주석을 유지보수하는 경우는 거의 없다.\n  \n2. 주석 대신 코드로 의도를 표현하라! // 직원에게 복지 혜택을 받을 자격이 있는지 검사한다. if ((emplotee.flags \u0026amp; HOURLY_FLAG) \u0026amp;\u0026amp; (employee.age \u0026gt; 65)  위 코드를 주석을 제거하고 함수 이름만으로 표현하면\nif (employee.isEligibleForFullBenefits())  다음과 같은 코드가 된다. 훨씬 보기 좋지 않은가?\n\n3. 필요한 주석  법적인 주석 : 소스 파일 첫머리에 들어가는 저작권 정보와 소유권 정보 등   // Copyright \u0026copy; 2003, 2004, 2005 by Object Montor, Inc. All right reserved. // GNU General Public License\n  정보를 제공하는 주석\n// kk:mm:ss EEE, MMM dd, yyyy 형식이다. Pattern timeMatcher = Pattern.compile(\u0026quot;\\\\d*:\\\\d*\\\\d* \\\\w*, \\\\w*, \\\\d*, \\\\d*\u0026quot;);  의도를 설명하는 주석\n// 스레드를 대량 생성하는 방법으로 어떻게든 경쟁 조건을 만들려 시도한다. for (int i = 0; i \u0026gt; 2500; i++) { WidgetBuilderThread widgetBuilderThread = new WidgetBuilderThread(widgetBuilder, text, parent, failFlag); Thread thread = new Thread(widgetBuilderThread); thread.start(); }  결과를 경고하는 주석\n// 여유 시간이 충분하지 않다면 실행하지 마십시오. public void _testWithReallyBigFile() { ... }  중요성을 강조하는 주석\nString listItemContent = match.group(3).trim(); // 여기서 trim은 정말 중요하다. trim 함수는 문자열에서 시작 공백을 제거한다. // 문자열에 시작 공백이 있으면 다른 문자열로 인식되기 때문이다. new ListItemWidget(this, listItemContent, this.level + 1); return buildList(text.substring(match.end()));  공개 API에서 Javadocs\n 설명이 잘 된 공개 API는 참으로 유용하고 만족스럽다. 공개 API를 구현한다면 반드시 훌륭한 Javadocs 작성을 추천한다. 하지만 여느 주석과 마찬가지로 Javadocs 역시 독자를 오도하거나, 잘못 위치하거나, 그릇된 정보를 전달할 가능성이 존재하는 것 역시 잊으면 안 된다.   \n4. 나쁜 주석  주절거리는 주석(특별한 이유없이 달리는 주석)\n 같은 이야기를 중복하는 주석\n 오해의 여지가 있는 주석\n 의무적으로 다는 주석\n 모든 함수에 Javadocs를 달거나 모든 변수에 주석을 달아야 한다는 규칙은 어리석기 그지없다. 이런 주석은 코드를 복잡하게 만들며, 거짓말을 퍼뜨리고, 혼동과 무질서를 초래한다. 아래와 같은 주석은 아무 가치도 없다.\n/** * * @param title CD 제목 * @param author CD 저자 * @param tracks CD 트랙 숫자 * @param durationInMinutes CD 길이(단위: 분) */ public void addCD(String title, String author, int tracks, int durationInMinutes) { CD cd = new CD(); cd.title = title; cd.author = author; cd.tracks = tracks; cd.duration = durationInMinutes; cdList.add(cd); }   소스 코드 관리 시스템이 해주는 것들\n 저자를 표시하는 주석\n 이력(기록)을 표시하는 주석\n 주석으로 처리한 코드\n 소스 코드 관리 시스템은 우리의 지난 코드들을 보관해준다.\n  위치를 표시하는 주석\n 닫는 괄호에 다는 주석\n 전역 정보(소스 코드 전체적으로 다는 주석)\n 주석은 반드시 근처에 있는 코드에 한해서만 기술하자.  비공개 코드에서 Javadocs\n 공개 API에서는 Javadocs가 유용하지만 공개하지 않을 코드이면 Javadocs는 쓸모가 없다.   \n결론  좋은 주석의 예시로 TODO 주석 같은게 있었지만, 이는 현재 다른 툴로 충분히 다룰수 있으므로 제외하였다.\n 사실 나쁜 주석으로 여러 예시들을 나열 했는데, 좋은 주석 예제들을 자세히보고 그 외의 주석들은 안다는게 편할듯 하다.\n 예전에야 주석이 잘 짜여져야 보기 편하다 했지만, 확실히 불필요한 주석은 가독성을 저해하고 유지보수가 되면서 왜곡된 정보들이 노출되는 것 같다. 앞으로 주석은 가급적 지양하고 함수명과 변수명을 통해 내 의도가 드러나도록 만들도록 해야겠다.\n  \n출저 : https://github.com/Yooii-Studios/Clean-Code\n출저 : Clean Code 클린 코드 : 애자일 소프트웨어 장인 정신\n","id":50,"section":"posts","summary":"Chapter 04 - 주석 나쁜 코드에 주석을 달지 마라. 새로 짜라. - 브라이언 W.커니핸, P.J.플라우거 1. 불필요한 주석을 없애자. 주석은 코드로 의도를 표현하지 못하여","tags":["클린코드"],"title":"Chapter 04 - 주석","uri":"https://chlalstjd430.github.io/2020/01/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C_004/","year":"2020"},{"content":" Chapter 03 - 함수 이번 시간에는 clean한 함수를 만드는 방법에 공부하였다. 어떻게 해야 좋은 함수를 만들 수 있는지 같이 확인 해 보자. 1. 함수는 작을수록(분리될수록) 좋다.  다음은 코드의 예시다, 위의 코드보다 아래 코드처럼 5줄 이내로 줄여서 사용할 것을 권장한다.\npublic static String renderPageWithSetupsAndTeardowns( PageData pageData, boolean isSuite) throws Exception { boolean isTestPage = pageData.hasAttribute(\u0026quot;Test\u0026quot;); if (isTestPage) { WikiPage testPage = pageData.getWikiPage(); StringBuffer newPageContent = new StringBuffer(); includeSetupPages(testPage, newPageContent, isSuite); newPageContent.append(pageData.getContent()); includeTeardownPages(testPage, newPageContent, isSuite); pageData.setContent(newPageContent.toString()); } return pageData.getHtml(); }  public static String renderPageWithSetupsAndTeardowns( PageData pageData, boolean isSuite) throws Exception { if (isTestPage(pageData)) includeSetupAndTeardownPages(pageData, isSuite); return pageData.getHtml(); }  에네르기파를 자제하자\n 우리는 간혹 if~else 문으로 depth가 3단계 넘어가는 경우도 보게된다. 그러한 코드는 가독성 뿐만 아니라 상당히 비효율적인 코드이다.   \n2. 함수는 하나의 기능만!  함수는 한 가지 기능만 해야한다. 한가지 함수내에서 기능들을 여러가지 나눌 수 있다면 그 함수는 하나가 아닌 여러작업을 하는 함수이다.  \n3. 함수 당 추상화 수준은 하나로  한 함수 내에서 추상화 수준은 섞이지 않고 동일해야 된다.\n 내려가기 규칙(위에서 아래로 코드 읽기)\n 함수 추상화 부분이 한번에 한단계씩 낮아지는 것이 가장 이상적이다.   \n4. switch는 댜형적 객체를 생성하는 코드 안에서만 사용을 권장한다.  물론 불가피한 상황에서는 적절히 이용할 수 있다.\n switch를 abstract factory에 숨겨 다형적 코드를 생성하는 예\npublic abstract class Employee { public abstract boolean isPayday(); public abstract Money calculatePay(); public abstract void deliverPay(Money pay); } public interface EmployeeFactory { public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType; } public class EmployeeFactoryImpl implements EmployeeFactory { public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType { switch (r.type) { case COMMISSIONED: return new CommissionedEmployee(r) ; case HOURLY: return new HourlyEmployee(r); case SALARIED: return new SalariedEmploye(r); default: throw new InvalidEmployeeType(r.type); } } }   \n5. 함수 인수 함수에서 이상적인 인수 개수는 0개(무항). 인수는 코드 이해에 방해가 되는 요소이므로 최선은 0개이고, 차선은 1개뿐인 경우이다. 출력인수(함수의 반환 값이 아닌 입력 인수로 결과를 받는 경우)는 이해하기 어려우므로 왠만하면 쓰지 않는 것이 좋겠다.\n 많이 쓰이는 단항 형식\n 인수에 질문을 던지는 경우\n boolean fileExists(“MyFile”);\n 인수를 뭔가로 변환해 결과를 변환하는 경우\n InputStream fileOpen(“MyFile”);\n 이벤트 함수일 경우 (이 경우에는 이벤트라는 사실이 코드에 명확하게 드러나야 한다.)\n  플래그 인수\n bool값을 넘기는 것 자체가 함수의 기능이 하나가 아닌 것을 입증하게 된다. 즉, 플래그 인수는 쓰지말자.  단항 함수\n 단항 함수는 함수와 인수가 동사/명사 쌍을 이루어야 한다.\n writeField(name);\n 함수이름에 키워드(인수 이름)을 추가하면 인수 순서를 기억할 필요가 없다.\n assertExpectedEqualsActual(expected, actual);\n  다항 함수\n 단항 함수보다 한번에 알아보기 힘들다. 이항 함수의 경우에는 무조건적으로 지양해야 할 대상은 아니지만 가능하면 단항 함수로 변경하여 사용하자.\n 결론적으로 매개변수가 많아질수록 코드의 이해도는 떨어질 것이다.\n 많은 매개변수를 전달해야 할 때 클래스로 변수를 넘길수는 없는지 생각해보자.\n 때로는 String format 같은 인수 개수가 가변적인 경우도 필요하다.\n   \n6. 부수 효과를 일으키지 말자! 부수효과는 함수에서 한 가지 역할만 하겠다고 약속하고 거짓말을 하는 셈이다.\n\n7. 명령과 조회를 분리하라 함수는 객체 상태를 변겅하거나, 객체 정보를 반환하거나 둘 중 하나다. 둘 다 수행해서는 안된다.\n\n\u0026lt;br?\n8. 오류코드보다 예외를 사용하자 try/catch 를 사용하면 코드가 훨씬 간결해진다.\n if/else 로 정상 작동과 오류 처리 작동을 뒤섞는 구조는 정말 보기 안좋다. 그러므로 try/catch 로 예외 처리를 진행하자.\n// 보기 안좋은 if/else로 정상/오류 작동 처리 if (deletePage(page) == E_OK) { if (registry.deleteReference(page.name) == E_OK) { if (configKeys.deleteKey(page.name.makeKey()) == E_OK) { logger.log(\u0026quot;page deleted\u0026quot;); } else { logger.log(\u0026quot;configKey not deleted\u0026quot;); } } else { logger.log(\u0026quot;deleteReference from registry failed\u0026quot;); } } else { logger.log(\u0026quot;delete failed\u0026quot;); return E_ERROR; }  // try/catch를 사용한 예외 처리 public void delete(Page page) { try { deletePageAndAllReferences(page); } catch (Exception e) { logError(e); } } private void deletePageAndAllReferences(Page page) throws Exception { deletePage(page); registry.deleteReference(page.name); configKeys.deleteKey(page.name.makeKey()); } private void logError(Exception e) { logger.log(e.getMessage()); }   \n9. 코드의 중복은 없애자  중복은 모든 소프트웨어에서 악의 근원이다. 중복된 코드는 하나의 함수로 만들어 재사용하자.  \n10. 구조적 프로그래밍 다익스크라의 구조적 프로그래밍의 원칙을 따르자면 모든 함수와 함수 내 모든 블록에 입구와 출구가 하나여야 된다. 즉, 함수는 return문이 하나여야 되며, 루프 안에서 break나 continue를 사용해선 안된며 goto는 절대로, 절대로 사용하지 말자. 함수가 클 경우에만 상당 이익을 제공하므로, 함수를 작게 만든다면 오히려 여러차례 사용하는 것이 함수의 의도를 표현하기 쉬워진다.\n그런데 구조적 프로그래밍의 목표와 규율은 공감하지만 함수가 작다면 위 규칙은 별 이익을 제공하지 못한다. 함수가 아주 클 때만 상당한 이익을 제공한다. 그러므로 함수를 작게 만든다면 간혹 return, break, continue를 사용해도 괜찮다. 오히려 때로는 단일 입/출구 규칙보다 의도를 표현하기 쉬워진다.\n결론  이 문서에서 다루지는 않았지만 chapter02 - 의미있는 이름에서 함수명을 짓는 방법도 나와있으니 참고하면 좋을 것 같다.\n 처음부터 완벽히 위의 10개의 규칙들을 적용하며 함수를 만들면 좋지만, 사람이다보니 처음부터 완벽할수는 없다. 차근차근 습관을 길들이도록 하자.\n  \n출저 : https://github.com/Yooii-Studios/Clean-Code\n출저 : Clean Code 클린 코드 : 애자일 소프트웨어 장인 정신\n","id":51,"section":"posts","summary":"Chapter 03 - 함수 이번 시간에는 clean한 함수를 만드는 방법에 공부하였다. 어떻게 해야 좋은 함수를 만들 수 있는지 같이 확인 해 보자. 1. 함수는 작을수록(분리될수록","tags":["클린코드"],"title":"Chapter 03 - 함수","uri":"https://chlalstjd430.github.io/2020/01/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C_003/","year":"2020"},{"content":" 백준 문제 바로가기 \n사용 언어  C++  적용 알고리즘  다익스트라 알고리즘  문제풀이 이 문제는 얼핏 보면 단순 다익스트라 알고리즘을 한번 적용하여 풀 수 있는 문제로 보인다. 그러나 문제를 잘 들여다 보면 다음과 같은 문구를 확인할 수 있다.\n 세준이는 한번 이동했던 정점은 물론, 한번 이동했던 간선도 다시 이동할 수 있다. 하지만 반드시 최단 경로로 이동해야 한다는 사실에 주의하라. 1번 정점에서 N번 정점으로 이동할 때, 주어진 두 정점을 반드시 거치면서 최단 경로로 이동하는 프로그램을 작성하시오.\n 이 문구를 통해 우리는 반드시 주어진 두 정점을 거쳐 1부터 N번의 정점으로 이동하여야 한다. 위 문제를 해결하기 위해서 반드시 거쳐야 할 두 정점을 a,b라고 가정해보면 다음과 같은 과정이 나온다.\n1. a-\u0026gt;b로 이동하는 과정\n 1 -\u0026gt; a -\u0026gt; b -\u0026gt; N\n dijkstra(1-\u0026gt;a) + dijkstra(a-\u0026gt;b) + dijkstra(b-\u0026gt;N)\n  2. b-\u0026gt;a로 이동하는 과정\n 1 -\u0026gt; b -\u0026gt; a -\u0026gt; N\n dijkstra(1-\u0026gt;b) + dijkstra(b-\u0026gt;a) + dijkstra(a -\u0026gt; N)\n  총 2가지의 과정 중 적은 과정을 택하여 값으로 출력하면 된다. 그리하여 작성된 코드를 보면 다음과 같다.\n코드 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; const int INF = 1000000; // 과정을 진행할 때 INF가 3번 더해지는 경우가 있으니 이를 고려하여 INF값을 설정하여야 한다. const int MAX = 10000; int N, E; vector\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; graph[MAX]; int visited[MAX]; void dijkstra(int start) { visited[start] = 0; priority_queue\u0026lt;pair\u0026lt;int,int\u0026gt; \u0026gt; pq; pq.push(make_pair(0, start)); while (!pq.empty()) { int current = pq.top().second; int distance = -pq.top().first; pq.pop(); int size = graph[current].size(); for(int i = 0; i \u0026lt; size; i++){ int next = graph[current][i].first; int nextDistance = distance + graph[current][i].second; if (nextDistance \u0026lt; visited[next]) { visited[next] = nextDistance; pq.push(make_pair(-nextDistance, next)); } } } } // 초기화 void init() { fill(\u0026amp;visited[0], \u0026amp;visited[MAX - 1], INF); } // 다익스트라 알고리즘 실행 후 원하는 경로가 있는지 확인 int isINF(int goal) { if (visited[goal] == INF) return INF; else return visited[goal]; } int isPossible(int a, int b, int c, int d) { init(); dijkstra(a); int a_b = isINF(b); init(); dijkstra(b); int b_c = isINF(c); init(); dijkstra(c); int c_d = isINF(d); // 3개의 경로 중 하나라도 경로가 없으면 두 정점을 거쳐서 1부터 N까지 갈 수 없으므로 INF값을 리턴 if (a_b == INF || b_c == INF || c_d == INF) return INF; // 3개의 경로 모두 값이 있으면 합계 리턴 return a_b + b_c + c_d; } int main() { cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; E; int a, b, c; int start, goal; for (int i = 0; i \u0026lt; E; i++) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; // 무방향 그래프이므로 a에서 b로 가는 것과 b에서 a로 가는 것 둘다 받아야 한다. graph[a].push_back(make_pair(b, c)); graph[b].push_back(make_pair(a, c)); } cin \u0026gt;\u0026gt; start \u0026gt;\u0026gt; goal; int one = isPossible(1, start, goal, N); int two = isPossible(1, goal, start, N); int result = min(one, two); // 두가지 과정 모두 경로가 없으면 -1 리턴 cout \u0026lt;\u0026lt; (result \u0026gt;= INF ? -1 : result); }  ","id":52,"section":"posts","summary":"백준 문제 바로가기 사용 언어 C++ 적용 알고리즘 다익스트라 알고리즘 문제풀이 이 문제는 얼핏 보면 단순 다익스트라 알고리즘을 한번 적용하여 풀 수 있는 문제로 보인다. 그","tags":["다익스트라 알고리즘"],"title":"백준 1504 - 특정한 최단 경로","uri":"https://chlalstjd430.github.io/2020/01/%EB%B0%B1%EC%A4%801504/","year":"2020"},{"content":" Chapter 02 - 의미있는 이름 \n1. 의도가 담긴 이름을 짓자  변수명/메서드명을 통해서 역할을 추정할 수 있도록 이름을 짓자.\n 별도의 주석이 필요 없을 정도로 명확하게 이름을 짓자.\n 예시\nint d; (X) -\u0026gt; int elapsedTimeInDays; public void getThem(){ ... } (x) -\u0026gt; public void getFlaggedCells(){ ... } (o)   \n2. 그릇된 정보를 피하자.  중의적인 의미를 피하자.\n 개발자에게 특수한 의미를 가지는 단어(Collection - list 등)는 실제 컨테이너가 해당 타입이 아닌 경우 변수명에 넣지 말자.\n 예시\nString[] customerList; (x) -\u0026gt; List\u0026lt;String\u0026gt; customerList; (o)   \n3. 불용어(noise word)를 사용하지 말자.  클래스 이름에 Manager, Processor, Data, Info 같은 불용어를 붙이지 말자.\n 예시\nClass StudentInfo{ ... } (x) -\u0026gt; Class Student{ ... } (o)   \n4. 발음하기 쉬운 이름을 사용하자.  숫자를 혼용하지 말자.\n 우리가 아는 단어 위주로 사용하자.\n  \n5. 검색하기 쉬운 이름을 사용하자.  상수는 static final과 같이 정희하여 사용하자.\n 변수의 이름은 변수의 범위에 비례하여 길어진다.\n  6. 클래스/메서드  변수\n 변수명에 해당 변수의 타입등을 적지말자.  클래스\n 명사 혹은 명사구(Custemer, Student)를 사용하고 동사는 사용하지 말자.  메서드\n 동사 혹은 동사구(updatePayment, deleteAccount)하자.\n 접근자는 get, 변경자는 set, 조건자는 is로 시작하자. (should, has 도 가능)\n 생성자를 오버로드할 경우 정적 팩토리 메서드를 사용하고 해당 생성자를 private로 선언한다.\n 예시\nComplex fulcrumPoint = new Complex(23.0); (x) Complex fulcrumPoint = Complex.FromRealNumber(23.0); (o)    \n7. 함부로 이름을 줄이지 말자. GS (x) -\u0026gt; GasStation (o)  \n결론  사실 위의 내용 말고 \u0026ldquo; -를 사용하자\u0026rdquo;, \u0026ldquo;-를 하지말자\u0026rdquo; 라는 내용이 더 있다. 하지만 근본적인 내용들은 위의 내용과 겹칠 뿐더러 오히려 더 나열하면 헷갈릴 것 같아 정리 내용에서 제외하였다.\n 결론적으로 이름을 성의있게 지어야 한다는 것을 알게 되었다. 나 역시도 어느정도 성의 있게 지켜가며 이름을 지었지만 이번 공부를 통해 더 명확하게 이름을 지을 수 있을 것 같다.\n  \n출저 : https://github.com/Yooii-Studios/Clean-Code\n출저 : Clean Code 클린 코드 : 애자일 소프트웨어 장인 정신\n","id":53,"section":"posts","summary":"Chapter 02 - 의미있는 이름 1. 의도가 담긴 이름을 짓자 변수명/메서드명을 통해서 역할을 추정할 수 있도록 이름을 짓자. 별도의 주석이 필요 없을 정도로 명확하게 이름을 짓자","tags":["클린코드"],"title":"Chapter 02 - 의미있는 이름","uri":"https://chlalstjd430.github.io/2020/01/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C_002/","year":"2020"},{"content":" 01.21부로 클린 코드에 대하여 요약한 게시글을 보고 나만의 후기를 남길 예정이다.\n책은 우선시 되는 다른 공부가 어느정도 정리되면 그 때 읽어볼 예정이다.\n\nChapter 01 - 깨끗한 코드 \n1. 나쁜 코드 우리는 종종 당장의 문제를 해결하기 위해 나쁜 코드(가독성,효율성,등 여러면에서)를 작성하고는 한다. 이러한 코드들은 당장의 문제를 해결해 줄 뿐이지 추후 결과적으로는 우리에게 최악의 상황을 초래한다. 그렇기 때문에 초기에 나쁜 코드가 아닌 클린한 코드를 작성하는 것이 중요하다.\n\n2. 보이스카우트 규칙  \u0026ldquo;Leave the campground cleaner than you found it.\u0026rdquo;\n 위 문구는 보이스카우트에서 인용된 문구이다. 이 말을 우리(프로그래머)의 언어로 받아 들이면 다음과 같다.\n \u0026ldquo;눈 앞에 더러운 코드가 보이면 조금이라도(변수명,if문 한줄) 개선하여라\u0026rdquo;\n 한번에 모든걸 하려면 어렵다. 그러나 조금씩이라도 변화를 지속하다보면 그것이 습관이되고 결국에는 근본적인 문제점 또한 해결 될 것이다.\n\n3. 같이 읽어보면 좋은 책 클린 코드에서는 이 책이 Agile Sorfware Development의 프리퀄이라고 말하였다. 추후에 해당 책도 읽어보면 좋을 듯 하다.\n\n결론  깨끗한 코드를 만들기 위해서 무작정 당장의 문제 해결에 집중하지 말고 장기적인 관점에서 코드를 작성하다.\n 보이스카우트 규칙에 따라 많이는 아니더라도 조금씩이라도 코드를 고쳐나가자.\n Agile Sorfware Development을 시간이 되면 읽어보자.\n  \n출저 : https://github.com/Yooii-Studios/Clean-Code\n출저 : Clean Code 클린 코드 : 애자일 소프트웨어 장인 정신\n","id":54,"section":"posts","summary":"01.21부로 클린 코드에 대하여 요약한 게시글을 보고 나만의 후기를 남길 예정이다. 책은 우선시 되는 다른 공부가 어느정도 정리되면 그 때 읽어볼 예정이다. Chapter 01 -","tags":["클린코드"],"title":"Chapter 01 - 깨끗한 코드","uri":"https://chlalstjd430.github.io/2020/01/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C_001/","year":"2020"},{"content":" 백준 문제 바로가기 \n사용 언어  C++  적용 알고리즘  다이나믹 프로그래밍  문제풀이   포도주 잔을 선택하면 그 잔에 들어있는 포도주는 모두 마셔야 하고, 마신 후에는 원래 위치에 다시 놓아야 한다. 연속으로 놓여 있는 3잔을 모두 마실 수는 없다.   문제의 조건 중 위 두가지 조건으로 보아 일정한 규칙을 세울 수 있다.\n포도주를 마실때 총 3가지 조건으로 나누어지게 된다.\n첫번째 포도주인 경우\n 현재까지의 포도주 양 = 현재 포도주 양 + 이전까지의 포도주 양\n 두번째 포도주인 경우\n 현재까지의 포도주 양 = 현재 포도주 양 + 이전 포도주 양 + 현재-3까지의 포도주 양\n 세번째 포도주인 경우(건너띄는 포도주)\n 현재까지의 포도주 양 = 이전까지의 포도주 양\n 이를 통해 다음과 같은 코드가 나오게 되었다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; long long int podo[10002]; long long int dp[10002]; int main() { int n; long long int maxPodo; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; podo[i]; } if (n == 1) { cout \u0026lt;\u0026lt; podo[1]; return 0; } else if (n == 2) { cout \u0026lt;\u0026lt; max(podo[1], (podo[1] + podo[2])); return 0; } dp[1] = podo[1]; dp[2] = dp[1] + podo[2]; maxPodo = dp[2]; for (int i = 3; i \u0026lt;= n; i++) { dp[i] = max(podo[i] + dp[i - 2], max((podo[i] + podo[i - 1] + dp[i - 3]), dp[i-1]) ); maxPodo = max(maxPodo, dp[i]); } cout \u0026lt;\u0026lt; maxPodo; }  ","id":55,"section":"posts","summary":"백준 문제 바로가기 사용 언어 C++ 적용 알고리즘 다이나믹 프로그래밍 문제풀이 포도주 잔을 선택하면 그 잔에 들어있는 포도주는 모두 마셔야 하고, 마신 후에는 원래 위치에","tags":["다이나믹 프로그래밍"],"title":"백준 2156 - 포도주 시식","uri":"https://chlalstjd430.github.io/2020/01/%EB%B0%B1%EC%A4%802156/","year":"2020"},{"content":"☞ 백준 문제 바로가기[9465- 스티커]\n\u0026nbsp;\n\u0026nbsp;\n사용 언어\n- C++\n\u0026nbsp;\n﻿적용 알고리즘\n- Dynamic Programing(다이나믹 프로그래밍)\n-\u0026nbsp;관련 동영상 강의 바로가기\n\u0026nbsp;\n\u0026nbsp;\n관련 문제\n- 백준\n\u0026nbsp;-\u0026gt;\u0026nbsp;1149,\u0026nbsp;9465,\u0026nbsp;2579, 1003, 11726, 11727 2133, 14852, 11048, 1309,\u0026nbsp; 2156, 2864, 1965, 2293, 11066, 9461, 1520, 10942\n\u0026nbsp;\n문제 풀이\n다이나믹 프로그래밍(Dynamic Programing) 문제를 풀 때에는 항상\u0026nbsp;문제의 조건과\u0026nbsp;하나의 값을 가질 수 있는 경우이다.\n현재 문제에서의 조건은 다음과 같다.\n\n1. 스티커는 2N의 크기이다.\n2. 뗀 스티커의 왼쪽,위,오른쪽,아래의 스티커는 사용 할 수 없다.\n\n따라서 왼쪽부터 스티커를 뗀다고 하면, 최종적으로 마지막 (0,N),(1,N)의 스티커 중 하나는 뗴어져야한다. 이를 가지고 조건을 만든다면.\n1) 마지막 스티커가 첫번째 줄인 경우 - (0,N)\n(1) 이전 스티커가 현재 스티커 기준으로 왼쪽 대각선 아래인 경우 - (1,N-1)\n현재 스티커까지의 합 = 현재 스티커 + 왼쪽 대각선 아래 스티커까지의 합\ndp([0][N]) = [0][N] + dp([1][N-1])\u0026nbsp;\n(2) 이전 스티커가 현재 스티커 기준으로 왼쪽에서 두번째인 경우 - (0, N-2)\n현재 스티커까지의 합 = 현재 스티커 + 왼쪽 두번째 스티커까지의 합\ndp([0][N]) = [0][N] + dp([0][N-2])\n(3) 이전 스티커가 현재 스티커 기준으로 왼쪽에서 두번째, 대각선 아래인 경우 - (1, N-2)\n현재 스티커까지의 합 = 현재 스티커 + 왼쪽 두번째,대각선 아래 스티커까지의 합\ndp([0][N]) = [0][N] + dp([1][N-2])\n\n- dp([0][N]) = (1),(2),(3) 중에 가장 큰 값\n\n2) 마지막 스티커가 두번째 줄인 경우 - (1,N)\n(1) 이전 스티커가 현재 스티커 기준으로 왼쪽 대각선 위인 경우 - (0,N-1)\n현재 스티커까지의 합 = 현재 스티커 + 왼쪽 대각선 위 스티커까지의 합\ndp([1][N]) = [1][N] + dp([0][N-1])\u0026nbsp;\n(2) 이전 스티커가 현재 스티커 기준으로 왼쪽에서 두번째인 경우 - (1, N-2)\n현재 스티커까지의 합 = 현재 스티커 + 왼쪽 두번째 스티커까지의 합\ndp([1][N]) = [1][N] + dp([1][N-2])\n(3) 이전 스티커가 현재 스티커 기준으로 왼쪽에서 두번째, 대각선 위인 경우 - (1, N-2)\n현재 스티커까지의 합 = 현재 스티커 + 왼쪽 두번째,대각선 위 스티커까지의 합\ndp([1][N]) = [1][N] + dp([0][N-2])\n\n- dp([1][N]) = (1),(2),(3) 중에 가장 큰 값\n\n최종적으로 dp[0][N]과 dp[1][N] 중에 큰 값이 답이 될 수 있다.\u0026nbsp;\n\n이를 통해 스티커와 DP 배열을 선언한다.\n\n12int\u0026nbsp;sticker[2][100002];int\u0026nbsp;dp[2][100002];cs이후 앞에서 설명한 조건을 통해 최대값을 구한 후 출력하면 문제를 해결 할 수 있다.\n123456789dp[0][1]\u0026nbsp;=\u0026nbsp;sticker[0][1];dp[1][1]\u0026nbsp;=\u0026nbsp;sticker[1][1];\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;j\u0026nbsp;=\u0026nbsp;2;\u0026nbsp;j\u0026nbsp;\u0026lt;=\u0026nbsp;n;\u0026nbsp;j++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[0][j]\u0026nbsp;=\u0026nbsp;sticker[0][j]\u0026nbsp;+\u0026nbsp;max(dp[1][j\u0026nbsp;-\u0026nbsp;1],\u0026nbsp;max(dp[0][j\u0026nbsp;-\u0026nbsp;2],\u0026nbsp;dp[1][j\u0026nbsp;-\u0026nbsp;2]));\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[1][j]\u0026nbsp;=\u0026nbsp;sticker[1][j]\u0026nbsp;+\u0026nbsp;max(dp[0][j\u0026nbsp;-\u0026nbsp;1],\u0026nbsp;max(dp[0][j\u0026nbsp;-\u0026nbsp;2],\u0026nbsp;dp[1][j\u0026nbsp;-\u0026nbsp;2]));}\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;max(dp[0][n],\u0026nbsp;dp[1][n])\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;endl;Colored by Color Scriptercs\n\u0026nbsp;\n\u0026nbsp;\n최종 코드\n\n12345678910111213141516171819202122232425262728293031323334353637383940#include\u0026nbsp;\u0026lt;iostream\u0026gt;#include\u0026nbsp;\u0026lt;algorithm\u0026gt;\u0026nbsp;using\u0026nbsp;namespace\u0026nbsp;std;\u0026nbsp;int\u0026nbsp;sticker[2][100002];//스티커를\u0026nbsp;저장할\u0026nbsp;배열int\u0026nbsp;dp[2][100002];//dp\u0026nbsp;전용\u0026nbsp;배열\u0026nbsp;int\u0026nbsp;main()\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;tc,n;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;tc;//테스트\u0026nbsp;케이스\u0026nbsp;입력\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;i\u0026nbsp;\u0026lt;\u0026nbsp;tc;\u0026nbsp;i++)\u0026nbsp;{//테스트\u0026nbsp;케이스\u0026nbsp;만큼\u0026nbsp;반복\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;n;//스티커\u0026nbsp;크기\u0026nbsp;입력\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;j\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;j\u0026nbsp;\u0026lt;\u0026nbsp;2;\u0026nbsp;j++)\u0026nbsp;{//스티커\u0026nbsp;값\u0026nbsp;입력\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;k\u0026nbsp;=\u0026nbsp;1;\u0026nbsp;k\u0026nbsp;\u0026lt;=\u0026nbsp;n;\u0026nbsp;k++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;sticker[j][k];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;//dp\u0026nbsp;첫번째\u0026nbsp;값\u0026nbsp;입력\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[0][1]\u0026nbsp;=\u0026nbsp;sticker[0][1];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[1][1]\u0026nbsp;=\u0026nbsp;sticker[1][1];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;//dp\u0026nbsp;구하기\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;j\u0026nbsp;=\u0026nbsp;2;\u0026nbsp;j\u0026nbsp;\u0026lt;=\u0026nbsp;n;\u0026nbsp;j++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[0][j]\u0026nbsp;=\u0026nbsp;sticker[0][j]\u0026nbsp;+\u0026nbsp;max(dp[1][j\u0026nbsp;-\u0026nbsp;1],\u0026nbsp;max(dp[0][j\u0026nbsp;-\u0026nbsp;2],\u0026nbsp;dp[1][j\u0026nbsp;-\u0026nbsp;2]));\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[1][j]\u0026nbsp;=\u0026nbsp;sticker[1][j]\u0026nbsp;+\u0026nbsp;max(dp[0][j\u0026nbsp;-\u0026nbsp;1],\u0026nbsp;max(dp[0][j\u0026nbsp;-\u0026nbsp;2],\u0026nbsp;dp[1][j\u0026nbsp;-\u0026nbsp;2]));\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;//최종\u0026nbsp;값\u0026nbsp;출력\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;max(dp[0][n],\u0026nbsp;dp[1][n])\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;endl;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;//스티커와\u0026nbsp;DP\u0026nbsp;배열\u0026nbsp;초기화\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;j\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;j\u0026nbsp;\u0026lt;=\u0026nbsp;n;\u0026nbsp;j++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[0][j]\u0026nbsp;=\u0026nbsp;sticker[0][j]\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[1][j]\u0026nbsp;=\u0026nbsp;sticker[1][j]\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}Colored by Color Scriptercs\n\n추가적으로 질문사항이 있으시면 언제든지 댓글을 달아주세요:D\n\n\u0026nbsp;\n\n\u0026nbsp;\n\n\u0026nbsp;\n\n\u0026nbsp;\n","id":56,"section":"posts","summary":"☞ 백준 문제 바로가기[9465- 스티커] \u0026nbsp; \u0026nbsp; 사용 언어 - C++ \u0026nbsp; ﻿적용 알고리즘 - Dynamic Programing(다이나믹 프로그래밍) -\u0026nbsp;관련 동영상","tags":["다이나믹 프로그래밍"],"title":"백준 9465 - 스티커","uri":"https://chlalstjd430.github.io/2020/01/%EB%B0%B1%EC%A4%809465/","year":"2020"},{"content":"☞ 백준 문제 바로가기[2579- 계단 오르기]\n\u0026nbsp;\n\u0026nbsp;\n사용 언어\n- C++\n\u0026nbsp;\n﻿적용 알고리즘\n- Dynamic Programing(다이나믹 프로그래밍)\n-\u0026nbsp;관련 동영상 강의 바로가기\n\u0026nbsp;\n\u0026nbsp;\n관련 문제\n- 백준\n\u0026nbsp;-\u0026gt;\u0026nbsp;1149,\u0026nbsp;9465,\u0026nbsp;2579, 1003, 11726, 11727 2133, 14852, 11048, 1309,\u0026nbsp; 2156, 2864, 1965, 2293, 11066, 9461, 1520, 10942\n\u0026nbsp;\n문제 풀이\n문제에서 주어진 조건들을 먼저 살표보면 다음과 같습니다.\n\n1. 계단은 한번에 1개 혹은 2개를 오를 수 있다.\n2. 계단은 연속으로 3칸을 오를 수 없다.\n3. 마지막 계단은 무조건 밟아야한다.\n\n따라서 마지막 계단을 밟아야한다면 다음과 같이 두 조건으로 분류 할 수 있습니다.\n1) 마지막 계단이 처음 밟는 계단일 경우\n마지막 계단까지의 값 = 마지막 계단 값 + [마지막 - 2]까지 밟았던 값들의 총합\nN = N + dp(n-2)\n\n2) 마지막 계단이 마지막으로(두번째로) 밟는 계단일 경우\n마지막 계단까지의 값 = 마지막 계단 값 + [마지막 - 1] 계단의 값 + [마지막 - 3] 까지 밟았던 값들의 총합\nN = N + N-1 +dp(n-3)\n\n이를 통해 N을 stair(=현재 계단)이라고 하고 하면 다음과 같이 전역 변수를 선언 할 수 있습니다.\n\n12int\u0026nbsp;stair[301];int\u0026nbsp;dp[301];cs이어서 두가지의 경우 중 큰 값들을 나란히 넣어주고 최종적으로 마지막 계단 값을 출력하면 결과를 도출해 낼 수 있습니다.\n\n123456dp[1]\u0026nbsp;=\u0026nbsp;stair[1];dp[2]\u0026nbsp;=\u0026nbsp;stair[2]\u0026nbsp;+\u0026nbsp;dp[1];for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;3;\u0026nbsp;i\u0026nbsp;\u0026lt;=\u0026nbsp;tc;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[i]\u0026nbsp;=\u0026nbsp;stair[i]\u0026nbsp;+\u0026nbsp;\u0026nbsp;max(dp[i\u0026nbsp;-\u0026nbsp;2],\u0026nbsp;(stair[i\u0026nbsp;-\u0026nbsp;1]\u0026nbsp;+\u0026nbsp;dp[i\u0026nbsp;-\u0026nbsp;3]));}cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;dp[tc];Colored by Color Scriptercs\n\u0026nbsp;\n\u0026nbsp;\n최종 코드\n\n12345678910111213141516171819202122#include\u0026nbsp;\u0026lt;iostream\u0026gt;#include\u0026nbsp;\u0026lt;algorithm\u0026gt;\u0026nbsp;using\u0026nbsp;namespace\u0026nbsp;std;\u0026nbsp;int\u0026nbsp;stair[301];int\u0026nbsp;dp[301];\u0026nbsp;int\u0026nbsp;main()\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;tc;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;tc;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;1;\u0026nbsp;i\u0026nbsp;\u0026lt;=\u0026nbsp;tc;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;stair[i];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[1]\u0026nbsp;=\u0026nbsp;stair[1];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[2]\u0026nbsp;=\u0026nbsp;stair[2]\u0026nbsp;+\u0026nbsp;dp[1];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;3;\u0026nbsp;i\u0026nbsp;\u0026lt;=\u0026nbsp;tc;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dp[i]\u0026nbsp;=\u0026nbsp;stair[i]\u0026nbsp;+\u0026nbsp;\u0026nbsp;max(dp[i\u0026nbsp;-\u0026nbsp;2],\u0026nbsp;(stair[i\u0026nbsp;-\u0026nbsp;1]\u0026nbsp;+\u0026nbsp;dp[i\u0026nbsp;-\u0026nbsp;3]));\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;dp[tc];}\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;Colored by Color Scriptercs\n추가적으로 질문사항이 있으시면 언제든지 댓글을 달아주세요:D\n\n\u0026nbsp;\n\n\u0026nbsp;\n\n\u0026nbsp;\n","id":57,"section":"posts","summary":"☞ 백준 문제 바로가기[2579- 계단 오르기] \u0026nbsp; \u0026nbsp; 사용 언어 - C++ \u0026nbsp; ﻿적용 알고리즘 - Dynamic Programing(다이나믹 프로그래밍) -\u0026nbsp;관련 동","tags":["다이나믹 프로그래밍"],"title":"백준 2579 - 계단 오르기","uri":"https://chlalstjd430.github.io/2020/01/%EB%B0%B1%EC%A4%802579/","year":"2020"},{"content":"☞ 백준 문제 바로가기[1149 - RGB거리]\n\u0026nbsp;\n\u0026nbsp;\n사용 언어\n- C++\n\u0026nbsp;\n﻿적용 알고리즘\n- Dynamic Programing(다이나믹 프로그래밍)\n-\u0026nbsp;관련 동영상 강의 바로가기\n\u0026nbsp;\n\u0026nbsp;\n관련 문제\n- 백준\n\u0026nbsp;-\u0026gt;\u0026nbsp;1149,\u0026nbsp;9465,\u0026nbsp;2579, 1003, 11726, 11727 2133, 14852, 11048, 1309,\u0026nbsp; 2156, 2864, 1965, 2293, 11066, 9461, 1520, 10942\n\u0026nbsp;\n문제 풀이\n해당 문제에서 요구하는 것은 하나의 집에 대헤서 이웃하는 집(i-1,i+1)과 다른 페인트를 색칠하게 하는 것이다. 그리하여 모든 집을 칠하는 최소 페인트 비용을 구하면된다.\n우선 하나의 집에 대헤서 각각의 페인트 비용을 저장하기 위해 다음과 같은 전역 변수를 선언해주었다.\n\n1int\u0026nbsp;cost[1001][3];cs그리고 문제 해결을 위해서 다음과 같은 접근을 하게 되었다.\n\n12345\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;1;\u0026nbsp;i\u0026nbsp;\u0026lt;\u0026nbsp;n;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cost[i][0]\u0026nbsp;=\u0026nbsp;cost[i][0]\u0026nbsp;+\u0026nbsp;min(cost[i\u0026nbsp;-\u0026nbsp;1][1],\u0026nbsp;cost[i\u0026nbsp;-\u0026nbsp;1][2]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cost[i][1]\u0026nbsp;=\u0026nbsp;cost[i][1]\u0026nbsp;+\u0026nbsp;min(cost[i\u0026nbsp;-\u0026nbsp;1][0],\u0026nbsp;cost[i\u0026nbsp;-\u0026nbsp;1][2]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cost[i][2]\u0026nbsp;=\u0026nbsp;cost[i][2]\u0026nbsp;+\u0026nbsp;min(cost[i\u0026nbsp;-\u0026nbsp;1][0],\u0026nbsp;cost[i\u0026nbsp;-\u0026nbsp;1][1]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}Colored by Color Scriptercs\n﻿이를 가지고 최종적으로 가장 비용이 적은 결과를 출력하게 되었다.\u0026nbsp;\n\n1cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;min(cost[n\u0026nbsp;-\u0026nbsp;1][0],\u0026nbsp;min(cost[n\u0026nbsp;-\u0026nbsp;1][1],\u0026nbsp;cost[n\u0026nbsp;-\u0026nbsp;1][2]));cs실제로 문제의 예제를 가지고 테스트하면\n1. 첫번째\nR : 26[R]\nG : 40[G]\nB : 83[B]\n\u0026nbsp;\n2. 두번째\u0026nbsp;\nR : 49[R] + 40[첫번째의 G]\nG : 60[G] + 26[첫번째의\u0026nbsp;R]\nB : 57[B] + 26[첫번째의 R]\n\u0026nbsp;\n4. 세번째\u0026nbsp;\nR : 13[R] + ( 57 + 26[첫번째의 R])[두번째의 B] = 96\nG: 89[G]\u0026hellip;\nB : 99[B]\u0026hellip;\n최종적으로 나온 값의 가장 작은 값이 예체의 출력값과 같은 것을 확인 할 수 있다.\n\u0026nbsp;\u0026nbsp;\n\n최종 코드\n\n123456789101112131415161718192021222324252627#include\u0026nbsp;\u0026lt;iostream\u0026gt;#include\u0026nbsp;\u0026lt;algorithm\u0026gt;\u0026nbsp;using\u0026nbsp;namespace\u0026nbsp;std;\u0026nbsp;int\u0026nbsp;cost[1001][3];\u0026nbsp;int\u0026nbsp;main()\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;n;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;r,\u0026nbsp;g,\u0026nbsp;b;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;n;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;i\u0026nbsp;\u0026lt;\u0026nbsp;n;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;cost[i][0]\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;cost[i][1]\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;cost[i][2];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;1;\u0026nbsp;i\u0026nbsp;\u0026lt;\u0026nbsp;n;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cost[i][0]\u0026nbsp;=\u0026nbsp;cost[i][0]\u0026nbsp;+\u0026nbsp;min(cost[i\u0026nbsp;-\u0026nbsp;1][1],\u0026nbsp;cost[i\u0026nbsp;-\u0026nbsp;1][2]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cost[i][1]\u0026nbsp;=\u0026nbsp;cost[i][1]\u0026nbsp;+\u0026nbsp;min(cost[i\u0026nbsp;-\u0026nbsp;1][0],\u0026nbsp;cost[i\u0026nbsp;-\u0026nbsp;1][2]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cost[i][2]\u0026nbsp;=\u0026nbsp;cost[i][2]\u0026nbsp;+\u0026nbsp;min(cost[i\u0026nbsp;-\u0026nbsp;1][0],\u0026nbsp;cost[i\u0026nbsp;-\u0026nbsp;1][1]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;min(cost[n\u0026nbsp;-\u0026nbsp;1][0],\u0026nbsp;min(cost[n\u0026nbsp;-\u0026nbsp;1][1],\u0026nbsp;cost[n\u0026nbsp;-\u0026nbsp;1][2]));}Colored by Color Scriptercs\n﻿\n\n\n추가적으로 질문사항이 있으시면 언제든지 댓글을 달아주세요:D\n\n\u0026nbsp;\n\n\u0026nbsp;\n","id":58,"section":"posts","summary":"☞ 백준 문제 바로가기[1149 - RGB거리] \u0026nbsp; \u0026nbsp; 사용 언어 - C++ \u0026nbsp; ﻿적용 알고리즘 - Dynamic Programing(다이나믹 프로그래밍) -\u0026nbsp;관련 동","tags":["다이나믹 프로그래밍"],"title":"백준 1149 - RGB거리","uri":"https://chlalstjd430.github.io/2020/01/%EB%B0%B1%EC%A4%801149/","year":"2020"},{"content":" 백준 문제 바로가기 \n사용 언어  C++  적용 알고리즘  최소 스패닝 트리 합집합 찾기  문제풀이 일반적으로 난이도가 쉬운 최소 스패닝 트리 문제를 풀 때, 가중치 값 기준으로 정렬 후 크르스칼 알고리즘을 적용하면 문제를 쉽게 풀 수 있습니다. 그러나 해당 문제는 가중치 값 기준으로 정렬할 때 다른 문제와 다르다는 것을 느낄 수 있습니다.\n먼저 정렬을 위해서 문제 중 이 한 문장을 잘 이해할 필요가 있겠습니다\n 두 행성 A(xA, yA, zA)와 B(xB, yB, zB)를 터널로 연결할 때 드는 비용은 min(|xA-xB|, |yA-yB|, |zA-zB|)이다.\n 이 문장을 통해 최종적으로 x,y,z 값을 각각 기준으로 정렬후 모든 값들을 vector에 넣어 정렬한 뒤 크루스칼 알고리즘을 적용하면 답이 나올 것을 예상할수 있었습니다.\n먼저 Planet 클래스와, Planet 클래스를 x,y,z 값으로 정렬 후 담아줄수 있는 Edge 클래스를 생성합니다.\n//행성 정보를 담아줄 Planet 클래스 class Planet { public: int node[3]; int index; Planet(int x, int y, int z, int index) { node[0] = x; node[1] = y; node[2] = z; this-\u0026gt;index = index; } }; //Planet Class를 x,y,z기준으로 각각 sort를 위해 만들어줍니다. bool cmpX (Planet \u0026amp;planet, Planet \u0026amp;planet2) { return planet.node[0] \u0026lt; planet2.node[0]; } bool cmpY(Planet \u0026amp;planet, Planet \u0026amp;planet2) { return planet.node[1] \u0026lt; planet2.node[1]; } bool cmpZ(Planet \u0026amp;planet, Planet \u0026amp;planet2) { return planet.node[2] \u0026lt; planet2.node[2]; } //sort이후 가중치 정보를 담아줄 Edge 클래스를 만들어줍니다. class Edge { public: int x, y; int value; Edge(int x, int y, int value) { this-\u0026gt;x = x; this-\u0026gt;y = y; this-\u0026gt;value = value; } bool operator \u0026lt;(Edge \u0026amp;edge) { return this-\u0026gt;value \u0026lt; edge.value; } };  이후 앞서 말씀드린 것처럼 x,y,z 기준으로 Plaent Class를 정렬 후 Edge Class에 담아 최종적으로 Edge Class를 정렬 후 크루스칼 알고리즘을 적용하면 결과가 나옵니다.\n//정렬 과정 sort(planet.begin(), planet.end(), cmpX); for (int i = 0; i \u0026lt; N - 1; i++) { edge.push_back(Edge(planet[i].index, planet[i + 1].index, abs(planet[i].node[0] - planet[i + 1].node[0]))); } sort(planet.begin(), planet.end(), cmpY); for (int i = 0; i \u0026lt; N - 1; i++) { edge.push_back(Edge(planet[i].index, planet[i + 1].index, abs(planet[i].node[1] - planet[i + 1].node[1]))); } sort(planet.begin(), planet.end(), cmpZ); for (int i = 0; i \u0026lt; N - 1; i++) { edge.push_back(Edge(planet[i].index, planet[i + 1].index, abs(planet[i].node[2] - planet[i + 1].node[2]))); } sort(edge.begin(), edge.end());  최종코드 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; class Planet { public: int node[3]; int index; Planet(int x, int y, int z, int index) { node[0] = x; node[1] = y; node[2] = z; this-\u0026gt;index = index; } }; bool cmpX (Planet \u0026amp;planet, Planet \u0026amp;planet2) { return planet.node[0] \u0026lt; planet2.node[0]; } bool cmpY(Planet \u0026amp;planet, Planet \u0026amp;planet2) { return planet.node[1] \u0026lt; planet2.node[1]; } bool cmpZ(Planet \u0026amp;planet, Planet \u0026amp;planet2) { return planet.node[2] \u0026lt; planet2.node[2]; } class Edge { public: int x, y; int value; Edge(int x, int y, int value) { this-\u0026gt;x = x; this-\u0026gt;y = y; this-\u0026gt;value = value; } bool operator \u0026lt;(Edge \u0026amp;edge) { return this-\u0026gt;value \u0026lt; edge.value; } }; int getParent(int parent[], int x) { if (parent[x] == x) return x; return getParent(parent, parent[x]); } void unionParent(int parent[], int x, int y) { x = getParent(parent, x); y = getParent(parent, y); if (x \u0026gt; y) parent[x] = y; else parent[y] = x; } bool findParent(int parent[], int x, int y) { x = getParent(parent, x); y = getParent(parent, y); if (x == y) return true; return false; } int dist[100002]; vector\u0026lt;Planet\u0026gt; planet; vector\u0026lt;Edge\u0026gt; edge; int main() { int N; int x, y, z; int sum = 0; cin \u0026gt;\u0026gt; N; for (int i = 0; i \u0026lt; N; i++) { cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; z; planet.push_back(Planet(x, y, z, i)); } for (int i = 0; i \u0026lt;= N; i++) { dist[i] = i; } sort(planet.begin(), planet.end(), cmpX); for (int i = 0; i \u0026lt; N - 1; i++) { edge.push_back(Edge(planet[i].index, planet[i + 1].index, abs(planet[i].node[0] - planet[i + 1].node[0]))); } sort(planet.begin(), planet.end(), cmpY); for (int i = 0; i \u0026lt; N - 1; i++) { edge.push_back(Edge(planet[i].index, planet[i + 1].index, abs(planet[i].node[1] - planet[i + 1].node[1]))); } sort(planet.begin(), planet.end(), cmpZ); for (int i = 0; i \u0026lt; N - 1; i++) { edge.push_back(Edge(planet[i].index, planet[i + 1].index, abs(planet[i].node[2] - planet[i + 1].node[2]))); } sort(edge.begin(), edge.end()); for (int i = 0; i \u0026lt; edge.size(); i++) { if (!(findParent(dist, edge[i].x, edge[i].y))) { sum += edge[i].value; unionParent(dist, edge[i].x, edge[i].y); } } cout \u0026lt;\u0026lt; sum; }  추가적인 질문사항 있으시면 언제든지 댓글 달아주시면 감사하겠습니다😊\n","id":59,"section":"posts","summary":"백준 문제 바로가기 사용 언어 C++ 적용 알고리즘 최소 스패닝 트리 합집합 찾기 문제풀이 일반적으로 난이도가 쉬운 최소 스패닝 트리 문제를 풀 때, 가중치 값 기준으로 정렬 후","tags":["최소 스패닝 트리"],"title":"백준 2887 - 행성터널","uri":"https://chlalstjd430.github.io/2020/01/%EB%B0%B1%EC%A4%802887/","year":"2020"},{"content":"☞ 백준 문제 바로가기[ 1991 - 트리 순회]\n\u0026nbsp;\n\u0026nbsp;\n사용 언어\n- C++\n\u0026nbsp;\n﻿적용 알고리즘\n- 이진 트리 전위/중위/후위 순회 알고리즘\n-\u0026nbsp;관련 동영상 강의 바로가기\n\u0026nbsp;\n\u0026nbsp;\n관련 문제\n- 관련 문제들은 추후에 수정하도록 하겠습니다.\n\u0026nbsp;\n문제 풀이\n- 해당 문제는 이진 트리를 이용하여 순회 알고리즘을 사용하는 문제입니다.\n먼저 다음과 같이 이진 트리 구조를 가진 구조체를 만들어줍니다.\n\n\n12345typedef\u0026nbsp;struct\u0026nbsp;node\u0026nbsp;tree;typedef\u0026nbsp;struct\u0026nbsp;node{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;char\u0026nbsp;data;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;tree\u0026nbsp;left,\u0026nbsp;right;};cs\n이후 전위/중위/후위 함수를 만들어줍니다.\n\n\n123456789101112131415161718192021222324//전위void\u0026nbsp;preorder(tree\u0026nbsp;tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;tr-\u0026gt;data;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;preorder(tr-\u0026gt;left);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;preorder(tr-\u0026gt;right);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}}//중위void\u0026nbsp;inorder(tree\u0026nbsp;tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;inorder(tr-\u0026gt;left);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;tr-\u0026gt;data;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;inorder(tr-\u0026gt;right);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}}//후위void\u0026nbsp;postorder(tree\u0026nbsp;tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;postorder(tr-\u0026gt;left);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;postorder(tr-\u0026gt;right);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;tr-\u0026gt;data;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}}cs\u0026nbsp;\n마지막으로 다음과 같이 데이터를 받고 출력해주면 정상적으로 결과가 나온 것을 확인 하실 수 있습니다.\n\n\n12345678910111213141516171819int\u0026nbsp;main()\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;node\u0026nbsp;nodes[27];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;nodeCnt;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;char\u0026nbsp;a,\u0026nbsp;b,\u0026nbsp;c;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;nodeCnt;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;i\u0026nbsp;\u0026lt;\u0026nbsp;nodeCnt;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;a\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;b\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;c;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1].data\u0026nbsp;=\u0026nbsp;a;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;(b\u0026nbsp;==\u0026nbsp;\u0026rsquo;.\u0026rsquo;)\u0026nbsp;?\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1].left\u0026nbsp;=\u0026nbsp;NULL\u0026nbsp;:\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1].left\u0026nbsp;=\u0026nbsp;\u0026amp;nodes[b\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;(c\u0026nbsp;==\u0026nbsp;\u0026rsquo;.\u0026rsquo;)\u0026nbsp;?\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1].right\u0026nbsp;=\u0026nbsp;NULL\u0026nbsp;:\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1].right\u0026nbsp;=\u0026nbsp;\u0026amp;nodes[c\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;preorder(\u0026amp;nodes[1]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;endl;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;inorder(\u0026amp;nodes[1]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;endl;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;postorder(\u0026amp;nodes[1]);;}Colored by Color Scriptercs\n최종 코드\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include\u0026nbsp;\u0026lt;iostream\u0026gt;\u0026nbsp;using\u0026nbsp;namespace\u0026nbsp;std;\u0026nbsp;typedef\u0026nbsp;struct\u0026nbsp;node\u0026nbsp;tree;typedef\u0026nbsp;struct\u0026nbsp;node{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;char\u0026nbsp;data;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;tree\u0026nbsp;left,\u0026nbsp;right;};\u0026nbsp;//전위void\u0026nbsp;preorder(tree\u0026nbsp;tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;tr-\u0026gt;data;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;preorder(tr-\u0026gt;left);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;preorder(tr-\u0026gt;right);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}}//중위void\u0026nbsp;inorder(tree\u0026nbsp;tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;inorder(tr-\u0026gt;left);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;tr-\u0026gt;data;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;inorder(tr-\u0026gt;right);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}}//후위void\u0026nbsp;postorder(tree\u0026nbsp;tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(tr)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;postorder(tr-\u0026gt;left);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;postorder(tr-\u0026gt;right);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;tr-\u0026gt;data;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}}\u0026nbsp;int\u0026nbsp;main()\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;node\u0026nbsp;nodes[27];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;nodeCnt;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;char\u0026nbsp;a,\u0026nbsp;b,\u0026nbsp;c;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;nodeCnt;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;i\u0026nbsp;\u0026lt;\u0026nbsp;nodeCnt;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;a\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;b\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;c;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1].data\u0026nbsp;=\u0026nbsp;a;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;(b\u0026nbsp;==\u0026nbsp;\u0026rsquo;.\u0026rsquo;)\u0026nbsp;?\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1].left\u0026nbsp;=\u0026nbsp;NULL\u0026nbsp;:\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1].left\u0026nbsp;=\u0026nbsp;\u0026amp;nodes[b\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;(c\u0026nbsp;==\u0026nbsp;\u0026rsquo;.\u0026rsquo;)\u0026nbsp;?\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1].right\u0026nbsp;=\u0026nbsp;NULL\u0026nbsp;:\u0026nbsp;nodes[a\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1].right\u0026nbsp;=\u0026nbsp;\u0026amp;nodes[c\u0026nbsp;-\u0026nbsp;\u0026lsquo;A\u0026rsquo;\u0026nbsp;+\u0026nbsp;1];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;preorder(\u0026amp;nodes[1]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;endl;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;inorder(\u0026amp;nodes[1]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;endl;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;postorder(\u0026amp;nodes[1]);;}Colored by Color Scriptercs\n\n추가적으로 질문사항이 있으시면 언제든지 댓글을 달아주세요:D\n\n\u0026nbsp;\n","id":60,"section":"posts","summary":"☞ 백준 문제 바로가기[ 1991 - 트리 순회] \u0026nbsp; \u0026nbsp; 사용 언어 - C++ \u0026nbsp; ﻿적용 알고리즘 - 이진 트리 전위/중위/후위 순회 알고리즘 -\u0026nbsp;관련 동영상 강의 바로가기","tags":["이진 트리 알고리즘"],"title":"백준 1991 - 트리 순회","uri":"https://chlalstjd430.github.io/2020/01/%EB%B0%B1%EC%A4%801991/","year":"2020"},{"content":" IT 동아리 정보 1. YAPP  6-7월 / 12-1월  2. NEXTERS  5월 / 11월  3. SOPT  3월 / 9월  4. 프로그라피  2-3월 / 8월  5. Mash-Up  3월 / 8-9월  6. DEPROMEET  2월 / 9월  7. 멋쟁이사자처럼  2월  그 외 IT 활동 1. S/W 마에스트로(1월 중순 - 2월 중순) 2. 우아한 테크코스(10월 ~ 11월) 3. 우아한 테크캠프(5월) 4. 스마일 게이트 서버캠프(11월) 5. 42SEOUL 6. SSAFY(삼성 청년 소프트웨어 아카데미) 7. Slipp 스터디(6-7월/12-1월) ","id":61,"section":"posts","summary":"IT 동아리 정보 1. YAPP 6-7월 / 12-1월 2. NEXTERS 5월 / 11월 3. SOPT 3월 / 9월 4. 프로그라피 2-3월 / 8월 5. Mash-Up 3월 / 8-9월 6. DEPROMEET 2월 / 9월 7. 멋쟁이사자처럼","tags":["IT 정보","IT 동아리"],"title":"IT 동아리 정보","uri":"https://chlalstjd430.github.io/2020/01/%EC%A0%95%EB%B3%B4_001/","year":"2020"},{"content":" 2020년 학업 계획 1. IT동아리\n- YOURSSU 활동중(19.11.01~ )\n YAPP\n 지원중(1.18 면접)\n 최종 합격(1.22)\n   \n2. S/W 마에스트로\n- 1월 중순~말 서류 접수\n 서류 준비중(1.22~)  \n3. 클린코드 공부\n- 1) 블로그 읽기\n- 2) Clean Code 책 읽기\n- 클린코드 정리중 4. Spring Framework 더 자유롭게 다루기\n- 1) 프로젝트 하면서 필요한 부분 학습\n- 2) 인프런 강의\n5. JPA/DB 공부\n- 1) 프로젝트 하면서 필요한 부분 학습\n- 2) 인프런 강의\n6. 학점 4.0\n- 평균 학점 3.5이상 유지하기\n7. 여름/겨울에 인턴활동\n- S/W마에스트로 활동중이라면 겨울에라도 지원하기\n8. 꾸준한 알고리즘 공부\n- 스터디 활동 (01/01 ~ 02.28 진행중)\n- github 9. 프로젝트 실제 런칭 해보기\n10. 꾸준한 블로그 포스팅\n- 최소 1일 1포스팅\n11. S/W 관련 공모전 나가보기\n12. ACM 도전\n- 교내 입상이라도..\n13. AWS 공부\n14. 교내 멘토 활동 지원해보기\n15. 깃에 1일 1커밋\n16. 삼성 SW 역량 테스트(A형) 취득\n17. TDD로 개발하기!\n","id":62,"section":"posts","summary":"2020년 학업 계획 1. IT동아리 - YOURSSU 활동중(19.11.01~ ) YAPP 지원중(1.18 면접) 최종 합격(1.22) 2. S/W 마에스트로 - 1월 중순~말 서류 접","tags":["계획"],"title":"2020 학업 계획","uri":"https://chlalstjd430.github.io/2020/01/2020%EA%B3%84%ED%9A%8D_001/","year":"2020"},{"content":"Reactive Programing\u0026nbsp;간단 정리!\n\u0026nbsp;\n안녕하세요,\u0026nbsp;이 글에서는 제가\u0026nbsp;Reactive Programing을 처음 접하게 되며 알게된 내용들을 간략하게 설명하고자합니다.\u0026nbsp;개인적인 이해가 담겨져있는 글이므로 정확하지 않은 부분에 대하여 언제든지 피드백 해주시면 감사하겠습니다:D\n\u0026nbsp;\n\u0026nbsp;\n\n\n\n\nReactive Programing이란?\n\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;\u0026nbsp;\u0026nbsp;\n\n유어슈에 들어오고\u0026nbsp;Reactive Programing을 처음 접하게 되었습니다.\u0026nbsp;이후\u0026nbsp;Reactive Programing의 정의에 대하여 찾아보았고,\u0026nbsp;그중에서 가장 간결하면서 명확한 정의를 소개해드리겠습니다.\u0026nbsp;\n\u0026nbsp;\nReactive programming is programming with asynchronous data streams.\n\n리엑티브 프로그래밍은 비동기적 데이터 흐름을 처리하는 프로그래밍이다.\n\u0026nbsp;\n\u0026nbsp;Reactive Programming에서의 핵심은 모든 것들을 비동기적인 데이터의 흐름으로 간주한다는 것입니다. 다시 말하여 기존에 정해진 절차에 따라 작성한 코드가 실행되는 명령형 프로그래밍과는 다르게 리엑티브 프로그래밍은 데이터의 흐름을 정의하고 데이터가 변경되었을 때 연관되는 함수나 수식이 같이 변경되는 방식입니다.\u0026nbsp; 이것을 사용자의 입장에서 보았을 때\u0026nbsp; 실시간 반응이 이루어진다고 할 수 있습니다. 대표적으로 엑셀을 예로 들어보겠습니다.\n\u0026nbsp;A\n\u0026nbsp;B\n\u0026nbsp;C\n\u0026nbsp;6\n\u0026nbsp;7\n\u0026nbsp;= A1 + B1\n\n이라는 표가 있을 때 우리는 C1의 값으로 13을 기대할 수 있습니다.\n\u0026nbsp;A\n\u0026nbsp;B\n\u0026nbsp;C\n\u0026nbsp;6\n\u0026nbsp;7\n13\n\n실제로 수행 결과 13이 나오는 것을 알 수있습니다. 그렇다면 여기서 A를 10으로 변경하였을 때도 C는 13일까요?\n\n\u0026nbsp;A\n\u0026nbsp;B\n\u0026nbsp;C\n\u0026nbsp;10\n\u0026nbsp;7\n17\n결과는 17입니다. A가 변함에 따라 C의 값이 달라지게 됩니다. 우리는 엑셀을 통해서 데이터의 흐름에 따라 결과값이 다르게 표현되는 것을 확인 하실 수 있습니다.\n\u0026nbsp;\n\u0026nbsp;이러한 Reactive Programming은 함수형 프로그래밍(Functional Programming)을 지원 받습니다. 함수형 프로그래밍은\u0026nbsp; 데이터를 immutable하게 취급하고, 데이터 변경시 원본 데이터는 유지하고 새로운 데이터를 만들어 변경하고, 관점을 데이터가 아닌 Process에 집중하게 됩니다. 그리하여 Side-effect 최소화해 병렬처리에서 큰 장점을 가져오게 됩니다.\n\u0026nbsp;\n\u0026nbsp;\n​\n\n\n\n왜\u0026nbsp;Reactive Programing일까?\n\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;\u0026nbsp;\n\n\u0026nbsp;리엑티브 선언문에 따른\u0026nbsp;4가지 속성은 응답성,탄력성,유연성,메시지 구동으로 이루어져있고 내용은 다음과 같습니다.\n\u0026nbsp;\u0026nbsp;https://www.reactivemanifesto.org/ko\n응답성(Responsive):\u0026nbsp;시스템이 가능한 한 즉각적으로 응답하는 것을 응답성이 있다고 합니다.\u0026nbsp;응답성은 사용자의 편의성과 유용성의 기초가 되지만,\u0026nbsp;그것뿐만 아니라 문제를 신속하게 탐지하고 효과적으로 대처할 수 있는 것을 의미합니다.\u0026nbsp;응답성 있는 시스템은 신속하고 일관성 있는 응답 시간을 제공하고,\u0026nbsp;신뢰할 수 있는 상한선을 설정하여 일관된 서비스 품질을 제공합니다.\u0026nbsp;이러한 일관된 동작은 오류 처리를 단순화하고,\u0026nbsp;일반 사용자에게 신뢰를 조성하고,\u0026nbsp;새로운 상호작용을 촉진합니다.\n\n탄력성(Resilient):\u0026nbsp;시스템이\u0026nbsp;장애에 직면하더라도 응답성을 유지 하는 것을 탄력성이 있다고 합니다.\u0026nbsp;탄력성은 고가용성 시스템,\u0026nbsp;미션 크리티컬 시스템에만 적용되지 않습니다.\u0026nbsp;탄력성이 없는 시스템은 장애가 발생할 경우 응답성을 잃게 됩니다.\u0026nbsp;탄력성은\u0026nbsp;복제,\u0026nbsp;봉쇄,\u0026nbsp;격리, 위임에 의해 실현됩니다.\u0026nbsp;장애는 각각의\u0026nbsp;구성 요소에 포함되며 구성 요소들은 서로 분리되어 있기 때문에 이는 시스템이 부분적으로 고장이 나더라도,\u0026nbsp;전체 시스템을 위험하게 하지 않고 복구 할 수 있도록 보장합니다.\u0026nbsp;각 구성 요소의 복구 프로세스는 다른(외부의)\u0026nbsp;구성 요소에 위임되며 필요한 경우 복제를 통해 고가용성이 보장됩니다.\u0026nbsp;구성 요소의 클라이언트는 장애를 처리하는데에 압박을 받지 않습니다.\n\n유연성(Elastic):\u0026nbsp;시스템이 작업량이 변화하더라도 응답성을 유지하는 것을 유연성이라고 합니다.\u0026nbsp;리액티브 시스템은 입력 속도의 변화에 따라 이러한 입력에 할당된\u0026nbsp;자원을 증가시키거나 감소키면서 변화에 대응합니다.\u0026nbsp;이것은 시스템에서 경쟁하는 지점이나 중앙 집중적인 병목 현상이 존재하지 않도록 설계하여,\u0026nbsp;구성 요소를 샤딩하거나 복제하여 입력을 분산시키는 것을 의미합니다.\u0026nbsp;리액티브 시스템은 실시간 성능을 측정하는 도구를 제공하여 응답성 있고 예측 가능한 규모 확장 알고리즘을 지원합니다.\u0026nbsp;이 시스템은 하드웨어 상품 및 소프트웨어 플랫폼에 비용 효율이 높은 방식으로\u0026nbsp;유연성을 제공합니다.\n\n메시지 구동(Message Driven):\u0026nbsp;리액티브 시스템은\u0026nbsp;비동기 메시지 전달에 의존하여 구성 요소 사이에서 느슨한 결합,\u0026nbsp;격리,\u0026nbsp;위치 투명성을 보장하는 경계를 형성합니다.\u0026nbsp;이 경계는\u0026nbsp;장애를 메시지로 지정하는 수단을 제공합니다.\u0026nbsp;명시적인 메시지 전달은 시스템에 메시지 큐를 생성하고,\u0026nbsp;모니터링하며 필요시\u0026nbsp;배압을 적용함으로써 유연성을 부여하고,\u0026nbsp;부하 관리와 흐름제어를 가능하게 합니다.\u0026nbsp;위치 투명 메시징을 통신 수단으로 사용하면 단일 호스트든 클러스터를 가로지르든 동일한 구성과 의미를 갖고 장애를 관리할 수 있습니다.\u0026nbsp;논블로킹\u0026nbsp;통신은 수신자가 활성화가 되어 있을 때만\u0026nbsp;자원을 소비할 수 있기 때문에 시스템 부하를 억제할 수 있습니다.\n\u0026nbsp;\n\u0026nbsp;\n이러한 특징들가 더불어\u0026nbsp;과거보다\u0026nbsp;다양한 웹,앱의 UI 이벤트가 존재하는\u0026nbsp;현대에 더 나은 자원 활용과 확장성에 대한 필요성이 증가되고 더 나아가 모든 구현체가 상호운영할 수 있는 표준으로 특정 구현체에 얽매이는 감소가 추구되기 때문에\u0026nbsp;Reactive Programming이 사용됩니다.\u0026nbsp;\n\n\u0026nbsp;\n\n\n\n\n\n\n마무리\n\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;\u0026nbsp;\n\n간략하게\u0026nbsp;Reactive Programming을 알아보았는데,\u0026nbsp;단순히\u0026nbsp;Reactive Programming추종하며 따라가기 보다는 충분히 고민하고 이해하는게 좋을 것 같습니다.\u0026nbsp;이것으로 저의 첫번째 글은 마무리하고 추후에\u0026nbsp;Reactive Streams와 관련된 주제로 다음에 찾아뵙도록 하겠습니다:D\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n참고\n리엑티브 정의\nhttps://gist.github.com/staltz/868e7e9bc2a7b8c1f754#reactive-programming-is-programming-with-asynchronous-data-streams\n리엑티브 선언문\nhttps://www.reactivemanifesto.org/ko\u0026nbsp;\n","id":63,"section":"posts","summary":"Reactive Programing\u0026nbsp;간단 정리! \u0026nbsp; 안녕하세요,\u0026nbsp;이 글에서는 제가\u0026nbsp;Reactive Programing을 처음 접","tags":["리액티브 프로그래밍"],"title":"Reactive Programming이란?","uri":"https://chlalstjd430.github.io/2020/01/%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_reactive_programming/","year":"2020"},{"content":"☞ 백준 문제 바로가기[ 6497 - 전력난 ]\n\u0026nbsp;\n\u0026nbsp;\n사용 언어\n- C++\n\u0026nbsp;\n﻿적용 알고리즘\n- 크루스칼 알고리즘(Kruscal Algorithm)\n- 합집합 찾기 알고리즘(Union - Find)\n- 최소 스패닝 트리(MST)\n-\u0026nbsp;관련 동영상 강의 바로가기\n\u0026nbsp;\n\u0026nbsp;\n관련 문제\n-\u0026nbsp;1922(네트워크 연결),\u0026nbsp;1647(도시 분할 계획),\u0026nbsp;2887(행성 터널),\u0026nbsp;1197(최소 스패닝 트리)\n- 해당 문제들 풀이내용은 추후에 게시하도록 하겠습니다.\n\u0026nbsp;\n문제 풀이\n- 해당 문제는 크루스칼 알고리즘만 알고있다면 간단하게 풀수있는 MST 문제입니다. 먼저 코드를 보시면 다음과 같습니다.\n\u0026nbsp;\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include\u0026nbsp;\u0026lt;iostream\u0026gt;#include\u0026nbsp;\u0026lt;vector\u0026gt;#include\u0026nbsp;\u0026lt;algorithm\u0026gt;\u0026nbsp;using\u0026nbsp;namespace\u0026nbsp;std;\u0026nbsp;int\u0026nbsp;dist[200002];int\u0026nbsp;m,\u0026nbsp;n;\u0026nbsp;class\u0026nbsp;Edge\u0026nbsp;{public:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;node[2];\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;value;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;Edge(int\u0026nbsp;x,\u0026nbsp;int\u0026nbsp;y,\u0026nbsp;int\u0026nbsp;value)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;this-\u0026gt;node[0]\u0026nbsp;=\u0026nbsp;x;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;this-\u0026gt;node[1]\u0026nbsp;=\u0026nbsp;y;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;this-\u0026gt;value\u0026nbsp;=\u0026nbsp;value;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;bool\u0026nbsp;operator\u0026nbsp;\u0026lt;\u0026nbsp;(Edge\u0026nbsp;\u0026amp;edge)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;return\u0026nbsp;this-\u0026gt;value\u0026nbsp;\u0026lt;\u0026nbsp;edge.value;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}};\u0026nbsp;int\u0026nbsp;getParent(int\u0026nbsp;parent[],\u0026nbsp;int\u0026nbsp;num)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(parent[num]\u0026nbsp;==\u0026nbsp;num)\u0026nbsp;return\u0026nbsp;num;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;return\u0026nbsp;parent[num]\u0026nbsp;=\u0026nbsp;getParent(parent,\u0026nbsp;parent[num]);}\u0026nbsp;void\u0026nbsp;unionParent(int\u0026nbsp;parent[],\u0026nbsp;int\u0026nbsp;x,\u0026nbsp;int\u0026nbsp;y)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;x\u0026nbsp;=\u0026nbsp;getParent(parent,\u0026nbsp;x);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;y\u0026nbsp;=\u0026nbsp;getParent(parent,\u0026nbsp;y);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(x\u0026nbsp;\u0026gt;\u0026nbsp;y)parent[x]\u0026nbsp;=\u0026nbsp;y;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;else\u0026nbsp;parent[y]\u0026nbsp;=\u0026nbsp;x;\u0026nbsp;}\u0026nbsp;bool\u0026nbsp;equalParent(int\u0026nbsp;parent[],\u0026nbsp;int\u0026nbsp;x,\u0026nbsp;int\u0026nbsp;y)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;x\u0026nbsp;=\u0026nbsp;getParent(parent,\u0026nbsp;x);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;y\u0026nbsp;=\u0026nbsp;getParent(parent,\u0026nbsp;y);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(x\u0026nbsp;==\u0026nbsp;y)\u0026nbsp;return\u0026nbsp;true;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;return\u0026nbsp;false;}\u0026nbsp;int\u0026nbsp;main()\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;vector\u0026lt;Edge\u0026gt;\u0026nbsp;map;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;while\u0026nbsp;(true)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;m\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;n;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(m\u0026nbsp;==\u0026nbsp;0\u0026nbsp;\u0026amp;\u0026amp;\u0026nbsp;n\u0026nbsp;==\u0026nbsp;0)\u0026nbsp;break;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;i\u0026nbsp;\u0026lt;=\u0026nbsp;m;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;dist[i]\u0026nbsp;=\u0026nbsp;i;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;x\u0026nbsp;=\u0026nbsp;0,\u0026nbsp;y\u0026nbsp;=\u0026nbsp;0,\u0026nbsp;z\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;i\u0026nbsp;\u0026lt;\u0026nbsp;n;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cin\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;x\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;y\u0026nbsp;\u0026gt;\u0026gt;\u0026nbsp;z;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;map.push_back(Edge(x,\u0026nbsp;y,\u0026nbsp;z));\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;sort(map.begin(),\u0026nbsp;map.end());\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;size\u0026nbsp;=\u0026nbsp;map.size();\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;sum\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;i\u0026nbsp;\u0026lt;\u0026nbsp;size;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;sum\u0026nbsp;+=\u0026nbsp;map[i].value;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;for\u0026nbsp;(int\u0026nbsp;i\u0026nbsp;=\u0026nbsp;0;\u0026nbsp;i\u0026nbsp;\u0026lt;\u0026nbsp;size;\u0026nbsp;i++)\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;if\u0026nbsp;(!equalParent(dist,\u0026nbsp;map[i].node[0],\u0026nbsp;map[i].node[1]))\u0026nbsp;{\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;unionParent(dist,\u0026nbsp;map[i].node[0],\u0026nbsp;map[i].node[1]);\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;sum\u0026nbsp;-=\u0026nbsp;map[i].value;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;cout\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;sum\u0026nbsp;\u0026lt;\u0026lt;\u0026nbsp;endl;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;map.clear(); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;}}\n\n\u0026nbsp;\n\n\u0026nbsp;기본적인 크루스칼 알고리즘을 적용해 구하는 MST 구조와 같습니다. 다만 문제를 풀 때 주의하실 점은 문제 요구사항입니다.\n처음에 문제를 풀었을 때, 요구사항 중\u0026nbsp;\n\u0026nbsp;\n출력각 테스트 케이스마다 한 줄에 걸쳐 절약할 수 있는 최대 비용을 출력한다.\n\u0026nbsp;\n라는 내용을 인지하지 못하여서 최소 비용 값이 왜 다르지하고 한동안 코드를 다시 분석하는 행위를 반복하였습니다.\u0026nbsp;\n\u0026nbsp;\n추가적으로\n입력입력은 여러 개의 테스트 케이스로 구분되어 있다.\n각 테스트 케이스의 첫째 줄에는 집의 수 m과 길의 수 n이 주어진다. (1 ≤ m ≤ 200000,\u0026nbsp;m-1 ≤ n ≤ 200000)\n이어서 n개의 줄에 각 길에 대한 정보 x, y, z가 주어지는데, 이는 x번 집과 y번 집 사이에 양방향 도로가 있으며 그 거리가 z미터라는 뜻이다. (0 ≤ x, y \u0026lt; m,\u0026nbsp;x ≠ y)\n도시는 항상 연결 그래프의 형태이고(즉, 어떤 두 집을 골라도 서로 왕래할 수 있는 경로가 있다), 도시상의 모든 길의 거리 합은 231미터보다 작다.\n입력의 끝에서는 첫 줄에 0이 2개 주어진다.\n\u0026nbsp;\n라는 입력 조건에서 첫번째 줄과 마지막 줄 또한 무시하고 문제를 제출하였다가 틀렸습니다.\n\u0026nbsp;\n\u0026nbsp;\n그외에는 별다른 어려움은 없었던 것 같습니다! 코드에 대한 지적이나 풀이에 대한 질문은 댓글로 남겨주시면 확인 후 답장 메일이나 댓글을 달아드리겠습니다:D\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n","id":64,"section":"posts","summary":"☞ 백준 문제 바로가기[ 6497 - 전력난 ] \u0026nbsp; \u0026nbsp; 사용 언어 - C++ \u0026nbsp; ﻿적용 알고리즘 - 크루스칼 알고리즘(Kruscal Algorithm) - 합집합 찾기 알고리즘(Union - Find) - 최","tags":["크루스칼 알고리즘"],"title":"백준6497 - 전력난","uri":"https://chlalstjd430.github.io/2020/01/%EB%B0%B1%EC%A4%806497/","year":"2020"}],"tags":[{"title":"IT 동아리","uri":"https://chlalstjd430.github.io/tags/it-%EB%8F%99%EC%95%84%EB%A6%AC/"},{"title":"IT 정보","uri":"https://chlalstjd430.github.io/tags/it-%EC%A0%95%EB%B3%B4/"},{"title":"JWT","uri":"https://chlalstjd430.github.io/tags/jwt/"},{"title":"KMP 알고리즘","uri":"https://chlalstjd430.github.io/tags/kmp-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"title":"spring webflux","uri":"https://chlalstjd430.github.io/tags/spring-webflux/"},{"title":"계획","uri":"https://chlalstjd430.github.io/tags/%EA%B3%84%ED%9A%8D/"},{"title":"그리디 알고리즘","uri":"https://chlalstjd430.github.io/tags/%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"title":"다이나믹 프로그래밍","uri":"https://chlalstjd430.github.io/tags/%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"},{"title":"다익스트라 알고리즘","uri":"https://chlalstjd430.github.io/tags/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"title":"리액티브 프로그래밍","uri":"https://chlalstjd430.github.io/tags/%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"},{"title":"브루트 포스트","uri":"https://chlalstjd430.github.io/tags/%EB%B8%8C%EB%A3%A8%ED%8A%B8-%ED%8F%AC%EC%8A%A4%ED%8A%B8/"},{"title":"알고리즘","uri":"https://chlalstjd430.github.io/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"title":"위상 정렬 알고리즘","uri":"https://chlalstjd430.github.io/tags/%EC%9C%84%EC%83%81-%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"title":"이진 트리 알고리즘","uri":"https://chlalstjd430.github.io/tags/%EC%9D%B4%EC%A7%84-%ED%8A%B8%EB%A6%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"title":"최소 스패닝 트리","uri":"https://chlalstjd430.github.io/tags/%EC%B5%9C%EC%86%8C-%EC%8A%A4%ED%8C%A8%EB%8B%9D-%ED%8A%B8%EB%A6%AC/"},{"title":"크루스칼 알고리즘","uri":"https://chlalstjd430.github.io/tags/%ED%81%AC%EB%A3%A8%EC%8A%A4%EC%B9%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"title":"클린코드","uri":"https://chlalstjd430.github.io/tags/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C/"}]}